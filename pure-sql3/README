
DRAFT FOR DISCUSSION PURPOSES ONLY.
NOT COMPLETED, NOT CURRENT, NOT WORTH READING AT THIS POINT.

=========
Pure-Sql3
=========

This document describes Peter Summerland's Sqlite3_ module, named **Sql3**,
for the Pure_ programming language.

.. _Sqlite3: http://www.sqlite.org/
.. _Pure: http://pure-lang.googlecode.com

.. contents::
.. sectnum::

Introduction
============

SQLite is a software library that implements a self-contained,
serverless, zero-configuration, transactional SQL database engine. It
is small and fast, and is the most widely deployed SQL database engine
in the world. http://www.sqlite.org/mostdeployed.html The source code
for SQLite is in the public domain.

.. http://www.sqlite.org/


http://www.sqlite.org/whentouse.html

Like other database programs SQLite has its quirks and has some very
powerful features that cannot be accessed through the generic OBCD
interface.

Sql3 is a "transparent" wrapper around Sqlite3's C interface that is
designed to give the developer access to all of Sqlite3's features in
a way that is convenient for Pure programmers. It provides a handful
of convenience functions that make the C interface "core" functions
easier to use without impeading the users ability to tap into the rest
of the C interface directly.

Simple Example
--------------

Here is a simple example that opens a database file "abc.db" (creating
it if it does not exist), adds a table, populates the table and
queries it.

::

  pure-sql3$> pure -q
  > 

  > using sql3; using namespace sql3;

  > let dbp = open "readme.db";

  > exec dbp "create table if not exists RM (name text, age integer)";

  > exec dbp "delete from RM";

  > let sp1 = prep dbp "ci" "insert into RM values (?,?)";

  > exec sp1 ("Sam",20);
  > exec sp1 ("Fred",22);

  > let sp2 = prep dbp "ci:i" "select * from RM where age > ?";

  > exec sp2 18;
  [["Sam",20],["Fred",22]]

The Pure statements shown as examples are contained in readme.pure in
the pure-sql3 directory.

These basic functions, `open`, `prep`, `exec` wrap the core
functionality of Sqlite3 and in many cases are all you need to use it
effectively. 

More Examples
-------------

The examples subdirectory contains numerous examples that further
illustrate basic usage as well some of Sql3's more sophisticated
features. These include the ability to implement functions, in Pure,
that can appear in SQL statements, custom binding types and convenient
access to the "raw" SQLite3 C interface.

SQLite3 Documentation and Tools
-------------------------------

SQLite3's home page provides excellent documentation regarding its SQL
dialect as well as its C interface. In the rest of this document, it
is assumed the reader has some familiarity with SQLite3 and its C
interface, and has read `An Introduction To The SQLite C/C++
Interface`_.

.. _An Introduction To The SQLite C/C++ Interface: http://www.sqlite.org/cintro.html


The SQLite library includes a simple command-line utility named
sqlite3 (or sqlite3.exe on windows) that allows the user to manually
enter and execute SQL commands against an SQLite database. 

.. http://www.sqlite.org/sqlite.html

This tool is an invaluable aid when working with SQLite in general and
with Sql3 in the Pure interpreter in particular. Just fire up sqlite3
in a new termial and use it to observe changes to the database
generated by your REPL commands. For example, after entering the Pure
statements from the Simple Example above, you can start a new
terminal, cd to pure-sql3, type sqlite3 readme.db, and start examining
the database:
::

  pure-sql3$> sqlite3 readme.db
  SQLite version 3.6.16
  Enter ".help" for instructions
  Enter SQL statements terminated with a ";"

  sqlite> select * from RM;
  Sam|20
  Fred|22

Of course changes caused by SQL statements are reflected in queries
entered via the Pure interpreter and vis-a-versa. I.e., the Pure
interpreter and sqlite3 can "simultaneously" access the same database
file, which is very handy while developing a Pure program that uses
Sql3.

Copying
=======

Copyright (c) 2010 by Peter Summerland and Albert Graef, all rights
reserved. 

Sql3 is is free software: you can redistribute it and/or modify it
under the terms of the New BSD License, often referred to as the 3
clause BSD license. Please see the COPYING file for the actual
license.

Installation
============

You need to have Pure and SQLite3_ installed, obviously. Run ``make`` to
compile the module, and ``sudo make install`` to install it in the Pure
library directory.

Data Structure
==============

As far as the native SQLite C interface is concerned, the most
important "data structures" are pointers to the following encapsulated
SQLite objects.

  * Database connection object: sqlite3
  * Prepared statement object: sqlite3_stmt

``Sql3::open`` and `Sql3::prep`` return "sentry-guarded" pointers to
these objects referred to herein as ``db_ptr`` and ``stmt_ptr``,
respectively. 

A db_ptr or a stmt_ptr is, as far as SQLite is concerned, the same as
a raw pointer returned by sqlite3_open_v2 (sqlite3*) and
sqlite3_prepare_v2 (sqlite3_stmt*), the native interface functions
corresponding to sql3::open and sql3::prep. While this facility can be
powerful, and avoids a lot of redundant wrapping functions, it can
also be dangerous as is the case with any call to and external C
function.

Sql3 users have to be especially careful in this regard because USING
A DB_PTR OR A STMT_PTR IN CALLS TO CERTAIN NATIVE FUNCTIONS, INCLUDING
IN PARTICULAR SQLITE3_CLOSE, SQLITE_PREPARE AND SQLITE_FINALIZE, WILL
CORRUPT DATA HELD BY THE DB_PTR OR STMT_PTR.

The reason for this restriction is that Sql3 uses sentries to insure
that the resources associated with a db_ptr or a stmt_ptr are
automatically finalized by SQLite when they go out of scope. In
addition, the sentries carry internal information used by Sql3 for
other purposes. Accordingly, native SQLite functions that change the
state of a database connection or a prepared statement behind Sql3's
back can oftern result in undefined behavior. (See Advanced Usage,
Accessing the C Interface for more information.)

Basic Operations
================

The basic operations, the ones that are used 99 percent of the time,
are (a) opening and closing database connections and (b) preparing and
executing SQL statements.

Opening a Database Connection
-----------------------------

In Sql3 ``open filename`` provides a db_ptr that can be used access
specified SQLite database.

* ``open (file_path::string [,access_mode::int,custom_bindings]])``:
  opens a SQLite database file whose name is given by the file_path
  argument and returns a db_ptr for the database connection object
  created by SQlite. The access_mode is what one would expect
  ... readonly, create if not found, etc. plus some very sophisticated
  caching and threading options. The custom_bindings option allows the
  user to prepare statements associated with the returned db_ptr that
  have custom binding types.

If the filename is ":memory:", then a private, temporary in-memory database
is created for the connection. This in-memory database will vanish when the
database connection is closed. The basic access modes are:

* SQLITE_OPEN_READONLY - the database is opened in read-only mode. If the
  database does not already exist, an error is returned.

* SQLITE_OPEN_READWRITE - the database is opened for reading and writing if
  possible, or reading only if the file is write protected by the operating
  system. In either case the database must already exist, otherwise an
  error is returned.

* SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE - the database is opened for
  reading and writing, and is creates it if it does not already exist. This
  is the default value that is used if the flags argument is omitted.

* SQLITE_OPEN - an alias for SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE
  provided by Sql3.

These flags can be combined with SQLITE_OPEN_NOMUTEX SQLITE_OPEN_FULLMUTEX
SQLITE_OPEN_SHAREDCACHE SQLITE_OPEN_PRIVATECACHE to control SQLite's
threading and shared cache features. See ...

The optional ``custom_bindings`` argument allows the user to set up
customized binding and fetching behavior for prepared statements
associated with the returned db_ptr. See Advanced Usage, Custome
Binding Types.

Failure to Open a Database Connection
-------------------------------------

Open a piece of junk -- will suceed. Only when queried will get error.

Seems to be a bug in exec db. Misses the error code. Is this a step thing?
Need to check for error from step.

Even if SQlite cannot open the connection, it still returns a pointer
to a database connection object that must be closed. In this case,
``open`` closes the the connection object and throws an
exception. E.g.,::

  >  let dbp = open "abc.db"; db1;
  #<pointer 0x992dff8>

  > catch error (open ("_RM_zyx.db",SQLITE_OPEN_READONLY));
  error "sqlite3 error 14: unable to open database file [open abcx.db]"


Testing a db_ptr
----------------

* ``is_db_ptr ptr::pointer``: returns 1 if ptr is a db_ptr returned by
  open, and 0 if it is not.

* ``is_open ptr::pointer``: returns 1 if the database connection referenced by
  by ptr is open.




Closing a Database Connection
-----------------------------

When a database connection object is no longer needed, it should be closed
so that SQLite can free the associated resources. 

* ``close dp1::pointer``: - if dp1's database connection is open, calls
  sqlite_close dp1. Otherwise does nothing. Before calling sqlite_close,
  close finalizes all "prepared statements" that associated with the
  connection.::

  > close dbp;
  1
  > close dbp; 
  0

Note that ``close ptr`` only matches when ptr is a db_ptr returned by
open::

  > sqlite3_errmsg dbp; //set ans to a "random" pointer
  #<pointer 0xb644eee4>

  > close ans;          //close does not reduce on a random pointer
  sql3::close #<pointer 0xb644eee4>

If a db_ptr, say dbp, goes out of scope, close dbp, is called
automagically. When debugging, this behavior can be observed by
editing sql3.pure, changing "const SHOW_OPEN_CLOSE = 1;" to "const
SHOW_OPEN_CLOSE = 0;" and running sudo make install in the pure-sql3
directory. This will cause a message to be printed whenever a db_ptr
or stmt_ptr is created or finalized.

Constructing Prepared Statements
--------------------------------

In SQLite3, prepared statement objects are used to execute SQL
statements using the following functions. As explained in An
Introduction  

    * sqlite3_prepare()
    * sqlite3_bind()
    * sqlite3_step()
    * sqlite3_column()
    * sqlite3_finalize()

The basic procedure is to prepare a statement, use the appropriate
sqlite_bind functions to bind its parameters, step it one or more
times until it is done and then finalize it. To The SQLite C/C++
Interface, sqlite3_bind and sqlite3_column represent families of bind
and column functions, with one member for each of the basic data types
recognized by SQLite. Thus, for example, sqlite_bind_double() would be
the function one would use to bind a prepared statement with an
argument of type double.  If a step returns data, use the appropriate
sqlite3_column functions (e.g., sqlite3_column_double) to extract the
data from each column.

Sql3 captures these procedure in four functions: ``prep``, ``exec``
``lexec`` and ``finalize``.


* ``prep dbp::pointer types::string sql::string`` - constructs prepared
  statement object and returns a stmt_ptr that references it. ``dbp`` must
  be a db_ptr or the rule will not match. ``sql`` is a string that
  specifies the sql statement to be executed. It can contain argument
  placeholders, indicated by "?", "?nnn", ":AAA", etc. See
  sqlite3_prepare_v2 for further details. The ``types`` parameter tells
  Sql3 the types of arguments to be used when binding the prepared
  statement as well as the types of objects returned at each step.

In the following two examples, the "c" and "i" int the binding strings
indicate that a string and an int will be used to bind stmp1, an int
will be used to bind stmp2 and that stmp2, when executed, will return
a result set in the form of a list of sublists each of which contains a
string and an int.  
::

  > let sp1 = prep dbp "ci" "insert into RM values (?,?)";

  > let sp2 = prep dbp "ci:i" "select * from RM where age > ?"; stmp;
  #<pointer 0xa4b43c0>

  > exec sp1 ("Tom",30);  //insert Tom
  []

  > exec sp2 19;          //select age > 19
  [["Sam",20],["Tom",30],["Fred",35]]

In general, the characters in the type string before the ":", if any, indicate
the types in the result set. Those that occur after the ":", if any
indicate the types of the arguments used to bind the prepared statement
object. If the type string does not contain a ":", the characters in the type
string, if any, are the types of binding arguments.

Sql3 provides the following set of "core" binding types:

::
  b; raw data; blob
  c; string; text (utf8)
  d; double; float;
  i; int; int64;
  k: int or bigint in int64 range; int64
  l; bigint; blob -- TODO
  n; SQLNULL; NULL
  x; binary serialized pure expression; blob
  v; variant; same as b,c,d,i,n as appropriate 

The "k" type, which converts ints and a subset of bigints into int64,
is useful when dealing with SQLite3's "integer primary keys" and
"rowids" both of which are 64 bit ints. The "n" type can only appear
on the binding side of a type string. A binding argument corresponding
to a "v" in the type string will be treated as bound as if the "v"
were a "b", "c", "d", "i" or "n", based on the type of the binding
argument. An object returned when a prepared statement is stepped that
corresponding to a "v" type will be fetched according to the native
SQLite column type of the corresponding column. The "x" type is used
to store and reconstruct Pure expressions as binary objects, using
``val`` and ``blob``.

As mentioned, users can define custom binding types and pass them as a
third parameter to open. The resulting db_ptr can be used with the
additional binding types to construct prepared statements that can be
executed with customized arguments. See advanced usage.

The examples directory contains a file sql3_types.pure that has an example
for each core binding type.

The stmt_p returned by `prep` is a sentry guarded sqlite3_stmt* that will
automagically be finalized when the stmt_p goes out of scope.

Executing Prepared Statements
-----------------------------

In Sql3, the bind, step, column, step, column ... cyle is encapsulated in
the exec and lexec functions.

* ``exec`` stmp::pointer args - uses args to bind the prepared statement
  referenced by stmp, then steps the prepared statement until it is done,
  collecting the results of the steps in a list. ``args`` is a tuple or
  list of arguments whose number and type correspond to the bind parameter
  types specified in the call to prep that produced stmp. This rule matches
  only if stmp is a stmt_ptr. Throws and error if SQlite returns an error
  code anywhere in the process.

If the statement does not return values, exec returns [];

  > exec sp1 ("Tom",30);  //insert Tom
  []

  > exec sp2 19;          //select age > 19
  [["Sam",20],["Tom",30],["Fred",35]]

 An error is thrown if the args do not correspond to the specified types.

  > catch error (exec stmp "a");
  error "sql3 error: Attempt to bind a \"a\" as a int"

If a prepared statement does not have any binding paramenters,
executed it with ():

  > let sp3 = prep dbp "c:" "select name from RM";

  > exec sp3 ();
  [["Sam"],["Fred"]]

A little extra care is required when executing prepared statements
that take a blob argument.  A blob argument is different than the
other types in that it must be a tuple (n,ptr) where n is the length
of the data in bytes and ptr is its address.  In order to preserve the
tuple as a pair, a blob argument should be passed to exec using the
list form rather than the tuple form. (See ...).

  > let blb = (100,ptr);

  > (a,blb,c);
  a,100,ptr,c

  > [a,blb,c];
  [a,(100,ptr),c]

Thus "exec stpx [a,blb,c]" would work fine, while exec stpx (a,blb,c)
would produce a Sql3 binding exception.

Busy
----

What to do .. in a transaction should roll back. How to do this? Or
disclaim for now.



Lazy Execution
--------------

The ``exec`` function returns result sets as an eager list, which
could be inefficient or simply not feesible for large result sets. In
such cases it is preferable to use ``lexec`` instead.

* ``lexec stmp::pointer args`` - same as ``exec`` except that it returns a
  lazy list.

E.g.,::

  > lexec stmp2 19;
  ["Sam",20]:#<thunk 0xb6475ab0>

Note that no changes to stmp2 were required. In addition, for most purposes
the lazy list returned by lexec can be processed by the same code that
processed the eager list returned by exec (see the "Lazy Evaluation and
Streams" section in the Pure manual)! The examples directory contains the
file sql3_lexec.pure that compares memory usage and time for a moderately
sized result set using ``exec`` and ``lexec``.

Automatically Prepared Statements
---------------------------------

For statements that have no parameters and which do not return results,
`exec` can be applied to a db_ptr.

* ``exec dbp::pointer sql::string`` - constructs a temporary prepared
  statement using the sql string. The sql string cannot contain parameters
  (?, ?nnn, etc.). Throws an error if SQLite indicates an error while exec
  is processing the sql. Otherwise retruns SQLITE_DONE.[TODO - BUG Try
  commit/rollback]::

  > exec db1 "create table if not exists RM (name varchar, age integer)";
  101 //SQLITE_DONE

Testing a stmt_ptr
------------------

For argument checking and other purposes it is sometimes useful to
determine if a given expression is a valid stmt_ptr.

* ``is_stmt_ptr ptr::pointer`` - returns 1 if ptr is a stmt_ptr, otherwise
  returns 0.::

  > is_stmt_ptr sp2;
  1

Finalizing Prepared Statements
------------------------------




Transactions
------------

No changes can be made to a SQLite database except within a
transaction. Any command that changes the database (basically, any SQL
command other than SELECT) will automatically start a transaction if
one is not already in effect. Automatically started transactions are
committed when the last query finishes. The upshot of this is that
unless a transaction is started manually, the database will be updated
(usually on disk) after each exec. For a long series of updates or
inserts this a can be very slow. The way to avoid this problem is to
begin a transaction manually before the first update and manually
ending the transaction after the last update.

Transactions can be started manually using the BEGIN command. Such
transactions persist until the next COMMIT or ROLLBACK
command. Transactions are also ended if an error occurs before the
transaction is manually ended using a COMMIT or ROLLBACK
statement. This behavior provides the means make a series of changes
on an "atomic" or all or nothing basis.

Transactions created using BEGIN...COMMIT do not nest. For nested
transactions, use the SAVEPOINT and RELEASE statements. 

Sql3 provides the following convenience functions all of which simply
exec dbp with the appropriate SQL statement. For example begin dbp is
exactly the same as 'exec dbp "BEGIN"'.

* ``begin dbp``
* ``begin_exclusive``
* ``begin_immediate``
* ``commit dbp``

* ``savepoint dbp``
* ``release dbp``
* ``rollback_to``
* ``rollback dbp``

See the SQLite documentation for further details on the use of these
SQL statements.

Advanced Usage
==============


Callbacks
---------




Accessing the rest of the SQLite3 C Interface
---------------------------------------------


Example of getting row headers.


Custom Binding Types for Prepared Statements
--------------------------------------------

Pass



TODO
----

db_busy dbp
   --- rollback (unless in a commit).
             --- throw special exception
             --- user can try again or rollback.
             --- need example

BUG -- junk files, step errors not caught.

THREAD SAFE -- modes, note the multi thread. Using for a desktop or
analysis tool.

db_error ec msg
 -- ec 0 means was an Sql3 error -- e.g., else a SQLITE error, or extended error.