

=========
Pure-Sql3
=========

:Authors: - Peter Summerland
          - Albert Graef <Dr.Graef@t-online.de>

:Date: |date|

.. |date| date::

DRAFT FOR DISCUSSION PURPOSES ONLY



This document describes **Sql3**, a SQLite_ module for the Pure_
programming language.

.. _SQLite: http://www.sqlite.org
.. _Pure: http://pure-lang.googlecode.com

.. contents::
.. sectnum::

Introduction
============

SQLite is a software library that implements an easy to use,
self-contained, serverless, zero-configuration, transactional SQL
database engine. SQLite is not intended to be an enterprise database
engine like Oracle or PostgreSQL. Instead, SQLite strives to be small,
fast, and reliable, but first and above all simple. It turns out that
this type of database engine has many uses. See `Appropriate Uses For
SQLite`_.

.. _Appropriate Uses For SQLite: http://www.sqlite.org/whentouse.html

Sql3 is a "transparent" wrapper around SQLite's C interface that is
designed to give Pure programers access to almost all of SQLite's
features, including many that are not available through Pure's generic
OBCD interface. It provides a handful of convenience functions that
make the C interface "core" functions easier to use without limiting
the programmer's ability to tap into the rest of the C interface
directly.

Simple Example
--------------

Here is a simple example that opens a database file "abc.db" (creating
it if it does not exist), adds a table "RM", populates "RM" and
executes a query.

::

  pure-sql3$> pure -q
  > 

  > using sql3; using namespace sql3;

  > let dbp = open "readme.db";

  > exec dbp "create table if not exists RM (name text, age integer)";

  > exec dbp "delete from RM";

  > let sp1 = prep dbp "ci" "insert into RM values (?,?)";

  > exec sp1 ("Sam",20);

  > exec sp1 ("Fred",22);

  > let sp2 = prep dbp "ci:i" "select * from RM where age > ?";

  > exec sp2 18;
  [["Sam",20],["Fred",22]]

The Sql3 functions, **open**, **prep** and **exec** encapsulate the
core functionality of SQLite, and in many cases are all you need to
use SQLite effectively. The string "ci:i" in the second call to
**prep** is called a "binding string". It indicates that sp2 needs to
be bound with and int and that, when executed will provide records
consisting of a string field and an int field.

By the way, if you would like to try things out as you read this
document, the Pure expressions shown as examples herein are contained
in readme.pure in the pure-sql3 directory.

More Examples
-------------

The examples subdirectory of pure-Sql3 contains numerous examples that
further illustrate basic usage as well as some of Sql3's more
sophisticated features.

SQLite Documentation
--------------------

SQLite's home page provides excellent documentation regarding its SQL
dialect as well as its C interface. Comments in this document
regarding SQLite are not meant to be a substitute for the actual
documentation and should not be relied upon, other than as general
introductory comments. Sql3 is really just a collection of functions
that make certain often repeated tasks easier, and the correspondence
between the Sql3 functions and the underlying functions provided by
the native C interface should be readily apparent to people familiar
with the C interface. Accordingly, the best way to use Sql3 is to get
familiar with SQLite and its C interface and then go directly to the 
`SQLite Site Map`_ for authoritative information.

.. _`SQLite Site Map`: http://www.sqlite.org/sitemap.html

In the rest of this document, it is assumed the reader has some
familiarity with SQLite and has read `An Introduction To The SQLite
C/C++ Interface`_.

.. _An Introduction To The SQLite C/C++ Interface:
    http://www.sqlite.org/cintro.html

Sqlite3 - The SQLite Command-Line Utility
-----------------------------------------

The SQLite library includes a really nice command-line utility named
sqlite3 (or sqlite3.exe on windows) that allows the user to manually
enter and execute SQL statements against a SQLite database (and much
more).

.. http://www.sqlite.org/sqlite.html

This tool is an invaluable aid when working with SQLite in general and
with Sql3 in the Pure interpreter in particular. Just fire up sqlite3
in a new terminal and use it to observe changes to the database
generated by Pure language statements submitted to the Pure
interpreter. For example, after entering the Pure statements from the
Simple Example above, you can start a new terminal, cd to pure-sql3,
type "sqlite3 readme.db" at the prompt, and see the effect the Pure
statements had on the database: ::

  pure-sql3$> sqlite3 readme.db
  SQLite version 3.6.16
  Enter ".help" for instructions
  Enter SQL statements terminated with a ";"

  sqlite> select * from RM;
  Sam|20
  Fred|22

Again, the fact that the Pure interpreter and sqlite3 can
"simultaneously" access the same database file can be very helpful
while developing a Pure program that accesses a SQLite database.

Copying
=======

| Copyright (c) 2010 by Peter Summerland <p.summerland@gmail.com>.
| Copyright (c) 2010 by Albert Graef <Dr.Graef@t-online.de>.

All rights reserved.

Sql3 is is free software: you can redistribute it and/or modify it
under the terms of the New BSD License, often referred to as the 3
clause BSD license.  Sql3 is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Please see the COPYING file for the actual license applicable to Sql3.

Installation
============

You need to have Pure and SQLite_ installed, obviously. Run ``make`` to
compile the module, and ``sudo make install`` to install Sql3 in the Pure
library directory.

Data Structure
==============

As far as the SQLite C interface is concerned, the most important
"data structures" are pointers to the following encapsulated SQLite
objects.

  * Database connection object: sqlite3
  * Prepared statement object: sqlite3_stmt

The Sql3 functions **open** and **prep** return "sentry-guarded"
pointers to database connection objects and prepared statement
objects, respectively. The pointers returned by these two functions
are refered to herein as **db_ptrs** and **stmt_ptrs**.

A db_ptr or a stmt_ptr is, as far as SQLite is concerned, the same as
a raw pointer returned by **sqlite3_open_v2** or
**sqlite3_prepare_v2**, the native interface functions corresponding
to **open** and **prep**. This allows the programmer to use db_ptrs
and stmt_ptrs to call functions provided by the SQLite C interface
just about anywhere a native pointer would be used.

This facility avoids a lot of redundant wrapping functions and a lot
of redundant documentation. But using it can be dangerous as is the
case with any call from Pure code to an external C function.  Sql3
users should be especially careful in this regard because using a
db_ptr or a stmt_ptr in calls to certain native C interface functions,
including in particular **sqlite3_close** and **sqlite3_finalize**, will
corrupt data held by the db_ptr or stmt_ptr, leading to undefined
behavior.

The reason for this restriction is that Sql3 uses sentries to insure
that the resources associated with a db_ptr or a stmt_ptr are
automatically finalized by SQLite when they go out of scope. In
addition, the sentries carry internal information used by Sql3 for
other purposes. (See `Accessing the Rest of SQLite's C Interface`_).

Core Database Operations
========================

The core database operations, the ones that are used 99 percent of the
time, are (a) opening and closing database connections and (b)
preparing and executing SQL statements.

Database Connections
--------------------

Opening a Database Connection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In Sql3 **open** provides a db_ptr that refers to a SQLite database
connection object.

.. _open:

**open (file_path::string [,access_mode::int,custom_bindings]])**
  opens a SQLite database file whose name is given by the file_path
  argument and returns a db_ptr for the database connection object
  created by SQLite. The access_mode is what one would expect
  ... read-only, create if not found, etc. plus some sophisticated
  caching and threading options. The custom_bindings option allows the
  user to prepare statements associated with the returned db_ptr that
  have custom binding types.

Example::

  >  let dbp2 = open "abc.db"; dbp2;
  #<pointer 0x992dff8>

If the filename is ":memory:", then a private, temporary in-memory database
is created for the connection. This in-memory database will vanish when the
database connection is closed. 

The basic access modes are:

* SQLITE_OPEN_READONLY - the database is opened in read-only mode. If the
  database does not already exist, an error is returned.

* SQLITE_OPEN_READWRITE - the database is opened for reading and writing if
  possible, or reading only if the file is write protected by the operating
  system. In either case the database must already exist, otherwise an
  error is returned.

* SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE - the database is opened for
  reading and writing, and is creates it if it does not already exist. This
  is the default value that is used if the flags argument is omitted.

* SQLITE_OPEN - an alias for SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE
  provided by Sql3.

These flags can be combined with SQLITE_OPEN_NOMUTEX
SQLITE_OPEN_FULLMUTEX SQLITE_OPEN_SHAREDCACHE SQLITE_OPEN_PRIVATECACHE
to control SQLite's threading and shared cache features. All of these
flags are exported by Sql3.

The optional ``custom_bindings`` argument allows the user to set up
customized binding and fetching behavior for prepared statements
associated with the returned db_ptr. (See `Custom Binding Types for
Prepared Statements`_)

Failure to Open a Database Connection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Even if SQLite cannot open the connection, it still returns a pointer
to a database connection object that must be closed. In this case,
**open** automatically closes the the connection object and then
throws an exception. E.g.,::

  > catch error (open ("RM_zyx.db",SQLITE_OPEN_READONLY));
  error (sql3::db_error 14 "unable to open database file [open RM_zyx.db]")


SQLite does not check to see that a file is a valid SQLite database
when it opens it. If the file is corrupted SQLite will return and
error when the connection is used.

Testing a db_ptr
~~~~~~~~~~~~~~~~

For argument checking and other purposes Sql3 provides the following
functions:

.. _is_db_ptr:

**is_db_ptr ptr::pointer**
  returns 1 if ptr is a db_ptr returned by open, and 0 if it is not.

.. _is_open:

**is_open ptr::pointer**
  returns 1 if the database connection referenced by by ptr is open.

Closing a Database Connection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When a database connection object is no longer needed, it should be closed
so that SQLite can free the associated resources.

.. _close:

**close dp1::pointer**

  if the database connection referenced by the db_ptr dp1 is open,
  close it using sqlite3_close Otherwise does nothing. Before calling
  sqlite3_close, close finalizes all "prepared statements" that
  associated with the connection.

Example::

  > close dbp;

If a db_ptr, say dbp, goes out of scope, close dbp is called
automatically. When debugging, this behavior can be observed by
editing sql3.pure, changing "const SHOW_OPEN_CLOSE = 0;" to "const
SHOW_OPEN_CLOSE = 1;" and running sudo make install in the pure-sql3
directory. This will cause a message to be printed whenever a db_ptr
or stmt_ptr is created or finalized.

Prepared Statements
-------------------

Constructing Prepared Statements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In SQLite, prepared statement objects are used to execute SQL
statements using the following SQLite C interface functions.

* sqlite3_prepare()
* sqlite3_bind()
* sqlite3_step()
* sqlite3_column()
* sqlite3_finalize()

The basic procedure is to prepare a statement, use the appropriate
sqlite3_bind to bind its parameters, step it one or more times until
it is done and then finalize it. Each time sqlite3_step() returns
SQLITE_ROW, use sqlite3_column to fetch the row's values.

In the SQLite C Interface, sqlite3_bind and sqlite3_column represent
families of bind and column functions, with one member for each of the
basic data types recognized by SQLite. Thus, for example,
sqlite_bind_double() would be the function one would use to bind a
prepared statement with an argument of type double.

Sql3 captures these procedure in four functions: **prep**, **exec**,
**lexec** and **finalize**.

.. _prep:

**prep dbp::pointer types::string sql::string**
  constructs prepared statement object and returns a stmt_ptr that
  references it. "dbp" must be a db_ptr or the rule will not
  match. "sql" is a string that specifies the sql statement to be
  executed. It can contain argument placeholders, indicated by "?",
  "?nnn", ":AAA", etc. See sqlite3_prepare_v2 for further details. The
  "type" parameter is the binding string tells Sql3 the types of
  arguments to be used when binding the prepared statement as well as
  the types of objects returned at each execution step.

In the following two examples, the "c" and "i" int the binding strings
indicate that a string and an int will be used to bind stmp1, an int
will be used to bind stmp2 and that stmp2, when executed, will return
a result set in the form of a list of sublists each of which contains a
string and an int. ::

  > let sp1 = prep dbp "ci" "insert into RM values (?,?)";

  > let sp2 = prep dbp "ci:i" "select * from RM where age > ?"; stmp;
  #<pointer 0xa4b43c0>

  > exec sp1 ("Tom",30);  //insert Tom
  []

  > exec sp2 19;          //select age > 19
  [["Sam",20],["Tom",30],["Fred",35]]

In general, the characters in the type string before the ":", if any, indicate
the types in the result set. Those that occur after the ":", if any
indicate the types of the arguments used to bind the prepared statement
object. If the type string does not contain a ":", the characters in the type
string, if any, are the types of binding arguments.

Sql3 provides the following set of "core" binding types:

==== ================ ===========
Type Pure Type        SQLite Type
==== ================ ===========
b    (int, pointer)   blob
c    string           text (utf8)
d    double           float
i    int              int
k    int or bigint    int64
l    bigint           blob
n    Sql3::SQLNULL    NULL
x    expression       blob
v    variant          variant
==== ================ ===========


The "b" or blob type is different from the rest in that on the Pure
side it is specified as a pair. The "c" type which stands for
"char*". The "d" for double and "i" for int should be self
explanitory.

The "k" type, which converts ints and a subset of bigints into int64,
is useful when dealing with SQLite's "integer primary keys" and
"rowids" both of which are 64 bit ints. It is also useful for storing
a useful subset of bigint in a format that can be recognized by SQLite
in SQL math expressions. The "l" type, in contrast maps the bigints
onto blobs, which are generally meaningless in SQL math
expressions. 

The "n" type can only appear on the binding side of a
type string. A binding argument corresponding to a "v" in the type
string will be treated as bound as if the "v" were a "b", "c", "d",
"i" or "n", based on the type of the binding argument. An object
returned when a prepared statement is stepped that corresponding to a
"v" type will be fetched according to the native SQLite column type of
the corresponding column. 

The "x" type is used to store and reconstruct Pure expressions as
binary objects, using **val** and **blob**.

As mentioned, users can define custom binding types and pass them as a
third parameter to open. The resulting db_ptr can be used with the
additional binding types to construct prepared statements that can be
executed with customized arguments. (`Custom Binding Types for
Prepared Statements`_).

The examples directory contains a file, sql3_types.pure, that has an
example for each core binding type and a file,
sql3_user_bind_types.pure, that has an example using custom bind
types.

Executing Prepared Statements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In Sql3, the bind, step, column, step, column ... cycle is encapsulated in
the **exec** and **lexec** functions.

.. _exec:

**exec sp::pointer args**
  uses args to bind the prepared statement referenced by sp, then
  steps the prepared statement until it is done, collecting the
  results of the steps in a list. ``args`` is a tuple or list of
  arguments whose number and type correspond to the bind parameter
  types specified in the call to prep that produced stmp. This rule
  matches only if stmp is a stmt_ptr. Throws and error if SQLite
  returns an error code anywhere in the process.

Example::

  > exec sp1 ("Tom",30);  //insert Tom
  []

  > exec sp2 19;          //select age > 19
  [["Sam",20],["Tom",30],["Fred",35]]

An error is thrown if the args do not correspond to the specified types. ::

  > catch error (exec sp2 "a");
  error "sql3 error: Attempt to bind a \"a\" as a int"

If a prepared statement does not have any binding parameters,
the call to exec should use () as the binding argument. ::

  > let sp3 = prep dbp "c:" "select name from RM";

  > exec sp3 ();
  [["Sam"],["Fred"]]

A little extra care is required when executing prepared statements
that take a blob argument.  A blob argument is different than the
other types in that it must be a tuple (n,ptr) where n is the length
of the data in bytes and ptr is its address.  In order to preserve the
tuple as a pair, a blob argument should be passed to exec using the
list form rather than the tuple form. ::

  > let blb = (100,ptr);

  > (a,blb,c);
  a,100,ptr,c

  > [a,blb,c];
  [a,(100,ptr),c]

Thus "exec stpx [a,blb,c]" would work fine, while exec stpx (a,blb,c)
would produce a Sql3 binding exception.

Executing Lazily
~~~~~~~~~~~~~~~~

The **exec** function returns result sets as an eager list which can
sometimes be inefficient or simply not feasible for large result
sets. In such cases it is preferable to use **lexec** instead of
**exec**.

.. _lexec:

**lexec stmp::pointer args**
  same as ``exec`` except that it returns a lazy list.

E.g.,::

  > lexec sp2 19;
  ["Sam",20]:#<thunk 0xb6475ab0>

Note that no changes to stmp2 were required. In addition, for most
purposes the lazy list returned by **lexec** can be processed by the same
code that processed the eager list returned by **exec** (see ``Lazy
Evaluation and Streams`` FIX )! The examples directory contains a
file sql3_lexec.pure that compares memory usage and time for a
moderately sized result set using **exec** and **lexec**.

Executing Directly on A db_ptr
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For statements that have no parameters and which do not return results,
`exec` can be applied to a db_ptr.

.. _exec dbp:

**exec dbp::pointer sql::string**
  constructs a temporary prepared statement using the sql string. The
  sql string cannot contain parameters (?, ?nnn, etc.). Throws an
  error if SQLite indicates an error while exec is processing the sql. 

Example::

  > exec db1 "create table if not exists RM (name varchar, age integer)";

.. _Executing Against a Busy Database:

Executing Against a Busy Database
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Multiple processes can have the same database open at the same
time. Thus you can simultaneously process a SQLite database file using
your Pure application from one terminal and run sqlite3 on the same
file from another terminal. SQLite allows multiple processes to read
the database at once, but when any process wants to write, it must
lock the entire database file for the duration of its update.

When **sqlite3_step** (called by **exec** and **lexec**) tries to
access a file that is locked by another process, it treats the
database as "busy and returns the SQLITE_BUSY error code. If this
happens in a call to **exec** or **lexec**, a db_busy_ exception will
be thrown. You can adjust this behavior from C code using the
sqlite3_busy_handler() or sqlite3_busy_timeout() API functions. Sql3
does not currently provide a simple way to set up a busy handler, but
if all you want to do is provide for a retry after a short amount of
time, you can easily call sqlite3_busy_timeout() from Pure.

Testing a stmt_ptr
~~~~~~~~~~~~~~~~~~

For argument checking and other purposes it is sometimes useful to
determine if a given expression is a valid stmt_ptr.

.. _is_stmt_ptr:

**is_stmt_ptr ptr::pointer**
  returns 1 if ptr is a stmt_ptr, otherwise returns 0.

::

  > is_stmt_ptr sp2;
  1

Finalizing Prepared Statements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When a prepared statement is no longer needed it should be finalized
so that SQLite can free the associated resources.

.. _finalize:

**finalize sp::pointer**
  finalize the prepared statement referenced by sp, which must be a
  stmt_ptr returned by **prep**.

Often there is no need to call this function for a given stmt_ptr
because it will be automatically called when the stmt_ptr goes out of
scope.

In contrast to **sqlite3_finalize**, the corresponding native C
function, finalize can be called multiple times (without causing a seg
fault).

NEVER CALL **SQLITE3_FINALIZE** WITH A STMT_PTR. If a stmt_ptr is
closed behind Sql3's back, a subsequent call to **finalize**
(including the call that will automatically occur when the stmt_ptr
goes out of scope) will cause a seg fault.

Grouping Execution with Transactions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

No changes can be made to a SQLite database file except within a
transaction. Transactions can be started manually by executing a BEGIN
statement. Manually started transactions persist until the next COMMIT
or ROLLBACK statement is executed. Transactions are also ended if an
error occurs before the transaction is manually ended using a COMMIT
or ROLLBACK statement. This behavior provides the means make a series
of changes on an "atomic" or all or nothing basis.

By default, SQLite operates in autocommit mode. In autocommit mode,
any SQL statement that changes the database (basically, anything other
than SELECT) will automatically start a transaction if one is not
already in effect. As opposed to manually started transactions,
automatically started transactions are committed as soon as they
execution of the related statement completes.

The upshot of this, in Sql3 terms, is that unless a transaction is
started manually, the database will be updated (usually on disk) each
time **exec** is called. For a long series of updates or inserts this
a can be very slow. The way to avoid this problem is to begin a
transaction manually before the first update and manually ending the
transaction after the last update.

Transactions created using BEGIN...COMMIT do not nest. For nested
transactions, use the SAVEPOINT and RELEASE statements. 

Sql3 provides the following convenience functions all of which simply
exec dbp with the appropriate statement. For example begin dbp is
exactly the same as **exec dbp "BEGIN"**.

.. _begin:
.. _begin_exclusive:
.. _begin_immediate:
.. _commit:
.. _savepoint:
.. _release:
.. _rollback_to:
.. _rollback:

* begin dbp::pointer
* begin_exclusive dbp::pointer
* begin_immediate dbp::pointer
* commit dbp::pointer
* rollback dbp::pointer
* savepoint dbp::pointer save_point::string
* release dbp::pointer  save_point::string
* rollback_to dbp::pointer  save_point::string

See the SQLite documentation for further details.

Exceptions
----------

Sql3 throws two types of exceptions, one for outright errors and one
for database "busy" conditions.

.. _db_error:

db_error
~~~~~~~~

When and Sql3 function detects and error it throws an exception of the
form "db_error ec msg" where ec is and error code and msg is the
corresponding error message. If ec>0, the error was detected by SQLite
itself, and ec and msg are those returned by SQLite. If ec==0, the
error was detected by Sql3 and msg is a Sql3 specific description of
the error. E.g., ::

  >db_error_handler (db_error ec msg) = ()
  >when
  >  source = if ec > 0 then "SQLite" else "Sql3";
  >  printf "%s db_error: ec %d, %s\n" (source,ec,msg);
  >db_error_handler x = throw x;

  >catch db_error_handler (exec dbp "select * from NO_TABLE");
  SQLite db_error: ec 1, no such table: NO_TABLE

.. _db_busy:

db_busy
~~~~~~~

Sql3 functions **exec** and **lexec** throw exceptions of the from
"db_busy dbp", where dbp is a db_ptr, if they are prevented from
executing succesfully because the database referenced by dbp is
locked. (See `Executing Against a Busy Database`_).

If the statement is a COMMIT (including a call to the Sql3 commit
function) or occurs outside of an explicit transaction, then you can
retry the statement. If the statement is not a COMMIT and occurs
within a explicit transaction then you should rollback the transaction
before continuing.


SQLite Error Codes
~~~~~~~~~~~~~~~~~~

Here is a list, as of April 2, 2010, SQLite's error codes. ::

  SQLITE_ERROR        1   /* SQL error or missing database */
  SQLITE_INTERNAL     2   /* Internal logic error in SQLite */
  SQLITE_PERM         3   /* Access permission denied */
  SQLITE_ABORT        4   /* Callback routine requested an abort */
  SQLITE_BUSY         5   /* The database file is locked */
  SQLITE_LOCKED       6   /* A table in the database is locked */
  SQLITE_NOMEM        7   /* A malloc() failed */
  SQLITE_READONLY     8   /* Attempt to write a readonly database */
  SQLITE_INTERRUPT    9   /* Operation terminated by sqlite3_interrupt()*/
  SQLITE_IOERR       10   /* Some kind of disk I/O error occurred */
  SQLITE_CORRUPT     11   /* The database disk image is malformed */
  SQLITE_NOTFOUND    12   /* NOT USED. Table or record not found */
  SQLITE_FULL        13   /* Insertion failed because database is full */
  SQLITE_CANTOPEN    14   /* Unable to open the database file */
  SQLITE_PROTOCOL    15   /* NOT USED. Database lock protocol error */
  SQLITE_EMPTY       16   /* Database is empty */
  SQLITE_SCHEMA      17   /* The database schema changed */
  SQLITE_TOOBIG      18   /* String or BLOB exceeds size limit */
  SQLITE_CONSTRAINT  19   /* Abort due to constraint violation */
  SQLITE_MISMATCH    20   /* Data type mismatch */
  SQLITE_MISUSE      21   /* Library used incorrectly */
  SQLITE_NOLFS       22   /* Uses OS features not supported on host */
  SQLITE_AUTH        23   /* Authorization denied */
  SQLITE_FORMAT      24   /* Auxiliary database format error */
  SQLITE_RANGE       25   /* 2nd parameter to sqlite3_bind out of range */
  SQLITE_NOTADB      26   /* File opened that is not a database file */

New error codes may be added in future versions of SQLite. Note that
the SQLite names of the error codes are not exported by the Sql3
module.

Advanced Usage
==============

Sql3's advanced features include the ability to implement SQL
functions in Pure, convenient access to the SQLite C interface and
custom binding types.

Custom SQL Functions
--------------------

An extremely powerful (albeit complex) feature of the SQLite C
interface is the ability to add new SQL scalar or aggregate
functions. The new functions can be used in SQL statements the same as
the prepackaged functions and aggregates. Sql3 hides the complexity
and seamlessly integrates all of this functionality, :), into Pure via
the **function** function. **function** has two forms: one for
registering scalar SQL functions and one for registering aggregate SQL
functions.

Scalar Functions
~~~~~~~~~~~~~~~~

You can add a custom SQL scalar function to SQLite using the following form:

**function dbp::pointer name::string nargs::int pure_fun**
  registers a new SQL scalar function of nargs arguments that can be
  called, as "name", in SQL statements prepared with respect to dbp, a
  db_ptr. When the SQL function is called in a SQL statement, control
  will be passed to pure_fun, a curried function written in Pure. If
  nargs is (-1), the SQL function "name" is variadic, and the
  argumentw will be passed to pure_fun as a single list.

Here is an example of a scalar function that takes two parameters. Note
that any kind of Pure "function" can be passed here; local functions,
global functions, lambdas or partial applications all work. ::

  >function dbp "p_fn" 2 plus with plus x y = x + y; end;

  >let sp4 = prep dbp "cii:" 
  >         "select p_fn('Hi ',name), age, p_fn(age,10) from RM";

  >exec sp4 ();
  [["Hi Sam",20,30],["Hi Fred",22,32]]

Here is an example of a variadic function::

  >function dbp "p_qm" (-1) quasimodo with
  >  quasimodo xs = "quasimodo: "+join ":" [str x | x=xs];
  >end;

If the SQL function takes no arguments, the corresponding Pure
function must, for technical reasons in Pure, take a single dummy
argument. E.g., ::

  >function dbp "p_count" 0 counter with
  >  counter () = put r (get r+1);
  >end when r = ref 0 end;

Here is how "count" and "quasimodo" might be used::

  >let sp5 = prep dbp "ic:" "select p_count(), p_qm(name,age) from RM";

  > exec sp5 ();
  [[1,"quasimodo: \"Sam\":20"],[2,"quasimodo: \"Fred\":22"]]

  > exec sp5 ();
  [[3,"quasimodo: \"Sam\":20"],[4,"quasimodo: \"Fred\":22"]]


Aggregate Functions
~~~~~~~~~~~~~~~~~~~

If the fourth argument passed to **function** is a triple, the
registered SQL function will be an aggregate function.

**function dbp::pointer name::string nargs::int (step,final,start)**
  registers a new SQL aggregate function of nargs arguments that can
  be called, as "name" in SQL statements prepared with respect to dbp,
  a db_ptr.  Step and final are curried Pure functions and start is
  the initial value for the aggregation. The 'step' function is called
  repeatedly to accumulate values from the database, starting from the
  given 'start' value, and finally the 'final' function is applied to
  the accumulated result.

Note that for a single-argument 'step' function, this works exactly as
if the functions were invoked as 'final (foldl step start values)',
where 'values' is the list of aggregated values from the database. E.g.,::

  >function dbp "p_avg" 1 (step,final,(0,0.0)) with
  >  step (n,a) x = n+1, a+x;
  >  final (n,a) = a/n;
  >end;

  >let sp6 = prep dbp "id:" "select count(name), p_avg(age) from RM";

  >exec sp6 ();
   [[2,21.0]]

More on Custom Functions
~~~~~~~~~~~~~~~~~~~~~~~~

More examples using **function** can be found in sql_funs.pure in the
examples subdirectory.

It's ok to register multiple SQL functions with the same name if they
have differing numbers of arguments. Built-in SQL functions may be
overloaded or replaced by new application-defined functions.

Generally, a custom function is permitted to call other Sql3 and
native SQLite C interface functions. However, such calls must not
close the database connection nor finalize or reset the prepared
statement in which the function is running.

.. _Accessing the Rest of SQLite's C Interface:


Accessing the Rest of SQLite's C Interface
------------------------------------------

A db_ptr returned by **open** and a stmt_ptr returned by **prep** are
the actual pointers to the data base connection objects and prepared
statement objects returned by the the corresponding native C interface
functions **sqlite3_open_v2** and **sqlite3_prepare_v2** (except that
they have sentries attached). Accordingly, it is easy to call almost
any native C function in SQLite's C interface.

For example, you can override SQLite's default behavior with respect
to busy databases as follows:

  > extern int sqlite3_busy_timeout(sqlite3*, int);

  > sqlite3_busy_timeout dbp 10;

This sets a busy handler that will "sleep and retry" multiple times
until at least 10 milliseconds of sleeping have accumulated.  Calling
this routine with an argument less than or equal to zero turns off all
busy handlers.

Or you might be interested in the the number of database rows that
were changed or inserted or deleted by the most recently completed SQL
statement executed on a given database connection::

  > extern int sqlite3_changes(sqlite3*);

  > exec sp1 ("Harvey",30);

  > sqlite3_changes dbp;
  1

As a final example, in this case using a stmt_ptr, you can determine
name assigned to a column in a result using **sqlite3_column_name**::

  > extern char *sqlite3_column_name(sqlite3_stmt*, int);
 
  > exec sp2 29;
  [["Harvey",30]]

  > sqlite3_column_name sp2 1;
  "age"

Note that in order to call a native C function you must first make it
accessible using an extern statement.

.. _Custom Binding Types for Prepared Statements:

Custom Binding Types for Prepared Statements
--------------------------------------------

Your can add your own binding types to a database connection when
they open it by specifying a third parameter to **open**.  The custom
binding types can then be specified in calls to **prep** that use the
db_ptr returned by the call to **open**. The third parameter is a list
of "hash rocket pairs" in which the first element is a character for
the custom binding type and the second element is a list with three
members. The second and third members of the list are functions that
map objects from the new type to one of the Sql3 core types REF and
back. The first member of the list is the character for the Sql3 core
types referenced by the mapping functions.

The file sql3_user_bind_types.pure in the examples subdirectory shows
how this might be done for a couple of user defined types. The example
script deals with dates and certain Pure expressions as bigints and
native Pure expressions, while the database stores these in utf_8
text. The following snippets show parts of the script that are
relevant to this discussion::

  const custom_binds = [
    "t"=>["c", day_to_str,str_to_day],
    "s"=>["c",str,eval]
  ];

  d1 = str_to_day "2010-03-22";

  db = open ("abc.db", SQLITE_OPEN, custom_binds); 
  stm1 = prep db "cts" "insert into TC values(?,?,?)";  
  exec stm1 ["Manny", d1, s_expr];
  stm3a = sql3::prep db "t:" "select t_date from TC";
  stm3b = sql3::prep db "c:" "select t_date from TC";

Executing stm3a and stm3b from the interpreter shows that TC's date
field is stored as a string, but returned to the Pure script as a
bigint. ::

  > sql3::exec stm3a ());
  [[14691L]]
  > sql3::exec stm3b ());
  [["2010-03-22"]]

The character designating the custom type must not be one of the
letters used to designate Sql3 core binding types.

Threading Modes
---------------

SQLite supports three different threading modes:

1. Single-thread. In this mode, all mutexes are disabled and SQLite
   is unsafe to use in more than a single thread at once. 

2. Multi-thread. In this mode, SQLite can be safely used by multiple
   threads provided that no single database connection is used
   simultaneously in two or more threads.

3. Serialized. In serialized mode, SQLite can be safely used by
   multiple threads with no restriction.

SQLite can be compiled with or without support for multithreading and
the default is to support it. 

In many cases, single-thread mode might be appropriate if only because
it is measurably faster. This might be the case, for example, if you
are using SQLite as the on-disk file format for a desktop application.

If your version of SQLite was compiled with support for
multithreading, you can switch to single-thread mode at runtime by calling
sqlite3_config() with the verb SQLITE_CONFIG_SINGLETHREAD.

If you must use threads, using Sql3 probably will not interfere,
assuming that you apply the same precautions to a db_ptr or stm_ptr
that you would apply to the underlying sqlite* and sqlite_stmt*s if
you were not using Sql3. Since everything that is imposed between the
raw pointers returned by the SQlite interface and the corresponding
db_ptr and stmt_ptrs is written in Pure, it should be relatively easy
to determine how Sql3 and your multithreading strategy will
interact. See `Is SQLite threadsafe?`_ , `Opening A New Database
Connection`_ and `Test To See If The Library Is Threadsafe`_.

.. _`Is SQLite threadsafe?`: http://www.sqlite.org/faq.html#q6

.. _Opening A New Database Connection: http://www.sqlite.org/c3ref/open.html

.. _Test To See If The Library Is Threadsafe: http://www.sqlite.org/c3ref/threadsafe.html


