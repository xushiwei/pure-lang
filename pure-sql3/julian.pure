/* julian.pure - functions for dealing with Julian dates */

using system;
using "lib:julianutil";
using math;

namespace julian;

/* The algorithms used in this module reflect the Gregorian proleptic
   calendar (i.e., the Gregorian calendar extended to cover dates
   before its introduction in 1582.) When expressing Gregorian dates
   as yyyy-mm-dd, astronomical year numbering is used, thus 1 BC is 0,
   2 BC is −1, and 4714 BC is −4713. The months (mm) and days (dd)
   start with 1.

   Daylight saving time adjustments for dates before 1971 are assumed
   to be zero. Those after 1970, except for current dates, are
   estimates that might not be accurate.
    
   These algorithms are based on algorithms in SQLite's date.c file
   which are implemented based on descriptions in the following text:
  
        Jean Meeus
        Astronomical Algorithms, 2nd Edition, 1998
        ISBM 0-943396-61-1
        Willmann-Bell, Inc
        Richmond, Virginia (USA)

   The date European countries adopted the Gregorian calendar varied
   by country. For the first adopters the last day of the Julian
   calendar was Thursday, 1582-10-4 and this was followed by the first
   day of the Gregorian calendar, Friday, 15 October 1582.  In
   Historians usually use the Julian calendar for dates prior to
   1582-10-15 and for some dates afterwards, depending on locale, as
   opposed to the Gregorian proleptic calendar.  Thus, depending on
   what calendar is being used to express dates before 1582-10-15, you
   will see different values for the same Julian date JD. For example:

   JD 0 for Julian proleptic calendar is noon -4713-01-01
   JD 0 for the Gregorian proleptic calendar is noon -4714-11-24
   JD 0 for these algorithms is noon -4713-11-24

   For dates after the adoption, the date components returned by these
   algoritms conform to the Gregorian calendar. For example:

   JD 2400000 for these algorithms is 1858-11-16 12:00:00.000
   JD 2400000 for the Gregorian calendar is noon 1858-11-16

   Please notice that Julian dates start at noon. Thus the JD for
   1858-11-16 00:00:00 is 2399999.5 (I.e., 2399999.5 days after JD 0,
   noon of -4713-11-24).

   One advantage of using the Gregorian proleptic calendar with
   astronomical year numbering is that if two julian dates differ by 1
   day their yyyy-mm-dd will differ by one day (as were are normally
   accustomed to) without a 13 day or one year gap. E.g., using the
   functions from this module one does not have to worry about the
   when the Gregorian calendar was adopted. For example:

   > let ad1 = greg_to_jd (1582, 10, 10);
   > let ad2 = greg_to_jd (1582, 10, 11);
   > ad2 -ad1;
   1.0

   In contrast, when confronted with 1582-10-10, the julian date
   converter at http://aa.usno.navy.mil/data/docs/JulianDate.php
   responds with: "The dates 5 through 14 October, 1582, do not exist
   in the Gregorian Calendar!". Furthermore, according to that site,
   the calendar dates for the following adjacent Julian dates reflect
   a 13 day gap.

   JD 2299159.50000: 1582-10-04
   JD 2299160.50000: 1582-10-15

   Please bear these factors in mind when using this module.
  
   See http://en.wikipedia.org/wiki/Julian_day for further information.*/

public 
jd_to_unixtime jd_to_greg jd_to_str
unixtime_to_jd greg_to_jd str_to_jd 
current_jd weekday begmonth endmonth;

private extern double ymd_to_jd(int Y, int M, int D);
private extern expr* jd_to_ymd(double jd);
private extern double ymdhms_to_jd(int Y, int M, int D,
               int hr, int mn, double sc);
private extern expr* jd_to_ymdhms(double jd);
private extern double l_ymd_to_jd(int Y, int M, int D);
private extern expr* l_jd_to_ymd(double jd);
private extern double l_ymdhms_to_jd(int Y, int M, int D,
               int hr, int mn, double sc);
private extern expr* l_jd_to_ymdhms(double jd);

extern double local_jd(double jd);

private aux_str_to_jd scan_str;


/* Get current UTC time as JD, convert to and from unixtime (seconds
   since midnight January 1, 1970). */

extern double current_jd();
extern int jd_to_unixtime(double jd);
extern double unixtime_to_jd(int t);


/* Convert from "Gregorian tuples" of the form (Y,M,D[,h,m,s]) to JDs
   and back. */

greg_to_jd ("loc", Y::int, M::int, D::int, h::int, m::int, s::double) =
           l_ymdhms_to_jd Y M D h m s;
greg_to_jd ("loc", Y::int, M::int, D) = l_ymd_to_jd Y M D;
greg_to_jd (Y::int, M::int, D::int, h::int, m::int, s::double) =
           ymdhms_to_jd Y M D h m s;
greg_to_jd (Y::int, M::int, D) = ymd_to_jd Y M D;

jd_to_greg ("loc", jd,"long") = l_jd_to_ymdhms jd;
jd_to_greg ("loc",jd) = l_jd_to_ymd jd;
jd_to_greg (jd,"long") = jd_to_ymdhms jd;
jd_to_greg jd = jd_to_ymd jd;


/* Convert to and from strings of the form "YYYY-MM-DD[ hh:mm:ss.sss]"
   and back. */

str_to_jd ("loc", s::string) = aux_str_to_jd 1 s;
str_to_jd s::string = aux_str_to_jd 0 s;

jd_to_str ("loc",jd,"long") = 
   sprintf "%04d-%02d-%02d %02d:%02d:%06.3f" (l_jd_to_ymdhms jd);
jd_to_str ("loc",jd) = 
   sprintf "%04d-%02d-%02d" (l_jd_to_ymd jd);
jd_to_str (jd,"long") = 
   sprintf "%04d-%02d-%02d %02d:%02d:%06.3f" (jd_to_ymdhms jd);
jd_to_str jd = 
   sprintf "%04d-%02d-%02d" (jd_to_ymd jd);


/* Convenience functions */

weekday ("loc", jd::double) = ((int (ceil (local_jd jd))) + 1) mod 7;
weekday jd::double = ((int (ceil jd)) + 1) mod 7;

begmonth ("loc", jd::double) = l_ymdhms_to_jd y m 1 0 0 0.0
when y,m,d = jd_to_ymd (local_jd jd); end;

begmonth jd::double = ymdhms_to_jd y m 1 0 0 0.0
when y,m,d = jd_to_ymd jd; end;

endmonth ("loc", jd::double) = l_ymdhms_to_jd y (m+1) 0 0 0 0.0
when y,m,d = jd_to_ymd (local_jd jd); end;

endmonth jd::double = ymdhms_to_jd y (m+1) 0 0 0 0.0
when y,m,d = jd_to_ymd jd; end;


/* Helpers */

scan_str s::string = catch (cst ()) (scan_str_both s)
with
  scan_str_both s = catch (scan_str_short s) (scan_str_long s);
  scan_str_short s _ = if #s<=n then y,m,d else ()
  when
    y,m,d,n = sscanf s "%i-%u-%u%n";
  end;
  scan_str_long s =  if #s<=n then y,m,d,hr,mn,sc else throw 0
  when
    y,m,d,hr,mn,sc,n = sscanf s "%i-%u-%u%u:%u:%f%n";
  end;
end;

aux_str_to_jd locp s::string = res
when
  greg = scan_str s;
  null greg && throw julian_bad_string;
  res = if locp then greg_to_jd ("loc",greg) else greg_to_jd greg;
end;

