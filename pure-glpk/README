
============================================================
Pure-GLPK - GLPK interface for the Pure programming language
============================================================

:Author: - Jiri Spitz <jiri.spitz@bluetone.cz>
:Date: |date|

.. |date| date::

This module provides a feature complete GLPK interface for the Pure programming
language, which lets you use all capabilities of the GNU Linear Programming Kit
(GLPK) directly from Pure.

GLPK (see http://www.gnu.org/software/glpk) contains an efficient simplex
LP solver, a simplex LP solver in exact arithmetics, an interior-point solver,
a branch-and-cut solver for mixed integer programming and some specialized
algorithms for net/grid problems. Using this interface you can build, modify
and solve the problem, retrieve the solution, load and save the problem and
solution data in standard formats and use any of advanced GLPK features.

The interface uses native Pure data types - lists and tuples - so that you
need not perform any data conversions to/from GLPK internal data structures.

To make this module work, you must have a GLPK installation on your system,
the version 4.37 is required. 

.. contents::
.. sectnum::

.. Note: If you're wondering about the funny formatting, this README
simultaneously serves to generate the documentation for this module
in a variety of formats, using the docutils text formatting system
(http://docutils.sourceforge.net/).


Installation
============

Run ``make`` to compile the module and ``make install`` (as root) to install
it in the Pure library directory. This requires GNU make, and of course you
need to have Pure installed.

The default make options suppose that GLPK was configured with the following
options:
``--enable-dl --enable-odbc --enable-mysql --with-gmp --with-zlib``

Using the given options the depndencies are:

- GNU Multiprecision Library (GMP) - serves for the exact simplex solver.
  When disabled, the exact solver still works but it is much slower.
- ODBC library - serves for reading data directly from database tables
  within the GNU MathProg language translator through the ODBC interface.
- zlib compression library - enables reading and writing gzip compressed
  problem and solution files.
- MySQL client library - serves for reading data directly from MySQL tables
  within the GNU MathProg language translator.
- ltdl dlopen library - must be enabled together with any of ODBC, zlib or
  MySQL.

``make`` tries to guess your Pure installation directory and platform-specific
setup. If it gets this wrong, you can set some variables manually. In
particular, ``make install prefix=/usr`` sets the installation prefix, and
``make PIC=-fPIC`` or some similar flag might be needed for compilation on 64
bit systems. The variable ``ODBCLIB`` specifies the ODBC library to be linked
with. The default value is ``ODBCLIB=-lodbc``. Please see the Makefile for
details.


Error Handling
==============

When an error condition occurs, the GLPK library itself prints an error mesage
and terminates the application. This behaviour is not pleasant when working
within an interpreter. Therefore, the Pure - GLPK bindings catches at least
the most common errors like indices out of bounds. On such an error an
appropriate message is returned to the interpreter. The less common errors
are still trapped by the GLPK library.

When one of the most common errors occurs, an error term of the form
``glp::error message`` will be returned, which specifies what kind of error
happend. For instance, an index out of boundsd will cause a report like the
following::

glp::error "[Pure GLPK error] row index out of bounds"

You can check for such return values and take some appropriate action. By
redefining glp::error accordingly, you can also have it generate exceptions
or print an error message. For instance::

glp::error message = fprintf stderr "%s\n" message $$ ();

**NOTE:** When redefining ``glp::error`` in this manner, you should be aware
that the return value of ``glp::error`` is what will be returned by the other
operations of this module in case of an error condition. These return values
are checked by other functions. Thus the return value should still indicate
that an error has happened, and not be something that might be interpreted
as a legal return value, such as an integer or a nonempty tuple. It is usually
safe to have ``glp::error`` return an empty tuple or throw an exception, but
other types of return values should be avoided.

**IMPORTANT:** It is really good to define a ``glp::error`` function,
otherwise the errors might remain unnoticed.


Further Information and Examples
================================

For further details about the operations provided by this module please see
the GLPK Reference Manual. Sample scripts illustrating the usage of the module
can be found in the examples directory.


Interface description
=====================

Most GLPK functions and symbols live in the namespace ``glp``. There are a few
functions and symbols in the namespace ``lpx``. These functions and symbols
are likely to be removed and replaced by new ones in the future.

In general, when you replace the ``glp_`` prefix from the GLPK Reference Manual
with the namespace specification ``glp::`` then you receive the function name
in this module. The same is valid for ``lpx_`` and ``lpx::``. The symbolic
constants are converted into lower case in this module, again obeying the
same prefix rules.


Descriptions of interface functions
===================================


Basic API routines
::::::::::::::::::


Problem creating and modifying routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Create the GLPK problem object
------------------------------
``glp::create_prob``

Set the problem name
--------------------
``glp::set_prob_name lp name``

Set objective name
------------------
``glp::set_obj_name lp name``

Set minimization or maximization
--------------------------------
``glp::set_obj_dir lp direction``

Add new rows to the problem
---------------------------
``glp::add_rows lp count``

Add new cols to the problem
---------------------------
``glp::add_cols lp count``

Set the row name
----------------
``glp::set_row_name lp (rowindex, rowname)``

Set the column name
-------------------
``glp::set_col_name lp (colindex, colname)``

Set (change) row bounds
-----------------------
``glp::set_row_bnds lp (rowindex, rowtype, lowerbound, upperbound)``

Set (change) column bounds
--------------------------
``glp::set_col_bnds lp (colindex, coltype, lowerbound, upperbound)``

Set (change) objective coeﬃcient or constant term
---------------------------------------------------
``glp::set_obj_coef lp (colindex, coefficient)``

Load or replace matrix row
--------------------------
``glp::set_mat_row lp (rowindex, rowvector)``

Load or replace matrix column
-----------------------------
``glp::set_mat_col lp (colindex, colvector)``

Load or replace the whole problem matrix
----------------------------------------
``glp::load_matrix lp matrix``

Delete rows from the matrix
---------------------------
``glp::del_rows lp rows``

Delete columns from the matrix
------------------------------
``glp::del_cols lp cols``

Copy the whole content of an GLPK problem object to another one
---------------------------------------------------------------
``glp::copy_prob destination source names``

Erase all data from the GLPK problem object
-------------------------------------------
``glp::erase_prob lp``

Delete the GLPK problem object
------------------------------
``glp::delete_prob lp``


Problem retrieving routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>


Get the problem name
--------------------
``glp::get_prob_name lp``

Get the objective name
----------------------
``glp::get_obj_name lp``

// Get minimization or maximization
``glp::get_obj_dir lp``

Get number of rows
------------------
``glp::get_num_rows lp``

Get number of columns
---------------------
``glp::get_num_cols lp``

Get name of a row
-----------------
``glp::get_row_name lp rowindex``

Get name of a column
--------------------
``glp::get_col_name lp colindex``

Get row type
------------
``glp::get_row_type lp rowindex``

Get row lower bound
-------------------
``glp::get_row_lb lp rowindex``

Get row upper bound
-------------------
``glp::get_row_ub lp rowindex``

Get column type
---------------
``glp::get_col_type lp colindex``

Get column lower bound
----------------------
``glp::get_col_lb lp colindex``

Get column upper bound
----------------------
``glp::get_col_ub lp colindex``

Get objective coefficient
-------------------------
``glp::get_obj_coef lp colindex``

Get number of nonzero coefficients
----------------------------------
``glp::get_num_nz lp``

Retrive a row from the problem matrix
-------------------------------------
``glp::get_mat_row lp rowindex``

Retrive a column from the problem matrix
----------------------------------------
``glp::get_mat_col lp colindex``


Row and column searchin routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Create index for searching rows and columns by their names
----------------------------------------------------------
``glp::create_index lp``

Find a row number by name
-------------------------
``glp::find_row lp rowname``

Find a column number by name
----------------------------
``glp::find_col lp colname``

Delete index for searching rows and columns by their names
----------------------------------------------------------
``glp::delete_index lp``


Problem scaling routines
>>>>>>>>>>>>>>>>>>>>>>>>


Set the row scale factor
------------------------
``glp::set_rii lp (rowindex, coefficient)``

Set the column scale factor
---------------------------
``glp::set_sjj lp (colindex, coefficient)``

Retrieve the row scale factor
-----------------------------
``glp::get_rii lp rowindex``

Retrieve the column scale factor
--------------------------------
``glp::get_sjj lp colindex``

Scale the problem data according to supplied flags
--------------------------------------------------
``glp::scale_prob lp flags``

Unscale the problem data
------------------------
``glp::unscale_prob lp``


LP basis constructing routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Set the row status
------------------
``glp::set_row_stat lp (rowindex, status)``

Set the column status
---------------------
``glp::set_col_stat lp (colindex, status)``

Construct standard problem basis
--------------------------------
``glp::std_basis lp``

Construct advanced problem basis
--------------------------------
``glp::adv_basis lp``

Construct Bixby's problem basis
-------------------------------
``glp::cpx_basis lp``


Simplex method routines
>>>>>>>>>>>>>>>>>>>>>>>


Solve the LP problem using simplex method
-----------------------------------------
``glp::simplex lp options``

Solve the LP problem using simplex method in exact arithmetics
--------------------------------------------------------------
``glp::exact lp options``

Retrieve generic status of basic solution
-----------------------------------------
``glp::get_status lp``

Retrieve generic status of primal solution
------------------------------------------
``glp::get_prim_stat lp``

Retrieve generic status of dual solution
----------------------------------------
``glp::get_dual_stat lp``

Retrieve value of the objective function
----------------------------------------
``glp::get_obj_val lp``

Retrieve generic status of a row variable
-----------------------------------------
``glp::get_row_stat lp rowindex``

Retrieve row primal value
-------------------------
``glp::get_row_prim lp rowindex``

Retrieve row dual value
-----------------------
``glp::get_row_dual lp rowindex``

Retrieve generic status of a column variable
--------------------------------------------
``glp::get_col_stat lp colindex``

Retrieve column primal value
----------------------------
``glp::get_col_prim lp colindex``

Retrieve column dual value
--------------------------
``glp::get_col_dual lp colindex``

Determine variable causing unboundedness
----------------------------------------
``glp::get_unbnd_ray lp``


Interior-point method routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Solve the LP problem using interior-point method
------------------------------------------------
``glp::interior lp``

Retrieve status of interior-point solution
------------------------------------------
``glp::ipt_status lp``

Retrieve the objective function value of interior-point solution
----------------------------------------------------------------
``glp::ipt_obj_val lp``

Retrieve row primal value of interior-point solution
----------------------------------------------------
``glp::ipt_row_prim lp rowindex``

Retrieve row dual value of interior-point solution
--------------------------------------------------
``glp::ipt_row_dual lp rowindex``

Retrieve column primal value of interior-point solution
-------------------------------------------------------
``glp::ipt_col_prim lp colindex``

Retrieve column dual value of interior-point solution
-----------------------------------------------------
``glp::ipt_col_dual lp colindex``


Mixed integer programming routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Set column kind
---------------
``glp::set_col_kind lp (colindex, colkind)``

Retrieve column kind
--------------------
``glp::get_col_kind lp colindex``

Retrieve number of integer columns
----------------------------------
``glp::get_num_int lp``

Retrieve number of binary columns
---------------------------------
``glp::get_num_bin lp``

Solve the MIP problem using branch-and-cut method
-------------------------------------------------
``glp::intopt lp options``

Retrieve status of mip solution
-------------------------------
``glp::mip_status lp``

Retrieve the objective function value of mip solution
-----------------------------------------------------
``glp::mip_obj_val lp``

Retrieve row value of mip solution
----------------------------------
``glp::mip_row_val lp rowindex``

Retrieve column value of mip solution
-------------------------------------
``glp::mip_col_val lp colindex``


Additional routines
>>>>>>>>>>>>>>>>>>>


Check Karush-Kuhn-Tucker conditions
-----------------------------------
``lpx::check_kkt lp scaled``


Utility API routines
::::::::::::::::::::


Problem data reading/writing routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Read LP problem data from a MPS file
------------------------------------
``glp::read_mps lp format filename``

Write LP problem data into a MPS file
-------------------------------------
``glp::write_mps lp format filename``

Read LP problem data from a CPLEX file
--------------------------------------
``glp::read_lp lp filename``

Write LP problem data into a CPLEX file
---------------------------------------
``glp::write_lp lp filename``


Routines for MathProg models
>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Create the MathProg translator object
-------------------------------------
``glp::mpl_alloc_wksp``

Read and translate model section
--------------------------------
``glp::mpl_read_model tranobject filename skip``

Read and translate data section
-------------------------------
``glp::mpl_read_data tranobject filename``

Generate the model
------------------
``glp::mpl_generate tranobject filename``

Build problem instance from the model
-------------------------------------
``glp::mpl_build_prob tranobject lp``

Postsolve the model
-------------------
``glp::mpl_postsolve tran lp solution``

Delete the MathProg translator object
-------------------------------------
``glp::mpl_free_wksp tranobject``


Problem solution reading/writing routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Write basic solution in printable format
----------------------------------------
``glp::print_sol lp filename``

Read basic solution from a text file
------------------------------------
``glp::read_sol lp filename``

Write basic solution into a text file
-------------------------------------
``glp::write_sol lp filename``

Write bounds sensitivity information
------------------------------------
``lpx::print_sens_bnds lp filename``

Write interior-point solution in printable format
-------------------------------------------------
``glp::print_ipt lp filename``

Read interior-point solution from a text file
---------------------------------------------
``glp::read_ipt lp filename``

Write interior-point solution into a text file
----------------------------------------------
``glp::write_ipt lp filename``

Write MIP solution in printable format
--------------------------------------
``glp::print_mip lp filename``

Read MIP solution from a text file
----------------------------------
``glp::read_mip lp filename``

Write MIP solution into a text file
-----------------------------------
``glp::write_mip lp filename``


Advanced API routines
:::::::::::::::::::::


LP basis routines
>>>>>>>>>>>>>>>>>


Check whether basis factorization exists
----------------------------------------
``glp::bf_exists lp``

Compute the basis factorization
-------------------------------
``glp::factorize lp``

Check whether basis factorization has been updated
--------------------------------------------------
``glp::bf_updated lp``

Get basis factorization parameters
----------------------------------
``glp::get_bfcp lp``

Change basis factorization parameters
-------------------------------------
``glp::set_bfcp lp options``

Retrieve the basis header information
-------------------------------------
``glp::get_bhead lp k``

Retrieve row index in the basis header
--------------------------------------
``glp::get_row_bind lp rowindex``

Retrieve column index in the basis header
-----------------------------------------
``glp::get_col_bind lp colindex``

Perform forward transformation
------------------------------
``glp::ftran lp vector``

Perform backward transformation
-------------------------------
``glp::btran lp vector``

Warm up LP basis
----------------
``lpx::warm_up lp``


Simplex tableau routines
>>>>>>>>>>>>>>>>>>>>>>>>


Compute row of the tableau
--------------------------
``glp::eval_tab_row lp k``

Compute column of the tableau
-----------------------------
``glp::eval_tab_col lp k``

Transform explicitly specified row
----------------------------------
``lpx::transform_row lp rowvector``

Transform explicitly specified column
-------------------------------------
``lpx::transform_col lp colvector``

Perform primal ratio test
-------------------------
``lpx::prim_ratio_test lp vector how tol``

Perform dual ratio test
-----------------------
``lpx::dual_ratio_test lp vector how tol``


Branch-and-cut API routines
:::::::::::::::::::::::::::


Basic routines
>>>>>>>>>>>>>>


Determine reason for calling the callback routine
-------------------------------------------------
``glp::ios_reason tree``

Access the problem object
-------------------------
``glp::ios_get_prob tree``

Determine additional row attributes
-----------------------------------
``glp::ios_row_attr tree rowindex``

Compute relative MIP gap
------------------------
``glp::ios_mip_gap tree``

Access application-speciﬁc data
-------------------------------
``glp::ios_node_data tree node``

Select subproblem to continue the search
----------------------------------------
``glp::ios_select_node tree node``

Provide solution found by heuristic
-----------------------------------
``glp::ios_heur_sol tree colvector``

Check whether can branch upon speciﬁed variable
-----------------------------------------------
``glp::ios_can_branch tree j``

Choose variable to branch upon
------------------------------
``glp::ios_branch_upon tree j selection``

Terminate the solution process
------------------------------
``glp::ios_terminate tree``


The search tree exploring routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Determine the search tree size
------------------------------
``glp::ios_tree_size tree``

Determine current active subproblem
-----------------------------------
``glp::ios_curr_node tree``

Determine next active subproblem
--------------------------------
``glp::ios_next_node tree node``

Determine previous active subproblem
------------------------------------
``glp::ios_prev_node tree node``

Determine parent active subproblem
----------------------------------
``glp::ios_up_node tree node``

Determine subproblem level
--------------------------
``glp::ios_node_level tree node``

Determine subproblem local bound
--------------------------------
``glp::ios_node_bound tree node``

Find active subproblem with the best local bound
------------------------------------------------
``glp::ios_best_node tree``


The cut pool routines
>>>>>>>>>>>>>>>>>>>>>


Determine current size of the cut pool
--------------------------------------
``glp::ios_pool_size tree``

Add constraint to the cut pool
------------------------------
``glp::ios_add_row tree (name, klass, flags, row, type, rhs)``

Remove constraint from the cut pool
-----------------------------------
``glp::ios_del_row tree rowindex``

Remove all constraints from the cut pool
----------------------------------------
``glp::ios_clear_pool tree``


Graph and network API routines
::::::::::::::::::::::::::::::


Basic graph routines
>>>>>>>>>>>>>>>>>>>>


Create the GLPK graph object
----------------------------
``glp::create_graph v_size a_size``

Set the graph name
------------------
``glp::set_graph_name graph name``

Add vertices to a graph
-----------------------
``glp::add_vertices graph count``

Add arc to a graph
------------------
``glp::add_arc graph i j``

Erase content of the GLPK graph object
--------------------------------------
``glp::erase_graph graph v_size a_size``

Delete the GLPK graph object
----------------------------
``glp::delete_graph graph``

Read graph in a plain text format
---------------------------------
``glp::read_graph graph filename``

Write graph in a plain text format
----------------------------------
``glp::write_graph graph filename``


Graph analysis routines
>>>>>>>>>>>>>>>>>>>>>>>


Find all weakly connected components of a graph
-----------------------------------------------
``glp::weak_comp graph v_num``

Find all strongly connected components of a graph
-------------------------------------------------
``glp::strong_comp graph v_num``


Minimum cost flow problem
>>>>>>>>>>>>>>>>>>>>>>>>>


Read minimum cost flow problem data in DIMACS format
----------------------------------------------------
``glp::read_mincost graph v_rhs a_low a_cap a_cost filename``

Write minimum cost flow problem data in DIMACS format
-----------------------------------------------------
``glp::write_mincost graph v_rhs a_low a_cap a_cost fname``

Convert minimum cost flow problem to LP
---------------------------------------
``glp::mincost_lp lp graph names v_rhs a_low a_cap a_cost``

Solve minimum cost flow problem with out-of-kilter algorithm
------------------------------------------------------------
``glp::mincost_okalg graph v_rhs a_low a_cap a_cost a_x v_pi``

Klingman's network problem generator
------------------------------------
``glp::netgen graph v_rhs a_cap a_cost parameters``

Grid-like network problem generator
-----------------------------------
``glp::gridgen graph v_rhs a_cap a_cost parameters``


Maximum flow problem
>>>>>>>>>>>>>>>>>>>>


Read maximum cost flow problem data in DIMACS format
----------------------------------------------------
``glp::read_maxflow graph a_cap filename``

Write maximum cost flow problem data in DIMACS format
-----------------------------------------------------
``glp::write_maxflow graph s t a_cap filename``

Convert maximum flow problem to LP
----------------------------------
``glp::maxflow_lp lp graph names s t a_cap``

Solve maximum flow problem with Ford-Fulkerson algorithm
--------------------------------------------------------
``glp::maxflow_ffalg graph s t a_cap a_x v_cut``

Goldfarb's maximum flow problem generator
-----------------------------------------
``glp::rmfgen graph a_cap parameters``


Miscellaneous routines
::::::::::::::::::::::


Library environment routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Determine library version
-------------------------
``glp::version``

Enable/disable terminal output
------------------------------
``glp::term_out switch``

Enable/disable the terminal hook routine
----------------------------------------
``glp::term_hook switch info``

Get memory usage information
----------------------------
``glp::mem_usage``

Set memory usage limit
----------------------
``glp::mem_limit limit``

Free GLPK library environment
-----------------------------
``glp::free_env``
