
============================================================
Pure-GLPK - GLPK interface for the Pure programming language
============================================================

:Author: Jiri Spitz <jiri.spitz@bluetone.cz>
:Date: |date|

.. |date| date::

This module provides a feature complete GLPK interface for the Pure programming
language, which lets you use all capabilities of the GNU Linear Programming Kit
(GLPK) directly from Pure.

GLPK (see http://www.gnu.org/software/glpk) contains an efficient simplex
LP solver, a simplex LP solver in exact arithmetics, an interior-point solver,
a branch-and-cut solver for mixed integer programming and some specialized
algorithms for net/grid problems. Using this interface you can build, modify
and solve the problem, retrieve the solution, load and save the problem and
solution data in standard formats and use any of advanced GLPK features.

The interface uses native Pure data types - lists and tuples - so that you
need not perform any data conversions to/from GLPK internal data structures.

To make this module work, you must have a GLPK installation on your system,
the version 4.37 is required. 

.. contents::
.. sectnum::

.. Note: If you're wondering about the funny formatting, this README
   simultaneously serves to generate the documentation for this module
   in a variety of formats, using the docutils text formatting system
   (http://docutils.sourceforge.net/).


Installation
============

Run ``make`` to compile the module and ``make install`` (as root) to install
it in the Pure library directory. This requires GNU make, and of course you
need to have Pure installed.

The default make options suppose that GLPK was configured with the following
options:
``--enable-dl --enable-odbc --enable-mysql --with-gmp --with-zlib``

Using the given options the depndencies are:

- GNU Multiprecision Library (GMP) - serves for the exact simplex solver.
  When disabled, the exact solver still works but it is much slower.
- ODBC library - serves for reading data directly from database tables
  within the GNU MathProg language translator through the ODBC interface.
- zlib compression library - enables reading and writing gzip compressed
  problem and solution files.
- MySQL client library - serves for reading data directly from MySQL tables
  within the GNU MathProg language translator.
- ltdl dlopen library - must be enabled together with any of ODBC, zlib or
  MySQL.

``make`` tries to guess your Pure installation directory and platform-specific
setup. If it gets this wrong, you can set some variables manually. In
particular, ``make install prefix=/usr`` sets the installation prefix, and
``make PIC=-fPIC`` or some similar flag might be needed for compilation on 64
bit systems. The variable ``ODBCLIB`` specifies the ODBC library to be linked
with. The default value is ``ODBCLIB=-lodbc``. Please see the Makefile for
details.


Error Handling
==============

When an error condition occurs, the GLPK library itself prints an error mesage
and terminates the application. This behaviour is not pleasant when working
within an interpreter. Therefore, the Pure - GLPK bindings catches at least
the most common errors like indices out of bounds. On such an error an
appropriate message is returned to the interpreter. The less common errors
are still trapped by the GLPK library.

When one of the most common errors occurs, an error term of the form
``glp::error message`` will be returned, which specifies what kind of error
happend. For instance, an index out of boundsd will cause a report like the
following:

``glp::error "[Pure GLPK error] row index out of bounds"``

You can check for such return values and take some appropriate action. By
redefining ``glp::error`` accordingly, you can also have it generate exceptions
or print an error message. For instance:

``glp::error message = fprintf stderr "%s\n" message $$ ();``

**NOTE:** When redefining ``glp::error`` in this manner, you should be aware
that the return value of ``glp::error`` is what will be returned by the other
operations of this module in case of an error condition. These return values
are checked by other functions. Thus the return value should still indicate
that an error has happened, and not be something that might be interpreted
as a legal return value, such as an integer or a nonempty tuple. It is usually
safe to have ``glp::error`` return an empty tuple or throw an exception, but
other types of return values should be avoided.

**IMPORTANT:** It is really good to define a ``glp::error`` function,
otherwise the errors might remain unnoticed.


Further Information and Examples
================================

For further details about the operations provided by this module please see
the GLPK Reference Manual. Sample scripts illustrating the usage of the module
can be found in the examples directory.


Interface description
=====================

Most GLPK functions and symbols live in the namespace ``glp``. There are a few
functions and symbols in the namespace ``lpx``. These functions and symbols
are likely to be removed and replaced by new ones in the future.

In general, when you replace the ``glp_`` prefix from the GLPK Reference Manual
with the namespace specification ``glp::`` then you receive the function name
in this module. The same is valid for ``lpx_`` and ``lpx::``. The symbolic
constants are converted into lower case in this module, again obeying the
same prefix rules.


Descriptions of interface functions
===================================


Basic API routines
::::::::::::::::::


Problem creating and modifying routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Create the GLPK problem object
------------------------------
**Synopsis**::

  glp::create_prob

**Parameters**:

  none

**Returns**:

  pointer to the LP problem object

**Example**::

    > let lp = glp::create_prob;
    > lp;
    #<pointer 0x9de7168>
    >

Set the problem name
--------------------
**Synopsis**::

  glp::set_prob_name lp name

**Parameters**:

  :lp: pointer to the LP problem object
  :name: problem name

**Returns**:

  ``()``

**Example**::

  > glp::set_prob_name lp "Testing problem";
  ()
  >

Set objective name
------------------
**Synopsis**::

  glp::set_obj_name lp name

**Parameters**:

  :lp: pointer to the LP problem object
  :name: objective name

**Returns**:

  ``()``

**Example**::

  > glp::set_obj_name lp "Total costs";
  ()
  >

Set the objective direction
---------------------------
**Synopsis**::

  glp::set_obj_dir lp direction

**Parameters**:

  :lp: pointer to the LP problem object
  :direction: one of the following:

    :glp\:\:min: minimize
    :glp\:\:max: maximize

**Returns**:

  ``()``

**Example**::

  > glp::set_obj_dir lp glp::min;
  ()
  >

Add new rows to the problem
---------------------------
**Synopsis**::

  glp::add_rows lp count

**Parameters**:

  :lp: pointer to the LP problem object
  :count: number of rows to add

**Returns**:

  index of the first row added

**Example**::

  > let first_added_row = glp_add_rows lp 3;
  > first_added_row;
  6
  >

Add new columns to the problem
------------------------------
**Synopsis**::

  glp::add_cols lp count

**Parameters**:

  :lp: pointer to the LP problem object
  :count: number of columns to add

**Returns**:

  index of the first column added

**Example**::

  > let first_added_col = glp_add_cols lp 3;
  > first_added_col;
  5
  >

Set the row name
----------------
**Synopsis**::

  glp::set_row_name lp (rowindex, rowname)

**Parameters**:

  :lp: pointer to the LP problem object
  :rowindex: row index
  :rowname: row name

**Returns**:

  ``()``

**Example**::

  > glp::set_row_name lp (3, "The third row");
  ()
  >

Set the column name
-------------------
**Synopsis**::

  glp::set_col_name lp (colindex, colname)

**Parameters**:

  :lp: pointer to the LP problem object
  :colindex: column index
  :colname: column name

**Returns**:

  ``()``

**Example**::

  > glp::set_col_name lp (3, "The third column");
  ()
  >

Set (change) row bounds
-----------------------
**Synopsis**::

  glp::set_row_bnds lp (rowindex, rowtype, lowerbound, upperbound)

**Parameters**:

  :lp: pointer to the LP problem object
  :rowindex: row index
  :rowtype: one of the following:
  
    :glp\:\:fr: free variable (both bounds are ignored)
    :glp\:\:lo: variable with lower bound (upper bound is ignored)
    :glp\:\:up: variable with upper bound (lower bound is ignored)
    :glp\:\:db: double bounded variable
    :glp\:\:fx: fixed variable (lower bound applies, upper bound is ignored)
    
  :lowerbound: lower row bound
  :upperbound: upper row bound

**Returns**:
  ``()``

**Example**::
  ``glp::set_row_bnds lp (3, glp::up, 0.0, 150.0);``

Set (change) column bounds
--------------------------
**Synopsis**::

  glp::set_col_bnds lp (colindex, coltype, lowerbound, upperbound)

**Parameters**:

  :lp: pointer to the LP problem object
  :colindex: column index
  :coltype: one of the following:

    :glp\:\:fr: free variable (both bounds are ignored)
    :glp\:\:lo: variable with lower bound (upper bound is ignored)
    :glp\:\:up: variable with upper bound (lower bound is ignored)
    :glp\:\:db: double bounded variable
    :glp\:\:fx: fixed variable (lower bound applies, upper bound is ignored)

  :lowerbound: lower column bound
  :upperbound: upper column bound

**Returns**:

  ``()``

**Example**::

  > glp::set_col_bnds lp (3, glp::db, 100.0, 150.0);
  ()
  >

Set (change) objective coefficient or constant term
---------------------------------------------------
**Synopsis**::

  glp::set_obj_coef lp (colindex, coefficient)

**Parameters**:

  :lp: pointer to the LP problem object
  :colindex: column index, zero index denotes the constant term
             (objective shift)

**Returns**:

  ``()``

**Example**::

  > glp::set_obj_coef lp (3, 15.8);
  ()
  >

Load or replace matrix row
--------------------------
**Synopsis**::

  glp::set_mat_row lp (rowindex, rowvector)

**Parameters**:

  :lp: pointer to the LP problem object
  :rowindex: row index
  :rowvector: list of tuples (colindex, coefficient); only non-zero
              coefficients have to be specified, the order of column
              indices is not important, duplicates are **not** allowed

**Returns**:

  ``()``

**Example**::

  > glp::set_mat_row lp (3, [(1, 3.0), (4, 5.2)]);
  ()
  >

Load or replace matrix column
-----------------------------
**Synopsis**::

  glp::set_mat_col lp (colindex, colvector)

**Parameters**:

  :lp: pointer to the LP problem object
  :colindex: column index
  :colvector: list of tuples (rowindex, coefficient); only non-zero
              coefficients have to be specified, the order of row
              indices is not important, duplicates are **not** allowed

**Returns**:

  ``()``

**Example**::

  > glp::set_mat_col lp (2, [(4, 2.0), (2, 1.5)]);
  ()
  >

Load or replace the whole problem matrix
----------------------------------------
**Synopsis**::

  glp::load_matrix lp matrix

**Parameters**:

  :lp: pointer to the LP problem object
  :matrix: list of tuples (rowindex, colindex, coefficient); only non-zero
           coefficients have to be specified, the order of indices is not
           important, duplicates are **not** allowed

**Returns**:

  ``()``

**Example**::

  > glp::load_matrix lp [(1, 3, 5.0), (2, 2, 3.5), (3, 1, -2.0), (3, 2, 1.0)];
  ()
  >

Delete rows from the matrix
---------------------------
**Synopsis**::

  glp::del_rows lp rows

**Parameters**:

  :lp: pointer to the LP problem object
  :rows: list of indices of rows to be deleted; the order of indices is not
         important, duplicates are **not** allowed

**Returns**:

  ``()``

**Remark:**

  Deleting rows involves changing ordinal numbers of other rows
  remaining in the problem object. New ordinal numbers of the remaining
  rows are assigned under the assumption that the original order of rows is
  not changed.

**Example**::

  > glp::del_rows lp [3, 4, 7];
  ()
  >

Delete columns from the matrix
------------------------------
**Synopsis**::

  glp::del_cols lp cols

**Parameters**:

  :lp: pointer to the LP problem object
  :cols: list of indices of columns to be deleted; the order of indices is not
         important, duplicates are **not** allowed

**Returns**:

  ``()``

**Remark:**

  Deleting columns involves changing ordinal numbers of other columns
  remaining in the problem object. New ordinal numbers of the remaining
  columns are assigned under the assumption that the original order of
  columns is not changed.

**Example**::

  > glp::del_cols lp [6, 4, 5];
  ()
  >

Copy the whole content of the GLPK problem object to another one
----------------------------------------------------------------
**Synopsis**::

  glp::copy_prob destination source names

**Parameters**:

  :destination: pointer to the destination LP problem object (must already
                exist)
  :source: pointer to the source LP problem object
  :names: one of the following:

    :glp\:\:on: copy all symbolic names as well
    :glp\:\:off: do not copy the symbolic names

**Returns**:

  ``()``

**Example**::

  > glp::copy_prob lp_dest lp_src glp::on;
  ()
  >

Erase all data from the GLPK problem object
-------------------------------------------
**Synopsis**::

  glp::erase_prob lp

**Parameters**:

  :lp: pointer to the LP problem object, it remains still valid after
       the function call

**Returns**:

  ``()``

**Example**::

  > glp::erase_prob lp;
  ()
  >

Delete the GLPK problem object
------------------------------
**Synopsis**::

  glp::delete_prob lp

**Parameters**:

  :lp: pointer to the LP problem object, it is not valid any more after
       the function call

**Returns**:

  ``()``

**Example**::

  > glp::delete_prob lp;
  ()
  >


Problem retrieving routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>


Get the problem name
--------------------
**Synopsis**::

  glp::get_prob_name lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

  name of the problem
  
**Example**::

  > glp::get_prob_name lp;
  "Testing problem"
  >

Get the objective name
----------------------
**Synopsis**::

  glp::get_obj_name lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

  name of the objective

**Example**::

  > glp::get_obj_name lp;
  "Total costs"
  >

Get the objective direction
---------------------------
**Synopsis**::

  glp::get_obj_dir lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

  returns one of the following:

    :glp\:\:min: minimize
    :glp\:\:max: maximize

**Example**::

  > glp::get_obj_dir lp;
  glp::min
  >

Get number of rows
------------------
**Synopsis**::

  glp::get_num_rows lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

  number of rows (constraints)

**Example**::

  > glp::get_num_rows lp;
  58
  >

Get number of columns
---------------------
**Synopsis**::

  glp::get_num_cols lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

  number of columns (structural variables)

**Example**::

  > glp::get_num_cols lp;
  65
  >

Get name of a row
-----------------
**Synopsis**::

  glp::get_row_name lp rowindex

**Parameters**:

  :lp: pointer to the LP problem object
  :rowindex: row index

**Returns**:

  name of the given row

**Example**::

  > glp::get_row_name lp 3;
  "The third row"
  >

Get name of a column
--------------------
**Synopsis**::

  glp::get_col_name lp colindex

**Parameters**:

  :lp: pointer to the LP problem object
  :colindex: column index

**Returns**:

  name of the given column

**Example**::

  > glp::get_col_name lp 2;
  "The second column"
  >

Get row type
------------
**Synopsis**::

  glp::get_row_type lp rowindex

**Parameters**:

  :lp: pointer to the LP problem object
  :rowindex: row index

**Returns**:

  returns one of the following:

    :glp\:\:fr: free variable
    :glp\:\:lo: variable with lower bound
    :glp\:\:up: variable with upper bound
    :glp\:\:db: double bounded variable
    :glp\:\:fx: fixed variable

**Example**::

  > glp::get_row_type lp 3;
  glp::db
  >

Get row lower bound
-------------------
**Synopsis**::

  glp::get_row_lb lp rowindex

**Parameters**:

  :lp: pointer to the LP problem object
  :rowindex: row index

**Returns**:

  the row lower bound; if the row has no lower bound then it returns
  the smallest double number

**Example**::

  > glp::get_row_lb lp 3;
  50.0
  >

Get row upper bound
-------------------
**Synopsis**::

  glp::get_row_ub lp rowindex

**Parameters**:

  :lp: pointer to the LP problem object
  :rowindex: row index

**Returns**:

  the row upper bound; if the row has no upper bound then it returns
  the biggest double number

**Example**::

  > glp::get_row_ub lp 3;
  150.0
  >

Get column type
---------------
**Synopsis**::

  glp::get_col_type lp colindex

**Parameters**:

  :lp: pointer to the LP problem object
  :colindex: column index

**Returns**:

  returns one of the following:

    :glp\:\:fr: free variable
    :glp\:\:lo: variable with lower bound
    :glp\:\:up: variable with upper bound
    :glp\:\:db: double bounded variable
    :glp\:\:fx: fixed variable

**Example**::

  > glp::get_col_type lp 2;
  glp::up
  >

Get column lower bound
----------------------
**Synopsis**::

  glp::get_col_lb lp colindex

**Parameters**:

  :lp: pointer to the LP problem object
  :colindex: column index

**Returns**:

  the column lower bound; if the column has no lower bound then it returns
  the smallest double number

**Example**::

  > glp::get_col_lb lp 3;
  -1.79769313486232e+308
  >

Get column upper bound
----------------------
**Synopsis**::

  glp::get_col_ub lp colindex

**Parameters**:

  :lp: pointer to the LP problem object
  :colindex: column index

**Returns**:

  the column upper bound; if the column has no upper bound then it returns
  the biggest double number

**Example**::

  > glp::get_col_lb lp 3;
  150.0
  >

Get objective coefficient
-------------------------
**Synopsis**::

  glp::get_obj_coef lp colindex

**Parameters**:

  :lp: pointer to the LP problem object
  :colindex: column index; zero index denotes the constant term
             (objective shift)

**Returns**:

  the coefficient of given column in the objective

**Example**::

  > glp::get_obj_coef lp 3;
  5.8
  >

Get number of nonzero coefficients
----------------------------------
**Synopsis**::

  glp::get_num_nz lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

  number of non-zero coefficients in the problem matrix

**Example**::

  > glp::get_num_nz lp;
  158
  >

Retrive a row from the problem matrix
-------------------------------------
**Synopsis**::

  glp::get_mat_row lp rowindex

**Parameters**:

  :lp: pointer to the LP problem object
  :rowindex: row index

**Returns**:

  non-zero coefficients of the given row in a list form of tuples
  (colindex, coefficient)

**Example**::

  > get_mat_row lp 3;
  [(3,6.0),(2,2.0),(1,2.0)]
  >

Retrive a column from the problem matrix
----------------------------------------
**Synopsis**::

  glp::get_mat_col lp colindex

**Parameters**:

  :lp: pointer to the LP problem object
  :colindex: column index

**Returns**:

  non-zero coefficients of the given column in a list form of tuples
  (rowindex, coefficient)

**Example**::

  > get_mat_col lp 2;
  [(3,2.0),(2,4.0),(1,1.0)]
  >


Row and column searchin routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Create index for searching rows and columns by their names
----------------------------------------------------------
**Synopsis**::

  glp::create_index lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Find a row number by name
-------------------------
**Synopsis**::

  glp::find_row lp rowname

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Find a column number by name
----------------------------
**Synopsis**::

  glp::find_col lp colname

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Delete index for searching rows and columns by their names
----------------------------------------------------------
**Synopsis**::

  glp::delete_index lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 


Problem scaling routines
>>>>>>>>>>>>>>>>>>>>>>>>


Set the row scale factor
------------------------
**Synopsis**::

  glp::set_rii lp (rowindex, coefficient)

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Set the column scale factor
---------------------------
**Synopsis**::

  glp::set_sjj lp (colindex, coefficient)

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve the row scale factor
-----------------------------
**Synopsis**::

  glp::get_rii lp rowindex

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve the column scale factor
--------------------------------
**Synopsis**::

  glp::get_sjj lp colindex

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Scale the problem data according to supplied flags
--------------------------------------------------
**Synopsis**::

  glp::scale_prob lp flags

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Unscale the problem data
------------------------
**Synopsis**::

  glp::unscale_prob lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 


LP basis constructing routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Set the row status
------------------
**Synopsis**::

  glp::set_row_stat lp (rowindex, status)

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Set the column status
---------------------
**Synopsis**::

  glp::set_col_stat lp (colindex, status)

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Construct standard problem basis
--------------------------------
**Synopsis**::

  glp::std_basis lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Construct advanced problem basis
--------------------------------
**Synopsis**::

  glp::adv_basis lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Construct Bixby's problem basis
-------------------------------
**Synopsis**::

  glp::cpx_basis lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 


Simplex method routines
>>>>>>>>>>>>>>>>>>>>>>>


Solve the LP problem using simplex method
-----------------------------------------
**Synopsis**::

  glp::simplex lp options

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Solve the LP problem using simplex method in exact arithmetics
--------------------------------------------------------------
**Synopsis**::

  glp::exact lp options

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve generic status of basic solution
-----------------------------------------
**Synopsis**::

  glp::get_status lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve generic status of primal solution
------------------------------------------
**Synopsis**::

  glp::get_prim_stat lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve generic status of dual solution
----------------------------------------
**Synopsis**::

  glp::get_dual_stat lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve value of the objective function
----------------------------------------
**Synopsis**::

  glp::get_obj_val lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve generic status of a row variable
-----------------------------------------
**Synopsis**::

  glp::get_row_stat lp rowindex

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve row primal value
-------------------------
**Synopsis**::
  glp::get_row_prim lp rowindex

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve row dual value
-----------------------
**Synopsis**::

  glp::get_row_dual lp rowindex

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve generic status of a column variable
--------------------------------------------
**Synopsis**::

  glp::get_col_stat lp colindex

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve column primal value
----------------------------
**Synopsis**::

  glp::get_col_prim lp colindex

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve column dual value
--------------------------
**Synopsis**::

  glp::get_col_dual lp colindex

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Determine variable causing unboundedness
----------------------------------------
**Synopsis**::

  glp::get_unbnd_ray lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 


Interior-point method routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Solve the LP problem using interior-point method
------------------------------------------------
**Synopsis**::

  glp::interior lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve status of interior-point solution
------------------------------------------
**Synopsis**::

  glp::ipt_status lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve the objective function value of interior-point solution
----------------------------------------------------------------
**Synopsis**::

  glp::ipt_obj_val lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve row primal value of interior-point solution
----------------------------------------------------
**Synopsis**::

  glp::ipt_row_prim lp rowindex

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve row dual value of interior-point solution
--------------------------------------------------
**Synopsis**::

  glp::ipt_row_dual lp rowindex

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve column primal value of interior-point solution
-------------------------------------------------------
**Synopsis**::

  glp::ipt_col_prim lp colindex

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve column dual value of interior-point solution
-----------------------------------------------------
**Synopsis**::

  glp::ipt_col_dual lp colindex

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 


Mixed integer programming routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Set column kind
---------------
**Synopsis**::

  glp::set_col_kind lp (colindex, colkind)

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve column kind
--------------------
**Synopsis**::

  glp::get_col_kind lp colindex

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve number of integer columns
----------------------------------
**Synopsis**::

  glp::get_num_int lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve number of binary columns
---------------------------------
**Synopsis**::

  glp::get_num_bin lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Solve the MIP problem using branch-and-cut method
-------------------------------------------------
**Synopsis**::

  glp::intopt lp options

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve status of mip solution
-------------------------------
**Synopsis**::

  glp::mip_status lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve the objective function value of mip solution
-----------------------------------------------------
**Synopsis**::

  glp::mip_obj_val lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve row value of mip solution
----------------------------------
**Synopsis**::

  glp::mip_row_val lp rowindex

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve column value of mip solution
-------------------------------------
**Synopsis**::

  glp::mip_col_val lp colindex

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 


Additional routines
>>>>>>>>>>>>>>>>>>>


Check Karush-Kuhn-Tucker conditions
-----------------------------------
**Synopsis**::

  lpx::check_kkt lp scaled

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 


Utility API routines
::::::::::::::::::::


Problem data reading/writing routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Read LP problem data from a MPS file
------------------------------------
**Synopsis**::

  glp::read_mps lp format filename

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Write LP problem data into a MPS file
-------------------------------------
**Synopsis**::

  glp::write_mps lp format filename

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Read LP problem data from a CPLEX file
--------------------------------------
**Synopsis**::

  glp::read_lp lp filename

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Write LP problem data into a CPLEX file
---------------------------------------
**Synopsis**::

  glp::write_lp lp filename

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 


Routines for MathProg models
>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Create the MathProg translator object
-------------------------------------
**Synopsis**::

  glp::mpl_alloc_wksp

**Parameters**:

**Returns**:

**Example**::

  > 

Read and translate model section
--------------------------------
**Synopsis**::

  glp::mpl_read_model tranobject filename skip

**Parameters**:

**Returns**:

**Example**::

  > 

Read and translate data section
-------------------------------
**Synopsis**::

  glp::mpl_read_data tranobject filename

**Parameters**:

**Returns**:

**Example**::

  > 

Generate the model
------------------
**Synopsis**::

  glp::mpl_generate tranobject filename

**Parameters**:

**Returns**:

**Example**::

  > 

Build problem instance from the model
-------------------------------------
**Synopsis**::

  glp::mpl_build_prob tranobject lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Postsolve the model
-------------------
**Synopsis**::

  glp::mpl_postsolve tran lp solution

**Parameters**:

**Returns**:

**Example**::

  > 

Delete the MathProg translator object
-------------------------------------
**Synopsis**::

  glp::mpl_free_wksp tranobject

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 


Problem solution reading/writing routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Write basic solution in printable format
----------------------------------------
**Synopsis**::

  glp::print_sol lp filename

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Read basic solution from a text file
------------------------------------
**Synopsis**::

  glp::read_sol lp filename

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Write basic solution into a text file
-------------------------------------
**Synopsis**::

  glp::write_sol lp filename

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Write bounds sensitivity information
------------------------------------
**Synopsis**::

  lpx::print_sens_bnds lp filename

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Write interior-point solution in printable format
-------------------------------------------------
**Synopsis**::

  glp::print_ipt lp filename

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Read interior-point solution from a text file
---------------------------------------------
**Synopsis**::

  glp::read_ipt lp filename

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Write interior-point solution into a text file
----------------------------------------------
**Synopsis**::

  glp::write_ipt lp filename

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Write MIP solution in printable format
--------------------------------------
**Synopsis**::

  glp::print_mip lp filename

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Read MIP solution from a text file
----------------------------------
**Synopsis**::

  glp::read_mip lp filename

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Write MIP solution into a text file
-----------------------------------
**Synopsis**::

  glp::write_mip lp filename

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 


Advanced API routines
:::::::::::::::::::::


LP basis routines
>>>>>>>>>>>>>>>>>


Check whether basis factorization exists
----------------------------------------
**Synopsis**::

  glp::bf_exists lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Compute the basis factorization
-------------------------------
**Synopsis**::

  glp::factorize lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Check whether basis factorization has been updated
--------------------------------------------------
**Synopsis**::

  glp::bf_updated lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Get basis factorization parameters
----------------------------------
**Synopsis**::

  glp::get_bfcp lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Change basis factorization parameters
-------------------------------------
**Synopsis**::

  glp::set_bfcp lp options

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve the basis header information
-------------------------------------
**Synopsis**::

  glp::get_bhead lp k

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve row index in the basis header
--------------------------------------
**Synopsis**::

  glp::get_row_bind lp rowindex

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Retrieve column index in the basis header
-----------------------------------------
**Synopsis**::

  glp::get_col_bind lp colindex

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Perform forward transformation
------------------------------
**Synopsis**::

  glp::ftran lp vector

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Perform backward transformation
-------------------------------
**Synopsis**::

  glp::btran lp vector

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Warm up LP basis
----------------
**Synopsis**::

  lpx::warm_up lp

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 


Simplex tableau routines
>>>>>>>>>>>>>>>>>>>>>>>>


Compute row of the tableau
--------------------------
**Synopsis**::

  glp::eval_tab_row lp k

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Compute column of the tableau
-----------------------------
**Synopsis**::

  glp::eval_tab_col lp k

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Transform explicitly specified row
----------------------------------
**Synopsis**::

  lpx::transform_row lp rowvector

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Transform explicitly specified column
-------------------------------------
**Synopsis**::

  lpx::transform_col lp colvector

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Perform primal ratio test
-------------------------
**Synopsis**::

  lpx::prim_ratio_test lp vector how tol

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 

Perform dual ratio test
-----------------------
**Synopsis**::

  lpx::dual_ratio_test lp vector how tol

**Parameters**:

  :lp: pointer to the LP problem object

**Returns**:

**Example**::

  > 


Branch-and-cut API routines
:::::::::::::::::::::::::::


Basic routines
>>>>>>>>>>>>>>


Determine reason for calling the callback routine
-------------------------------------------------
**Synopsis**::

  glp::ios_reason tree

**Parameters**:

**Returns**:

**Example**::

  > 

Access the problem object
-------------------------
**Synopsis**::

  glp::ios_get_prob tree

**Parameters**:

**Returns**:

**Example**::

  > 

Determine additional row attributes
-----------------------------------
**Synopsis**::

  glp::ios_row_attr tree rowindex

**Parameters**:

**Returns**:

**Example**::

  > 

Compute relative MIP gap
------------------------
**Synopsis**::

  glp::ios_mip_gap tree

**Parameters**:

**Returns**:

**Example**::

  > 

Access application-specific data
--------------------------------
**Synopsis**::

  glp::ios_node_data tree node

**Parameters**:

**Returns**:

**Example**::

  > 

Select subproblem to continue the search
----------------------------------------
**Synopsis**::

  glp::ios_select_node tree node

**Parameters**:

**Returns**:

**Example**::

  > 

Provide solution found by heuristic
-----------------------------------
**Synopsis**::

  glp::ios_heur_sol tree colvector

**Parameters**:

**Returns**:

**Example**::

  > 

Check whether can branch upon specified variable
------------------------------------------------
**Synopsis**::

  glp::ios_can_branch tree j

**Parameters**:

**Returns**:

**Example**::

  > 

Choose variable to branch upon
------------------------------
**Synopsis**::

  glp::ios_branch_upon tree j selection

**Parameters**:

**Returns**:

**Example**::

  > 

Terminate the solution process
------------------------------
**Synopsis**::

  glp::ios_terminate tree

**Parameters**:

**Returns**:

**Example**::

  > 


The search tree exploring routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Determine the search tree size
------------------------------
**Synopsis**::

  glp::ios_tree_size tree

**Parameters**:

**Returns**:

**Example**::

  > 

Determine current active subproblem
-----------------------------------
**Synopsis**::

  glp::ios_curr_node tree

**Parameters**:

**Returns**:

**Example**::

  > 

Determine next active subproblem
--------------------------------
**Synopsis**::

  glp::ios_next_node tree node

**Parameters**:

**Returns**:

**Example**::

  > 

Determine previous active subproblem
------------------------------------
**Synopsis**::

  glp::ios_prev_node tree node

**Parameters**:

**Returns**:

**Example**::

  > 

Determine parent active subproblem
----------------------------------
**Synopsis**::

  glp::ios_up_node tree node

**Parameters**:

**Returns**:

**Example**::

  > 

Determine subproblem level
--------------------------
**Synopsis**::

  glp::ios_node_level tree node

**Parameters**:

**Returns**:

**Example**::

  > 

Determine subproblem local bound
--------------------------------
**Synopsis**::

  glp::ios_node_bound tree node

**Parameters**:

**Returns**:

**Example**::

  > 

Find active subproblem with the best local bound
------------------------------------------------
**Synopsis**::

  glp::ios_best_node tree

**Parameters**:

**Returns**:

**Example**::

  > 


The cut pool routines
>>>>>>>>>>>>>>>>>>>>>


Determine current size of the cut pool
--------------------------------------
**Synopsis**::

  glp::ios_pool_size tree

**Parameters**:

**Returns**:

**Example**::

  > 

Add constraint to the cut pool
------------------------------
**Synopsis**::

  glp::ios_add_row tree (name, klass, flags, row, type, rhs)

**Parameters**:

**Returns**:

**Example**::

  > 

Remove constraint from the cut pool
-----------------------------------
**Synopsis**::

  glp::ios_del_row tree rowindex

**Parameters**:

**Returns**:

**Example**::

  > 

Remove all constraints from the cut pool
----------------------------------------
**Synopsis**::

  glp::ios_clear_pool tree

**Parameters**:

**Returns**:

**Example**::

  > 


Graph and network API routines
::::::::::::::::::::::::::::::


Basic graph routines
>>>>>>>>>>>>>>>>>>>>


Create the GLPK graph object
----------------------------
**Synopsis**::

  glp::create_graph v_size a_size

**Parameters**:

**Returns**:

**Example**::

  > 

Set the graph name
------------------
**Synopsis**::

  glp::set_graph_name graph name

**Parameters**:

**Returns**:

**Example**::

  > 

Add vertices to a graph
-----------------------
**Synopsis**::

  glp::add_vertices graph count

**Parameters**:

**Returns**:

**Example**::

  > 

Add arc to a graph
------------------
**Synopsis**::

  glp::add_arc graph i j

**Parameters**:

**Returns**:

**Example**::

  > 

Erase content of the GLPK graph object
--------------------------------------
**Synopsis**::

  glp::erase_graph graph v_size a_size

**Parameters**:

**Returns**:

**Example**::

  > 

Delete the GLPK graph object
----------------------------
**Synopsis**::

  glp::delete_graph graph

**Parameters**:

**Returns**:

**Example**::

  > 

Read graph in a plain text format
---------------------------------
**Synopsis**::

  glp::read_graph graph filename

**Parameters**:

**Returns**:

**Example**::

  > 

Write graph in a plain text format
----------------------------------
**Synopsis**::

  glp::write_graph graph filename

**Parameters**:

**Returns**:

**Example**::

  > 


Graph analysis routines
>>>>>>>>>>>>>>>>>>>>>>>


Find all weakly connected components of a graph
-----------------------------------------------
**Synopsis**::

  glp::weak_comp graph v_num

**Parameters**:

**Returns**:

**Example**::

  > 

Find all strongly connected components of a graph
-------------------------------------------------
**Synopsis**::

  glp::strong_comp graph v_num

**Parameters**:

**Returns**:

**Example**::

  > 


Minimum cost flow problem
>>>>>>>>>>>>>>>>>>>>>>>>>


Read minimum cost flow problem data in DIMACS format
----------------------------------------------------
**Synopsis**::

  glp::read_mincost graph v_rhs a_low a_cap a_cost filename

**Parameters**:

**Returns**:

**Example**::

  > 

Write minimum cost flow problem data in DIMACS format
-----------------------------------------------------
**Synopsis**::

  glp::write_mincost graph v_rhs a_low a_cap a_cost fname

**Parameters**:

**Returns**:

**Example**::

  > 

Convert minimum cost flow problem to LP
---------------------------------------
**Synopsis**::

  glp::mincost_lp lp graph names v_rhs a_low a_cap a_cost

**Parameters**:

**Returns**:

**Example**::

  > 

Solve minimum cost flow problem with out-of-kilter algorithm
------------------------------------------------------------
**Synopsis**::

  glp::mincost_okalg graph v_rhs a_low a_cap a_cost a_x v_pi

**Parameters**:

**Returns**:

**Example**::

  > 

Klingman's network problem generator
------------------------------------
**Synopsis**::

  glp::netgen graph v_rhs a_cap a_cost parameters

**Parameters**:

**Returns**:

**Example**::

  > 

Grid-like network problem generator
-----------------------------------
**Synopsis**::

  glp::gridgen graph v_rhs a_cap a_cost parameters

**Parameters**:

**Returns**:

**Example**::

  > 


Maximum flow problem
>>>>>>>>>>>>>>>>>>>>


Read maximum cost flow problem data in DIMACS format
----------------------------------------------------
**Synopsis**::

  glp::read_maxflow graph a_cap filename

**Parameters**:

**Returns**:

**Example**::

  > 

Write maximum cost flow problem data in DIMACS format
-----------------------------------------------------
**Synopsis**::

  glp::write_maxflow graph s t a_cap filename

**Parameters**:

**Returns**:

**Example**::

  > 

Convert maximum flow problem to LP
----------------------------------
**Synopsis**::

  glp::maxflow_lp lp graph names s t a_cap

**Parameters**:

**Returns**:

**Example**::

  > 

Solve maximum flow problem with Ford-Fulkerson algorithm
--------------------------------------------------------
**Synopsis**::

  glp::maxflow_ffalg graph s t a_cap a_x v_cut

**Parameters**:

**Returns**:

**Example**::

  > 

Goldfarb's maximum flow problem generator
-----------------------------------------
**Synopsis**::

  glp::rmfgen graph a_cap parameters

**Parameters**:

**Returns**:

**Example**::

  > 


Miscellaneous routines
::::::::::::::::::::::


Library environment routines
>>>>>>>>>>>>>>>>>>>>>>>>>>>>


Determine library version
-------------------------
**Synopsis**::

  `glp::version

**Parameters**:

  none

**Returns**:

  GLPK library version

**Example**::

  > glp::version;
  "4.37"
  >

Enable/disable terminal output
------------------------------
**Synopsis**::

  glp::term_out switch

**Parameters**:

  :switch: one of the following:

    :glp\:\:on: enable terminal output from GLPK routines
    :glp\:\:off: disable terminal output from GLPK routines

**Returns**:

  ``()``

**Example**::

  > glp::term_out glp:off;
  ()
  >

Enable/disable the terminal hook routine
----------------------------------------
**Synopsis**::

  glp::term_hook switch info

**Parameters**:

  :switch: one of the following:

    :glp\:\:on: use the terminal callback function
    :glp\:\:off: don't use the terminal callback function

  :info: pointer to a memory block which can be used for passing
         additional information to the terminal callback function

**Returns**:

  ``()``

**Example**::

  > glp::term_hook glp::on NULL;
  ()
  >

Get memory usage information
----------------------------
**Synopsis**::

  glp::mem_usage

**Parameters**:

  none

**Returns**:

  tuple consisting of four numbers:
  
    * ``count`` (int) - the number of currently allocated memory blocks
    * ``cpeak`` (int) - the peak value of ``count`` reached since the
      initialization of the GLPK library environment
    * ``total`` (bigint) - the total amount, in bytes, of currently
      allocated memory blocks
    * ``tpeak`` (bigint) - the peak value of ``total`` reached since the
      initialization of the GLPK library envirionment

**Example**::

  > glp::mem_usage;
  7,84,10172L,45304L
  >

Set memory usage limit
----------------------
**Synopsis**::

  glp::mem_limit limit

**Parameters**:

  :limit: memory limit in megabytes

**Returns**:

  ``()``

**Example**::

  > glp::mem_limit 200;
  ()
  >

Free GLPK library environment
-----------------------------
**Synopsis**::

  glp::free_env

**Parameters**:

  none

**Returns**:

  ``()``

**Example**::

  > glp_free_env;
  ()
  >
