<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.7: http://docutils.sourceforge.net/" />
<title>Pure-GLPK - GLPK interface for the Pure programming language</title>
<meta name="author" content="Jiri Spitz &lt;jiri.spitz&#64;bluetone.cz&gt;" />
<meta name="date" content="2010-02-02" />
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 5951 2009-05-18 18:03:10Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left{
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: left }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="pure-glpk-glpk-interface-for-the-pure-programming-language">
<h1 class="title">Pure-GLPK - GLPK interface for the Pure programming language</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Jiri Spitz &lt;<a class="reference external" href="mailto:jiri.spitz&#64;bluetone.cz">jiri.spitz&#64;bluetone.cz</a>&gt;</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>2010-02-02</td></tr>
</tbody>
</table>
<p>This module provides a feature complete GLPK interface for the Pure programming
language, which lets you use all capabilities of the GNU Linear Programming Kit
(GLPK) directly from Pure.</p>
<p>GLPK (see <a class="reference external" href="http://www.gnu.org/software/glpk">http://www.gnu.org/software/glpk</a>) contains an efficient simplex
LP solver, a simplex LP solver in exact arithmetics, an interior-point solver,
a branch-and-cut solver for mixed integer programming and some specialized
algorithms for net/grid problems. Using this interface you can build, modify
and solve the problem, retrieve the solution, load and save the problem and
solution data in standard formats and use any of advanced GLPK features.</p>
<p>The interface uses native Pure data types - lists and tuples - so that you
need not perform any data conversions to/from GLPK internal data structures.</p>
<p>To make this module work, you must have a GLPK installation on your system,
the version 4.38 is required.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#installation" id="id1">1&nbsp;&nbsp;&nbsp;Installation</a></li>
<li><a class="reference internal" href="#error-handling" id="id2">2&nbsp;&nbsp;&nbsp;Error Handling</a></li>
<li><a class="reference internal" href="#further-information-and-examples" id="id3">3&nbsp;&nbsp;&nbsp;Further Information and Examples</a></li>
<li><a class="reference internal" href="#interface-description" id="id4">4&nbsp;&nbsp;&nbsp;Interface description</a></li>
<li><a class="reference internal" href="#descriptions-of-interface-functions" id="id5">5&nbsp;&nbsp;&nbsp;Descriptions of interface functions</a><ul class="auto-toc">
<li><a class="reference internal" href="#basic-api-routines" id="id6">5.1&nbsp;&nbsp;&nbsp;Basic API routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#problem-creating-and-modifying-routines" id="id7">5.1.1&nbsp;&nbsp;&nbsp;Problem creating and modifying routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#create-the-glpk-problem-object" id="id8">5.1.1.1&nbsp;&nbsp;&nbsp;Create the GLPK problem object</a></li>
<li><a class="reference internal" href="#set-the-problem-name" id="id9">5.1.1.2&nbsp;&nbsp;&nbsp;Set the problem name</a></li>
<li><a class="reference internal" href="#set-objective-name" id="id10">5.1.1.3&nbsp;&nbsp;&nbsp;Set objective name</a></li>
<li><a class="reference internal" href="#set-the-objective-direction" id="id11">5.1.1.4&nbsp;&nbsp;&nbsp;Set the objective direction</a></li>
<li><a class="reference internal" href="#add-new-rows-to-the-problem" id="id12">5.1.1.5&nbsp;&nbsp;&nbsp;Add new rows to the problem</a></li>
<li><a class="reference internal" href="#add-new-columns-to-the-problem" id="id13">5.1.1.6&nbsp;&nbsp;&nbsp;Add new columns to the problem</a></li>
<li><a class="reference internal" href="#set-the-row-name" id="id14">5.1.1.7&nbsp;&nbsp;&nbsp;Set the row name</a></li>
<li><a class="reference internal" href="#set-the-column-name" id="id15">5.1.1.8&nbsp;&nbsp;&nbsp;Set the column name</a></li>
<li><a class="reference internal" href="#set-change-row-bounds" id="id16">5.1.1.9&nbsp;&nbsp;&nbsp;Set (change) row bounds</a></li>
<li><a class="reference internal" href="#set-change-column-bounds" id="id17">5.1.1.10&nbsp;&nbsp;&nbsp;Set (change) column bounds</a></li>
<li><a class="reference internal" href="#set-change-objective-coefficient-or-constant-term" id="id18">5.1.1.11&nbsp;&nbsp;&nbsp;Set (change) objective coefficient or constant term</a></li>
<li><a class="reference internal" href="#load-or-replace-matrix-row" id="id19">5.1.1.12&nbsp;&nbsp;&nbsp;Load or replace matrix row</a></li>
<li><a class="reference internal" href="#load-or-replace-matrix-column" id="id20">5.1.1.13&nbsp;&nbsp;&nbsp;Load or replace matrix column</a></li>
<li><a class="reference internal" href="#load-or-replace-the-whole-problem-matrix" id="id21">5.1.1.14&nbsp;&nbsp;&nbsp;Load or replace the whole problem matrix</a></li>
<li><a class="reference internal" href="#check-for-duplicate-elements-in-sparse-matrix" id="id22">5.1.1.15&nbsp;&nbsp;&nbsp;Check for duplicate elements in sparse matrix</a></li>
<li><a class="reference internal" href="#sort-elements-of-the-constraint-matrix" id="id23">5.1.1.16&nbsp;&nbsp;&nbsp;Sort elements of the constraint matrix</a></li>
<li><a class="reference internal" href="#delete-rows-from-the-matrix" id="id24">5.1.1.17&nbsp;&nbsp;&nbsp;Delete rows from the matrix</a></li>
<li><a class="reference internal" href="#delete-columns-from-the-matrix" id="id25">5.1.1.18&nbsp;&nbsp;&nbsp;Delete columns from the matrix</a></li>
<li><a class="reference internal" href="#copy-the-whole-content-of-the-glpk-problem-object-to-another-one" id="id26">5.1.1.19&nbsp;&nbsp;&nbsp;Copy the whole content of the GLPK problem object to another one</a></li>
<li><a class="reference internal" href="#erase-all-data-from-the-glpk-problem-object" id="id27">5.1.1.20&nbsp;&nbsp;&nbsp;Erase all data from the GLPK problem object</a></li>
<li><a class="reference internal" href="#delete-the-glpk-problem-object" id="id28">5.1.1.21&nbsp;&nbsp;&nbsp;Delete the GLPK problem object</a></li>
</ul>
</li>
<li><a class="reference internal" href="#problem-retrieving-routines" id="id29">5.1.2&nbsp;&nbsp;&nbsp;Problem retrieving routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#get-the-problem-name" id="id30">5.1.2.1&nbsp;&nbsp;&nbsp;Get the problem name</a></li>
<li><a class="reference internal" href="#get-the-objective-name" id="id31">5.1.2.2&nbsp;&nbsp;&nbsp;Get the objective name</a></li>
<li><a class="reference internal" href="#get-the-objective-direction" id="id32">5.1.2.3&nbsp;&nbsp;&nbsp;Get the objective direction</a></li>
<li><a class="reference internal" href="#get-number-of-rows" id="id33">5.1.2.4&nbsp;&nbsp;&nbsp;Get number of rows</a></li>
<li><a class="reference internal" href="#get-number-of-columns" id="id34">5.1.2.5&nbsp;&nbsp;&nbsp;Get number of columns</a></li>
<li><a class="reference internal" href="#get-name-of-a-row" id="id35">5.1.2.6&nbsp;&nbsp;&nbsp;Get name of a row</a></li>
<li><a class="reference internal" href="#get-name-of-a-column" id="id36">5.1.2.7&nbsp;&nbsp;&nbsp;Get name of a column</a></li>
<li><a class="reference internal" href="#get-row-type" id="id37">5.1.2.8&nbsp;&nbsp;&nbsp;Get row type</a></li>
<li><a class="reference internal" href="#get-row-lower-bound" id="id38">5.1.2.9&nbsp;&nbsp;&nbsp;Get row lower bound</a></li>
<li><a class="reference internal" href="#get-row-upper-bound" id="id39">5.1.2.10&nbsp;&nbsp;&nbsp;Get row upper bound</a></li>
<li><a class="reference internal" href="#get-column-type" id="id40">5.1.2.11&nbsp;&nbsp;&nbsp;Get column type</a></li>
<li><a class="reference internal" href="#get-column-lower-bound" id="id41">5.1.2.12&nbsp;&nbsp;&nbsp;Get column lower bound</a></li>
<li><a class="reference internal" href="#get-column-upper-bound" id="id42">5.1.2.13&nbsp;&nbsp;&nbsp;Get column upper bound</a></li>
<li><a class="reference internal" href="#get-objective-coefficient" id="id43">5.1.2.14&nbsp;&nbsp;&nbsp;Get objective coefficient</a></li>
<li><a class="reference internal" href="#get-number-of-nonzero-coefficients" id="id44">5.1.2.15&nbsp;&nbsp;&nbsp;Get number of nonzero coefficients</a></li>
<li><a class="reference internal" href="#retrive-a-row-from-the-problem-matrix" id="id45">5.1.2.16&nbsp;&nbsp;&nbsp;Retrive a row from the problem matrix</a></li>
<li><a class="reference internal" href="#retrive-a-column-from-the-problem-matrix" id="id46">5.1.2.17&nbsp;&nbsp;&nbsp;Retrive a column from the problem matrix</a></li>
</ul>
</li>
<li><a class="reference internal" href="#row-and-column-searching-routines" id="id47">5.1.3&nbsp;&nbsp;&nbsp;Row and column searching routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#create-index-for-searching-rows-and-columns-by-their-names" id="id48">5.1.3.1&nbsp;&nbsp;&nbsp;Create index for searching rows and columns by their names</a></li>
<li><a class="reference internal" href="#find-a-row-number-by-name" id="id49">5.1.3.2&nbsp;&nbsp;&nbsp;Find a row number by name</a></li>
<li><a class="reference internal" href="#find-a-column-number-by-name" id="id50">5.1.3.3&nbsp;&nbsp;&nbsp;Find a column number by name</a></li>
<li><a class="reference internal" href="#delete-index-for-searching-rows-and-columns-by-their-names" id="id51">5.1.3.4&nbsp;&nbsp;&nbsp;Delete index for searching rows and columns by their names</a></li>
</ul>
</li>
<li><a class="reference internal" href="#problem-scaling-routines" id="id52">5.1.4&nbsp;&nbsp;&nbsp;Problem scaling routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#set-the-row-scale-factor" id="id53">5.1.4.1&nbsp;&nbsp;&nbsp;Set the row scale factor</a></li>
<li><a class="reference internal" href="#set-the-column-scale-factor" id="id54">5.1.4.2&nbsp;&nbsp;&nbsp;Set the column scale factor</a></li>
<li><a class="reference internal" href="#retrieve-the-row-scale-factor" id="id55">5.1.4.3&nbsp;&nbsp;&nbsp;Retrieve the row scale factor</a></li>
<li><a class="reference internal" href="#retrieve-the-column-scale-factor" id="id56">5.1.4.4&nbsp;&nbsp;&nbsp;Retrieve the column scale factor</a></li>
<li><a class="reference internal" href="#scale-the-problem-data-according-to-supplied-flags" id="id57">5.1.4.5&nbsp;&nbsp;&nbsp;Scale the problem data according to supplied flags</a></li>
<li><a class="reference internal" href="#unscale-the-problem-data" id="id58">5.1.4.6&nbsp;&nbsp;&nbsp;Unscale the problem data</a></li>
</ul>
</li>
<li><a class="reference internal" href="#lp-basis-constructing-routines" id="id59">5.1.5&nbsp;&nbsp;&nbsp;LP basis constructing routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#set-the-row-status" id="id60">5.1.5.1&nbsp;&nbsp;&nbsp;Set the row status</a></li>
<li><a class="reference internal" href="#set-the-column-status" id="id61">5.1.5.2&nbsp;&nbsp;&nbsp;Set the column status</a></li>
<li><a class="reference internal" href="#construct-standard-problem-basis" id="id62">5.1.5.3&nbsp;&nbsp;&nbsp;Construct standard problem basis</a></li>
<li><a class="reference internal" href="#construct-advanced-problem-basis" id="id63">5.1.5.4&nbsp;&nbsp;&nbsp;Construct advanced problem basis</a></li>
<li><a class="reference internal" href="#construct-bixby-s-problem-basis" id="id64">5.1.5.5&nbsp;&nbsp;&nbsp;Construct Bixby's problem basis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#simplex-method-routines" id="id65">5.1.6&nbsp;&nbsp;&nbsp;Simplex method routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#solve-the-lp-problem-using-simplex-method" id="id66">5.1.6.1&nbsp;&nbsp;&nbsp;Solve the LP problem using simplex method</a></li>
<li><a class="reference internal" href="#solve-the-lp-problem-using-simplex-method-in-exact-arithmetics" id="id67">5.1.6.2&nbsp;&nbsp;&nbsp;Solve the LP problem using simplex method in exact arithmetics</a></li>
<li><a class="reference internal" href="#retrieve-generic-status-of-basic-solution" id="id68">5.1.6.3&nbsp;&nbsp;&nbsp;Retrieve generic status of basic solution</a></li>
<li><a class="reference internal" href="#retrieve-generic-status-of-primal-solution" id="id69">5.1.6.4&nbsp;&nbsp;&nbsp;Retrieve generic status of primal solution</a></li>
<li><a class="reference internal" href="#retrieve-generic-status-of-dual-solution" id="id70">5.1.6.5&nbsp;&nbsp;&nbsp;Retrieve generic status of dual solution</a></li>
<li><a class="reference internal" href="#retrieve-value-of-the-objective-function" id="id71">5.1.6.6&nbsp;&nbsp;&nbsp;Retrieve value of the objective function</a></li>
<li><a class="reference internal" href="#retrieve-generic-status-of-a-row-variable" id="id72">5.1.6.7&nbsp;&nbsp;&nbsp;Retrieve generic status of a row variable</a></li>
<li><a class="reference internal" href="#retrieve-row-primal-value" id="id73">5.1.6.8&nbsp;&nbsp;&nbsp;Retrieve row primal value</a></li>
<li><a class="reference internal" href="#retrieve-row-dual-value" id="id74">5.1.6.9&nbsp;&nbsp;&nbsp;Retrieve row dual value</a></li>
<li><a class="reference internal" href="#retrieve-generic-status-of-a-column-variable" id="id75">5.1.6.10&nbsp;&nbsp;&nbsp;Retrieve generic status of a column variable</a></li>
<li><a class="reference internal" href="#retrieve-column-primal-value" id="id76">5.1.6.11&nbsp;&nbsp;&nbsp;Retrieve column primal value</a></li>
<li><a class="reference internal" href="#retrieve-column-dual-value" id="id77">5.1.6.12&nbsp;&nbsp;&nbsp;Retrieve column dual value</a></li>
<li><a class="reference internal" href="#determine-variable-causing-unboundedness" id="id78">5.1.6.13&nbsp;&nbsp;&nbsp;Determine variable causing unboundedness</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interior-point-method-routines" id="id79">5.1.7&nbsp;&nbsp;&nbsp;Interior-point method routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#solve-the-lp-problem-using-interior-point-method" id="id80">5.1.7.1&nbsp;&nbsp;&nbsp;Solve the LP problem using interior-point method</a></li>
<li><a class="reference internal" href="#retrieve-status-of-interior-point-solution" id="id81">5.1.7.2&nbsp;&nbsp;&nbsp;Retrieve status of interior-point solution</a></li>
<li><a class="reference internal" href="#retrieve-the-objective-function-value-of-interior-point-solution" id="id82">5.1.7.3&nbsp;&nbsp;&nbsp;Retrieve the objective function value of interior-point solution</a></li>
<li><a class="reference internal" href="#retrieve-row-primal-value-of-interior-point-solution" id="id83">5.1.7.4&nbsp;&nbsp;&nbsp;Retrieve row primal value of interior-point solution</a></li>
<li><a class="reference internal" href="#retrieve-row-dual-value-of-interior-point-solution" id="id84">5.1.7.5&nbsp;&nbsp;&nbsp;Retrieve row dual value of interior-point solution</a></li>
<li><a class="reference internal" href="#retrieve-column-primal-value-of-interior-point-solution" id="id85">5.1.7.6&nbsp;&nbsp;&nbsp;Retrieve column primal value of interior-point solution</a></li>
<li><a class="reference internal" href="#retrieve-column-dual-value-of-interior-point-solution" id="id86">5.1.7.7&nbsp;&nbsp;&nbsp;Retrieve column dual value of interior-point solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mixed-integer-programming-routines" id="id87">5.1.8&nbsp;&nbsp;&nbsp;Mixed integer programming routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#set-column-kind" id="id88">5.1.8.1&nbsp;&nbsp;&nbsp;Set column kind</a></li>
<li><a class="reference internal" href="#retrieve-column-kind" id="id89">5.1.8.2&nbsp;&nbsp;&nbsp;Retrieve column kind</a></li>
<li><a class="reference internal" href="#retrieve-number-of-integer-columns" id="id90">5.1.8.3&nbsp;&nbsp;&nbsp;Retrieve number of integer columns</a></li>
<li><a class="reference internal" href="#retrieve-number-of-binary-columns" id="id91">5.1.8.4&nbsp;&nbsp;&nbsp;Retrieve number of binary columns</a></li>
<li><a class="reference internal" href="#solve-the-mip-problem-using-branch-and-cut-method" id="id92">5.1.8.5&nbsp;&nbsp;&nbsp;Solve the MIP problem using branch-and-cut method</a></li>
<li><a class="reference internal" href="#retrieve-status-of-mip-solution" id="id93">5.1.8.6&nbsp;&nbsp;&nbsp;Retrieve status of mip solution</a></li>
<li><a class="reference internal" href="#retrieve-the-objective-function-value-of-mip-solution" id="id94">5.1.8.7&nbsp;&nbsp;&nbsp;Retrieve the objective function value of mip solution</a></li>
<li><a class="reference internal" href="#retrieve-row-value-of-mip-solution" id="id95">5.1.8.8&nbsp;&nbsp;&nbsp;Retrieve row value of mip solution</a></li>
<li><a class="reference internal" href="#retrieve-column-value-of-mip-solution" id="id96">5.1.8.9&nbsp;&nbsp;&nbsp;Retrieve column value of mip solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#additional-routines" id="id97">5.1.9&nbsp;&nbsp;&nbsp;Additional routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#check-karush-kuhn-tucker-conditions" id="id98">5.1.9.1&nbsp;&nbsp;&nbsp;Check Karush-Kuhn-Tucker conditions</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#utility-api-routines" id="id99">5.2&nbsp;&nbsp;&nbsp;Utility API routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#problem-data-reading-writing-routines" id="id100">5.2.1&nbsp;&nbsp;&nbsp;Problem data reading/writing routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#read-lp-problem-data-from-a-mps-file" id="id101">5.2.1.1&nbsp;&nbsp;&nbsp;Read LP problem data from a MPS file</a></li>
<li><a class="reference internal" href="#write-lp-problem-data-into-a-mps-file" id="id102">5.2.1.2&nbsp;&nbsp;&nbsp;Write LP problem data into a MPS file</a></li>
<li><a class="reference internal" href="#read-lp-problem-data-from-a-cplex-file" id="id103">5.2.1.3&nbsp;&nbsp;&nbsp;Read LP problem data from a CPLEX file</a></li>
<li><a class="reference internal" href="#write-lp-problem-data-into-a-cplex-file" id="id104">5.2.1.4&nbsp;&nbsp;&nbsp;Write LP problem data into a CPLEX file</a></li>
<li><a class="reference internal" href="#read-lp-problem-data-in-glpk-format" id="id105">5.2.1.5&nbsp;&nbsp;&nbsp;Read LP problem data in GLPK format</a></li>
<li><a class="reference internal" href="#write-lp-problem-data-in-glpk-format" id="id106">5.2.1.6&nbsp;&nbsp;&nbsp;Write LP problem data in GLPK format</a></li>
</ul>
</li>
<li><a class="reference internal" href="#routines-for-mathprog-models" id="id107">5.2.2&nbsp;&nbsp;&nbsp;Routines for MathProg models</a><ul class="auto-toc">
<li><a class="reference internal" href="#create-the-mathprog-translator-object" id="id108">5.2.2.1&nbsp;&nbsp;&nbsp;Create the MathProg translator object</a></li>
<li><a class="reference internal" href="#read-and-translate-model-section" id="id109">5.2.2.2&nbsp;&nbsp;&nbsp;Read and translate model section</a></li>
<li><a class="reference internal" href="#read-and-translate-data-section" id="id110">5.2.2.3&nbsp;&nbsp;&nbsp;Read and translate data section</a></li>
<li><a class="reference internal" href="#generate-the-model" id="id111">5.2.2.4&nbsp;&nbsp;&nbsp;Generate the model</a></li>
<li><a class="reference internal" href="#build-problem-instance-from-the-model" id="id112">5.2.2.5&nbsp;&nbsp;&nbsp;Build problem instance from the model</a></li>
<li><a class="reference internal" href="#postsolve-the-model" id="id113">5.2.2.6&nbsp;&nbsp;&nbsp;Postsolve the model</a></li>
<li><a class="reference internal" href="#delete-the-mathprog-translator-object" id="id114">5.2.2.7&nbsp;&nbsp;&nbsp;Delete the MathProg translator object</a></li>
</ul>
</li>
<li><a class="reference internal" href="#problem-solution-reading-writing-routines" id="id115">5.2.3&nbsp;&nbsp;&nbsp;Problem solution reading/writing routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#write-basic-solution-in-printable-format" id="id116">5.2.3.1&nbsp;&nbsp;&nbsp;Write basic solution in printable format</a></li>
<li><a class="reference internal" href="#read-basic-solution-from-a-text-file" id="id117">5.2.3.2&nbsp;&nbsp;&nbsp;Read basic solution from a text file</a></li>
<li><a class="reference internal" href="#write-basic-solution-into-a-text-file" id="id118">5.2.3.3&nbsp;&nbsp;&nbsp;Write basic solution into a text file</a></li>
<li><a class="reference internal" href="#print-sensitivity-analysis-report" id="id119">5.2.3.4&nbsp;&nbsp;&nbsp;Print sensitivity analysis report</a></li>
<li><a class="reference internal" href="#write-interior-point-solution-in-printable-format" id="id120">5.2.3.5&nbsp;&nbsp;&nbsp;Write interior-point solution in printable format</a></li>
<li><a class="reference internal" href="#read-interior-point-solution-from-a-text-file" id="id121">5.2.3.6&nbsp;&nbsp;&nbsp;Read interior-point solution from a text file</a></li>
<li><a class="reference internal" href="#write-interior-point-solution-into-a-text-file" id="id122">5.2.3.7&nbsp;&nbsp;&nbsp;Write interior-point solution into a text file</a></li>
<li><a class="reference internal" href="#write-mip-solution-in-printable-format" id="id123">5.2.3.8&nbsp;&nbsp;&nbsp;Write MIP solution in printable format</a></li>
<li><a class="reference internal" href="#read-mip-solution-from-a-text-file" id="id124">5.2.3.9&nbsp;&nbsp;&nbsp;Read MIP solution from a text file</a></li>
<li><a class="reference internal" href="#write-mip-solution-into-a-text-file" id="id125">5.2.3.10&nbsp;&nbsp;&nbsp;Write MIP solution into a text file</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#advanced-api-routines" id="id126">5.3&nbsp;&nbsp;&nbsp;Advanced API routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#lp-basis-routines" id="id127">5.3.1&nbsp;&nbsp;&nbsp;LP basis routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#check-whether-basis-factorization-exists" id="id128">5.3.1.1&nbsp;&nbsp;&nbsp;Check whether basis factorization exists</a></li>
<li><a class="reference internal" href="#compute-the-basis-factorization" id="id129">5.3.1.2&nbsp;&nbsp;&nbsp;Compute the basis factorization</a></li>
<li><a class="reference internal" href="#check-whether-basis-factorization-has-been-updated" id="id130">5.3.1.3&nbsp;&nbsp;&nbsp;Check whether basis factorization has been updated</a></li>
<li><a class="reference internal" href="#get-basis-factorization-parameters" id="id131">5.3.1.4&nbsp;&nbsp;&nbsp;Get basis factorization parameters</a></li>
<li><a class="reference internal" href="#change-basis-factorization-parameters" id="id132">5.3.1.5&nbsp;&nbsp;&nbsp;Change basis factorization parameters</a></li>
<li><a class="reference internal" href="#retrieve-the-basis-header-information" id="id133">5.3.1.6&nbsp;&nbsp;&nbsp;Retrieve the basis header information</a></li>
<li><a class="reference internal" href="#retrieve-row-index-in-the-basis-header" id="id134">5.3.1.7&nbsp;&nbsp;&nbsp;Retrieve row index in the basis header</a></li>
<li><a class="reference internal" href="#retrieve-column-index-in-the-basis-header" id="id135">5.3.1.8&nbsp;&nbsp;&nbsp;Retrieve column index in the basis header</a></li>
<li><a class="reference internal" href="#perform-forward-transformation" id="id136">5.3.1.9&nbsp;&nbsp;&nbsp;Perform forward transformation</a></li>
<li><a class="reference internal" href="#perform-backward-transformation" id="id137">5.3.1.10&nbsp;&nbsp;&nbsp;Perform backward transformation</a></li>
<li><a class="reference internal" href="#warm-up-lp-basis" id="id138">5.3.1.11&nbsp;&nbsp;&nbsp;Warm up LP basis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#simplex-tableau-routines" id="id139">5.3.2&nbsp;&nbsp;&nbsp;Simplex tableau routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#compute-row-of-the-tableau" id="id140">5.3.2.1&nbsp;&nbsp;&nbsp;Compute row of the tableau</a></li>
<li><a class="reference internal" href="#compute-column-of-the-tableau" id="id141">5.3.2.2&nbsp;&nbsp;&nbsp;Compute column of the tableau</a></li>
<li><a class="reference internal" href="#transform-explicitly-specified-row" id="id142">5.3.2.3&nbsp;&nbsp;&nbsp;Transform explicitly specified row</a></li>
<li><a class="reference internal" href="#transform-explicitly-specified-column" id="id143">5.3.2.4&nbsp;&nbsp;&nbsp;Transform explicitly specified column</a></li>
<li><a class="reference internal" href="#perform-primal-ratio-test" id="id144">5.3.2.5&nbsp;&nbsp;&nbsp;Perform primal ratio test</a></li>
<li><a class="reference internal" href="#perform-dual-ratio-test" id="id145">5.3.2.6&nbsp;&nbsp;&nbsp;Perform dual ratio test</a></li>
<li><a class="reference internal" href="#analyze-active-bound-of-non-basic-variable" id="id146">5.3.2.7&nbsp;&nbsp;&nbsp;Analyze active bound of non-basic variable</a></li>
<li><a class="reference internal" href="#analyze-objective-coefficient-at-basic-variable" id="id147">5.3.2.8&nbsp;&nbsp;&nbsp;Analyze objective coefficient at basic variable</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#branch-and-cut-api-routines" id="id148">5.4&nbsp;&nbsp;&nbsp;Branch-and-cut API routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#basic-routines" id="id149">5.4.1&nbsp;&nbsp;&nbsp;Basic routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#determine-reason-for-calling-the-callback-routine" id="id150">5.4.1.1&nbsp;&nbsp;&nbsp;Determine reason for calling the callback routine</a></li>
<li><a class="reference internal" href="#access-the-problem-object" id="id151">5.4.1.2&nbsp;&nbsp;&nbsp;Access the problem object</a></li>
<li><a class="reference internal" href="#determine-additional-row-attributes" id="id152">5.4.1.3&nbsp;&nbsp;&nbsp;Determine additional row attributes</a></li>
<li><a class="reference internal" href="#compute-relative-mip-gap" id="id153">5.4.1.4&nbsp;&nbsp;&nbsp;Compute relative MIP gap</a></li>
<li><a class="reference internal" href="#access-application-specific-data" id="id154">5.4.1.5&nbsp;&nbsp;&nbsp;Access application-specific data</a></li>
<li><a class="reference internal" href="#select-subproblem-to-continue-the-search" id="id155">5.4.1.6&nbsp;&nbsp;&nbsp;Select subproblem to continue the search</a></li>
<li><a class="reference internal" href="#provide-solution-found-by-heuristic" id="id156">5.4.1.7&nbsp;&nbsp;&nbsp;Provide solution found by heuristic</a></li>
<li><a class="reference internal" href="#check-whether-can-branch-upon-specified-variable" id="id157">5.4.1.8&nbsp;&nbsp;&nbsp;Check whether can branch upon specified variable</a></li>
<li><a class="reference internal" href="#choose-variable-to-branch-upon" id="id158">5.4.1.9&nbsp;&nbsp;&nbsp;Choose variable to branch upon</a></li>
<li><a class="reference internal" href="#terminate-the-solution-process" id="id159">5.4.1.10&nbsp;&nbsp;&nbsp;Terminate the solution process</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-search-tree-exploring-routines" id="id160">5.4.2&nbsp;&nbsp;&nbsp;The search tree exploring routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#determine-the-search-tree-size" id="id161">5.4.2.1&nbsp;&nbsp;&nbsp;Determine the search tree size</a></li>
<li><a class="reference internal" href="#determine-current-active-subproblem" id="id162">5.4.2.2&nbsp;&nbsp;&nbsp;Determine current active subproblem</a></li>
<li><a class="reference internal" href="#determine-next-active-subproblem" id="id163">5.4.2.3&nbsp;&nbsp;&nbsp;Determine next active subproblem</a></li>
<li><a class="reference internal" href="#determine-previous-active-subproblem" id="id164">5.4.2.4&nbsp;&nbsp;&nbsp;Determine previous active subproblem</a></li>
<li><a class="reference internal" href="#determine-parent-active-subproblem" id="id165">5.4.2.5&nbsp;&nbsp;&nbsp;Determine parent active subproblem</a></li>
<li><a class="reference internal" href="#determine-subproblem-level" id="id166">5.4.2.6&nbsp;&nbsp;&nbsp;Determine subproblem level</a></li>
<li><a class="reference internal" href="#determine-subproblem-local-bound" id="id167">5.4.2.7&nbsp;&nbsp;&nbsp;Determine subproblem local bound</a></li>
<li><a class="reference internal" href="#find-active-subproblem-with-the-best-local-bound" id="id168">5.4.2.8&nbsp;&nbsp;&nbsp;Find active subproblem with the best local bound</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-cut-pool-routines" id="id169">5.4.3&nbsp;&nbsp;&nbsp;The cut pool routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#determine-current-size-of-the-cut-pool" id="id170">5.4.3.1&nbsp;&nbsp;&nbsp;Determine current size of the cut pool</a></li>
<li><a class="reference internal" href="#add-constraint-to-the-cut-pool" id="id171">5.4.3.2&nbsp;&nbsp;&nbsp;Add constraint to the cut pool</a></li>
<li><a class="reference internal" href="#remove-constraint-from-the-cut-pool" id="id172">5.4.3.3&nbsp;&nbsp;&nbsp;Remove constraint from the cut pool</a></li>
<li><a class="reference internal" href="#remove-all-constraints-from-the-cut-pool" id="id173">5.4.3.4&nbsp;&nbsp;&nbsp;Remove all constraints from the cut pool</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#graph-and-network-api-routines" id="id174">5.5&nbsp;&nbsp;&nbsp;Graph and network API routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#basic-graph-routines" id="id175">5.5.1&nbsp;&nbsp;&nbsp;Basic graph routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#create-the-glpk-graph-object" id="id176">5.5.1.1&nbsp;&nbsp;&nbsp;Create the GLPK graph object</a></li>
<li><a class="reference internal" href="#set-the-graph-name" id="id177">5.5.1.2&nbsp;&nbsp;&nbsp;Set the graph name</a></li>
<li><a class="reference internal" href="#add-vertices-to-a-graph" id="id178">5.5.1.3&nbsp;&nbsp;&nbsp;Add vertices to a graph</a></li>
<li><a class="reference internal" href="#add-arc-to-a-graph" id="id179">5.5.1.4&nbsp;&nbsp;&nbsp;Add arc to a graph</a></li>
<li><a class="reference internal" href="#erase-content-of-the-glpk-graph-object" id="id180">5.5.1.5&nbsp;&nbsp;&nbsp;Erase content of the GLPK graph object</a></li>
<li><a class="reference internal" href="#delete-the-glpk-graph-object" id="id181">5.5.1.6&nbsp;&nbsp;&nbsp;Delete the GLPK graph object</a></li>
<li><a class="reference internal" href="#read-graph-in-a-plain-text-format" id="id182">5.5.1.7&nbsp;&nbsp;&nbsp;Read graph in a plain text format</a></li>
<li><a class="reference internal" href="#write-graph-in-a-plain-text-format" id="id183">5.5.1.8&nbsp;&nbsp;&nbsp;Write graph in a plain text format</a></li>
</ul>
</li>
<li><a class="reference internal" href="#graph-analysis-routines" id="id184">5.5.2&nbsp;&nbsp;&nbsp;Graph analysis routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#find-all-weakly-connected-components-of-a-graph" id="id185">5.5.2.1&nbsp;&nbsp;&nbsp;Find all weakly connected components of a graph</a></li>
<li><a class="reference internal" href="#find-all-strongly-connected-components-of-a-graph" id="id186">5.5.2.2&nbsp;&nbsp;&nbsp;Find all strongly connected components of a graph</a></li>
</ul>
</li>
<li><a class="reference internal" href="#minimum-cost-flow-problem" id="id187">5.5.3&nbsp;&nbsp;&nbsp;Minimum cost flow problem</a><ul class="auto-toc">
<li><a class="reference internal" href="#read-minimum-cost-flow-problem-data-in-dimacs-format" id="id188">5.5.3.1&nbsp;&nbsp;&nbsp;Read minimum cost flow problem data in DIMACS format</a></li>
<li><a class="reference internal" href="#write-minimum-cost-flow-problem-data-in-dimacs-format" id="id189">5.5.3.2&nbsp;&nbsp;&nbsp;Write minimum cost flow problem data in DIMACS format</a></li>
<li><a class="reference internal" href="#convert-minimum-cost-flow-problem-to-lp" id="id190">5.5.3.3&nbsp;&nbsp;&nbsp;Convert minimum cost flow problem to LP</a></li>
<li><a class="reference internal" href="#solve-minimum-cost-flow-problem-with-out-of-kilter-algorithm" id="id191">5.5.3.4&nbsp;&nbsp;&nbsp;Solve minimum cost flow problem with out-of-kilter algorithm</a></li>
<li><a class="reference internal" href="#klingman-s-network-problem-generator" id="id192">5.5.3.5&nbsp;&nbsp;&nbsp;Klingman's network problem generator</a></li>
<li><a class="reference internal" href="#grid-like-network-problem-generator" id="id193">5.5.3.6&nbsp;&nbsp;&nbsp;Grid-like network problem generator</a></li>
</ul>
</li>
<li><a class="reference internal" href="#maximum-flow-problem" id="id194">5.5.4&nbsp;&nbsp;&nbsp;Maximum flow problem</a><ul class="auto-toc">
<li><a class="reference internal" href="#read-maximum-cost-flow-problem-data-in-dimacs-format" id="id195">5.5.4.1&nbsp;&nbsp;&nbsp;Read maximum cost flow problem data in DIMACS format</a></li>
<li><a class="reference internal" href="#write-maximum-cost-flow-problem-data-in-dimacs-format" id="id196">5.5.4.2&nbsp;&nbsp;&nbsp;Write maximum cost flow problem data in DIMACS format</a></li>
<li><a class="reference internal" href="#convert-maximum-flow-problem-to-lp" id="id197">5.5.4.3&nbsp;&nbsp;&nbsp;Convert maximum flow problem to LP</a></li>
<li><a class="reference internal" href="#solve-maximum-flow-problem-with-ford-fulkerson-algorithm" id="id198">5.5.4.4&nbsp;&nbsp;&nbsp;Solve maximum flow problem with Ford-Fulkerson algorithm</a></li>
<li><a class="reference internal" href="#goldfarb-s-maximum-flow-problem-generator" id="id199">5.5.4.5&nbsp;&nbsp;&nbsp;Goldfarb's maximum flow problem generator</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#miscellaneous-routines" id="id200">5.6&nbsp;&nbsp;&nbsp;Miscellaneous routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#library-environment-routines" id="id201">5.6.1&nbsp;&nbsp;&nbsp;Library environment routines</a><ul class="auto-toc">
<li><a class="reference internal" href="#determine-library-version" id="id202">5.6.1.1&nbsp;&nbsp;&nbsp;Determine library version</a></li>
<li><a class="reference internal" href="#enable-disable-terminal-output" id="id203">5.6.1.2&nbsp;&nbsp;&nbsp;Enable/disable terminal output</a></li>
<li><a class="reference internal" href="#enable-disable-the-terminal-hook-routine" id="id204">5.6.1.3&nbsp;&nbsp;&nbsp;Enable/disable the terminal hook routine</a></li>
<li><a class="reference internal" href="#get-memory-usage-information" id="id205">5.6.1.4&nbsp;&nbsp;&nbsp;Get memory usage information</a></li>
<li><a class="reference internal" href="#set-memory-usage-limit" id="id206">5.6.1.5&nbsp;&nbsp;&nbsp;Set memory usage limit</a></li>
<li><a class="reference internal" href="#free-glpk-library-environment" id="id207">5.6.1.6&nbsp;&nbsp;&nbsp;Free GLPK library environment</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<!-- Note: If you're wondering about the funny formatting, this README
simultaneously serves to generate the documentation for this module
in a variety of formats, using the docutils text formatting system
(http://docutils.sourceforge.net/). -->
<div class="section" id="installation">
<h1><a class="toc-backref" href="#id1">1&nbsp;&nbsp;&nbsp;Installation</a></h1>
<p>Run <tt class="docutils literal">make</tt> to compile the module and <tt class="docutils literal">make install</tt> (as root) to install
it in the Pure library directory. This requires GNU make, and of course you
need to have Pure installed.</p>
<p>The default make options suppose that GLPK was configured with the following
options:
<tt class="docutils literal"><span class="pre">--enable-dl</span> <span class="pre">--enable-odbc</span> <span class="pre">--enable-mysql</span> <span class="pre">--with-gmp</span> <span class="pre">--with-zlib</span></tt></p>
<p>Using the given options the depndencies are:</p>
<ul class="simple">
<li>GNU Multiprecision Library (GMP) - serves for the exact simplex solver.
When disabled, the exact solver still works but it is much slower.</li>
<li>ODBC library - serves for reading data directly from database tables
within the GNU MathProg language translator through the ODBC interface.</li>
<li>zlib compression library - enables reading and writing gzip compressed
problem and solution files.</li>
<li>MySQL client library - serves for reading data directly from MySQL tables
within the GNU MathProg language translator.</li>
<li>ltdl dlopen library - must be enabled together with any of ODBC, zlib or
MySQL.</li>
</ul>
<p><tt class="docutils literal">make</tt> tries to guess your Pure installation directory and platform-specific
setup. If it gets this wrong, you can set some variables manually. In
particular, <tt class="docutils literal">make install <span class="pre">prefix=/usr</span></tt> sets the installation prefix, and
<tt class="docutils literal">make <span class="pre">PIC=-fPIC</span></tt> or some similar flag might be needed for compilation on 64
bit systems. The variable <tt class="docutils literal">ODBCLIB</tt> specifies the ODBC library to be linked
with. The default value is <tt class="docutils literal"><span class="pre">ODBCLIB=-lodbc</span></tt>. Please see the Makefile for
details.</p>
</div>
<div class="section" id="error-handling">
<h1><a class="toc-backref" href="#id2">2&nbsp;&nbsp;&nbsp;Error Handling</a></h1>
<p>When an error condition occurs, the GLPK library itself prints an error mesage
and terminates the application. This behaviour is not pleasant when working
within an interpreter. Therefore, the Pure - GLPK bindings catches at least
the most common errors like indices out of bounds. On such an error an
appropriate message is returned to the interpreter. The less common errors
are still trapped by the GLPK library.</p>
<p>When one of the most common errors occurs, an error term of the form
<tt class="docutils literal"><span class="pre">glp::error</span> message</tt> will be returned, which specifies what kind of error
happend. For instance, an index out of boundsd will cause a report like the
following:</p>
<p><tt class="docutils literal"><span class="pre">glp::error</span> &quot;[Pure GLPK error] row index out of bounds&quot;</tt></p>
<p>You can check for such return values and take some appropriate action. By
redefining <tt class="docutils literal"><span class="pre">glp::error</span></tt> accordingly, you can also have it generate exceptions
or print an error message. For instance:</p>
<p><tt class="docutils literal"><span class="pre">glp::error</span> message = fprintf stderr &quot;%s\n&quot; message $$ ();</tt></p>
<p><strong>NOTE:</strong> When redefining <tt class="docutils literal"><span class="pre">glp::error</span></tt> in this manner, you should be aware
that the return value of <tt class="docutils literal"><span class="pre">glp::error</span></tt> is what will be returned by the other
operations of this module in case of an error condition. These return values
are checked by other functions. Thus the return value should still indicate
that an error has happened, and not be something that might be interpreted
as a legal return value, such as an integer or a nonempty tuple. It is usually
safe to have <tt class="docutils literal"><span class="pre">glp::error</span></tt> return an empty tuple or throw an exception, but
other types of return values should be avoided.</p>
<p><strong>IMPORTANT:</strong> It is really good to define a <tt class="docutils literal"><span class="pre">glp::error</span></tt> function,
otherwise the errors might remain unnoticed.</p>
</div>
<div class="section" id="further-information-and-examples">
<h1><a class="toc-backref" href="#id3">3&nbsp;&nbsp;&nbsp;Further Information and Examples</a></h1>
<p>For further details about the operations provided by this module please see
the GLPK Reference Manual. Sample scripts illustrating the usage of the module
can be found in the examples directory.</p>
</div>
<div class="section" id="interface-description">
<h1><a class="toc-backref" href="#id4">4&nbsp;&nbsp;&nbsp;Interface description</a></h1>
<p>Most GLPK functions and symbols live in the namespace <tt class="docutils literal">glp</tt>. There are a few
functions and symbols in the namespace <tt class="docutils literal">lpx</tt>. These functions and symbols
are likely to be removed and replaced by new ones in the future.</p>
<p>In general, when you replace the <tt class="docutils literal">glp_</tt> prefix from the GLPK Reference Manual
with the namespace specification <tt class="docutils literal">glp::</tt> then you receive the function name
in this module. The same is valid for <tt class="docutils literal">lpx_</tt> and <tt class="docutils literal">lpx::</tt>. The symbolic
constants are converted into lower case in this module, again obeying the
same prefix rules.</p>
</div>
<div class="section" id="descriptions-of-interface-functions">
<h1><a class="toc-backref" href="#id5">5&nbsp;&nbsp;&nbsp;Descriptions of interface functions</a></h1>
<div class="section" id="basic-api-routines">
<h2><a class="toc-backref" href="#id6">5.1&nbsp;&nbsp;&nbsp;Basic API routines</a></h2>
<div class="section" id="problem-creating-and-modifying-routines">
<h3><a class="toc-backref" href="#id7">5.1.1&nbsp;&nbsp;&nbsp;Problem creating and modifying routines</a></h3>
<div class="section" id="create-the-glpk-problem-object">
<h4><a class="toc-backref" href="#id8">5.1.1.1&nbsp;&nbsp;&nbsp;Create the GLPK problem object</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::create_prob
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
none</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
pointer to the LP problem object</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; let lp = glp::create_prob;
&gt; lp;
#&lt;pointer 0x9de7168&gt;
&gt;
</pre>
</div>
<div class="section" id="set-the-problem-name">
<h4><a class="toc-backref" href="#id9">5.1.1.2&nbsp;&nbsp;&nbsp;Set the problem name</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::set_prob_name lp name
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">name:</th><td class="field-body">problem name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::set_prob_name lp &quot;Testing problem&quot;;
()
&gt;
</pre>
</div>
<div class="section" id="set-objective-name">
<h4><a class="toc-backref" href="#id10">5.1.1.3&nbsp;&nbsp;&nbsp;Set objective name</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::set_obj_name lp name
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">name:</th><td class="field-body">objective name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::set_obj_name lp &quot;Total costs&quot;;
()
&gt;
</pre>
</div>
<div class="section" id="set-the-objective-direction">
<h4><a class="toc-backref" href="#id11">5.1.1.4&nbsp;&nbsp;&nbsp;Set the objective direction</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::set_obj_dir lp direction
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body"><p class="first">pointer to the LP problem object</p>
</td>
</tr>
<tr class="field"><th class="field-name">direction:</th><td class="field-body"><p class="first">one of the following:</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::min:</th><td class="field-body">minimize</td>
</tr>
<tr class="field"><th class="field-name">glp::max:</th><td class="field-body">maximize</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::set_obj_dir lp glp::min;
()
&gt;
</pre>
</div>
<div class="section" id="add-new-rows-to-the-problem">
<h4><a class="toc-backref" href="#id12">5.1.1.5&nbsp;&nbsp;&nbsp;Add new rows to the problem</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::add_rows lp count
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">count:</th><td class="field-body">number of rows to add</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
index of the first row added</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; let first_added_row = glp_add_rows lp 3;
&gt; first_added_row;
6
&gt;
</pre>
</div>
<div class="section" id="add-new-columns-to-the-problem">
<h4><a class="toc-backref" href="#id13">5.1.1.6&nbsp;&nbsp;&nbsp;Add new columns to the problem</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::add_cols lp count
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">count:</th><td class="field-body">number of columns to add</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
index of the first column added</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; let first_added_col = glp_add_cols lp 3;
&gt; first_added_col;
5
&gt;
</pre>
</div>
<div class="section" id="set-the-row-name">
<h4><a class="toc-backref" href="#id14">5.1.1.7&nbsp;&nbsp;&nbsp;Set the row name</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::set_row_name lp (rowindex, rowname)
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body">row index</td>
</tr>
<tr class="field"><th class="field-name">rowname:</th><td class="field-body">row name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::set_row_name lp (3, &quot;The third row&quot;);
()
&gt;
</pre>
</div>
<div class="section" id="set-the-column-name">
<h4><a class="toc-backref" href="#id15">5.1.1.8&nbsp;&nbsp;&nbsp;Set the column name</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::set_col_name lp (colindex, colname)
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body">column index</td>
</tr>
<tr class="field"><th class="field-name">colname:</th><td class="field-body">column name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::set_col_name lp (3, &quot;The third column&quot;);
()
&gt;
</pre>
</div>
<div class="section" id="set-change-row-bounds">
<h4><a class="toc-backref" href="#id16">5.1.1.9&nbsp;&nbsp;&nbsp;Set (change) row bounds</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::set_row_bnds lp (rowindex, rowtype, lowerbound, upperbound)
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body"><p class="first">pointer to the LP problem object</p>
</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body"><p class="first">row index</p>
</td>
</tr>
<tr class="field"><th class="field-name">rowtype:</th><td class="field-body"><p class="first">one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::fr:</th><td class="field-body">free variable (both bounds are ignored)</td>
</tr>
<tr class="field"><th class="field-name">glp::lo:</th><td class="field-body">variable with lower bound (upper bound is ignored)</td>
</tr>
<tr class="field"><th class="field-name">glp::up:</th><td class="field-body">variable with upper bound (lower bound is ignored)</td>
</tr>
<tr class="field"><th class="field-name">glp::db:</th><td class="field-body">double bounded variable</td>
</tr>
<tr class="field"><th class="field-name">glp::fx:</th><td class="field-body">fixed variable (lower bound applies, upper bound is ignored)</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">lowerbound:</th><td class="field-body"><p class="first">lower row bound</p>
</td>
</tr>
<tr class="field"><th class="field-name">upperbound:</th><td class="field-body"><p class="first last">upper row bound</p>
</td>
</tr>
</tbody>
</table>
</blockquote>
<dl class="docutils">
<dt><strong>Returns</strong>:</dt>
<dd><tt class="docutils literal">()</tt></dd>
<dt><strong>Example</strong>::</dt>
<dd><tt class="docutils literal"><span class="pre">glp::set_row_bnds</span> lp (3, <span class="pre">glp::up,</span> 0.0, 150.0);</tt></dd>
</dl>
</div>
<div class="section" id="set-change-column-bounds">
<h4><a class="toc-backref" href="#id17">5.1.1.10&nbsp;&nbsp;&nbsp;Set (change) column bounds</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::set_col_bnds lp (colindex, coltype, lowerbound, upperbound)
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body"><p class="first">pointer to the LP problem object</p>
</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body"><p class="first">column index</p>
</td>
</tr>
<tr class="field"><th class="field-name">coltype:</th><td class="field-body"><p class="first">one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::fr:</th><td class="field-body">free variable (both bounds are ignored)</td>
</tr>
<tr class="field"><th class="field-name">glp::lo:</th><td class="field-body">variable with lower bound (upper bound is ignored)</td>
</tr>
<tr class="field"><th class="field-name">glp::up:</th><td class="field-body">variable with upper bound (lower bound is ignored)</td>
</tr>
<tr class="field"><th class="field-name">glp::db:</th><td class="field-body">double bounded variable</td>
</tr>
<tr class="field"><th class="field-name">glp::fx:</th><td class="field-body">fixed variable (lower bound applies, upper bound is ignored)</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">lowerbound:</th><td class="field-body"><p class="first">lower column bound</p>
</td>
</tr>
<tr class="field"><th class="field-name">upperbound:</th><td class="field-body"><p class="first last">upper column bound</p>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::set_col_bnds lp (3, glp::db, 100.0, 150.0);
()
&gt;
</pre>
</div>
<div class="section" id="set-change-objective-coefficient-or-constant-term">
<h4><a class="toc-backref" href="#id18">5.1.1.11&nbsp;&nbsp;&nbsp;Set (change) objective coefficient or constant term</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::set_obj_coef lp (colindex, coefficient)
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body">column index, zero index denotes the constant term
(objective shift)</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::set_obj_coef lp (3, 15.8);
()
&gt;
</pre>
</div>
<div class="section" id="load-or-replace-matrix-row">
<h4><a class="toc-backref" href="#id19">5.1.1.12&nbsp;&nbsp;&nbsp;Load or replace matrix row</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::set_mat_row lp (rowindex, rowvector)
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body">row index</td>
</tr>
<tr class="field"><th class="field-name">rowvector:</th><td class="field-body">list of tuples (colindex, coefficient); only non-zero
coefficients have to be specified, the order of column
indices is not important, duplicates are <strong>not</strong> allowed</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::set_mat_row lp (3, [(1, 3.0), (4, 5.2)]);
()
&gt;
</pre>
</div>
<div class="section" id="load-or-replace-matrix-column">
<h4><a class="toc-backref" href="#id20">5.1.1.13&nbsp;&nbsp;&nbsp;Load or replace matrix column</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::set_mat_col lp (colindex, colvector)
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body">column index</td>
</tr>
<tr class="field"><th class="field-name">colvector:</th><td class="field-body">list of tuples (rowindex, coefficient); only non-zero
coefficients have to be specified, the order of row
indices is not important, duplicates are <strong>not</strong> allowed</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::set_mat_col lp (2, [(4, 2.0), (2, 1.5)]);
()
&gt;
</pre>
</div>
<div class="section" id="load-or-replace-the-whole-problem-matrix">
<h4><a class="toc-backref" href="#id21">5.1.1.14&nbsp;&nbsp;&nbsp;Load or replace the whole problem matrix</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::load_matrix lp matrix
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">matrix:</th><td class="field-body">list of tuples (rowindex, colindex, coefficient); only non-zero
coefficients have to be specified, the order of indices is not
important, duplicates are <strong>not</strong> allowed</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::load_matrix lp [(1, 3, 5.0), (2, 2, 3.5), (3, 1, -2.0), (3, 2, 1.0)];
()
&gt;
</pre>
</div>
<div class="section" id="check-for-duplicate-elements-in-sparse-matrix">
<h4><a class="toc-backref" href="#id22">5.1.1.15&nbsp;&nbsp;&nbsp;Check for duplicate elements in sparse matrix</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::check_dup numrows numcols indices
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">numrows:</th><td class="field-body">number of rows</td>
</tr>
<tr class="field"><th class="field-name">numcols:</th><td class="field-body">number of columns</td>
</tr>
<tr class="field"><th class="field-name">indices:</th><td class="field-body">list of tuples (rowindex, colindex); indices of only non-zero
coefficients have to be specified, the order of indices is not
important</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>returns one of the following:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">0:</th><td class="field-body">the matrix has no duplicate elements</td>
</tr>
<tr class="field"><th class="field-name">-k:</th><td class="field-body">rowindex or colindex of the k-th element in indices is out of range</td>
</tr>
<tr class="field"><th class="field-name">+k:</th><td class="field-body">the k-th element in indices is duplicate</td>
</tr>
</tbody>
</table>
</blockquote>
</blockquote>
<p><strong>Remark:</strong></p>
<blockquote>
Notice, that <tt class="docutils literal">k</tt> counts from 1, whereas list members are counted from 0.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::check_dup 3 3  [(1, 3), (2, 2), (3, 1), (2, 2)];
4
&gt;
</pre>
</div>
<div class="section" id="sort-elements-of-the-constraint-matrix">
<h4><a class="toc-backref" href="#id23">5.1.1.16&nbsp;&nbsp;&nbsp;Sort elements of the constraint matrix</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::sort_matrix lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::sort_matrix lp;
()
&gt;
</pre>
</div>
<div class="section" id="delete-rows-from-the-matrix">
<h4><a class="toc-backref" href="#id24">5.1.1.17&nbsp;&nbsp;&nbsp;Delete rows from the matrix</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::del_rows lp rows
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rows:</th><td class="field-body">list of indices of rows to be deleted; the order of indices is not
important, duplicates are <strong>not</strong> allowed</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Remark:</strong></p>
<blockquote>
Deleting rows involves changing ordinal numbers of other rows
remaining in the problem object. New ordinal numbers of the remaining
rows are assigned under the assumption that the original order of rows is
not changed.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::del_rows lp [3, 4, 7];
()
&gt;
</pre>
</div>
<div class="section" id="delete-columns-from-the-matrix">
<h4><a class="toc-backref" href="#id25">5.1.1.18&nbsp;&nbsp;&nbsp;Delete columns from the matrix</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::del_cols lp cols
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">cols:</th><td class="field-body">list of indices of columns to be deleted; the order of indices is not
important, duplicates are <strong>not</strong> allowed</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Remark:</strong></p>
<blockquote>
Deleting columns involves changing ordinal numbers of other columns
remaining in the problem object. New ordinal numbers of the remaining
columns are assigned under the assumption that the original order of
columns is not changed.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::del_cols lp [6, 4, 5];
()
&gt;
</pre>
</div>
<div class="section" id="copy-the-whole-content-of-the-glpk-problem-object-to-another-one">
<h4><a class="toc-backref" href="#id26">5.1.1.19&nbsp;&nbsp;&nbsp;Copy the whole content of the GLPK problem object to another one</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::copy_prob destination source names
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">destination:</th><td class="field-body"><p class="first">pointer to the destination LP problem object (must already
exist)</p>
</td>
</tr>
<tr class="field"><th class="field-name">source:</th><td class="field-body"><p class="first">pointer to the source LP problem object</p>
</td>
</tr>
<tr class="field"><th class="field-name">names:</th><td class="field-body"><p class="first">one of the following:</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::on:</th><td class="field-body">copy all symbolic names as well</td>
</tr>
<tr class="field"><th class="field-name">glp::off:</th><td class="field-body">do not copy the symbolic names</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::copy_prob lp_dest lp_src glp::on;
()
&gt;
</pre>
</div>
<div class="section" id="erase-all-data-from-the-glpk-problem-object">
<h4><a class="toc-backref" href="#id27">5.1.1.20&nbsp;&nbsp;&nbsp;Erase all data from the GLPK problem object</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::erase_prob lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object, it remains still valid after
the function call</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::erase_prob lp;
()
&gt;
</pre>
</div>
<div class="section" id="delete-the-glpk-problem-object">
<h4><a class="toc-backref" href="#id28">5.1.1.21&nbsp;&nbsp;&nbsp;Delete the GLPK problem object</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::delete_prob lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object, it is not valid any more after
the function call</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::delete_prob lp;
()
&gt;
</pre>
</div>
</div>
<div class="section" id="problem-retrieving-routines">
<h3><a class="toc-backref" href="#id29">5.1.2&nbsp;&nbsp;&nbsp;Problem retrieving routines</a></h3>
<div class="section" id="get-the-problem-name">
<h4><a class="toc-backref" href="#id30">5.1.2.1&nbsp;&nbsp;&nbsp;Get the problem name</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_prob_name lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
name of the problem</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_prob_name lp;
&quot;Testing problem&quot;
&gt;
</pre>
</div>
<div class="section" id="get-the-objective-name">
<h4><a class="toc-backref" href="#id31">5.1.2.2&nbsp;&nbsp;&nbsp;Get the objective name</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_obj_name lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
name of the objective</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_obj_name lp;
&quot;Total costs&quot;
&gt;
</pre>
</div>
<div class="section" id="get-the-objective-direction">
<h4><a class="toc-backref" href="#id32">5.1.2.3&nbsp;&nbsp;&nbsp;Get the objective direction</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_obj_dir lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>returns one of the following:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::min:</th><td class="field-body">minimize</td>
</tr>
<tr class="field"><th class="field-name">glp::max:</th><td class="field-body">maximize</td>
</tr>
</tbody>
</table>
</blockquote>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_obj_dir lp;
glp::min
&gt;
</pre>
</div>
<div class="section" id="get-number-of-rows">
<h4><a class="toc-backref" href="#id33">5.1.2.4&nbsp;&nbsp;&nbsp;Get number of rows</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_num_rows lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
number of rows (constraints)</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_num_rows lp;
58
&gt;
</pre>
</div>
<div class="section" id="get-number-of-columns">
<h4><a class="toc-backref" href="#id34">5.1.2.5&nbsp;&nbsp;&nbsp;Get number of columns</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_num_cols lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
number of columns (structural variables)</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_num_cols lp;
65
&gt;
</pre>
</div>
<div class="section" id="get-name-of-a-row">
<h4><a class="toc-backref" href="#id35">5.1.2.6&nbsp;&nbsp;&nbsp;Get name of a row</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_row_name lp rowindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body">row index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
name of the given row</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_row_name lp 3;
&quot;The third row&quot;
&gt;
</pre>
</div>
<div class="section" id="get-name-of-a-column">
<h4><a class="toc-backref" href="#id36">5.1.2.7&nbsp;&nbsp;&nbsp;Get name of a column</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_col_name lp colindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body">column index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
name of the given column</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_col_name lp 2;
&quot;The second column&quot;
&gt;
</pre>
</div>
<div class="section" id="get-row-type">
<h4><a class="toc-backref" href="#id37">5.1.2.8&nbsp;&nbsp;&nbsp;Get row type</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_row_type lp rowindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body">row index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>returns one of the following:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::fr:</th><td class="field-body">free variable</td>
</tr>
<tr class="field"><th class="field-name">glp::lo:</th><td class="field-body">variable with lower bound</td>
</tr>
<tr class="field"><th class="field-name">glp::up:</th><td class="field-body">variable with upper bound</td>
</tr>
<tr class="field"><th class="field-name">glp::db:</th><td class="field-body">double bounded variable</td>
</tr>
<tr class="field"><th class="field-name">glp::fx:</th><td class="field-body">fixed variable</td>
</tr>
</tbody>
</table>
</blockquote>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_row_type lp 3;
glp::db
&gt;
</pre>
</div>
<div class="section" id="get-row-lower-bound">
<h4><a class="toc-backref" href="#id38">5.1.2.9&nbsp;&nbsp;&nbsp;Get row lower bound</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_row_lb lp rowindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body">row index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
the row lower bound; if the row has no lower bound then it returns
the smallest double number</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_row_lb lp 3;
50.0
&gt;
</pre>
</div>
<div class="section" id="get-row-upper-bound">
<h4><a class="toc-backref" href="#id39">5.1.2.10&nbsp;&nbsp;&nbsp;Get row upper bound</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_row_ub lp rowindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body">row index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
the row upper bound; if the row has no upper bound then it returns
the biggest double number</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_row_ub lp 3;
150.0
&gt;
</pre>
</div>
<div class="section" id="get-column-type">
<h4><a class="toc-backref" href="#id40">5.1.2.11&nbsp;&nbsp;&nbsp;Get column type</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_col_type lp colindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body">column index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>returns one of the following:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::fr:</th><td class="field-body">free variable</td>
</tr>
<tr class="field"><th class="field-name">glp::lo:</th><td class="field-body">variable with lower bound</td>
</tr>
<tr class="field"><th class="field-name">glp::up:</th><td class="field-body">variable with upper bound</td>
</tr>
<tr class="field"><th class="field-name">glp::db:</th><td class="field-body">double bounded variable</td>
</tr>
<tr class="field"><th class="field-name">glp::fx:</th><td class="field-body">fixed variable</td>
</tr>
</tbody>
</table>
</blockquote>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_col_type lp 2;
glp::up
&gt;
</pre>
</div>
<div class="section" id="get-column-lower-bound">
<h4><a class="toc-backref" href="#id41">5.1.2.12&nbsp;&nbsp;&nbsp;Get column lower bound</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_col_lb lp colindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body">column index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
the column lower bound; if the column has no lower bound then it returns
the smallest double number</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_col_lb lp 3;
-1.79769313486232e+308
&gt;
</pre>
</div>
<div class="section" id="get-column-upper-bound">
<h4><a class="toc-backref" href="#id42">5.1.2.13&nbsp;&nbsp;&nbsp;Get column upper bound</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_col_ub lp colindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body">column index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
the column upper bound; if the column has no upper bound then it returns
the biggest double number</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_col_lb lp 3;
150.0
&gt;
</pre>
</div>
<div class="section" id="get-objective-coefficient">
<h4><a class="toc-backref" href="#id43">5.1.2.14&nbsp;&nbsp;&nbsp;Get objective coefficient</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_obj_coef lp colindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body">column index; zero index denotes the constant term
(objective shift)</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
the coefficient of given column in the objective</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_obj_coef lp 3;
5.8
&gt;
</pre>
</div>
<div class="section" id="get-number-of-nonzero-coefficients">
<h4><a class="toc-backref" href="#id44">5.1.2.15&nbsp;&nbsp;&nbsp;Get number of nonzero coefficients</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_num_nz lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
number of non-zero coefficients in the problem matrix</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_num_nz lp;
158
&gt;
</pre>
</div>
<div class="section" id="retrive-a-row-from-the-problem-matrix">
<h4><a class="toc-backref" href="#id45">5.1.2.16&nbsp;&nbsp;&nbsp;Retrive a row from the problem matrix</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_mat_row lp rowindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body">row index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
non-zero coefficients of the given row in a list form of tuples
(colindex, coefficient)</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; get_mat_row lp 3;
[(3,6.0),(2,2.0),(1,2.0)]
&gt;
</pre>
</div>
<div class="section" id="retrive-a-column-from-the-problem-matrix">
<h4><a class="toc-backref" href="#id46">5.1.2.17&nbsp;&nbsp;&nbsp;Retrive a column from the problem matrix</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_mat_col lp colindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body">column index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
non-zero coefficients of the given column in a list form of tuples
(rowindex, coefficient)</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; get_mat_col lp 2;
[(3,2.0),(2,4.0),(1,1.0)]
&gt;
</pre>
</div>
</div>
<div class="section" id="row-and-column-searching-routines">
<h3><a class="toc-backref" href="#id47">5.1.3&nbsp;&nbsp;&nbsp;Row and column searching routines</a></h3>
<div class="section" id="create-index-for-searching-rows-and-columns-by-their-names">
<h4><a class="toc-backref" href="#id48">5.1.3.1&nbsp;&nbsp;&nbsp;Create index for searching rows and columns by their names</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::create_index lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::create_index lp;
()
&gt;
</pre>
</div>
<div class="section" id="find-a-row-number-by-name">
<h4><a class="toc-backref" href="#id49">5.1.3.2&nbsp;&nbsp;&nbsp;Find a row number by name</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::find_row lp rowname
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rowname:</th><td class="field-body">row name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
ordinal number (index) of the row</blockquote>
<p><strong>Remark</strong>:</p>
<blockquote>
The search index is automatically created if it does not already exists.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::find_row lp &quot;The third row&quot;;
3
&gt;
</pre>
</div>
<div class="section" id="find-a-column-number-by-name">
<h4><a class="toc-backref" href="#id50">5.1.3.3&nbsp;&nbsp;&nbsp;Find a column number by name</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::find_col lp colname
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colname:</th><td class="field-body">column name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
ordinal number (index) of the column</blockquote>
<p><strong>Remark</strong>:</p>
<blockquote>
The search index is automatically created if it does not already exists.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::find_col lp &quot;The second row&quot;;
2
&gt;
</pre>
</div>
<div class="section" id="delete-index-for-searching-rows-and-columns-by-their-names">
<h4><a class="toc-backref" href="#id51">5.1.3.4&nbsp;&nbsp;&nbsp;Delete index for searching rows and columns by their names</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::delete_index lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::delete:index lp;
()
&gt;
</pre>
</div>
</div>
<div class="section" id="problem-scaling-routines">
<h3><a class="toc-backref" href="#id52">5.1.4&nbsp;&nbsp;&nbsp;Problem scaling routines</a></h3>
<div class="section" id="set-the-row-scale-factor">
<h4><a class="toc-backref" href="#id53">5.1.4.1&nbsp;&nbsp;&nbsp;Set the row scale factor</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::set_rii lp (rowindex, coefficient)
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body">row index</td>
</tr>
<tr class="field"><th class="field-name">coefficient:</th><td class="field-body">scaling coefficient</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::set_rii lp (3, 258.6);
()
&gt;
</pre>
</div>
<div class="section" id="set-the-column-scale-factor">
<h4><a class="toc-backref" href="#id54">5.1.4.2&nbsp;&nbsp;&nbsp;Set the column scale factor</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::set_sjj lp (colindex, coefficient)
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body">column index</td>
</tr>
<tr class="field"><th class="field-name">coefficient:</th><td class="field-body">scaling coefficient</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::set_sjj lp (2, 12.8);
()
&gt;
</pre>
</div>
<div class="section" id="retrieve-the-row-scale-factor">
<h4><a class="toc-backref" href="#id55">5.1.4.3&nbsp;&nbsp;&nbsp;Retrieve the row scale factor</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_rii lp rowindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body">row index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
scaling coefficient of given row</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_rii lp 3;
258.6
&gt;
</pre>
</div>
<div class="section" id="retrieve-the-column-scale-factor">
<h4><a class="toc-backref" href="#id56">5.1.4.4&nbsp;&nbsp;&nbsp;Retrieve the column scale factor</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_sjj lp colindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body">column index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
scaling coefficient of given column</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_sjj lp 2;
12.8
&gt;
</pre>
</div>
<div class="section" id="scale-the-problem-data-according-to-supplied-flags">
<h4><a class="toc-backref" href="#id57">5.1.4.5&nbsp;&nbsp;&nbsp;Scale the problem data according to supplied flags</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::scale_prob lp flags
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body"><p class="first">pointer to the LP problem object</p>
</td>
</tr>
<tr class="field"><th class="field-name">flags:</th><td class="field-body"><p class="first">symbolic integer constants which can be combined together
by arithmetic <cite>or</cite>; the possible constants are:</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::sf_gm:</th><td class="field-body">perform geometric mean scaling</td>
</tr>
<tr class="field"><th class="field-name">glp::sf_eq:</th><td class="field-body">perform equilibration scaling</td>
</tr>
<tr class="field"><th class="field-name">glp::sf_2n:</th><td class="field-body">round scale factors to power of two</td>
</tr>
<tr class="field"><th class="field-name">glp::sf_skip:</th><td class="field-body">skip if problem is well scaled</td>
</tr>
<tr class="field"><th class="field-name">glp::sf_auto:</th><td class="field-body">choose scaling options automatically</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::scale_prob lp (glp::sf_gm || glp::sf_2n);
()
&gt;
</pre>
</div>
<div class="section" id="unscale-the-problem-data">
<h4><a class="toc-backref" href="#id58">5.1.4.6&nbsp;&nbsp;&nbsp;Unscale the problem data</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::unscale_prob lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::unscale_prob lp;
()
&gt;
</pre>
</div>
</div>
<div class="section" id="lp-basis-constructing-routines">
<h3><a class="toc-backref" href="#id59">5.1.5&nbsp;&nbsp;&nbsp;LP basis constructing routines</a></h3>
<div class="section" id="set-the-row-status">
<h4><a class="toc-backref" href="#id60">5.1.5.1&nbsp;&nbsp;&nbsp;Set the row status</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::set_row_stat lp (rowindex, status)
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body"><p class="first">pointer to the LP problem object</p>
</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body"><p class="first">row index</p>
</td>
</tr>
<tr class="field"><th class="field-name">status:</th><td class="field-body"><p class="first">one of the following:</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::bs:</th><td class="field-body">make the row basic (make the constraint inactive)</td>
</tr>
<tr class="field"><th class="field-name">glp::nl:</th><td class="field-body">make the row non-basic (make the constraint active)</td>
</tr>
<tr class="field"><th class="field-name">glp::nu:</th><td class="field-body">make the row non-basic and set it to the upper bound;
if the row is not double-bounded, this status is
equivalent to glp::nl (only in the case of this routine)</td>
</tr>
<tr class="field"><th class="field-name">glp::nf:</th><td class="field-body">the same as glp::nl (only in the case of this routine)</td>
</tr>
<tr class="field"><th class="field-name">glp::ns:</th><td class="field-body">the same as glp::nl (only in the case of this routine)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::set_row_stat lp (3, glp::nu);
()
&gt;
</pre>
</div>
<div class="section" id="set-the-column-status">
<h4><a class="toc-backref" href="#id61">5.1.5.2&nbsp;&nbsp;&nbsp;Set the column status</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::set_col_stat lp (colindex, status)
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body"><p class="first">pointer to the LP problem object</p>
</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body"><p class="first">column index</p>
</td>
</tr>
<tr class="field"><th class="field-name">status:</th><td class="field-body"><p class="first">one of the following:</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::bs:</th><td class="field-body">make the column basic</td>
</tr>
<tr class="field"><th class="field-name">glp::nl:</th><td class="field-body">make the column non-basic</td>
</tr>
<tr class="field"><th class="field-name">glp::nu:</th><td class="field-body">make the column non-basic and set it to the upper bound;
if the column is not double-bounded, this status is
equivalent to glp::nl (only in the case of this routine)</td>
</tr>
<tr class="field"><th class="field-name">glp::nf:</th><td class="field-body">the same as glp::nl (only in the case of this routine)</td>
</tr>
<tr class="field"><th class="field-name">glp::ns:</th><td class="field-body">the same as glp::nl (only in the case of this routine)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::set_col_stat lp (2, glp::bs);
()
&gt;
</pre>
</div>
<div class="section" id="construct-standard-problem-basis">
<h4><a class="toc-backref" href="#id62">5.1.5.3&nbsp;&nbsp;&nbsp;Construct standard problem basis</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::std_basis lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::std_basis lp;
()
&gt;
</pre>
</div>
<div class="section" id="construct-advanced-problem-basis">
<h4><a class="toc-backref" href="#id63">5.1.5.4&nbsp;&nbsp;&nbsp;Construct advanced problem basis</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::adv_basis lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::adv_basis lp;
()
&gt;
</pre>
</div>
<div class="section" id="construct-bixby-s-problem-basis">
<h4><a class="toc-backref" href="#id64">5.1.5.5&nbsp;&nbsp;&nbsp;Construct Bixby's problem basis</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::cpx_basis lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::cpx_basis lp;
()
&gt;
</pre>
</div>
</div>
<div class="section" id="simplex-method-routines">
<h3><a class="toc-backref" href="#id65">5.1.6&nbsp;&nbsp;&nbsp;Simplex method routines</a></h3>
<div class="section" id="solve-the-lp-problem-using-simplex-method">
<h4><a class="toc-backref" href="#id66">5.1.6.1&nbsp;&nbsp;&nbsp;Solve the LP problem using simplex method</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::simplex lp options
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body"><p class="first">pointer to the LP problem object</p>
</td>
</tr>
<tr class="field"><th class="field-name">options:</th><td class="field-body"><p class="first">list of solver options in the form of tuples (option_name, value):</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::msg_lev:</th><td class="field-body"><p class="first">(default: glp::msg_all) - message level for
terminal output:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::msg_off:</th><td class="field-body">no output</td>
</tr>
<tr class="field"><th class="field-name">glp::msg_err:</th><td class="field-body">error and warning messages only</td>
</tr>
<tr class="field"><th class="field-name">glp::msg_on:</th><td class="field-body">normal output;</td>
</tr>
<tr class="field"><th class="field-name">glp::msg_all:</th><td class="field-body">full output (including
informational messages)</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">glp::meth:</th><td class="field-body"><p class="first">(default: glp::primal) - simplex method option</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::primal:</th><td class="field-body">use two-phase primal simplex</td>
</tr>
<tr class="field"><th class="field-name">glp::dual:</th><td class="field-body">use two-phase dual simplex;</td>
</tr>
<tr class="field"><th class="field-name">glp::dualp:</th><td class="field-body">use two-phase dual simplex,
and if it fails, switch to the
primal simplex</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">glp::pricing:</th><td class="field-body"><p class="first">(default: glp::pt_pse) - pricing technique</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::pt_std:</th><td class="field-body">standard (textbook)</td>
</tr>
<tr class="field"><th class="field-name">glp::pt_pse:</th><td class="field-body">projected steepest edge</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">glp::r_test:</th><td class="field-body"><p class="first">(default: glp::rt_har) - ratio test technique</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::rt_std:</th><td class="field-body">standard (textbook)</td>
</tr>
<tr class="field"><th class="field-name">glp::rt_har:</th><td class="field-body">Harris' two-pass ratio test</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">glp::tol_bnd:</th><td class="field-body"><p class="first">(default: 1e-7) - tolerance used to check if the
basic solution is primal feasible</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::tol_dj:</th><td class="field-body"><p class="first">(default: 1e-7) - tolerance used to check if the
basic solution is dual feasible</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::tol_piv:</th><td class="field-body"><p class="first">(default: 1e-10) - tolerance used to choose
eligble pivotal elements of the simplex table</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::obj_ll:</th><td class="field-body"><p class="first">(default: -DBL_MAX) - lower limit of the objective
function - if the objective function reaches this
limit and continues decreasing, the solver
terminates the search - used in the dual simplex
only</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::obj_ul:</th><td class="field-body"><p class="first">(default: +DBL_MAX) - upper limit of the objective
function. If the objective function reaches
this limit and continues increasing, the solver
terminates the search - used in the dual simplex
only</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::it_lim:</th><td class="field-body"><p class="first">(default: INT_MAX) - simplex iteration limit</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::tm lim:</th><td class="field-body"><p class="first">(default: INT_MAX) - searching time limit, in
milliseconds</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::out_frq:</th><td class="field-body"><p class="first">(default: 200) - output frequency, in
iterations - this parameter specifies how
frequently the solver sends information about
the solution process to the terminal</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::out_dly:</th><td class="field-body"><p class="first">(default: 0) - output delay, in milliseconds
- this parameter specifies how long the solver
should delay sending information about the
solution process to the terminal</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::presolve:</th><td class="field-body"><p class="first">(default: glp::off) - LP presolver option:</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::on:</th><td class="field-body">enable using the LP presolver</td>
</tr>
<tr class="field"><th class="field-name">glp::off:</th><td class="field-body">disable using the LP presolver</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::ok:</th><td class="field-body">the LP problem instance has been successfully solved; this code
does not necessarily mean that the solver has found optimal
solution, it only means that the solution process was successful</td>
</tr>
<tr class="field"><th class="field-name">glp::ebadb:</th><td class="field-body">unable to start the search, because the initial basis
specified in the problem object is invalid - the number
of basic (auxiliary and structural) variables is not the same
as the number of rows in the problem object</td>
</tr>
<tr class="field"><th class="field-name">glp::esing:</th><td class="field-body">unable to start the search, because the basis matrix
corresponding to the initial basis is singular within the
working precision</td>
</tr>
<tr class="field"><th class="field-name">glp::econd:</th><td class="field-body">unable to start the search, because the basis matrix
corresponding to the initial basis is ill-conditioned,
i.e. its condition number is too large</td>
</tr>
<tr class="field"><th class="field-name">glp::ebound:</th><td class="field-body">unable to start the search, because some double-bounded
(auxiliary or structural) variables have incorrect bounds</td>
</tr>
<tr class="field"><th class="field-name">glp::efail:</th><td class="field-body">the search was prematurely terminated due to the solver
failure</td>
</tr>
<tr class="field"><th class="field-name">glp::eobjll:</th><td class="field-body">the search was prematurely terminated, because the objective
function being maximized has reached its lower limit and
continues decreasing (the dual simplex only)</td>
</tr>
<tr class="field"><th class="field-name">glp::eobjul:</th><td class="field-body">the search was prematurely terminated, because the objective
function being minimized has reached its upper limit and
continues increasing (the dual simplex only)</td>
</tr>
<tr class="field"><th class="field-name">glp::eitlim:</th><td class="field-body">the search was prematurely terminated, because the simplex
iteration limit has been exceeded</td>
</tr>
<tr class="field"><th class="field-name">glp::etmlim:</th><td class="field-body">the search was prematurely terminated, because the time
limit has been exceeded</td>
</tr>
<tr class="field"><th class="field-name">glp::enopfs:</th><td class="field-body">the LP problem instance has no primal feasible solution
(only if the LP presolver is used)</td>
</tr>
<tr class="field"><th class="field-name">glp::enodfs:</th><td class="field-body">the LP problem instance has no dual feasible solution
(only if the LP presolver is used)</td>
</tr>
</tbody>
</table>
<p>When the list of options contains some bad option(s) then a list of bad
options is returned instead.</p>
</blockquote>
<p><strong>Remark</strong>:</p>
<blockquote>
Options not mentioned in the option list are set to their default values.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::simplex lp [(glp::presolve, glp::on), (glp::msg_lev, glp::msg_all)];
glp_simplex: original LP has 3 rows, 3 columns, 9 non-zeros
glp_simplex: presolved LP has 3 rows, 3 columns, 9 non-zeros
Scaling...
 A: min|aij| = 1,000e+000  max|aij| = 1,000e+001  ratio = 1,000e+001
Problem data seem to be well scaled
Crashing...
Size of triangular part = 3
*     0: obj =  0,000000000e+000  infeas = 0,000e+000 (0)
*     2: obj =  7,333333333e+002  infeas = 0,000e+000 (0)
OPTIMAL SOLUTION FOUND
glp::ok
&gt;
</pre>
</div>
<div class="section" id="solve-the-lp-problem-using-simplex-method-in-exact-arithmetics">
<h4><a class="toc-backref" href="#id67">5.1.6.2&nbsp;&nbsp;&nbsp;Solve the LP problem using simplex method in exact arithmetics</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::exact lp options
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body"><p class="first">pointer to the LP problem object</p>
</td>
</tr>
<tr class="field"><th class="field-name">options:</th><td class="field-body"><p class="first">list of solver options in the form of tuples (option_name, value):</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::it_lim:</th><td class="field-body">(default: INT_MAX) - simplex iteration limit</td>
</tr>
<tr class="field"><th class="field-name">glp::tm lim:</th><td class="field-body">(default: INT_MAX) - searching time limit, in
milliseconds</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::ok:</th><td class="field-body">the LP problem instance has been successfully solved; this code
does not necessarily mean that the solver has found optimal
solution, it only means that the solution process was successful</td>
</tr>
<tr class="field"><th class="field-name">glp::ebadb:</th><td class="field-body">unable to start the search, because the initial basis
specified in the problem object is invalid - the number
of basic (auxiliary and structural) variables is not the same
as the number of rows in the problem object</td>
</tr>
<tr class="field"><th class="field-name">glp::esing:</th><td class="field-body">unable to start the search, because the basis matrix
corresponding to the initial basis is singular within the
working precision</td>
</tr>
<tr class="field"><th class="field-name">glp::ebound:</th><td class="field-body">unable to start the search, because some double-bounded
(auxiliary or structural) variables have incorrect bounds</td>
</tr>
<tr class="field"><th class="field-name">glp::efail:</th><td class="field-body">the search was prematurely terminated due to the solver
failure</td>
</tr>
<tr class="field"><th class="field-name">glp::eitlim:</th><td class="field-body">the search was prematurely terminated, because the simplex
iteration limit has been exceeded</td>
</tr>
<tr class="field"><th class="field-name">glp::etmlim:</th><td class="field-body">the search was prematurely terminated, because the time
limit has been exceeded</td>
</tr>
</tbody>
</table>
<p>When the list of options contains some bad option(s) then a list of bad
options is returned instead.</p>
</blockquote>
<p><strong>Remark</strong>:</p>
<blockquote>
Options not mentioned in the option list are set to their default values.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::exact lp [];
glp_exact: 3 rows, 3 columns, 9 non-zeros
GNU MP bignum library is being used
*     2:   objval =                      0   (0)
*     4:   objval =       733,333333333333   (0)
OPTIMAL SOLUTION FOUND
glp::ok
&gt;
</pre>
</div>
<div class="section" id="retrieve-generic-status-of-basic-solution">
<h4><a class="toc-backref" href="#id68">5.1.6.3&nbsp;&nbsp;&nbsp;Retrieve generic status of basic solution</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_status lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::undef:</th><td class="field-body">solution is undefined</td>
</tr>
<tr class="field"><th class="field-name">glp::feas:</th><td class="field-body">solution is feasible</td>
</tr>
<tr class="field"><th class="field-name">glp::infeas:</th><td class="field-body">solution is infeasible</td>
</tr>
<tr class="field"><th class="field-name">glp::nofeas:</th><td class="field-body">no feasible solution exists</td>
</tr>
<tr class="field"><th class="field-name">glp::opt:</th><td class="field-body">solution is optimal</td>
</tr>
<tr class="field"><th class="field-name">glp::unbnd:</th><td class="field-body">solution is unbounded</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_status lp;
glp::opt
&gt;
</pre>
</div>
<div class="section" id="retrieve-generic-status-of-primal-solution">
<h4><a class="toc-backref" href="#id69">5.1.6.4&nbsp;&nbsp;&nbsp;Retrieve generic status of primal solution</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_prim_stat lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::undef:</th><td class="field-body">primal solution is undefined</td>
</tr>
<tr class="field"><th class="field-name">glp::feas:</th><td class="field-body">primal solution is feasible</td>
</tr>
<tr class="field"><th class="field-name">glp::infeas:</th><td class="field-body">primal solution is infeasible</td>
</tr>
<tr class="field"><th class="field-name">glp::nofeas:</th><td class="field-body">no primal feasible solution exists</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_prim_stat lp;
glp::feas
&gt;
</pre>
</div>
<div class="section" id="retrieve-generic-status-of-dual-solution">
<h4><a class="toc-backref" href="#id70">5.1.6.5&nbsp;&nbsp;&nbsp;Retrieve generic status of dual solution</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_dual_stat lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::undef:</th><td class="field-body">dual solution is undefined</td>
</tr>
<tr class="field"><th class="field-name">glp::feas:</th><td class="field-body">dual solution is feasible</td>
</tr>
<tr class="field"><th class="field-name">glp::infeas:</th><td class="field-body">dual solution is infeasible</td>
</tr>
<tr class="field"><th class="field-name">glp::nofeas:</th><td class="field-body">no dual feasible solution exists</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_dual_stat lp;
glp::feas
&gt;
</pre>
</div>
<div class="section" id="retrieve-value-of-the-objective-function">
<h4><a class="toc-backref" href="#id71">5.1.6.6&nbsp;&nbsp;&nbsp;Retrieve value of the objective function</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_obj_val lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
value of the objective function</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_obj_val lp
733.333333333333
&gt;
</pre>
</div>
<div class="section" id="retrieve-generic-status-of-a-row-variable">
<h4><a class="toc-backref" href="#id72">5.1.6.7&nbsp;&nbsp;&nbsp;Retrieve generic status of a row variable</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_row_stat lp rowindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body">row index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::bs:</th><td class="field-body">basic variable</td>
</tr>
<tr class="field"><th class="field-name">glp::nl:</th><td class="field-body">non-basic variable on its lower bound</td>
</tr>
<tr class="field"><th class="field-name">glp::nu:</th><td class="field-body">non-basic variable on its upper bound</td>
</tr>
<tr class="field"><th class="field-name">glp::nf:</th><td class="field-body">non-basic free (unbounded) variable</td>
</tr>
<tr class="field"><th class="field-name">glp::ns:</th><td class="field-body">non-basic fixed variable</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_row_stat lp 3;
glp::bs
&gt;
</pre>
</div>
<div class="section" id="retrieve-row-primal-value">
<h4><a class="toc-backref" href="#id73">5.1.6.8&nbsp;&nbsp;&nbsp;Retrieve row primal value</a></h4>
<dl class="docutils">
<dt><strong>Synopsis</strong>::</dt>
<dd>glp::get_row_prim lp rowindex</dd>
</dl>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body">row index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
primal value of the row (auxiliary) variable</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_row_prim lp 3;
200.0
&gt;
</pre>
</div>
<div class="section" id="retrieve-row-dual-value">
<h4><a class="toc-backref" href="#id74">5.1.6.9&nbsp;&nbsp;&nbsp;Retrieve row dual value</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_row_dual lp rowindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body">row index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
dual value of the row (auxiliary) variable</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_row_dual lp 3;
0.0
&gt;
</pre>
</div>
<div class="section" id="retrieve-generic-status-of-a-column-variable">
<h4><a class="toc-backref" href="#id75">5.1.6.10&nbsp;&nbsp;&nbsp;Retrieve generic status of a column variable</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_col_stat lp colindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body">column index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::bs:</th><td class="field-body">basic variable</td>
</tr>
<tr class="field"><th class="field-name">glp::nl:</th><td class="field-body">non-basic variable on its lower bound</td>
</tr>
<tr class="field"><th class="field-name">glp::nu:</th><td class="field-body">non-basic variable on its upper bound</td>
</tr>
<tr class="field"><th class="field-name">glp::nf:</th><td class="field-body">non-basic free (unbounded) variable</td>
</tr>
<tr class="field"><th class="field-name">glp::ns:</th><td class="field-body">non-basic fixed variable</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_col_stat lp 2;
glp::bs
&gt;
</pre>
</div>
<div class="section" id="retrieve-column-primal-value">
<h4><a class="toc-backref" href="#id76">5.1.6.11&nbsp;&nbsp;&nbsp;Retrieve column primal value</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_col_prim lp colindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body">column index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
primal value of the column (structural) variable</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_col_prim lp 2;
66.6666666666667
&gt;
</pre>
</div>
<div class="section" id="retrieve-column-dual-value">
<h4><a class="toc-backref" href="#id77">5.1.6.12&nbsp;&nbsp;&nbsp;Retrieve column dual value</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_col_dual lp colindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body">column index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
dual value of the column (structural) variable</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_col_dual lp 2;
0.0
&gt;
</pre>
</div>
<div class="section" id="determine-variable-causing-unboundedness">
<h4><a class="toc-backref" href="#id78">5.1.6.13&nbsp;&nbsp;&nbsp;Determine variable causing unboundedness</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_unbnd_ray lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
The routine glp_get_unbnd_ray returns the number k of a variable, which
causes primal or dual unboundedness. If 1 &lt;= k &lt;= m, it is k-th auxiliary
variable, and if m + 1 &lt;= k &lt;= m + n, it is (k - m)-th structural variable,
where m is the number of rows, n is the number of columns in the problem
object. If such variable is not defined, the routine returns 0.</blockquote>
<p><strong>Remark</strong>:</p>
<blockquote>
If it is not exactly known which version of the simplex solver detected
unboundedness, i.e. whether the unboundedness is primal or dual, it is
sufficient to check the status of the variable with the routine
glp::get_row_stat or glp::get_col_stat. If the variable is non-basic,
the unboundedness is primal, otherwise, if the variable is basic,
the unboundedness is dual (the latter case means that the problem has
no primal feasible dolution).</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_unbnd_ray lp;
0
&gt;
</pre>
</div>
</div>
<div class="section" id="interior-point-method-routines">
<h3><a class="toc-backref" href="#id79">5.1.7&nbsp;&nbsp;&nbsp;Interior-point method routines</a></h3>
<div class="section" id="solve-the-lp-problem-using-interior-point-method">
<h4><a class="toc-backref" href="#id80">5.1.7.1&nbsp;&nbsp;&nbsp;Solve the LP problem using interior-point method</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::interior lp options
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body"><p class="first">pointer to the LP problem object</p>
</td>
</tr>
<tr class="field"><th class="field-name">options:</th><td class="field-body"><p class="first">list of solver options in the form of tuples (option_name, value):</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::msg_lev:</th><td class="field-body"><p class="first">(default: glp::msg_all) - message level for
terminal output:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::msg_off:</th><td class="field-body">no output</td>
</tr>
<tr class="field"><th class="field-name">glp::msg_err:</th><td class="field-body">error and warning messages only</td>
</tr>
<tr class="field"><th class="field-name">glp::msg_on:</th><td class="field-body">normal output;</td>
</tr>
<tr class="field"><th class="field-name">glp::msg_all:</th><td class="field-body">full output (including
informational messages)</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">glp::ord_alg:</th><td class="field-body"><p class="first">(default: glp::ord_amd) - ordering algorithm option</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::ord_none:</th><td class="field-body">use natural (original) ordering</td>
</tr>
<tr class="field"><th class="field-name">glp::ord_qmd:</th><td class="field-body">quotient minimum degree (QMD)</td>
</tr>
<tr class="field"><th class="field-name">glp::ord_amd:</th><td class="field-body">approximate minimum degree (AMD)</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">glp::ord_sysamd:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">approximate minimum degree
(SYSAMD)</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::ok:</th><td class="field-body">the LP problem instance has been successfully solved;
this code does not necessarily mean that the solver has
found optimal solution, it only means that the solution
process was successful</td>
</tr>
<tr class="field"><th class="field-name">glp::efail:</th><td class="field-body">the problem has no rows/columns</td>
</tr>
<tr class="field"><th class="field-name">glp::enocvg:</th><td class="field-body">very slow convergence or divergence</td>
</tr>
<tr class="field"><th class="field-name">glp::eitlim:</th><td class="field-body">iteration limit exceeded</td>
</tr>
<tr class="field"><th class="field-name">glp::einstab:</th><td class="field-body">numerical instability on solving Newtonian system</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::interior lp [(glp::ord_alg, glp::ord_amd)];
Original LP has 3 row(s), 3 column(s), and 9 non-zero(s)
Working LP has 3 row(s), 6 column(s), and 12 non-zero(s)
Matrix A has 12 non-zeros
Matrix S = A*A' has 6 non-zeros (upper triangle)
Approximate minimum degree ordering (AMD)...
Computing Cholesky factorization S = L*L'...
Matrix L has 6 non-zeros
Guessing initial point...
Optimization begins...
  0: obj = -8,218489503e+002; rpi = 3,6e-001; rdi = 6,8e-001; gap = 2,5e-001
  1: obj = -6,719060895e+002; rpi = 3,6e-002; rdi = 1,9e-001; gap = 1,4e-002
  2: obj = -6,917210389e+002; rpi = 3,6e-003; rdi = 9,3e-002; gap = 3,0e-002
  3: obj = -7,267557732e+002; rpi = 2,1e-003; rdi = 9,3e-003; gap = 4,4e-002
  4: obj = -7,323038146e+002; rpi = 2,1e-004; rdi = 1,1e-003; gap = 4,8e-003
  5: obj = -7,332295932e+002; rpi = 2,1e-005; rdi = 1,1e-004; gap = 4,8e-004
  6: obj = -7,333229585e+002; rpi = 2,1e-006; rdi = 1,1e-005; gap = 4,8e-005
  7: obj = -7,333322959e+002; rpi = 2,1e-007; rdi = 1,1e-006; gap = 4,8e-006
  8: obj = -7,333332296e+002; rpi = 2,1e-008; rdi = 1,1e-007; gap = 4,8e-007
  9: obj = -7,333333230e+002; rpi = 2,1e-009; rdi = 1,1e-008; gap = 4,8e-008
 10: obj = -7,333333323e+002; rpi = 2,1e-010; rdi = 1,1e-009; gap = 4,8e-009
OPTIMAL SOLUTION FOUND
glp::ok
&gt;
</pre>
</div>
<div class="section" id="retrieve-status-of-interior-point-solution">
<h4><a class="toc-backref" href="#id81">5.1.7.2&nbsp;&nbsp;&nbsp;Retrieve status of interior-point solution</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ipt_status lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>one of the following</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::undef:</th><td class="field-body">interior-point solution is undefined</td>
</tr>
<tr class="field"><th class="field-name">glp::opt:</th><td class="field-body">interior-point solution is optimal</td>
</tr>
<tr class="field"><th class="field-name">glp::infeas:</th><td class="field-body">interior-point solution is infeasible</td>
</tr>
<tr class="field"><th class="field-name">glp::nofeas:</th><td class="field-body">no feasible primal-dual solution exists</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::ipt_status lp;
glp::opt
&gt;
</pre>
</div>
<div class="section" id="retrieve-the-objective-function-value-of-interior-point-solution">
<h4><a class="toc-backref" href="#id82">5.1.7.3&nbsp;&nbsp;&nbsp;Retrieve the objective function value of interior-point solution</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ipt_obj_val lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
objective function value of interior-point solution</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::ipt_obj_val lp;
733.333332295849
&gt;
</pre>
</div>
<div class="section" id="retrieve-row-primal-value-of-interior-point-solution">
<h4><a class="toc-backref" href="#id83">5.1.7.4&nbsp;&nbsp;&nbsp;Retrieve row primal value of interior-point solution</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ipt_row_prim lp rowindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body">row index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
primal value of the row (auxiliary) variable</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::ipt_row_prim lp 3;
200.000000920688
&gt;
</pre>
</div>
<div class="section" id="retrieve-row-dual-value-of-interior-point-solution">
<h4><a class="toc-backref" href="#id84">5.1.7.5&nbsp;&nbsp;&nbsp;Retrieve row dual value of interior-point solution</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ipt_row_dual lp rowindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body">row index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
dual value of the row (auxiliary) variable</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::ipt_row_dual lp 3;
2.50607466186742e-008
&gt;
</pre>
</div>
<div class="section" id="retrieve-column-primal-value-of-interior-point-solution">
<h4><a class="toc-backref" href="#id85">5.1.7.6&nbsp;&nbsp;&nbsp;Retrieve column primal value of interior-point solution</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ipt_col_prim lp colindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body">column index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
primal value of the column (structural) variable</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::ipt_col_prim lp 2;
66.666666406779
&gt;
</pre>
</div>
<div class="section" id="retrieve-column-dual-value-of-interior-point-solution">
<h4><a class="toc-backref" href="#id86">5.1.7.7&nbsp;&nbsp;&nbsp;Retrieve column dual value of interior-point solution</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ipt_col_dual lp colindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body">column index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
dual value of the column (structural) variable</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::ipt_col_dual lp 2;
2.00019467655466e-009
&gt;
</pre>
</div>
</div>
<div class="section" id="mixed-integer-programming-routines">
<h3><a class="toc-backref" href="#id87">5.1.8&nbsp;&nbsp;&nbsp;Mixed integer programming routines</a></h3>
<div class="section" id="set-column-kind">
<h4><a class="toc-backref" href="#id88">5.1.8.1&nbsp;&nbsp;&nbsp;Set column kind</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::set_col_kind lp (colindex, colkind)
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body"><p class="first">pointer to the LP problem object</p>
</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body"><p class="first">column index</p>
</td>
</tr>
<tr class="field"><th class="field-name">colkind:</th><td class="field-body"><p class="first">column kind - one of the following:</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::cv:</th><td class="field-body">continuous variable</td>
</tr>
<tr class="field"><th class="field-name">glp::iv:</th><td class="field-body">integer variable</td>
</tr>
<tr class="field"><th class="field-name">glp::bv:</th><td class="field-body">binary variable</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::set_col_kind lp (1, glp::iv);
()
&gt;
</pre>
</div>
<div class="section" id="retrieve-column-kind">
<h4><a class="toc-backref" href="#id89">5.1.8.2&nbsp;&nbsp;&nbsp;Retrieve column kind</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_col_kind lp colindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body">column index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::cv:</th><td class="field-body">continuous variable</td>
</tr>
<tr class="field"><th class="field-name">glp::iv:</th><td class="field-body">integer variable</td>
</tr>
<tr class="field"><th class="field-name">glp::bv:</th><td class="field-body">binary variable</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_col_kind lp 1;
glp::iv
&gt;
</pre>
</div>
<div class="section" id="retrieve-number-of-integer-columns">
<h4><a class="toc-backref" href="#id90">5.1.8.3&nbsp;&nbsp;&nbsp;Retrieve number of integer columns</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_num_int lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
number of integer columns (including binary columns)</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp_get_num_int lp;
1
&gt;
</pre>
</div>
<div class="section" id="retrieve-number-of-binary-columns">
<h4><a class="toc-backref" href="#id91">5.1.8.4&nbsp;&nbsp;&nbsp;Retrieve number of binary columns</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_num_bin lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
number of binary columns</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_num_bin lp
0
&gt;
</pre>
</div>
<div class="section" id="solve-the-mip-problem-using-branch-and-cut-method">
<h4><a class="toc-backref" href="#id92">5.1.8.5&nbsp;&nbsp;&nbsp;Solve the MIP problem using branch-and-cut method</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::intopt lp options
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body"><p class="first">pointer to the LP problem object</p>
</td>
</tr>
<tr class="field"><th class="field-name">options:</th><td class="field-body"><p class="first">list of solver options in the form of tuples (option_name, value):</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::msg_lev:</th><td class="field-body"><p class="first">(default: glp::msg_all) - message level for
terminal output:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::msg_off:</th><td class="field-body">no output</td>
</tr>
<tr class="field"><th class="field-name">glp::msg_err:</th><td class="field-body">error and warning messages only</td>
</tr>
<tr class="field"><th class="field-name">glp::msg_on:</th><td class="field-body">normal output;</td>
</tr>
<tr class="field"><th class="field-name">glp::msg_all:</th><td class="field-body">full output (including
informational messages)</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">glp::br_tech:</th><td class="field-body"><p class="first">(default: glp::bt::blb) - branching technique</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::br_ffv:</th><td class="field-body">first fractional variable</td>
</tr>
<tr class="field"><th class="field-name">glp::br_lfv:</th><td class="field-body">last fractional variable</td>
</tr>
<tr class="field"><th class="field-name">glp::br_mfv:</th><td class="field-body">most fractional variable</td>
</tr>
<tr class="field"><th class="field-name">glp::br_dth:</th><td class="field-body">heuristic by Driebeck and Tomlin</td>
</tr>
<tr class="field"><th class="field-name">glp::br_pch:</th><td class="field-body">hybrid pseudocost heuristic</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">glp::bt_tech:</th><td class="field-body"><p class="first">(default: glp::pt_pse) - backtracking technique</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::bt_dfs:</th><td class="field-body">depth first search;</td>
</tr>
<tr class="field"><th class="field-name">glp::bt_bfs:</th><td class="field-body">breadth first search;</td>
</tr>
<tr class="field"><th class="field-name">glp::bt_blb:</th><td class="field-body">best local bound;</td>
</tr>
<tr class="field"><th class="field-name">glp::bt_bph:</th><td class="field-body">best projection heuristic.</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">glp::pp_tech:</th><td class="field-body"><p class="first">(default: glp::pp_all) - preprocessing technique</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::pp_none:</th><td class="field-body">disable preprocessing;</td>
</tr>
<tr class="field"><th class="field-name">glp::pp_root:</th><td class="field-body">perform preprocessing only
on the root level</td>
</tr>
<tr class="field"><th class="field-name">glp::pp_all:</th><td class="field-body">perform preprocessing on all
levels</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">glp::fp_heur:</th><td class="field-body"><p class="first">(default: glp::off) - feasibility pump heuristic:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::on:</th><td class="field-body">enable applying the feasibility
pump heuristic</td>
</tr>
<tr class="field"><th class="field-name">glp::off:</th><td class="field-body">disable applying the feasibility
pump heuristic</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">glp::gmi_cuts:</th><td class="field-body"><p class="first">(default: glp::off) - Gomory’s mixed integer
cuts:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::on:</th><td class="field-body">enable generating Gomory’s cuts;</td>
</tr>
<tr class="field"><th class="field-name">glp::off:</th><td class="field-body">disable generating Gomory’s cuts.</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">glp::mir_cuts:</th><td class="field-body"><p class="first">(default: glp::off) - mixed integer rounding
(MIR) cuts:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::on:</th><td class="field-body">enable generating MIR cuts;</td>
</tr>
<tr class="field"><th class="field-name">glp::off:</th><td class="field-body">disable generating MIR cuts.</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">glp::cov_cuts:</th><td class="field-body"><p class="first">(default: glp::off) - mixed cover cuts:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::on:</th><td class="field-body">enable generating mixed cover cuts;</td>
</tr>
<tr class="field"><th class="field-name">glp::off:</th><td class="field-body">disable generating mixed cover cuts.</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">glp::clq_cuts (default:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first">glp::off) - clique cuts:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::on:</th><td class="field-body">enable generating clique cuts;</td>
</tr>
<tr class="field"><th class="field-name">glp::off:</th><td class="field-body">disable generating clique cuts.</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">glp::tol_int:</th><td class="field-body"><p class="first">(default: 1e-5) - absolute tolerance used to
check if optimal solution to the current LP
relaxation is integer feasible</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::tol_obj:</th><td class="field-body"><p class="first">(default: 1e-7) - relative tolerance used to
check if the objective value in optimal solution
to the current LP relaxation is not better than
in the best known integer feasible solution</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::mip_gap:</th><td class="field-body"><p class="first">(default: 0.0) - the relative mip gap tolerance;
if the relative mip gap for currently known best
integer feasible solution falls below this
tolerance, the solver terminates the search -
this allows obtainig suboptimal integer feasible
solutions if solving the problem to optimality
takes too long time</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::tm lim:</th><td class="field-body"><p class="first">(default: INT_MAX) - searching time limit, in
milliseconds</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::out_frq:</th><td class="field-body"><p class="first">(default: 5000) - output frequency, in
miliseconds - this parameter specifies how
frequently the solver sends information about
the solution process to the terminal</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::out_dly:</th><td class="field-body"><p class="first">(default: 10000) - output delay, in milliseconds
- this parameter specifies how long the solver
should delay sending information about the
solution of the current LP relaxation with the
simplex method to the terminal</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::cb_func:</th><td class="field-body"><p class="first">(default: glp::off) - specifies whether to use
the user-defined callback routine</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::on:</th><td class="field-body">use user-defined callback function -
the function <tt class="docutils literal"><span class="pre">glp::mip_cb</span> tree info</tt>
<strong>must</strong> be defined by the user</td>
</tr>
<tr class="field"><th class="field-name">glp::off:</th><td class="field-body">do not use user-defined callback
function</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">glp::cb_info:</th><td class="field-body"><p class="first">(default: NULL) - transit pointer passed to the
routine <tt class="docutils literal"><span class="pre">glp::mip_cb</span> tree info</tt> (see above)</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::cb_size:</th><td class="field-body"><p class="first">(default: 0) - the number of extra (up to 256)
bytes allocated for each node of the
branch-and-bound tree to store
application-specific data - on creating a
node these bytes are initialized by binary zeros</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::presolve:</th><td class="field-body"><p class="first">(default: glp::off) - LP presolver option:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::on:</th><td class="field-body">enable using the MIP presolver</td>
</tr>
<tr class="field"><th class="field-name">glp::off:</th><td class="field-body">disable using the MIP presolver</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">glp::binarize:</th><td class="field-body"><p class="first">(default: glp::off) - binarization (used only if
the presolver is enabled):</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::on:</th><td class="field-body">replace general integer variables by
binary ones</td>
</tr>
<tr class="field"><th class="field-name">glp::off:</th><td class="field-body">do not use binarization</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::ok:</th><td class="field-body">the MIP problem instance has been successfully solved; this code
does not necessarily mean that the solver has found optimal
solution, it only means that the solution process was successful</td>
</tr>
<tr class="field"><th class="field-name">glp::ebound:</th><td class="field-body">unable to start the search, because some double-bounded
(auxiliary or structural) variables have incorrect bounds
or some integer variables have non-integer (fractional)
bounds</td>
</tr>
<tr class="field"><th class="field-name">glp::eroot:</th><td class="field-body">unable to start the search, because optimal basis for initial
LP relaxation is not provided - this code may appear only
if the presolver is disabled</td>
</tr>
<tr class="field"><th class="field-name">glp::enopfs:</th><td class="field-body">unable to start the search, because LP relaxation of the
MIP problem instance has no primal feasible solution -
this code may appear only if the presolver is enabled</td>
</tr>
<tr class="field"><th class="field-name">glp::enodfs:</th><td class="field-body">unable to start the search, because LP relaxation of the
MIP problem instance has no dual feasible solution; in
other word, this code means that if the LP relaxation has
at least one primal feasible solution, its optimal solution
is unbounded, so if the MIP problem has at least one integer
feasible solution, its (integer) optimal solution is also
unbounded - this code may appear only if the presolver is
enabled</td>
</tr>
<tr class="field"><th class="field-name">glp::efail:</th><td class="field-body">the search was prematurely terminated due to the solver
failure</td>
</tr>
<tr class="field"><th class="field-name">glp::emipgap:</th><td class="field-body">the search was prematurely terminated, because the
relative mip gap tolerance has been reached</td>
</tr>
<tr class="field"><th class="field-name">glp::etmlim:</th><td class="field-body">the search was prematurely terminated, because the time
limit has been exceeded</td>
</tr>
<tr class="field"><th class="field-name">glp::estop:</th><td class="field-body">the search was prematurely terminated by application -
this code may appear only if the advanced solver
interface is used</td>
</tr>
</tbody>
</table>
<p>When the list of options contains some bad option(s) then a list of bad
options is returned instead.</p>
</blockquote>
<p><strong>Remark</strong>:</p>
<blockquote>
Options not mentioned in the option list are set to their default values.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::intopt lp [(glp::presolve, glp::on)];
ipp_basic_tech:  0 row(s) and 0 column(s) removed
ipp_reduce_bnds: 2 pass(es) made, 3 bound(s) reduced
ipp_basic_tech:  0 row(s) and 0 column(s) removed
ipp_reduce_coef: 1 pass(es) made, 0 coefficient(s) reduced
glp_intopt: presolved MIP has 3 rows, 3 columns, 9 non-zeros
glp_intopt: 3 integer columns, none of which are binary
Scaling...
 A: min|aij| =  1,000e+00  max|aij| =  1,000e+01  ratio =  1,000e+01
Problem data seem to be well scaled
Crashing...
Size of triangular part = 3
Solving LP relaxation...
*     2: obj =   0,000000000e+00  infeas =  0,000e+00 (0)
*     5: obj =   7,333333333e+02  infeas =  0,000e+00 (0)
OPTIMAL SOLUTION FOUND
Integer optimization begins...
+     5: mip =     not found yet &lt;=              +inf        (1; 0)
+     6: &gt;&gt;&gt;&gt;&gt;   7,320000000e+02 &lt;=   7,320000000e+02   0.0% (2; 0)
+     6: mip =   7,320000000e+02 &lt;=     tree is empty   0.0% (0; 3)
INTEGER OPTIMAL SOLUTION FOUND
glp::ok
&gt;
</pre>
</div>
<div class="section" id="retrieve-status-of-mip-solution">
<h4><a class="toc-backref" href="#id93">5.1.8.6&nbsp;&nbsp;&nbsp;Retrieve status of mip solution</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::mip_status lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::undef:</th><td class="field-body">MIP solution is undefined</td>
</tr>
<tr class="field"><th class="field-name">glp::opt:</th><td class="field-body">MIP solution is integer optimal</td>
</tr>
<tr class="field"><th class="field-name">glp::feas:</th><td class="field-body">MIP solution is integer feasible, however, its optimality
(or non-optimality) has not been proven, perhaps due
to premature termination of the search</td>
</tr>
<tr class="field"><th class="field-name">glp::nofeas:</th><td class="field-body">problem has no integer feasible solution (proven by the
solver)</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::mip_status lp;
glp::opt
&gt;
</pre>
</div>
<div class="section" id="retrieve-the-objective-function-value-of-mip-solution">
<h4><a class="toc-backref" href="#id94">5.1.8.7&nbsp;&nbsp;&nbsp;Retrieve the objective function value of mip solution</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::mip_obj_val lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
objective function value of mip solution</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::mip_obj_val lp;
732.0
&gt;
</pre>
</div>
<div class="section" id="retrieve-row-value-of-mip-solution">
<h4><a class="toc-backref" href="#id95">5.1.8.8&nbsp;&nbsp;&nbsp;Retrieve row value of mip solution</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::mip_row_val lp rowindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body">row index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
row value (value of auxiliary variable)</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::mip_row_val lp 3;
200.0
&gt;
</pre>
</div>
<div class="section" id="retrieve-column-value-of-mip-solution">
<h4><a class="toc-backref" href="#id96">5.1.8.9&nbsp;&nbsp;&nbsp;Retrieve column value of mip solution</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::mip_col_val lp colindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body">column index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
column value (value of structural variable)</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::mip_col_val lp 2;
67.0
&gt;
</pre>
</div>
</div>
<div class="section" id="additional-routines">
<h3><a class="toc-backref" href="#id97">5.1.9&nbsp;&nbsp;&nbsp;Additional routines</a></h3>
<div class="section" id="check-karush-kuhn-tucker-conditions">
<h4><a class="toc-backref" href="#id98">5.1.9.1&nbsp;&nbsp;&nbsp;Check Karush-Kuhn-Tucker conditions</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
lpx::check_kkt lp scaled
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body"><p class="first">pointer to the LP problem object</p>
</td>
</tr>
<tr class="field"><th class="field-name">scaled:</th><td class="field-body"><p class="first">one of the following:</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">true:</th><td class="field-body">test the scaled problem</td>
</tr>
<tr class="field"><th class="field-name">false:</th><td class="field-body">test the unscaled problem</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>list of four tuples with five mebers (see GLPK reference manual):</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="17%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Condition</th>
<th class="head">Member</th>
<th class="head">Comment</th>
</tr>
</thead>
<tbody valign="top">
<tr><td rowspan="5">(KKT.PE)</td>
<td>pe_ae_max</td>
<td>Largest absolute error</td>
</tr>
<tr><td>pe_ae_row</td>
<td>Number of row with largest absolute error</td>
</tr>
<tr><td>pe_re_max</td>
<td>Largest relative error</td>
</tr>
<tr><td>pe_re_row</td>
<td>Number of row with largest relative error</td>
</tr>
<tr><td>pe_quality</td>
<td>Quality of primal solution</td>
</tr>
<tr><td rowspan="5">(KKT.PB)</td>
<td>pb_ae_max</td>
<td>Largest absolute error</td>
</tr>
<tr><td>pb_ae_ind</td>
<td>Number of variable with largest absolute error</td>
</tr>
<tr><td>pb_re_max</td>
<td>Largest relative error</td>
</tr>
<tr><td>pb_re_ind</td>
<td>Number of variable with largest relative error</td>
</tr>
<tr><td>pb_quality</td>
<td>Quality of primal feasibility</td>
</tr>
<tr><td rowspan="5">(KKT.DE)</td>
<td>de_ae_max</td>
<td>Largest absolute error</td>
</tr>
<tr><td>de_ae_col</td>
<td>Number of column with largest absolute error</td>
</tr>
<tr><td>de_re_max</td>
<td>Largest relative error</td>
</tr>
<tr><td>de_re_col</td>
<td>Number of column with largest relative error</td>
</tr>
<tr><td>de_quality</td>
<td>Quality of dual solution</td>
</tr>
<tr><td rowspan="5">(KKT.DB)</td>
<td>db_ae_max</td>
<td>Largest absolute error</td>
</tr>
<tr><td>db_ae_ind</td>
<td>Number of variable with largest absolute error</td>
</tr>
<tr><td>db_re_max</td>
<td>Largest relative error</td>
</tr>
<tr><td>db_re_ind</td>
<td>Number of variable with largest relative error</td>
</tr>
<tr><td>db_quality</td>
<td>Quality of dual feasibility</td>
</tr>
</tbody>
</table>
<p>where number of variable is (1 &lt;= k &lt;= m) for auxiliary variable
and (m+1 &lt;= k &lt;= m+n) for structural variable</p>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; lpx::check_kkt lp true;
[(1.4210854715202e-14,2,3.54385404369127e-17,3,&quot;H&quot;),(0.0,0,0.0,0,&quot;H&quot;),
(4.44089209850063e-16,1,2.11471052309554e-17,1,&quot;H&quot;),(0.0,0,0.0,0,&quot;H&quot;)]
&gt;
</pre>
</div>
</div>
</div>
<div class="section" id="utility-api-routines">
<h2><a class="toc-backref" href="#id99">5.2&nbsp;&nbsp;&nbsp;Utility API routines</a></h2>
<div class="section" id="problem-data-reading-writing-routines">
<h3><a class="toc-backref" href="#id100">5.2.1&nbsp;&nbsp;&nbsp;Problem data reading/writing routines</a></h3>
<div class="section" id="read-lp-problem-data-from-a-mps-file">
<h4><a class="toc-backref" href="#id101">5.2.1.1&nbsp;&nbsp;&nbsp;Read LP problem data from a MPS file</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::read_mps lp format filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body"><p class="first">pointer to the LP problem object</p>
</td>
</tr>
<tr class="field"><th class="field-name">format:</th><td class="field-body"><p class="first">one of the following</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::mps_deck:</th><td class="field-body">fixed (ancient) MPS file format</td>
</tr>
<tr class="field"><th class="field-name">glp::mps_file:</th><td class="field-body">free (modern) MPS file format</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body"><p class="first last">file name - if the ﬁle name ends with suﬃx <strong>.gz</strong>,
the ﬁle is assumed to be compressed, in which case
the routine glp::read_mps decompresses it “on the ﬂy”</p>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if reading went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::read_mps lp glp::mps_deck &quot;examples/plan.mps&quot;;
Reading problem data from `examples/plan.mps'...
Problem PLAN
Objective R0000000
8 rows, 7 columns, 55 non-zeros
63 records were read
0
&gt;
</pre>
</div>
<div class="section" id="write-lp-problem-data-into-a-mps-file">
<h4><a class="toc-backref" href="#id102">5.2.1.2&nbsp;&nbsp;&nbsp;Write LP problem data into a MPS file</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::write_mps lp format filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body"><p class="first">pointer to the LP problem object</p>
</td>
</tr>
<tr class="field"><th class="field-name">format:</th><td class="field-body"><p class="first">one of the following</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::mps_deck:</th><td class="field-body">fixed (ancient) MPS file format</td>
</tr>
<tr class="field"><th class="field-name">glp::mps_file:</th><td class="field-body">free (modern) MPS file format</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body"><p class="first last">file name - if the ﬁle name ends with suﬃx <strong>.gz</strong>,
the ﬁle is assumed to be compressed, in which case
the routine glp_write_mps performs automatic
compression on writing it</p>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if writing went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::write_mps lp glp::mps_file &quot;examples/plan1.mps&quot;;
Writing problem data to `examples/plan1.mps'...
63 records were written
0
&gt;
</pre>
</div>
<div class="section" id="read-lp-problem-data-from-a-cplex-file">
<h4><a class="toc-backref" href="#id103">5.2.1.3&nbsp;&nbsp;&nbsp;Read LP problem data from a CPLEX file</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::read_lp lp filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body">file name - if the ﬁle name ends with suﬃx <strong>.gz</strong>,
the ﬁle is assumed to be compressed, in which case
the routine glp::read_lp decompresses it “on the ﬂy”</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if writing went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::read_lp lp &quot;examples/plan.lp&quot;;
reading problem data from `examples/plan.lp'...
8 rows, 7 columns, 48 non-zeros
39 lines were read
0
&gt;
</pre>
</div>
<div class="section" id="write-lp-problem-data-into-a-cplex-file">
<h4><a class="toc-backref" href="#id104">5.2.1.4&nbsp;&nbsp;&nbsp;Write LP problem data into a CPLEX file</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::write_lp lp filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body">file name - if the ﬁle name ends with suﬃx <strong>.gz</strong>,
the ﬁle is assumed to be compressed, in which case
the routine glp::write_lp performs automatic
compression on writing it</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if writing went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::write_lp lp &quot;examples/plan1.lp&quot;;
writing problem data to `examples/plan1.lp'...
29 lines were written
0
&gt;
</pre>
</div>
<div class="section" id="read-lp-problem-data-in-glpk-format">
<h4><a class="toc-backref" href="#id105">5.2.1.5&nbsp;&nbsp;&nbsp;Read LP problem data in GLPK format</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::read_prob lp filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body">file name - if the ﬁle name ends with suﬃx <strong>.gz</strong>,
the ﬁle is assumed to be compressed, in which case
the routine glp::read_prob decompresses it “on the ﬂy”</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if writing went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::read_prob lp &quot;examples/plan.glpk&quot;;
reading problem data from `examples/plan.glpk'...
8 rows, 7 columns, 48 non-zeros
86 lines were read
0
&gt;
</pre>
</div>
<div class="section" id="write-lp-problem-data-in-glpk-format">
<h4><a class="toc-backref" href="#id106">5.2.1.6&nbsp;&nbsp;&nbsp;Write LP problem data in GLPK format</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::write_prob lp filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body">file name - if the ﬁle name ends with suﬃx <strong>.gz</strong>,
the ﬁle is assumed to be compressed, in which case
the routine glp::write_prob performs automatic
compression on writing it</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if writing went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::write_prob lp &quot;examples/plan1.glpk&quot;;
writing problem data to `examples/plan1.glpk'...
86 lines were written
0
&gt;
</pre>
</div>
</div>
<div class="section" id="routines-for-mathprog-models">
<h3><a class="toc-backref" href="#id107">5.2.2&nbsp;&nbsp;&nbsp;Routines for MathProg models</a></h3>
<div class="section" id="create-the-mathprog-translator-object">
<h4><a class="toc-backref" href="#id108">5.2.2.1&nbsp;&nbsp;&nbsp;Create the MathProg translator object</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::mpl_alloc_wksp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
none</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
pointer to the MathProg translator object</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; let mpt = glp::mpl_alloc_wksp;
&gt; mpt;
#&lt;pointer 0xa0d0180&gt;
&gt;
</pre>
</div>
<div class="section" id="read-and-translate-model-section">
<h4><a class="toc-backref" href="#id109">5.2.2.2&nbsp;&nbsp;&nbsp;Read and translate model section</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::mpl_read_model tranobject filename skip
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tranobject:</th><td class="field-body">pointer to the MathProg translator object</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body">file name</td>
</tr>
<tr class="field"><th class="field-name">skip:</th><td class="field-body">if <strong>0</strong> then the data section from the model file is read;
if non-zero, the data section in the data model is skipped</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if reading went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; mpl_read_model mpt &quot;examples/sudoku.mod&quot; 1;
Reading model section from examples/sudoku.mod...
examples/sudoku.mod:69: warning: data section ignored
69 lines were read
0
&gt;
</pre>
</div>
<div class="section" id="read-and-translate-data-section">
<h4><a class="toc-backref" href="#id110">5.2.2.3&nbsp;&nbsp;&nbsp;Read and translate data section</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::mpl_read_data tranobject filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tranobject:</th><td class="field-body">pointer to the MathProg translator object</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body">file name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if reading went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::mpl_read_data mpt &quot;examples/sudoku.dat&quot;;
Reading data section from examples/sudoku.dat...
16 lines were read
0
&gt;
</pre>
</div>
<div class="section" id="generate-the-model">
<h4><a class="toc-backref" href="#id111">5.2.2.4&nbsp;&nbsp;&nbsp;Generate the model</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::mpl_generate tranobject filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tranobject:</th><td class="field-body">pointer to the MathProg translator object</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body">file name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if generating went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::mpl_generate mpt &quot;examples/sudoku.lst&quot;;
Generating fa...
Generating fb...
Generating fc...
Generating fd...
Generating fe...
Model has been successfully generated
0
&gt;
</pre>
</div>
<div class="section" id="build-problem-instance-from-the-model">
<h4><a class="toc-backref" href="#id112">5.2.2.5&nbsp;&nbsp;&nbsp;Build problem instance from the model</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::mpl_build_prob tranobject lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tranobject:</th><td class="field-body">pointer to the MathProg translator object</td>
</tr>
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::mpl_build_prob mpt lp;
()
&gt;
</pre>
</div>
<div class="section" id="postsolve-the-model">
<h4><a class="toc-backref" href="#id113">5.2.2.6&nbsp;&nbsp;&nbsp;Postsolve the model</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::mpl_postsolve tran lp solution
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tranobject:</th><td class="field-body"><p class="first">pointer to the MathProg translator object</p>
</td>
</tr>
<tr class="field"><th class="field-name">lp:</th><td class="field-body"><p class="first">pointer to the LP problem object</p>
</td>
</tr>
<tr class="field"><th class="field-name">solution:</th><td class="field-body"><p class="first">one of the following:</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::sol:</th><td class="field-body">use the basic solution</td>
</tr>
<tr class="field"><th class="field-name">glp::ipt:</th><td class="field-body">use the interior-point solution</td>
</tr>
<tr class="field"><th class="field-name">glp::mip:</th><td class="field-body">use mixed integer solution</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if postsolve went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::mpl_postsolve mpt lp glp::sol;
Model has been successfully processed
0
&gt;
</pre>
</div>
<div class="section" id="delete-the-mathprog-translator-object">
<h4><a class="toc-backref" href="#id114">5.2.2.7&nbsp;&nbsp;&nbsp;Delete the MathProg translator object</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::mpl_free_wksp tranobject
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tranobject:</th><td class="field-body">pointer to the MathProg translator object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::mpl_free_wksp mpt;
()
&gt;
</pre>
</div>
</div>
<div class="section" id="problem-solution-reading-writing-routines">
<h3><a class="toc-backref" href="#id115">5.2.3&nbsp;&nbsp;&nbsp;Problem solution reading/writing routines</a></h3>
<div class="section" id="write-basic-solution-in-printable-format">
<h4><a class="toc-backref" href="#id116">5.2.3.1&nbsp;&nbsp;&nbsp;Write basic solution in printable format</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::print_sol lp filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body">file name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if writing went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::print_sol lp &quot;examples/test.txt&quot;;
Writing basic solution to `examples/test.txt'...
0
&gt;
</pre>
</div>
<div class="section" id="read-basic-solution-from-a-text-file">
<h4><a class="toc-backref" href="#id117">5.2.3.2&nbsp;&nbsp;&nbsp;Read basic solution from a text file</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::read_sol lp filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body">file name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if reading went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::read_sol lp &quot;examples/test.txt&quot;;
Reading basic solution from `examples/test.txt'...
1235 lines were read
0
&gt;
</pre>
</div>
<div class="section" id="write-basic-solution-into-a-text-file">
<h4><a class="toc-backref" href="#id118">5.2.3.3&nbsp;&nbsp;&nbsp;Write basic solution into a text file</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::write_sol lp filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body">file name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if writing went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::write_sol lp &quot;examples/test.txt&quot;;
Writing basic solution to `examples/test.txt'...
1235 lines were written
0
&gt;
</pre>
</div>
<div class="section" id="print-sensitivity-analysis-report">
<h4><a class="toc-backref" href="#id119">5.2.3.4&nbsp;&nbsp;&nbsp;Print sensitivity analysis report</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::print_ranges lp indices filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">indices:</th><td class="field-body">list indices k of of rows and columns to be included in the report.
If 1 ≤ k ≤ m, the basic variable is k-th auxiliary variable,
and if m + 1 ≤ k ≤ m + n, the non-basic variable is (k − m)-th
structural variable, where m is the number of rows and n is the
number of columns in the speciﬁed problem object. An empty lists
means printing report for all rows and columns.</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body">file name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">0:</th><td class="field-body">if the operation was successful</td>
</tr>
<tr class="field"><th class="field-name">non-zero:</th><td class="field-body">if the operation failed</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::print_ranges lp [] &quot;sensitivity.rpt&quot;;
Write sensitivity analysis report to `sensitivity.rpt'...
0
&gt;
</pre>
</div>
<div class="section" id="write-interior-point-solution-in-printable-format">
<h4><a class="toc-backref" href="#id120">5.2.3.5&nbsp;&nbsp;&nbsp;Write interior-point solution in printable format</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::print_ipt lp filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body">file name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if writing went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::print_ipt lp &quot;examples/test.txt&quot;;
Writing interior-point solution to `examples/test.txt'...
0
&gt;
</pre>
</div>
<div class="section" id="read-interior-point-solution-from-a-text-file">
<h4><a class="toc-backref" href="#id121">5.2.3.6&nbsp;&nbsp;&nbsp;Read interior-point solution from a text file</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::read_ipt lp filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body">file name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if reading went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::read_ipt lp &quot;examples/test.txt&quot;;
Reading interior-point solution from `examples/test.txt'...
1235 lines were read
0
&gt;
</pre>
</div>
<div class="section" id="write-interior-point-solution-into-a-text-file">
<h4><a class="toc-backref" href="#id122">5.2.3.7&nbsp;&nbsp;&nbsp;Write interior-point solution into a text file</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::write_ipt lp filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body">file name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if writing went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::write_ipt lp &quot;examples/test.txt&quot;;
Writing interior-point solution to `examples/test.txt'...
1235 lines were written
0
&gt;
</pre>
</div>
<div class="section" id="write-mip-solution-in-printable-format">
<h4><a class="toc-backref" href="#id123">5.2.3.8&nbsp;&nbsp;&nbsp;Write MIP solution in printable format</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::print_mip lp filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body">file name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if writing went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::print_mip lp &quot;examples/test.txt&quot;;
Writing MIP solution to `examples/test.txt'...
0
&gt;
</pre>
</div>
<div class="section" id="read-mip-solution-from-a-text-file">
<h4><a class="toc-backref" href="#id124">5.2.3.9&nbsp;&nbsp;&nbsp;Read MIP solution from a text file</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::read_mip lp filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body">file name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if reading went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::read_mip lp &quot;examples/test.txt&quot;;
Reading MIP solution from `examples/test.txt'...
1235 lines were read
0
&gt;
</pre>
</div>
<div class="section" id="write-mip-solution-into-a-text-file">
<h4><a class="toc-backref" href="#id125">5.2.3.10&nbsp;&nbsp;&nbsp;Write MIP solution into a text file</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::write_mip lp filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body">file name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if writing went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::write_mip lp &quot;examples/test.txt&quot;;
Writing MIP solution to `examples/test.txt'...
1235 lines were written
0
&gt;
</pre>
</div>
</div>
</div>
<div class="section" id="advanced-api-routines">
<h2><a class="toc-backref" href="#id126">5.3&nbsp;&nbsp;&nbsp;Advanced API routines</a></h2>
<div class="section" id="lp-basis-routines">
<h3><a class="toc-backref" href="#id127">5.3.1&nbsp;&nbsp;&nbsp;LP basis routines</a></h3>
<div class="section" id="check-whether-basis-factorization-exists">
<h4><a class="toc-backref" href="#id128">5.3.1.1&nbsp;&nbsp;&nbsp;Check whether basis factorization exists</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::bf_exists lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">non-zero:</th><td class="field-body">the basis factorization exists and can be used for calculations</td>
</tr>
<tr class="field"><th class="field-name">0:</th><td class="field-body">the basis factorization does not exist</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::bf:exists lp;
1
&gt;
</pre>
</div>
<div class="section" id="compute-the-basis-factorization">
<h4><a class="toc-backref" href="#id129">5.3.1.2&nbsp;&nbsp;&nbsp;Compute the basis factorization</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::factorize lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::ok:</th><td class="field-body">the basis factorization has been successfully computed</td>
</tr>
<tr class="field"><th class="field-name">glp::ebadb:</th><td class="field-body">the basis matrix is invalid, because the number of basic
(auxiliary and structural) variables is not the same as the
number of rows in the problem object</td>
</tr>
<tr class="field"><th class="field-name">glp::esing:</th><td class="field-body">the basis matrix is singular within the working precision</td>
</tr>
<tr class="field"><th class="field-name">glp::exond:</th><td class="field-body">the basis matrix is ill-conditioned, i.e. its condition
number is too large</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::factorize lp;
glp::ok
&gt;
</pre>
</div>
<div class="section" id="check-whether-basis-factorization-has-been-updated">
<h4><a class="toc-backref" href="#id130">5.3.1.3&nbsp;&nbsp;&nbsp;Check whether basis factorization has been updated</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::bf_updated lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">0:</th><td class="field-body">if the basis factorization has been just computed from “scratch”</td>
</tr>
<tr class="field"><th class="field-name">non-zero:</th><td class="field-body">if the factorization has been updated at least once</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::bf_updated lp;
0
&gt;
</pre>
</div>
<div class="section" id="get-basis-factorization-parameters">
<h4><a class="toc-backref" href="#id131">5.3.1.4&nbsp;&nbsp;&nbsp;Get basis factorization parameters</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_bfcp lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>complete list of options in a form of tuples (option_name, value):</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::type:</th><td class="field-body"><p class="first">basis factorization type:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::bf_ft:</th><td class="field-body">LU + Forrest–Tomlin update</td>
</tr>
<tr class="field"><th class="field-name">glp::bf_bg:</th><td class="field-body">LU + Schur complement + Bartels–Golub update</td>
</tr>
<tr class="field"><th class="field-name">glp::bf_gr:</th><td class="field-body">LU + Schur complement + Givens rotation update</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">glp::lu_size:</th><td class="field-body"><p class="first">the initial size of the Sparse Vector Area, in non-zeros,
used on computing LU-factorization of the basis matrix for
the ﬁrst time - if this parameter is set to 0, the initial
SVA size is determined automatically</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::piv_tol:</th><td class="field-body"><p class="first">threshold pivoting (Markowitz) tolerance, 0 &lt; piv_tol &lt; 1,
used on computing LU-factorization of the basis matrix</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::piv_lim:</th><td class="field-body"><p class="first">this parameter is used on computing
LU-factorization of the basis matrix and speciﬁes how many
pivot candidates needs to be considered on choosing a pivot
element, piv_lim ≥ 1</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::suhl:</th><td class="field-body"><p class="first">this parameter is used on computing LU-factorization of
the basis matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::on:</th><td class="field-body">enables applying the heuristic proposed by Uwe Suhl</td>
</tr>
<tr class="field"><th class="field-name">glp::off:</th><td class="field-body">disables this heuristic</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">glp::eps_tol:</th><td class="field-body"><p class="first">epsilon tolerance, eps_tol ≥ 0, used on computing
LU-factorization of the basis matrix</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::max_gro:</th><td class="field-body"><p class="first">maximal growth of elements of factor U, max_gro ≥ 1,
allowable on computing LU-factorization of the basis matrix</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::nfs_max:</th><td class="field-body"><p class="first">maximal number of additional row-like factors (entries of
the eta ﬁle), nfs_max ≥ 1, which can be added to
LU-factorization of the basis matrix on updating it with
the Forrest–Tomlin technique</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::upd_tol:</th><td class="field-body"><p class="first">update tolerance, 0 &lt; upd_tol &lt; 1, used on updating
LU-factorization of the basis matrix with the Forrest–Tomlin
technique</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::nrs_max:</th><td class="field-body"><p class="first">maximal number of additional rows and columns, nrs_max ≥ 1,
which can be added to LU-factorization of the basis matrix
on updating it with the Schur complement technique</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::rs_size:</th><td class="field-body"><p class="first last">the initial size of the Sparse Vector Area, in non-zeros,
used to store non-zero elements of additional rows and
columns introduced on updating LU-factorization of the basis
matrix with the Schur complement technique - if this
parameter is set to 0, the initial SVA size is determined
automatically</p>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_bfcp lp;
[(glp::type,glp::bf_ft),(glp::lu_size,0),(glp::piv_tol,0.1),(glp::piv_lim,4),
(glp::suhl,glp::on),(glp::eps_tol,1e-15),(glp::max_gro,10000000000.0),
(glp::nfs_max,50),(glp::upd_tol,1e-06),(glp::nrs_max,50),(glp::rs_size,0)]
&gt;
</pre>
</div>
<div class="section" id="change-basis-factorization-parameters">
<h4><a class="toc-backref" href="#id132">5.3.1.5&nbsp;&nbsp;&nbsp;Change basis factorization parameters</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::set_bfcp lp options
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body"><p class="first">pointer to the LP problem object</p>
</td>
</tr>
<tr class="field"><th class="field-name">options:</th><td class="field-body"><p class="first">list of options in a form of tuples (option_name, value):</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::type:</th><td class="field-body"><p class="first">(default: glp::bf_ft) - basis factorization type:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::bf_ft:</th><td class="field-body">LU + Forrest–Tomlin update</td>
</tr>
<tr class="field"><th class="field-name">glp::bf_bg:</th><td class="field-body">LU + Schur complement + Bartels–Golub update</td>
</tr>
<tr class="field"><th class="field-name">glp::bf_gr:</th><td class="field-body">LU + Schur complement + Givens rotation update</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">glp::lu_size:</th><td class="field-body"><p class="first">(default: 0) - the initial size of the Sparse Vector Area,
in non-zeros, used on computing LU-factorization of the
basis matrix for the ﬁrst time - if this parameter is set
to 0, the initial SVA size is determined automatically</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::piv_tol:</th><td class="field-body"><p class="first">(default: 0.10) - threshold pivoting (Markowitz) tolerance,
0 &lt; piv_tol &lt; 1, used on computing LU-factorization of the
basis matrix.</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::piv_lim:</th><td class="field-body"><p class="first">(default: 4) - this parameter is used on computing
LU-factorization of the basis matrix and speciﬁes how many
pivot candidates needs to be considered on choosing a pivot
element, piv_lim ≥ 1</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::suhl:</th><td class="field-body"><p class="first">(default: glp::on) - this parameter is used on computing
LU-factorization of the basis matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::on:</th><td class="field-body">enables applying the heuristic proposed by Uwe Suhl</td>
</tr>
<tr class="field"><th class="field-name">glp::off:</th><td class="field-body">disables this heuristic</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">glp::eps_tol:</th><td class="field-body"><p class="first">(default: 1e-15) - epsilon tolerance, eps_tol ≥ 0, used on
computing LU -factorization of the basis matrix.</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::max_gro:</th><td class="field-body"><p class="first">(default: 1e+10) - maximal growth of elements of factor U,
max_gro ≥ 1, allowable on computing LU-factorization of the
basis matrix.</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::nfs_max:</th><td class="field-body"><p class="first">(default: 50) - maximal number of additional row-like
factors (entries of the eta ﬁle), nfs_max ≥ 1, which can
be added to LU-factorization of the basis matrix
on updating it with the Forrest–Tomlin technique.</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::upd_tol:</th><td class="field-body"><p class="first">(default: 1e-6) - update tolerance, 0 &lt; upd_tol &lt; 1,
used on updating LU -factorization of the basis matrix
with the Forrest–Tomlin technique.</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::nrs_max:</th><td class="field-body"><p class="first">(default: 50) - maximal number of additional rows and
columns, nrs_max ≥ 1, which can be added to LU-factorization
of the basis matrix on updating it with the Schur complement
technique.</p>
</td>
</tr>
<tr class="field"><th class="field-name">glp::rs_size:</th><td class="field-body"><p class="first last">(default: 0) - the initial size of the Sparse Vector Area,
in non-zeros, used to store non-zero elements of additional
rows and columns introduced on updating LU-factorization
of the basis matrix with the Schur complement technique -
if this parameter is set to 0, the initial SVA size is
determined automatically</p>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Remarks</strong>:</p>
<blockquote>
<p>Options not mentioned in the option list are left unchanged.</p>
<p>All options will be reset to their default values when an empty option list
is supplied.</p>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt> if all options are OK, otherwise returns a list of bad options</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp_set_bfcp lp [(glp::type, glp::bf_ft), (glp::piv_tol, 0.15)];
()
&gt;
</pre>
</div>
<div class="section" id="retrieve-the-basis-header-information">
<h4><a class="toc-backref" href="#id133">5.3.1.6&nbsp;&nbsp;&nbsp;Retrieve the basis header information</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_bhead lp k
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">k:</th><td class="field-body">variable index in the basis matrix</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
If basic variable (xB )k , 1 ≤ k ≤ m, is i-th auxiliary variable (1 ≤ i ≤ m), the
routine returns i. Otherwise, if (xB )k is j-th structural variable (1 ≤ j ≤ n),
the routine returns m+j. Here m is the number of rows and n is the number
of columns in the problem object.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_bhead lp 3;
5
&gt;
</pre>
</div>
<div class="section" id="retrieve-row-index-in-the-basis-header">
<h4><a class="toc-backref" href="#id134">5.3.1.7&nbsp;&nbsp;&nbsp;Retrieve row index in the basis header</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_row_bind lp rowindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body">row index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
This routine returns the index k of basic variable (xB )k, 1 ≤ k ≤ m,
which is i-th auxiliary variable (that is, the auxiliary variable
corresponding to i-th row), 1 ≤ i ≤ m, in the current basis associated with
the speciﬁed problem object, where m is the number of rows. However, if
i-th auxiliary variable is non-basic, the routine returns zero.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_row_bind lp 3;
1
&gt;
</pre>
</div>
<div class="section" id="retrieve-column-index-in-the-basis-header">
<h4><a class="toc-backref" href="#id135">5.3.1.8&nbsp;&nbsp;&nbsp;Retrieve column index in the basis header</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::get_col_bind lp colindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colindex:</th><td class="field-body">column index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
This routine returns the index k of basic variable (xB )k, 1 ≤ k ≤ m,
which is j-th structural variable (that is, the structural variable
corresponding to j-th column), 1 ≤ j ≤ n, in the current basis associated
with the speciﬁed problem object, where m is the number of rows, n is the
number of columns. However, if j-th structural variable is non-basic, the
routine returns zero.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::get_col_bind lp 2;
3
&gt;
</pre>
</div>
<div class="section" id="perform-forward-transformation">
<h4><a class="toc-backref" href="#id136">5.3.1.9&nbsp;&nbsp;&nbsp;Perform forward transformation</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ftran lp vector
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">vector:</th><td class="field-body">vector to be transformed - a dense vector in a form of a list of
double numbers has to be supplied and the number of its members
must exactly correspond to the number of LP problem constraints</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
the transformed vector in the same format</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::ftran lp [1.5, 3.2, 4.8];
[1.8,0.466666666666667,-1.96666666666667]
&gt;
</pre>
</div>
<div class="section" id="perform-backward-transformation">
<h4><a class="toc-backref" href="#id137">5.3.1.10&nbsp;&nbsp;&nbsp;Perform backward transformation</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::btran lp vector
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">vector:</th><td class="field-body">vector to be transformed - a dense vector in a form of a list of
double numbers has to be supplied and the number of its members
must exactly correspond to the number of LP problem constraints</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
the transformed vector in the same format</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::btran lp [1.5, 3.2, 4.8];
[-8.86666666666667,0.266666666666667,1.5]
&gt;
</pre>
</div>
<div class="section" id="warm-up-lp-basis">
<h4><a class="toc-backref" href="#id138">5.3.1.11&nbsp;&nbsp;&nbsp;Warm up LP basis</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::warm_up lp
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::ok:</th><td class="field-body">the LP basis has been successfully “warmed up”</td>
</tr>
<tr class="field"><th class="field-name">glp::ebadb:</th><td class="field-body">the LP basis is invalid, because the number of basic
variables is not the same as the number of rows</td>
</tr>
<tr class="field"><th class="field-name">glp::esing:</th><td class="field-body">the basis matrix is singular within the working precision</td>
</tr>
<tr class="field"><th class="field-name">glp::econd:</th><td class="field-body">the basis matrix is ill-conditioned, i.e. its condition
number is too large</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::warm_up lp;
glp::e_ok
&gt;
</pre>
</div>
</div>
<div class="section" id="simplex-tableau-routines">
<h3><a class="toc-backref" href="#id139">5.3.2&nbsp;&nbsp;&nbsp;Simplex tableau routines</a></h3>
<div class="section" id="compute-row-of-the-tableau">
<h4><a class="toc-backref" href="#id140">5.3.2.1&nbsp;&nbsp;&nbsp;Compute row of the tableau</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::eval_tab_row lp k
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">k:</th><td class="field-body">variable index such that it corresponds to some basic variable:
if 1 ≤ k ≤ m, the basic variable is k-th auxiliary variable,
and if m + 1 ≤ k ≤ m + n, the basic variable is (k − m)-th structural
variable, where m is the number of rows and n is the number of columns
in the speciﬁed problem object (the basis factorization must exist)</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
simplex tableau row in a sparse form as a list of tuples (index, value),
where index has the same meaning as k in parameters</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::eval_tab_row lp 3;
[(1,2.0),(6,4.0)]
&gt;
</pre>
</div>
<div class="section" id="compute-column-of-the-tableau">
<h4><a class="toc-backref" href="#id141">5.3.2.2&nbsp;&nbsp;&nbsp;Compute column of the tableau</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::eval_tab_col lp k
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">k:</th><td class="field-body">variable index such that it corresponds to some non-basic variable:
if 1 ≤ k ≤ m, the non-basic variable is k-th auxiliary variable,
and if m + 1 ≤ k ≤ m + n, the non-basic variable is (k − m)-th
structural variable, where m is the number of rows and n is the
number of columns in the speciﬁed problem object (the basis
factorization must exist)</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
simplex tableau column in a sparse form as a list of tuples (index, value),
where index has the same meaning as k in parameters</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::eval_tab_col lp 1;
[(3,2.0),(4,-0.666666666666667),(5,1.66666666666667)]
&gt;
</pre>
</div>
<div class="section" id="transform-explicitly-specified-row">
<h4><a class="toc-backref" href="#id142">5.3.2.3&nbsp;&nbsp;&nbsp;Transform explicitly specified row</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::transform_row lp rowvector
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rowvector:</th><td class="field-body">row vector to be transformed in a sparse form as a list of tuples
(k, value): if 1 ≤ k ≤ m, the non-basic variable is k-th
auxiliary variable, and if m + 1 ≤ k ≤ m + n, the non-basic
variable is (k − m)-th structural variable, where m is the number
of rows and n is the number of columns in the speciﬁed problem
object (the basis factorization must exist)</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
the transformed row in a sparse form as a list of tuples (index, value),
where index has the same meaning as k in parameters</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::transform_row lp [(1, 3.0), (2, 3.5)];
[(1,3.83333333333333),(2,-0.0833333333333333),(6,-3.41666666666667)]
&gt;
</pre>
</div>
<div class="section" id="transform-explicitly-specified-column">
<h4><a class="toc-backref" href="#id143">5.3.2.4&nbsp;&nbsp;&nbsp;Transform explicitly specified column</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::transform_col lp colvector
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colvector:</th><td class="field-body">column vector to be transformed in a sparse form as a list of
tuples (k, value): if 1 ≤ k ≤ m, the non-basic variable is k-th
auxiliary variable, and if m + 1 ≤ k ≤ m + n, the non-basic
variable is (k − m)-th structural variable, where m is the number
of rows and n is the number of columns in the speciﬁed problem
object (the basis factorization must exist)</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
the transformed column in a sparse form as a list of tuples (index, value),
where index has the same meaning as k in parameters</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::transform_col lp [(2, 1.0), (3, 2.3)];
[(3,2.3),(4,-0.166666666666667),(5,0.166666666666667)]
&gt;
</pre>
</div>
<div class="section" id="perform-primal-ratio-test">
<h4><a class="toc-backref" href="#id144">5.3.2.5&nbsp;&nbsp;&nbsp;Perform primal ratio test</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::prim_rtest lp colvector dir eps
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">colvector:</th><td class="field-body">simplex tableau column in a sparse form as a list of
tuples (k, value): if 1 ≤ k ≤ m, the basic variable is k-th
auxiliary variable, and if m + 1 ≤ k ≤ m + n, the basic variable
is (k − m)-th structural variable, where m is the number
of rows and n is the number of columns in the speciﬁed problem
object (the basis factorization must exist and the primal
solution must be feasible)</td>
</tr>
<tr class="field"><th class="field-name">dir:</th><td class="field-body">speciﬁes in which direction the variable y changes on entering the
basis: +1 means increasing, −1 means decreasing</td>
</tr>
<tr class="field"><th class="field-name">eps:</th><td class="field-body">relative tolerance (small positive number) used to skip small
values in the column</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
The routine returns the index, piv, in the colvector corresponding to the
pivot element chosen, 1 ≤ piv ≤ len. If the adjacent basic solution is primal
unbounded, and therefore the choice cannot be made, the routine returns zero.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::prim_rtest lp [(3, 2.5), (5, 7.0)] 1 1.0e-5;
3
&gt;
</pre>
</div>
<div class="section" id="perform-dual-ratio-test">
<h4><a class="toc-backref" href="#id145">5.3.2.6&nbsp;&nbsp;&nbsp;Perform dual ratio test</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::dual_rtest lp rowvector dir eps
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">rowvector:</th><td class="field-body">simplex tableau row in a sparse form as a list of
tuples (k, value): if 1 ≤ k ≤ m, the non-basic variable is k-th
auxiliary variable, and if m + 1 ≤ k ≤ m + n, the non-basic
variable is (k − m)-th structural variable, where m is the number
of rows and n is the number of columns in the speciﬁed problem
object (the basis factorization must exist and the dual
solution must be feasible)</td>
</tr>
<tr class="field"><th class="field-name">dir:</th><td class="field-body">speciﬁes in which direction the variable y changes on leaving
the basis: +1 means increasing, −1 means decreasing</td>
</tr>
<tr class="field"><th class="field-name">eps:</th><td class="field-body">relative tolerance (small positive number) used to skip small
values in the row</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
The routine returns the index, piv, in the rowvector corresponding to the
pivot element chosen, 1 ≤ piv ≤ len. If the adjacent basic solution is dual
unbounded, and therefore the choice cannot be made, the routine returns zero.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::dual_rtest lp [(1, 1.5), (6, 4.0)] 1 1.0e-5;
6
&gt;
</pre>
</div>
<div class="section" id="analyze-active-bound-of-non-basic-variable">
<h4><a class="toc-backref" href="#id146">5.3.2.7&nbsp;&nbsp;&nbsp;Analyze active bound of non-basic variable</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::analyze_bound lp k
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">k:</th><td class="field-body">if 1 ≤ k ≤ m, the non-basic variable is k-th auxiliary variable,
and if m + 1 ≤ k ≤ m + n, the non-basic variable is (k − m)-th
structural variable, where m is the number of rows and n is the
number of columns in the speciﬁed problem object (the basis
factorization must exist and the solution must be optimal)</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>The routine returns a tuple (limit1, var1, limit2 var2) where:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">value1:</th><td class="field-body">the minimal value of the active bound, at which the basis still
remains primal feasible and thus optimal. -DBL_MAX means that the
active bound has no lower limit.</td>
</tr>
<tr class="field"><th class="field-name">var1:</th><td class="field-body">the ordinal number of an auxiliary (1 to m) or structural
(m + 1 to m + n) basic variable, which reaches its bound ﬁrst
and thereby limits further decreasing the active bound being
analyzed. If value1 = -DBL_MAX, var1 is set to 0.</td>
</tr>
<tr class="field"><th class="field-name">value2:</th><td class="field-body">the maximal value of the active bound, at which the basis still
remains primal feasible and thus optimal. +DBL_MAX means that the
active bound has no upper limit.</td>
</tr>
<tr class="field"><th class="field-name">var2:</th><td class="field-body">the ordinal number of an auxiliary (1 to m) or structural
(m + 1 to m + n) basic variable, which reaches its bound ﬁrst
and thereby limits further increasing the active bound being
analyzed. If value2 = +DBL_MAX, var2 is set to 0.</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; analyze_bound lp 2;
1995.06864446899,12,2014.03478832467,4
&gt;
</pre>
</div>
<div class="section" id="analyze-objective-coefficient-at-basic-variable">
<h4><a class="toc-backref" href="#id147">5.3.2.8&nbsp;&nbsp;&nbsp;Analyze objective coefficient at basic variable</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::analyze_coef lp k
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body">pointer to the LP problem object</td>
</tr>
<tr class="field"><th class="field-name">k:</th><td class="field-body">if 1 ≤ k ≤ m, the basic variable is k-th auxiliary variable,
and if m + 1 ≤ k ≤ m + n, the non-basic variable is (k − m)-th
structural variable, where m is the number of rows and n is the
number of columns in the speciﬁed problem object (the basis
factorization must exist and the solution must be optimal)</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>The routine returns a tuple (coef1, var1, value1, coef2 var2, value2) where:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">coef1:</th><td class="field-body">the minimal value of the objective coeﬃcient, at which the
basis still remains dual feasible and thus optimal.
-DBL_MAX means that the objective coeﬃcient has no lower limit.</td>
</tr>
<tr class="field"><th class="field-name">var1:</th><td class="field-body">is the ordinal number of an auxiliary (1 to m) or structural
(m + 1 to m + n) non-basic variable, whose reduced cost reaches
its zero bound ﬁrst and thereby limits further decreasing the
objective coeﬃcient being analyzed. If coef1 = -DBL_MAX,
var1 is set to 0.</td>
</tr>
<tr class="field"><th class="field-name">value1:</th><td class="field-body">value of the basic variable being analyzed in an adjacent basis,
which is deﬁned as follows. Let the objective coeﬃcient reaches
its minimal value (coef1) and continues decreasing. Then the
reduced cost of the limiting non-basic variable (var1) becomes dual
infeasible and the current basis becomes non-optimal that forces
the limiting non-basic variable to enter the basis replacing there
some basic variable that leaves the basis to keep primal
feasibility. Should note that on determining the adjacent basis
current bounds of the basic variable being analyzed are ignored
as if it were free (unbounded) variable, so it cannot leave the
basis. It may happen that no dual feasible adjacent basis exists,
in which case value1 is set to -DBL_MAX or +DBL_MAX.</td>
</tr>
<tr class="field"><th class="field-name">coef2:</th><td class="field-body">the maximal value of the objective coeﬃcient, at which the
basis still remains dual feasible and thus optimal. +DBL_MAX
means that the objective coeﬃcient has no upper limit.</td>
</tr>
<tr class="field"><th class="field-name">var2:</th><td class="field-body">the ordinal number of an auxiliary (1 to m) or structural
(m + 1 to m + n) non-basic variable, whose reduced cost reaches
its zero bound ﬁrst and thereby limits further increasing the
objective coeﬃcient being analyzed. If coef2 = +DBL_MAX, var2
is set to 0.</td>
</tr>
<tr class="field"><th class="field-name">value2:</th><td class="field-body">value of the basic variable being analyzed in an adjacent basis,
which is deﬁned exactly in the same way as value1 above with
exception that now the objective coeﬃcient is increasing.</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; analyze_coef lp 1;
-1.0,3,306.771624713959,1.79769313486232e+308,0,296.216606498195
&gt;
</pre>
</div>
</div>
</div>
<div class="section" id="branch-and-cut-api-routines">
<h2><a class="toc-backref" href="#id148">5.4&nbsp;&nbsp;&nbsp;Branch-and-cut API routines</a></h2>
<blockquote>
All branch-and-cut API routines are supposed to be called from the callback
routine. They cannot be called directly.</blockquote>
<div class="section" id="basic-routines">
<h3><a class="toc-backref" href="#id149">5.4.1&nbsp;&nbsp;&nbsp;Basic routines</a></h3>
<div class="section" id="determine-reason-for-calling-the-callback-routine">
<h4><a class="toc-backref" href="#id150">5.4.1.1&nbsp;&nbsp;&nbsp;Determine reason for calling the callback routine</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_reason tree
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::irowgen:</th><td class="field-body">request for row generation</td>
</tr>
<tr class="field"><th class="field-name">glp::ibingo:</th><td class="field-body">better integer solution found</td>
</tr>
<tr class="field"><th class="field-name">glp::iheur:</th><td class="field-body">request for heuristic solution</td>
</tr>
<tr class="field"><th class="field-name">glp::icutgen:</th><td class="field-body">request for cut generation</td>
</tr>
<tr class="field"><th class="field-name">glp::ibranch:</th><td class="field-body">request for branching</td>
</tr>
<tr class="field"><th class="field-name">glp::iselect:</th><td class="field-body">request for subproblem selection</td>
</tr>
<tr class="field"><th class="field-name">glp::iprepro:</th><td class="field-body">request for preprocessing</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
glp::ios:reason tree;
</pre>
</div>
<div class="section" id="access-the-problem-object">
<h4><a class="toc-backref" href="#id151">5.4.1.2&nbsp;&nbsp;&nbsp;Access the problem object</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_get_prob tree
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
The routine returns a pointer to the problem object used by the MIP solver.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
glp::ios_get_prob tree;
</pre>
</div>
<div class="section" id="determine-additional-row-attributes">
<h4><a class="toc-backref" href="#id152">5.4.1.3&nbsp;&nbsp;&nbsp;Determine additional row attributes</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_row_attr tree rowindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body">row index</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>The routine returns a tuple consisting of three values
(level, origin, klass):</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">level:</th><td class="field-body"><p class="first">subproblem level at which the row was created</p>
</td>
</tr>
<tr class="field"><th class="field-name">origin:</th><td class="field-body"><p class="first">the row origin ﬂag - one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::rf_reg:</th><td class="field-body">regular constraint</td>
</tr>
<tr class="field"><th class="field-name">glp::rf_lazy:</th><td class="field-body">“lazy” constraint</td>
</tr>
<tr class="field"><th class="field-name">glp::rf_cut:</th><td class="field-body">cutting plane constraint</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">klass:</th><td class="field-body"><p class="first">the row class descriptor, which is a number passed to the routine
glp_ios_add_row as its third parameter - if the row is a cutting
plane constraint generated by the solver, its class may be the
following:</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::rf_gmi:</th><td class="field-body">Gomory’s mixed integer cut</td>
</tr>
<tr class="field"><th class="field-name">glp::rf_mir:</th><td class="field-body">mixed integer rounding cut</td>
</tr>
<tr class="field"><th class="field-name">glp::rf_cov:</th><td class="field-body">mixed cover cut</td>
</tr>
<tr class="field"><th class="field-name">glp::rf_clq:</th><td class="field-body">clique cut</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
glp::ios_row_attr tree 3;
</pre>
</div>
<div class="section" id="compute-relative-mip-gap">
<h4><a class="toc-backref" href="#id153">5.4.1.4&nbsp;&nbsp;&nbsp;Compute relative MIP gap</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_mip_gap tree
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
<div class="section" id="access-application-specific-data">
<h4><a class="toc-backref" href="#id154">5.4.1.5&nbsp;&nbsp;&nbsp;Access application-specific data</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_node_data tree node
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
<div class="section" id="select-subproblem-to-continue-the-search">
<h4><a class="toc-backref" href="#id155">5.4.1.6&nbsp;&nbsp;&nbsp;Select subproblem to continue the search</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_select_node tree node
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
<div class="section" id="provide-solution-found-by-heuristic">
<h4><a class="toc-backref" href="#id156">5.4.1.7&nbsp;&nbsp;&nbsp;Provide solution found by heuristic</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_heur_sol tree colvector
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
<div class="section" id="check-whether-can-branch-upon-specified-variable">
<h4><a class="toc-backref" href="#id157">5.4.1.8&nbsp;&nbsp;&nbsp;Check whether can branch upon specified variable</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_can_branch tree j
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
<div class="section" id="choose-variable-to-branch-upon">
<h4><a class="toc-backref" href="#id158">5.4.1.9&nbsp;&nbsp;&nbsp;Choose variable to branch upon</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_branch_upon tree j selection
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
<div class="section" id="terminate-the-solution-process">
<h4><a class="toc-backref" href="#id159">5.4.1.10&nbsp;&nbsp;&nbsp;Terminate the solution process</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_terminate tree
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
</div>
<div class="section" id="the-search-tree-exploring-routines">
<h3><a class="toc-backref" href="#id160">5.4.2&nbsp;&nbsp;&nbsp;The search tree exploring routines</a></h3>
<div class="section" id="determine-the-search-tree-size">
<h4><a class="toc-backref" href="#id161">5.4.2.1&nbsp;&nbsp;&nbsp;Determine the search tree size</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_tree_size tree
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
<div class="section" id="determine-current-active-subproblem">
<h4><a class="toc-backref" href="#id162">5.4.2.2&nbsp;&nbsp;&nbsp;Determine current active subproblem</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_curr_node tree
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
<div class="section" id="determine-next-active-subproblem">
<h4><a class="toc-backref" href="#id163">5.4.2.3&nbsp;&nbsp;&nbsp;Determine next active subproblem</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_next_node tree node
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
<div class="section" id="determine-previous-active-subproblem">
<h4><a class="toc-backref" href="#id164">5.4.2.4&nbsp;&nbsp;&nbsp;Determine previous active subproblem</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_prev_node tree node
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
<div class="section" id="determine-parent-active-subproblem">
<h4><a class="toc-backref" href="#id165">5.4.2.5&nbsp;&nbsp;&nbsp;Determine parent active subproblem</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_up_node tree node
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
<div class="section" id="determine-subproblem-level">
<h4><a class="toc-backref" href="#id166">5.4.2.6&nbsp;&nbsp;&nbsp;Determine subproblem level</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_node_level tree node
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
<div class="section" id="determine-subproblem-local-bound">
<h4><a class="toc-backref" href="#id167">5.4.2.7&nbsp;&nbsp;&nbsp;Determine subproblem local bound</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_node_bound tree node
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
<div class="section" id="find-active-subproblem-with-the-best-local-bound">
<h4><a class="toc-backref" href="#id168">5.4.2.8&nbsp;&nbsp;&nbsp;Find active subproblem with the best local bound</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_best_node tree
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
</div>
<div class="section" id="the-cut-pool-routines">
<h3><a class="toc-backref" href="#id169">5.4.3&nbsp;&nbsp;&nbsp;The cut pool routines</a></h3>
<div class="section" id="determine-current-size-of-the-cut-pool">
<h4><a class="toc-backref" href="#id170">5.4.3.1&nbsp;&nbsp;&nbsp;Determine current size of the cut pool</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_pool_size tree
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
The routine returns the current size of the cut pool, that is, the number
of cutting plane constraints currently added to it.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::ios_pool_size tree;
</pre>
</div>
<div class="section" id="add-constraint-to-the-cut-pool">
<h4><a class="toc-backref" href="#id171">5.4.3.2&nbsp;&nbsp;&nbsp;Add constraint to the cut pool</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_add_row tree (name, klass, flags, row, type, rhs)
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body"><p class="first">pointer to the branch-and-cut search tree</p>
</td>
</tr>
<tr class="field"><th class="field-name">name:</th><td class="field-body"><p class="first">symbolic name of the constraint</p>
</td>
</tr>
<tr class="field"><th class="field-name">klass:</th><td class="field-body"><p class="first">speciﬁes the constraint class, which must be either zero or a number
in the range from 101 to 200. The application may use this attribute
to distinguish between cutting plane constraints of diﬀerent classes.</p>
</td>
</tr>
<tr class="field"><th class="field-name">flags:</th><td class="field-body"><p class="first">currently is not used and must be zero</p>
</td>
</tr>
<tr class="field"><th class="field-name">row:</th><td class="field-body"><p class="first">list of pairs (colindex, coefficient)</p>
</td>
</tr>
<tr class="field"><th class="field-name">type:</th><td class="field-body"><p class="first">one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::lo:</th><td class="field-body">Σ(aj.xj) ≥ RHS constraint</td>
</tr>
<tr class="field"><th class="field-name">glp::up:</th><td class="field-body">Σ(aj.xj) ≤ RHS constraint</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">rhs:</th><td class="field-body"><p class="first last">right hand side of the constraint</p>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
The routine returns the ordinal number of the cutting plane constraint
added, which is the new size of the cut pool.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::ios_add_row tree (&quot;new_constraint&quot;, 101, 0, [(3, 15.0), (4, 6.7), (8, 1.25)], glp::up, 152.7);
</pre>
</div>
<div class="section" id="remove-constraint-from-the-cut-pool">
<h4><a class="toc-backref" href="#id172">5.4.3.3&nbsp;&nbsp;&nbsp;Remove constraint from the cut pool</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_del_row tree rowindex
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
<tr class="field"><th class="field-name">rowindex:</th><td class="field-body">index of row to be deleted from the cut pool</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
()</blockquote>
<p><strong>Remark</strong>:</p>
<blockquote>
Note that deleting a constraint from the cut pool leads to changing
ordinal numbers of other constraints remaining in the pool. New ordinal
numbers of the remaining constraints are assigned under assumption that
the original order of constraints is not changed.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::ios_del_row tree 5;
</pre>
</div>
<div class="section" id="remove-all-constraints-from-the-cut-pool">
<h4><a class="toc-backref" href="#id173">5.4.3.4&nbsp;&nbsp;&nbsp;Remove all constraints from the cut pool</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::ios_clear_pool tree
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">tree:</th><td class="field-body">pointer to the branch-and-cut search tree</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
()</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::ios_clear_pool tree;
</pre>
</div>
</div>
</div>
<div class="section" id="graph-and-network-api-routines">
<h2><a class="toc-backref" href="#id174">5.5&nbsp;&nbsp;&nbsp;Graph and network API routines</a></h2>
<div class="section" id="basic-graph-routines">
<h3><a class="toc-backref" href="#id175">5.5.1&nbsp;&nbsp;&nbsp;Basic graph routines</a></h3>
<div class="section" id="create-the-glpk-graph-object">
<h4><a class="toc-backref" href="#id176">5.5.1.1&nbsp;&nbsp;&nbsp;Create the GLPK graph object</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::create_graph v_size a_size
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">v_size:</th><td class="field-body">size of vertex data blocks, in bytes, 0 ≤ v size ≤ 256</td>
</tr>
<tr class="field"><th class="field-name">a_size:</th><td class="field-body">size of arc data blocks, in bytes, 0 ≤ a size ≤ 256.</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
The routine returns a pointer to the graph created.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; let g = glp::create_graph 32 64;
&gt; g;
#&lt;pointer 0x9de7168&gt;
&gt;
</pre>
</div>
<div class="section" id="set-the-graph-name">
<h4><a class="toc-backref" href="#id177">5.5.1.2&nbsp;&nbsp;&nbsp;Set the graph name</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::set_graph_name graph name
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">graph:</th><td class="field-body">pointer to the graph object</td>
</tr>
<tr class="field"><th class="field-name">name:</th><td class="field-body">the graph name, an empty string erases the current name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
()</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::set_graph_name graph &quot;MyGraph&quot;;
()
&gt;
</pre>
</div>
<div class="section" id="add-vertices-to-a-graph">
<h4><a class="toc-backref" href="#id178">5.5.1.3&nbsp;&nbsp;&nbsp;Add vertices to a graph</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::add_vertices graph count
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">graph:</th><td class="field-body">pointer to the graph object</td>
</tr>
<tr class="field"><th class="field-name">count:</th><td class="field-body">number of vertices to add</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
The routine returns the ordinal number of the ﬁrst new
vertex added to the graph.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::add_vertices graph 5;
18
&gt;
</pre>
</div>
<div class="section" id="add-arc-to-a-graph">
<h4><a class="toc-backref" href="#id179">5.5.1.4&nbsp;&nbsp;&nbsp;Add arc to a graph</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::add_arc graph i j
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">graph:</th><td class="field-body">pointer to the graph object</td>
</tr>
<tr class="field"><th class="field-name">i:</th><td class="field-body">index of the tail vertex</td>
</tr>
<tr class="field"><th class="field-name">j:</th><td class="field-body">index of the head vertex</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
()</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::add_arc graph 7 12;
()
&gt;
</pre>
</div>
<div class="section" id="erase-content-of-the-glpk-graph-object">
<h4><a class="toc-backref" href="#id180">5.5.1.5&nbsp;&nbsp;&nbsp;Erase content of the GLPK graph object</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::erase_graph graph v_size a_size
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">graph:</th><td class="field-body">pointer to the graph object</td>
</tr>
<tr class="field"><th class="field-name">v_size:</th><td class="field-body">size of vertex data blocks, in bytes, 0 ≤ v size ≤ 256</td>
</tr>
<tr class="field"><th class="field-name">a_size:</th><td class="field-body">size of arc data blocks, in bytes, 0 ≤ a size ≤ 256.</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
()</blockquote>
<p><strong>Remark</strong>:</p>
<blockquote>
The routine reinitialises the graph object. Its efect is equivalent to
calling delete_graph followed by a call to create_graph.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::erase_graph graph 16 34;
()
&gt;
</pre>
</div>
<div class="section" id="delete-the-glpk-graph-object">
<h4><a class="toc-backref" href="#id181">5.5.1.6&nbsp;&nbsp;&nbsp;Delete the GLPK graph object</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::delete_graph graph
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">graph:</th><td class="field-body">pointer to the graph object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
()</blockquote>
<p><strong>Remark</strong>:</p>
<blockquote>
The routine destroys the graph object and invalidates the pointer.
This is done automatically when the graph is not needed anymore,
the routine need not be usually called.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::delete_graph graph
()
&gt;
</pre>
</div>
<div class="section" id="read-graph-in-a-plain-text-format">
<h4><a class="toc-backref" href="#id182">5.5.1.7&nbsp;&nbsp;&nbsp;Read graph in a plain text format</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::read_graph graph filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">graph:</th><td class="field-body">pointer to the graph object</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body">file name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if reading went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::read_graph graph &quot;graph_data.txt&quot;;
0
&gt;
</pre>
</div>
<div class="section" id="write-graph-in-a-plain-text-format">
<h4><a class="toc-backref" href="#id183">5.5.1.8&nbsp;&nbsp;&nbsp;Write graph in a plain text format</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::write_graph graph filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">graph:</th><td class="field-body">pointer to the graph object</td>
</tr>
<tr class="field"><th class="field-name">filename:</th><td class="field-body">file name</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if reading went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::write_graph graph &quot;graph_data.txt&quot;;
0
&gt;
</pre>
</div>
</div>
<div class="section" id="graph-analysis-routines">
<h3><a class="toc-backref" href="#id184">5.5.2&nbsp;&nbsp;&nbsp;Graph analysis routines</a></h3>
<div class="section" id="find-all-weakly-connected-components-of-a-graph">
<h4><a class="toc-backref" href="#id185">5.5.2.1&nbsp;&nbsp;&nbsp;Find all weakly connected components of a graph</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::weak_comp graph v_num
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">graph:</th><td class="field-body">pointer to the graph object</td>
</tr>
<tr class="field"><th class="field-name">v_num:</th><td class="field-body">oﬀset of the ﬁeld of type int in the vertex data block, to which
the routine stores the number of a weakly connected component
containing that vertex - if v_num &lt; 0, no component numbers are
stored</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
The routine returns the total number of components found.</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::weak_comp graph 16;
3
&gt;
</pre>
</div>
<div class="section" id="find-all-strongly-connected-components-of-a-graph">
<h4><a class="toc-backref" href="#id186">5.5.2.2&nbsp;&nbsp;&nbsp;Find all strongly connected components of a graph</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::strong_comp graph v_num
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">graph:</th><td class="field-body">pointer to the graph object</td>
</tr>
<tr class="field"><th class="field-name">v_num:</th><td class="field-body">oﬀset of the ﬁeld of type int in the vertex data block, to which
the routine stores the number of a strongly connected component
containing that vertex - if v_num &lt; 0, no component numbers are
stored</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p>The routine returns the total number of components found.</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::strong_comp graph 16;
4
&gt;
</pre>
</div>
</div>
<div class="section" id="minimum-cost-flow-problem">
<h3><a class="toc-backref" href="#id187">5.5.3&nbsp;&nbsp;&nbsp;Minimum cost flow problem</a></h3>
<div class="section" id="read-minimum-cost-flow-problem-data-in-dimacs-format">
<h4><a class="toc-backref" href="#id188">5.5.3.1&nbsp;&nbsp;&nbsp;Read minimum cost flow problem data in DIMACS format</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::read_mincost graph v_rhs a_low a_cap a_cost filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">graph:</th><td class="field-body">pointer to the graph object</td>
</tr>
<tr class="field"><th class="field-name">v_rhs:</th><td class="field-body">oﬀset of the ﬁeld of type double in the vertex data block,
to which the routine stores bi, the supply/demand value -
if v_rhs &lt; 0, the value is not stored</td>
</tr>
<tr class="field"><th class="field-name">a_low:</th><td class="field-body">oﬀset of the ﬁeld of type double in the arc data block,
to which the routine stores lij, the lower bound to the
arc ﬂow - if a_low &lt; 0, the lower bound is not stored</td>
</tr>
<tr class="field"><th class="field-name">a_cap:</th><td class="field-body">oﬀset of the ﬁeld of type double in the arc data block,
to which the routine stores uij, the upper bound to the
arc ﬂow (the arc capacity) - if a_cap &lt; 0, the upper bound
is not stored</td>
</tr>
<tr class="field"><th class="field-name">a_cost:</th><td class="field-body">oﬀset of the ﬁeld of type double in the arc data block,
to which the routine stores cij, the per-unit cost of the
arc ﬂow - if a_cost &lt; 0, the cost is not stored</td>
</tr>
<tr class="field"><th class="field-name">fname:</th><td class="field-body">the name of a text ﬁle to be read in - if the ﬁle name name
ends with the suﬃx ‘.gz’, the ﬁle is assumed to be compressed,
in which case the routine decompresses it “on the ﬂy”</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if reading went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::read_mincost graph 0 8 16 24 &quot;graphdata.txt&quot;;
0
&gt;
</pre>
</div>
<div class="section" id="write-minimum-cost-flow-problem-data-in-dimacs-format">
<h4><a class="toc-backref" href="#id189">5.5.3.2&nbsp;&nbsp;&nbsp;Write minimum cost flow problem data in DIMACS format</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::write_mincost graph v_rhs a_low a_cap a_cost fname
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">graph:</th><td class="field-body">pointer to the graph object</td>
</tr>
<tr class="field"><th class="field-name">v_rhs:</th><td class="field-body">oﬀset of the ﬁeld of type double in the vertex data block,
to which the routine stores bi, the supply/demand value -
if v_rhs &lt; 0, the value is not stored</td>
</tr>
<tr class="field"><th class="field-name">a_low:</th><td class="field-body">oﬀset of the ﬁeld of type double in the arc data block,
to which the routine stores lij, the lower bound to the
arc ﬂow - if a_low &lt; 0, the lower bound is not stored</td>
</tr>
<tr class="field"><th class="field-name">a_cap:</th><td class="field-body">oﬀset of the ﬁeld of type double in the arc data block,
to which the routine stores uij, the upper bound to the
arc ﬂow (the arc capacity) - if a_cap &lt; 0, the upper bound
is not stored</td>
</tr>
<tr class="field"><th class="field-name">a_cost:</th><td class="field-body">oﬀset of the ﬁeld of type double in the arc data block,
to which the routine stores cij, the per-unit cost of the
arc ﬂow - if a_cost &lt; 0, the cost is not stored</td>
</tr>
<tr class="field"><th class="field-name">fname:</th><td class="field-body">the name of a text ﬁle to be written out - if the ﬁle name name
ends with the suﬃx ‘.gz’, the ﬁle is assumed to be compressed,
in which case the routine compresses it “on the ﬂy”</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if reading went OK; non-zero in case of an error</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::write_mincost graph 0 8 16 24 &quot;graphdata.txt&quot;;
0
&gt;
</pre>
</div>
<div class="section" id="convert-minimum-cost-flow-problem-to-lp">
<h4><a class="toc-backref" href="#id190">5.5.3.3&nbsp;&nbsp;&nbsp;Convert minimum cost flow problem to LP</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::mincost_lp lp graph names v_rhs a_low a_cap a_cost
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">lp:</th><td class="field-body"><p class="first">pointer to the LP problem object</p>
</td>
</tr>
<tr class="field"><th class="field-name">graph:</th><td class="field-body"><p class="first">pointer to the graph object</p>
</td>
</tr>
<tr class="field"><th class="field-name">names:</th><td class="field-body"><p class="first">one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::on:</th><td class="field-body">assign symbolic names of the graph object components
to symbolic names of the LP problem object components</td>
</tr>
<tr class="field"><th class="field-name">glp::off:</th><td class="field-body">no symbolic names are assigned</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">v_rhs:</th><td class="field-body"><p class="first">oﬀset of the ﬁeld of type double in the vertex data block,
to which the routine stores bi, the supply/demand value -
if v_rhs &lt; 0, it is assumed bi = 0 for all nodes</p>
</td>
</tr>
<tr class="field"><th class="field-name">a_low:</th><td class="field-body"><p class="first">oﬀset of the ﬁeld of type double in the arc data block,
to which the routine stores lij, the lower bound to the
arc ﬂow - if a_low &lt; 0, it is assumed lij = 0 for all arcs</p>
</td>
</tr>
<tr class="field"><th class="field-name">a_cap:</th><td class="field-body"><p class="first">oﬀset of the ﬁeld of type double in the arc data block,
to which the routine stores uij, the upper bound to the
arc ﬂow (the arc capacity) - if a_cap &lt; 0,it is assumed
uij = 1 for all arcs, value of DBL_MAX means an uncapacitated arc</p>
</td>
</tr>
<tr class="field"><th class="field-name">a_cost:</th><td class="field-body"><p class="first last">oﬀset of the ﬁeld of type double in the arc data block,
to which the routine stores cij, the per-unit cost of the
arc ﬂow - if a_cost &lt; 0, it is assumed cij = 0 for all arcs</p>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
()</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::mincost_lp lp graph glp::on 0 8 16 24;
()
&gt;
</pre>
</div>
<div class="section" id="solve-minimum-cost-flow-problem-with-out-of-kilter-algorithm">
<h4><a class="toc-backref" href="#id191">5.5.3.4&nbsp;&nbsp;&nbsp;Solve minimum cost flow problem with out-of-kilter algorithm</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::mincost_okalg graph v_rhs a_low a_cap a_cost a_x v_pi
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">graph:</th><td class="field-body">pointer to the graph object</td>
</tr>
<tr class="field"><th class="field-name">v_rhs:</th><td class="field-body">oﬀset of the ﬁeld of type double in the vertex data block,
to which the routine stores bi, the supply/demand value -
if v_rhs &lt; 0, it is assumed bi = 0 for all nodes</td>
</tr>
<tr class="field"><th class="field-name">a_low:</th><td class="field-body">oﬀset of the ﬁeld of type double in the arc data block,
to which the routine stores lij, the lower bound to the
arc ﬂow - if a_low &lt; 0, it is assumed lij = 0 for all arcs</td>
</tr>
<tr class="field"><th class="field-name">a_cap:</th><td class="field-body">oﬀset of the ﬁeld of type double in the arc data block,
to which the routine stores uij, the upper bound to the
arc ﬂow (the arc capacity) - if a_cap &lt; 0,it is assumed
uij = 1 for all arcs, value of DBL_MAX means an uncapacitated arc</td>
</tr>
<tr class="field"><th class="field-name">a_cost:</th><td class="field-body">oﬀset of the ﬁeld of type double in the arc data block,
to which the routine stores cij, the per-unit cost of the
arc ﬂow - if a_cost &lt; 0, it is assumed cij = 0 for all arcs</td>
</tr>
<tr class="field"><th class="field-name">a_x:</th><td class="field-body">oﬀset of the ﬁeld of type double in the arc data block,
to which the routine stores xij, the arc ﬂow found - if a_x &lt; 0,
the arc ﬂow value is not stored</td>
</tr>
<tr class="field"><th class="field-name">v_pi:</th><td class="field-body">speciﬁes an oﬀset of the ﬁeld of type double in the vertex data block,
to which the routine stores πi, the node potential, which is the
Lagrange multiplier for the corresponding ﬂow conservation
equality constraint</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Remark</strong>:</p>
<blockquote>
Note that all solution components (the objective value, arc ﬂows, and
node potentials) computed by the routine are always integer-valued.</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>The function returns a tuple in the form <strong>(code, obj)</strong>, where
<strong>code</strong> is one of the following</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::ok:</th><td class="field-body">optimal solution found</td>
</tr>
<tr class="field"><th class="field-name">glp::enopfs:</th><td class="field-body">no (primal) feasible solution exists</td>
</tr>
<tr class="field"><th class="field-name">glp::edata:</th><td class="field-body">unable to start the search, because some problem data are
either not integer-valued or out of range; this code is also
returned if the total supply, which is the sum of bi over all
source nodes (nodes with bi &gt; 0), exceeds INT_MAX</td>
</tr>
<tr class="field"><th class="field-name">glp::erange:</th><td class="field-body">the search was prematurely terminated because of integer
overflow</td>
</tr>
<tr class="field"><th class="field-name">glp::efail:</th><td class="field-body">an error has been detected in the program logic -  if this
code is returned for your problem instance, please report
to &lt;<a class="reference external" href="mailto:bug-glpk&#64;gnu.org">bug-glpk&#64;gnu.org</a>&gt;</td>
</tr>
</tbody>
</table>
<p>and <strong>obj</strong> is value of the objective function.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::mincost_okalg graph 0 8 16 24 32 40;
(glp::ok, 15)
&gt;
</pre>
</div>
<div class="section" id="klingman-s-network-problem-generator">
<h4><a class="toc-backref" href="#id192">5.5.3.5&nbsp;&nbsp;&nbsp;Klingman's network problem generator</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::netgen graph v_rhs a_cap a_cost parameters
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">graph:</th><td class="field-body"><p class="first">pointer to the graph object</p>
</td>
</tr>
<tr class="field"><th class="field-name">v_rhs:</th><td class="field-body"><p class="first">oﬀset of the ﬁeld of type double in the vertex data block,
to which the routine stores bi, the supply/demand value -
if v_rhs &lt; 0, it is assumed bi = 0 for all nodes</p>
</td>
</tr>
<tr class="field"><th class="field-name">a_cap:</th><td class="field-body"><p class="first">oﬀset of the ﬁeld of type double in the arc data block,
to which the routine stores uij, the upper bound to the
arc ﬂow (the arc capacity) - if a_cap &lt; 0,it is assumed
uij = 1 for all arcs, value of DBL_MAX means an uncapacitated arc</p>
</td>
</tr>
<tr class="field"><th class="field-name">a_cost:</th><td class="field-body"><p class="first">oﬀset of the ﬁeld of type double in the arc data block,
to which the routine stores cij, the per-unit cost of the
arc ﬂow - if a_cost &lt; 0, it is assumed cij = 0 for all arcs</p>
</td>
</tr>
<tr class="field"><th class="field-name">parameters:</th><td class="field-body"><p class="first">tuple of exactly 15 integer numbers with the following meaning:</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">parm[1]:</th><td class="field-body">iseed 8-digit positive random number seed</td>
</tr>
<tr class="field"><th class="field-name">parm[2]:</th><td class="field-body">nprob 8-digit problem id number</td>
</tr>
<tr class="field"><th class="field-name">parm[3]:</th><td class="field-body">nodes total number of nodes</td>
</tr>
<tr class="field"><th class="field-name">parm[4]:</th><td class="field-body">nsorc total number of source nodes
(including transshipment nodes)</td>
</tr>
<tr class="field"><th class="field-name">parm[5]:</th><td class="field-body">nsink total number of sink nodes
(including transshipment nodes)</td>
</tr>
<tr class="field"><th class="field-name">parm[6]:</th><td class="field-body">iarcs number of arc</td>
</tr>
<tr class="field"><th class="field-name">parm[7]:</th><td class="field-body">mincst minimum cost for arcs</td>
</tr>
<tr class="field"><th class="field-name">parm[8]:</th><td class="field-body">maxcst maximum cost for arcs</td>
</tr>
<tr class="field"><th class="field-name">parm[9]:</th><td class="field-body">itsup total supply</td>
</tr>
<tr class="field"><th class="field-name">parm[10]:</th><td class="field-body">ntsorc number of transshipment source nodes</td>
</tr>
<tr class="field"><th class="field-name">parm[11]:</th><td class="field-body">ntsink number of transshipment sink nodes</td>
</tr>
<tr class="field"><th class="field-name">parm[12]:</th><td class="field-body">iphic percentage of skeleton arcs to be given the
maximum cost</td>
</tr>
<tr class="field"><th class="field-name">parm[13]:</th><td class="field-body">ipcap percentage of arcs to be capacitated</td>
</tr>
<tr class="field"><th class="field-name">parm[14]:</th><td class="field-body">mincap minimum upper bound for capacitated arcs</td>
</tr>
<tr class="field"><th class="field-name">parm[15]:</th><td class="field-body">maxcap maximum upper bound for capacitated arcs</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if the instance was successfully generated, nonzero otherwise</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::netgen graph 0 8 16 (12345678, 87654321, 20, 12, 8, 25, 5, 20, 300, 6, 5, 15, 100, 1, 30);
0
&gt;
</pre>
</div>
<div class="section" id="grid-like-network-problem-generator">
<h4><a class="toc-backref" href="#id193">5.5.3.6&nbsp;&nbsp;&nbsp;Grid-like network problem generator</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::gridgen graph v_rhs a_cap a_cost parameters
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">graph:</th><td class="field-body"><p class="first">pointer to the graph object</p>
</td>
</tr>
<tr class="field"><th class="field-name">v_rhs:</th><td class="field-body"><p class="first">oﬀset of the ﬁeld of type double in the vertex data block,
to which the routine stores bi, the supply/demand value -
if v_rhs &lt; 0, it is assumed bi = 0 for all nodes</p>
</td>
</tr>
<tr class="field"><th class="field-name">a_cap:</th><td class="field-body"><p class="first">oﬀset of the ﬁeld of type double in the arc data block,
to which the routine stores uij, the upper bound to the
arc ﬂow (the arc capacity) - if a_cap &lt; 0,it is assumed
uij = 1 for all arcs, value of DBL_MAX means an uncapacitated arc</p>
</td>
</tr>
<tr class="field"><th class="field-name">a_cost:</th><td class="field-body"><p class="first">oﬀset of the ﬁeld of type double in the arc data block,
to which the routine stores cij, the per-unit cost of the
arc ﬂow - if a_cost &lt; 0, it is assumed cij = 0 for all arcs</p>
</td>
</tr>
<tr class="field"><th class="field-name">parameters:</th><td class="field-body"><p class="first">tuple of exactly 14 integer numbers with the following meaning:</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">parm[1]:</th><td class="field-body"><p class="first">two-ways arcs indicator:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">1:</th><td class="field-body">if links in both direction should be generated</td>
</tr>
<tr class="field"><th class="field-name">0:</th><td class="field-body">otherwise</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">parm[2]:</th><td class="field-body"><p class="first">random number seed (a positive integer)</p>
</td>
</tr>
<tr class="field"><th class="field-name">parm[3]:</th><td class="field-body"><p class="first">number of nodes (the number of nodes generated might be
slightly different to make the network a grid)</p>
</td>
</tr>
<tr class="field"><th class="field-name">parm[4]:</th><td class="field-body"><p class="first">grid width</p>
</td>
</tr>
<tr class="field"><th class="field-name">parm[5]:</th><td class="field-body"><p class="first">number of sources</p>
</td>
</tr>
<tr class="field"><th class="field-name">parm[6]:</th><td class="field-body"><p class="first">number of sinks</p>
</td>
</tr>
<tr class="field"><th class="field-name">parm[7]:</th><td class="field-body"><p class="first">average degree</p>
</td>
</tr>
<tr class="field"><th class="field-name">parm[8]:</th><td class="field-body"><p class="first">total flow</p>
</td>
</tr>
<tr class="field"><th class="field-name">parm[9]:</th><td class="field-body"><p class="first">distribution of arc costs:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">1:</th><td class="field-body">uniform</td>
</tr>
<tr class="field"><th class="field-name">2:</th><td class="field-body">exponential</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">parm[10]:</th><td class="field-body"><p class="first">lower bound for arc cost (uniform),
100 lambda¸ (exponential)</p>
</td>
</tr>
<tr class="field"><th class="field-name">parm[11]:</th><td class="field-body"><p class="first">upper bound for arc cost (uniform),
not used (exponential)</p>
</td>
</tr>
<tr class="field"><th class="field-name">parm[12]:</th><td class="field-body"><p class="first">distribution of arc capacities:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">1:</th><td class="field-body">uniform</td>
</tr>
<tr class="field"><th class="field-name">2:</th><td class="field-body">exponential</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">parm[13]:</th><td class="field-body"><p class="first">lower bound for arc capacity (uniform),
100 lambda (exponential)</p>
</td>
</tr>
<tr class="field"><th class="field-name">parm[14]:</th><td class="field-body"><p class="first last">upper bound for arc capacity (uniform),
not used (exponential)</p>
</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<strong>0</strong> if the instance was successfully generated, nonzero otherwise</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::gridgen graph 0 8 16 (1, 123, 20, 4, 7, 5, 3, 300, 1, 1, 5, 1, 5, 30);
0
&gt;
</pre>
</div>
</div>
<div class="section" id="maximum-flow-problem">
<h3><a class="toc-backref" href="#id194">5.5.4&nbsp;&nbsp;&nbsp;Maximum flow problem</a></h3>
<div class="section" id="read-maximum-cost-flow-problem-data-in-dimacs-format">
<h4><a class="toc-backref" href="#id195">5.5.4.1&nbsp;&nbsp;&nbsp;Read maximum cost flow problem data in DIMACS format</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::read_maxflow graph a_cap filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">graph:</th><td class="field-body">pointer to the graph object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
<div class="section" id="write-maximum-cost-flow-problem-data-in-dimacs-format">
<h4><a class="toc-backref" href="#id196">5.5.4.2&nbsp;&nbsp;&nbsp;Write maximum cost flow problem data in DIMACS format</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::write_maxflow graph s t a_cap filename
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">graph:</th><td class="field-body">pointer to the graph object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
<div class="section" id="convert-maximum-flow-problem-to-lp">
<h4><a class="toc-backref" href="#id197">5.5.4.3&nbsp;&nbsp;&nbsp;Convert maximum flow problem to LP</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::maxflow_lp lp graph names s t a_cap
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">graph:</th><td class="field-body">pointer to the graph object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
<div class="section" id="solve-maximum-flow-problem-with-ford-fulkerson-algorithm">
<h4><a class="toc-backref" href="#id198">5.5.4.4&nbsp;&nbsp;&nbsp;Solve maximum flow problem with Ford-Fulkerson algorithm</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::maxflow_ffalg graph s t a_cap a_x v_cut
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">graph:</th><td class="field-body">pointer to the graph object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
<div class="section" id="goldfarb-s-maximum-flow-problem-generator">
<h4><a class="toc-backref" href="#id199">5.5.4.5&nbsp;&nbsp;&nbsp;Goldfarb's maximum flow problem generator</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::rmfgen graph a_cap parameters
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">graph:</th><td class="field-body">pointer to the graph object</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt;
</pre>
</div>
</div>
</div>
<div class="section" id="miscellaneous-routines">
<h2><a class="toc-backref" href="#id200">5.6&nbsp;&nbsp;&nbsp;Miscellaneous routines</a></h2>
<div class="section" id="library-environment-routines">
<h3><a class="toc-backref" href="#id201">5.6.1&nbsp;&nbsp;&nbsp;Library environment routines</a></h3>
<div class="section" id="determine-library-version">
<h4><a class="toc-backref" href="#id202">5.6.1.1&nbsp;&nbsp;&nbsp;Determine library version</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
`glp::version
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
none</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
GLPK library version</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::version;
&quot;4.38&quot;
&gt;
</pre>
</div>
<div class="section" id="enable-disable-terminal-output">
<h4><a class="toc-backref" href="#id203">5.6.1.2&nbsp;&nbsp;&nbsp;Enable/disable terminal output</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::term_out switch
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">switch:</th><td class="field-body"><p class="first">one of the following:</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::on:</th><td class="field-body">enable terminal output from GLPK routines</td>
</tr>
<tr class="field"><th class="field-name">glp::off:</th><td class="field-body">disable terminal output from GLPK routines</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::term_out glp:off;
()
&gt;
</pre>
</div>
<div class="section" id="enable-disable-the-terminal-hook-routine">
<h4><a class="toc-backref" href="#id204">5.6.1.3&nbsp;&nbsp;&nbsp;Enable/disable the terminal hook routine</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::term_hook switch info
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">switch:</th><td class="field-body"><p class="first">one of the following:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">glp::on:</th><td class="field-body">use the terminal callback function</td>
</tr>
<tr class="field"><th class="field-name">glp::off:</th><td class="field-body">don't use the terminal callback function</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="field"><th class="field-name">info:</th><td class="field-body"><p class="first last">pointer to a memory block which can be used for passing
additional information to the terminal callback function</p>
</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::term_hook glp::on NULL;
()
&gt;
</pre>
</div>
<div class="section" id="get-memory-usage-information">
<h4><a class="toc-backref" href="#id205">5.6.1.4&nbsp;&nbsp;&nbsp;Get memory usage information</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::mem_usage
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
none</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>tuple consisting of four numbers:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal">count</tt> (int) - the number of currently allocated memory blocks</li>
<li><tt class="docutils literal">cpeak</tt> (int) - the peak value of <tt class="docutils literal">count</tt> reached since the
initialization of the GLPK library environment</li>
<li><tt class="docutils literal">total</tt> (bigint) - the total amount, in bytes, of currently
allocated memory blocks</li>
<li><tt class="docutils literal">tpeak</tt> (bigint) - the peak value of <tt class="docutils literal">total</tt> reached since the
initialization of the GLPK library envirionment</li>
</ul>
</blockquote>
</blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::mem_usage;
7,84,10172L,45304L
&gt;
</pre>
</div>
<div class="section" id="set-memory-usage-limit">
<h4><a class="toc-backref" href="#id206">5.6.1.5&nbsp;&nbsp;&nbsp;Set memory usage limit</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::mem_limit limit
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">limit:</th><td class="field-body">memory limit in megabytes</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp::mem_limit 200;
()
&gt;
</pre>
</div>
<div class="section" id="free-glpk-library-environment">
<h4><a class="toc-backref" href="#id207">5.6.1.6&nbsp;&nbsp;&nbsp;Free GLPK library environment</a></h4>
<p><strong>Synopsis</strong>:</p>
<pre class="literal-block">
glp::free_env
</pre>
<p><strong>Parameters</strong>:</p>
<blockquote>
none</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<tt class="docutils literal">()</tt></blockquote>
<p><strong>Example</strong>:</p>
<pre class="literal-block">
&gt; glp_free_env;
()
&gt;
</pre>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
