
/* Some basic examples for the hashmap module. This is intended to be fed to
   the interpreter in a piecemeal fashion (best done using "Send Current Line"
   in Emacs). To see the results, you can also run the script from the command
   line as follows: pure < hashmap_examp.pure */

using hashmap;

public foo bar baz; // free symbols used below

/* Create a hashmap and populate it with some Pure data. Both keys and values
   may be arbitrary Pure expressions. Note that in general the elements may be
   stored in an apparently random order (not necessarily the order in which
   they were inserted). */

let m = hashmap [foo=>99, bar=>bar 4711L, baz=>1..5]; m;

/* The notation {$ key=>val, ... $} is used for pretty-printing hashmaps, and
   can also be used for hashmap literals in Pure code. */

let m = {$ foo=>99, bar=>bar 4711L, baz=>1..5 $}; m;

// Query the map.
m!bar;  // => bar 4711L
keys m; // => [foo,bar,baz]
vals m; // => [99,bar 4711L,[1,2,3,4,5]]
list m; // => [foo=>99,bar=>bar 4711L,baz=>[1,2,3,4,5]]

// Membership test.
member m foo, member m bar;

// Delete an element. Note that hashmaps are mutable, so you need to take a
// copy if you want to preserve the original value.
let m1 = hashmap_copy m;
delete m foo; m1;
m!foo;  // => out_of_bounds exception
keys m; // => [bar,baz]
vals m; // => [bar 4711L,[1,2,3,4,5]]
list m; // => [bar=>bar 4711L,baz=>[1,2,3,4,5]]

member m foo, member m bar;

// Hashmaps can also be used in list and matrix comprehensions.
[x,y | x=>y = m1];
{x,y | x=>y = m1; listp y};

/* Note that, as hashmaps are really pointers, syntactic equality holds if and
   only if two hashmaps are exactly the same object. */

m===m, m===m1, m === hashmap_copy m;

/* The above can always be done in constant time but isn't very useful if you
   want to verify that two hashmaps contain the same key=>value associations.
   This can be done using the comparison operations provided by the module. */

m==m, m==m1, m == hashmap_copy m;

/* Hashmaps can also serve as a hashed set data structure which contains only
   keys but no values. In this case the value associated with a key defaults
   to the key itself. */

let m = {$ 99, bar 4711L, 1..5 $}; m;

member m 99;
m!99;
delete m 99;
member m 99;
m!99;
insert m 99;

// You can also mix singleton elements with ordinary key-value associations.
delete m (bar 4711L);
insert m (bar=>bar 4711L);
m!99;
m!bar;

/* Basic set-like operations like union, intersection etc. aren't provided by
   the module, but you can easily implement them yourself as follows. Note
   that we take a copy of the first operand here in order to preserve value
   semantics. */

x::hashmap + y::hashmap = foldl insert (hashmap_copy x) (list y);
x::hashmap - y::hashmap = foldl delete (hashmap_copy x) (keys y);
x::hashmap * y::hashmap = x-(x-y);

let m1 = {$5,1,3,11,3$};
let m2 = hashmap (3..6);

m1;m2;
m1+m2; // => {$11,1,3,4,5,6$}
m1-m2; // => {$11,1$}
m1*m2; // => {$3,5$}

// These operations also work with general hashmaps, of course.
{$foo=>99,baz=>1..5$} + {$bar=>bar 4711L$};
