## 1. ##

Imperative languages like C have expressions---sometimes with and sometimes without side-effects:

```
i++
```
```
i<10
```

and commands:

```
for(i=0; i<10; i++) {
    bar(i);
}
```

and declarations and definitions:

```
int i;
```
```
int j = 10;
```
```
int bar (int i) {
    return i + 1;
}
```


In functional languages like Pure on the other hand we again have expressions---sometimes with but usually without side-effects:

```
put cell (get cell + 1)
```
```
head [1,2,3] + 1
```
```
if get cell > 10 then "Done" else "Not done"
```

and "toplevel statements". These include expressions and also include
a variety of declarations and definitions and other sorts of directives:

  * global variable and const definitions
  * global function rules
  * macro definitions
  * type and interface definitions
  * operator and publicity declarations
  * `namespace` and `using namespace` directives
  * `using` and `extern` directives
  * pragmas and inline C code and so on


For the following we will primarily be concerned with Pure **expressions**: pieces of
Pure syntax that can appear embedded in other expressions and in rules, as well
as at the toplevel.


## 2. Source, Syntax and Values ##

First, though, let's get clear on the differences between Pure source text, Pure syntax,
and the space of Pure values. There is some overlap but also important differences.

The life of a Pure program, or some fragment thereof, can be thought of in the following stages.

<pre>
Source text<br>
|<br>
| Pure parser converts to<br>
V<br>
+----------------------------------------------------------<br>
| Pure expressions and other (toplevel) pieces of syntax  |<br>
|     |                                                   |<br>
|     | Macro-expands to                                  |<br>
|     V                                                   |<br>
| Possibly different Pure expressions                     |<br>
|     |                                                   |<br>
|     | Evaluates or reduces to                           |<br>
|     V                                                   |<br>
| Some Pure values                                        |<br>
+----------------------------------------------------------<br>
|<br>
| which in the interpreter will be displayed using<br>
V<br>
Text representation of the result<br>
</pre>

I don't say much about where the "compiler" or the "interpreter" is involved, or LLVM
bitcode, or anything of that sort. We're abstracting away from those low-level specifics.

Note the difference between the initial level, outside the box, and the first
level inside the box. Pure source text is just a flat sequence of
characters. The parser converts that into a rich syntactic structure. So pieces
of Pure syntax are different than Pure source text in that they have more
structure. They are also different in what they're made up of. Pure source text
is just a string, made up of shorter strings (characters). Pure syntax includes
strings (like `"hello"`) but it includes more besides, such as symbols
(`world`) and numbers (`14`) and more. The number `14` is itself part of Pure's syntax
(more on this soon), and so too is the string "14", but these are different
pieces of syntax.

Much of Pure's _syntax_ ---all of its expressions---also falls into the space of
_values_ that Pure can refer to and manipulate. But distinctively toplevel syntax
does not. From the other direction, many of the values that Pure can refer to
and manipulate can be expressed literally in Pure---or at any rate with Pure
code that could be evaluated at compile-time. For example:

```
1 // numbers are expressions that can be expressed literally
```
```
[1,2] // so too are lists
```
```
unbound // so too are symbols, here a symbol with no binding
```
```
unbound 1
```
```
quote (succ 1)
```

The compound expression `unbound 1` is expressed by itself. The compound
expression `succ 1` is not---it evaluates to something else. But that compound
expression _can_ be generated by the Pure code given in the last line, and this
code could be evaluated at compile-time. On the other hand, some Pure values can
only be generated at runtime:

```
malloc 10 // expresses a runtime value
```
```
(\x -> x + y) when y = 1 end // another runtime value
```

In fact, as we'll discuss, it's not straightforward whether the runtime values
generated by the last expressions should also be counted as Pure "expressions".
It is however clear that they are no part of Pure _syntax_. The Pure parser
neither knows nor cares about them. (It _does_ know and care about the
expressions displayed, _whose evaluation generates_ the runtime values.)


So there's an overlapping space of things like this:

<pre>
+================================+<br>
| Pure syntax, that the parser   |<br>
| converts source text into      |<br>
|                                |<br>
| distinctively top-level syntax |<br>
|    +--------------------------------------------------+<br>
|    |    values that Pure can refer to and manipulate  |<br>
|    |       expressions ...     |  runtime values      |<br>
|    +---------------------------|----------------------+<br>
+================================+<br>
</pre>

More about these distinctions as we proceed.


## 3. Expressions ##

Pure's syntax divides the class of **expressions** into three layers:

First, what Pure calls "primitive" expressions, and might also be called "atomic and parenthesized" expressions.

These include identifiers and nonfix symbols, numbers and strings and list and
matrix literals, and list and matrix comprehensions. They also include
"parenthesized" bits of Pure syntax, including things like:

  * `(EXPR)`, where EXPR is any Pure expression, even a non-primitive or "special" expression
  * "sections" like `(1+)` and `(+)`
  * constructions using user-defined outfix symbols, like `(: 1,2 :)`


Second, what Pure calls "simple" expressions, and might also be called "compound" or "operand-eligible" expressions.

These include primitive expressions, as well as _applications_ of any simple
expressions to other expressions. So:

```
succ 1
```

is a concatenation of two primitive expressions; that concatenation is a simple
but not a primitive expression. But:

```
(succ 1)
```

with parentheses is again a primitive expression.

Additionally, _binary applications of infix operators_, and well-formed
_applications of prefix or postfix operators_ are also simple expressions:

<pre>
What kind of expression?<br>
------------------------<br>
(+)                 primitive<br>
(1+)                primitive<br>
(+) 1               simple, not primitive<br>
(+) 1 2             simple, not primitive<br>
1+2                 simple, not primitive<br>
(1+2)               primitive<br>
</pre>

The third layer are what Pure calls "special expressions." These might also be called "block-level" expressions. They include:

  * `if ... then ... else` constructions
  * `case` constructions
  * `lambda` constructions
  * any expression with an attached `when` or `with` clause

As we said above, parenthesizing any expression again makes it primitive. Thus, although this is not well-formed:

```
flag || case x of pat = value end
```

---since operators (here `||`) require their arguments to be "simple" or "operand-eligible"---this works fine:

```
flag || (case x of pat = value end)
```


## 4. Referring to symbols ##

We've noted that Pure syntax includes things like numbers and lists, as well as
strings. There is no difference in Pure between a numeric value and the numeral
which evaluates to it: these are one and the same. There is of course a
difference between those two on the one hand, and _the string expression_ of
the number in one's source text, and which the interpreter prints to the
terminal. But by the time we have a Pure expression to evaluate, we've
_already_ moved from text to numbers.

Among the expressions of Pure, some are of the type `symbol`. Numbers aren't
symbols, nor are strings or lists. Nor are compound expressions like `succ 1`.
Symbols are Pure expressions that it'd be possible to bind to a value.

`symbol`s subdivide into `identifier`s and operators, including nonfix operators. By default, source text that looks like a
C identifier will be parsed into a Pure identifier, unless you've overriden that by explicitly declaring it
as an operator. Text that consists solely of punctuation will by default not be parsed at all, unless it (or pieces of it)
have been explicitly declared as an operator. In each case, these "declarations as operators" are syntactic directives and don't by themselves
yet introduce any semantic binding.

What I want to discuss here is not how to bind such symbols to (other) values,
but rather how to _refer to_ them _as_ values. Values of type `symbol` can be
referred to in one of two ways: first, with those same symbols, in contexts
where they're unbound. Or second, one could use a _quotation form_ to inhibit
the normal evaluation of the symbol. These forms suppress any global bindings
the symbols may have:

```
quote 3
```
```
'3
```

The syntactic forms just displayed are simple/compound expressions, not primitive/atomic ones. They
are _applications of_ the quotation operators to the primitive expression `3`. If one
had a Pure variable `exp` bound to one of those syntactic forms, the typechecks:

```
typep appl exp
```
```
case exp of _::appl = 1; _ = 0 end
```

would both come out true, and the checks:

```
typep number exp
```
```
case exp of _::number = 1; _ = 0 end
```


would both come out false. Similarly, if one had a Pure variable bound to the expressions
`quote succ` or `'succ`, it would also check as `appl` and would not check as `symbol`.

On the other hand, _evaluating_ these expressions gives us the number `3` and the symbol `succ`, which
_are_ primitive expressions. Evaluating the first of _these_ returns that same number back again;
evaluating the second may return that same symbol, or may return some other value, depending
on what bindings for `succ` are visible.

In what follows, I'll sometimes be talking about symbols like `succ` and `+` _themselves_, and other times
about the values those symbols are bound to---which I'll also refer to as `succ` and `+`. The surrounding text
will specify whether I mean the symbol `succ` or the function `succ`. I'll also sometimes be talking about the
_quotation expressions_ `'succ` and `quote succ`, rather than the expressions (here, the symbol `succ`)
those expressions evaluate to. (This is why it's easiest to say in the surrounding text whether I mean the symbol `succ` or the value it names, rather than
adopting some policy like "I will always refer to symbols with quotation forms." The quotation expressions we discuss aren't always meant to
be understood as evaluated.)


## 5. Referring to compound expressions ##

So far, we've been talking about atomic expression values.
Compound Pure expressions can be referred to either with more complex quote forms, or by _applying_ one of the
previous quote forms `quote succ` or `'succ` to further expressions, as here:

```
> quote succ 1; // that is, (quote succ) 1
succ 1
> ('succ) 1;
succ 1
```

Since the heads of these expressions are quoted, no further reduction will take place, even if rules matching the argument `1` are defined for the head.

`quote` is a function and `'` a prefix operator with a high precedence (only `&` is
higher). The application of ordinary (non-prefix, -postfix, or -infix)
functions has higher precedence than any operator. So `quote succ 1` is parsed as
`(quote succ) 1`; but `'succ 1` is parsed as `'(succ 1)`. These expressions are
syntactically distinct---but they _evaluate to_ the same unevaluated compound
expression: `succ 1`.

Note if you want to pass that compound expression to a
function `foo`, you have to use one of the following formats:

```
foo (quote succ 1) // that is, foo ((quote succ) 1)
```
```
foo (('succ) 1)
```
```
foo (quote (succ 1))
```
```
foo ('succ 1) // that is, foo ('(succ 1))
```

You can't use this:

```
foo '(succ 1)
```

since that's parsed as:

```
(foo ') (succ 1)
```

and the latter is ill-formed, because `'` is a prefix operator. You _could_ do this:

```
foo (') (succ 1) // that is, (foo (')) (succ 1)
```

but that passes `foo` a different argument and is likely to give different results than `foo ('succ 1)`.


## 6. Self-evaluating expressions ##

Many Pure expressions evaluate or reduce to some value distinct from the original expression.

But as we've seen, quotation inhibits this. The quotation of a Pure expression refers to the expression quoted:

```
> quote (succ 1);
succ 1
```

Some Pure expressions already evaluate to themselves when _unquoted_ too: so evaluating a quotation of them and evaluating the original give the same value:

```
> 1 === quote 1;
1
> [1] === quote [1];
1
```

Sometimes such expressions are called "self-quoting", but it'd make more sense to call them "self-evaluating".
To understand these cases, realize that the value
that the unquoted expressions evaluate to
are part of the very language being evaluated. Remember, the syntactic forms of Pure
don't consist only
of symbols or strings. They also include things like numbers
and lists. And some of these parts of the language evaluate to the very values they are:

```
> 1; // what does the expression `1` evaluate to?
1
> quote 1; // what is the expression `1` itself?
1
> 1 === quote 1; // they are the same!
1
```

In the case of lists, these turn out to be composed in part of the symbol `:` and the symbol `[]`. Many symbols
_aren't_ self-evaluating, because they're bound by global or local definitions. But these symbols aren't so bound, and so they are `===` their own quotations.
For this reason, lists whose members are also self-evaluating are themselves self-evaluating.


As we also noted before, the space of Pure values contains some things that
have no literal or compile-time representation, such as function closures and
allocated pointers. Some (all?) of these are equivalent to their own quotation
too:

```
> p === 'p when p = malloc 10 end;
1
```

As we'll discuss later, `'p` here is the quotation of the value `p` is assigned
in the `when` clause, and not a quotation of the symbol `p`. To get the latter,
you'd have to do:

```
> p === sym when sym = 'p; p = malloc 10 end;
0
```

I've been calling things like allocated pointers "runtime values".
It's not clear whether to regard them as "expressions" or not. On the one hand,
since they have no literal representation, the Pure parser doesn't know or care
about them. On the other hand, the quotation operators are defined on them, so
that speaks for regarding them as a distinctive kind of expression.

Interestingly, unevaluated Pure expressions are also self-evaluating:

```
> let exp = quote (succ 1);
> exp;
succ 1;
> let quoted_exp = 'e when e = exp end; // see explanation below
> quoted_exp;
succ 1;
> exp === quoted_exp;
1
```

The way we defined `quoted_exp` here is somewhat roundabout. We couldn't just
say `'exp` because that would give us the symbol `exp` itself, not the
quotation of the expression that `exp` was bound to. So what we did instead was
rely on the fact that Pure substitutes local variables into quotations. (More
on this in section 8, below.) The result is that `quoted_exp` is defined to
be the application of the `quote` operation to the unevaluated expression `succ 1` that
`exp` is bound to. As the above fragment demonstrates, this is the very
same expression. So unevaluated expressions are like numbers in that they are they
own quotations, and conversely, they evaluate to themselves.

One _can_ do something like stacking up multiple layers of quotation, like this:

```
let exp2 = quote (quote (succ 1));
```

But that doesn't define `exp2` to be the quotation of the value `exp` was bound to before.
Instead, it defines `exp2` to be a different expression `quote (succ 1)`, which _evaluates to_
the value that `exp` was bound to before...except that here we've inhibited that
evaluation by quoting this expression.


## 7. The function eval ##

Strings aside, applying the function `eval` to an expression evaluates to the value that expression evaluates to.
In other words, this function removes one layer of evaluation-inhibition, that may have been introduced by quoting:

```
> let exp = quote (succ 1);
> exp; // what is the expression `succ 1`?
succ 1
> eval exp; // what does it evaluate to?
2
> let exp2 = quote (quote (succ 1));
> exp2; // what is the expression `quote (succ 1)`?
quote (succ 1)
> eval exp2; // what does it evaluate to?
succ 1
> exp === eval exp2; // this is the same expression that exp is bound to
1
> eval (eval exp2); // and we know what THAT evaluates to
2
```

But this function handles strings differently. First, note that strings like numbers also evaluate to themselves:

```
> "hello";
"hello"
> "hello" === quote "hello";
1
```

However, something else you might do with a string---besides evaluate it---is
treat is as bit of Pure source text, that is, to _parse it_ into a Pure
expression. Doing that one of several roles of the `val` function. And after parsing
a string like `"hello"` into the Pure symbol `hello`, one might then go
on to _evaluate the latter_ ---to get either itself (if it's unbound), or some
value that it's globally bound to.

```
> let hello = 1; // give the symbol a global variable binding
> let exp = val "hello";
> exp, "hello";
hello, "hello" // one is a symbol, the other a string
> eval exp;
1
> eval exp when hello = 2 end; // when evaluating the symbol, local bindings are ignored
1
> eval (val "hello") when hello = 2 end; // here too
1
```

And now what's confusing is this. The function `eval` when applied to a string
_doesn't_ simply evaluate the string (returning the same string). Instead, it
applies `val` to the string, obtaining a parsed Pure expression, _and then_ evaluates
_that expression_. So:

```
> let hello = 1;
> eval "hello";
1
```

I see no objection to there being a function which performs
both of these steps; but arguably it would be clearer if that weren't the
behavior of the function named `eval`---since, as we saw, strings are
syntactically identical to their own quotations and hence, speaking accurately,
evaluate to themselves. It'd be better to call the function which did these things
"parse\_and\_eval" or something like that.

Many other languages overload the function `eval` in the same way Pure does.


## 8. Substitutions ##

When you use `val` to parse a string, the expressions created ignore all symbol bindings, both global and local:

```
> let v = 3; const c = 3; def m = 3; n = 3;
> let res = val "v,c,m,n" when v=4; c=4 end with n = 4 end;
> res; // note that the global and local bindings for v,c,m, and n are all ignored
v,c,m,n
> let v = 5;
> eval res; // however, if we evaluate the generated expressions, then global bindings are honored
5,3,3,3
> clear c m n
> const c = 5; def m = 5; n = 5;
> eval res;
5,5,5,5
```

(They also ignore what namespace is open; see section 10.)

With `quote` forms, on the other hand, the expressions are open to substitution
of local variables. Only the evaluation of global bindings (here, the
bindings for `y` and `succ`) are ignored:

```
> let y = 1;
> '(y, succ x) when x = pred 1 end;
y, succ 0
```



## 9. Symbolic patterns and pattern variables ##

Syntactically, **patterns** look just like simple expressions---that is, any Pure
expression that's eligible to be the argument of an operator. This includes
applications but excludes `case` and `when` constructs and the like, unless
they're enclosed in parentheses.

Semantically, though, patterns are interpreted differently than ordinary
expressions. We'll set aside the interpretation of parenthesized `case`
constructs and the like until we get to macros. Among the rest of the pattern
elements, these will always be interpreted either as _symbols_ or as _pattern
variables_. The variable `_` has a special role which you should know about,
but which we won't discuss here. Nor will we discuss as-variables or type-tags
in patterns; though you should also learn about these. Instead, we'll focus on
when pattern elements are interpreted as symbols and when as pattern variables.

In the following `case` expression:

```
case x of
    succ pred = 1;
end;
```

there is one rule and its pattern is expressed by `succ pred`. In this pattern,
the symbol `succ` occurs symbolically and the symbol `pred` occurs as a pattern
variable. We'll discuss why in a moment. This pattern also has a certain
structure: to match it, a value has to consist of two expressions applied to
each other, where the left-hand component matches the symbolic pattern `succ` and the
right-hand component can be anything, and will be bound to the variable `pred`
when evaluating the rhs of the rule.

Now one kind of thing that will match the symbolic pattern element `succ` is the symbol `succ` itself. So this will return `x`, not 0:

```
let x = 1;
case 'succ x of // same as '(succ x)
    succ pred = pred;
    _ = 0; // for everything that doesn't match the first rule
end;
```

Note what value we're presenting to be pattern-matched: not the result of
_evaluating_ `succ x`, which would be just `2` and so wouldn't even have the
right structure to match the first rule. Rather, we're presenting _the unevaluated expression_
`succ x` itself, which is the result of evaluating the quotation form `'succ x`. The left-hand
component of this expression is the symbol `succ`, and this matches the symbol `succ` in the pattern.
The right-hand component of this expression is the symbol `x`, and this is bound to the pattern
variable `pred`. Then the rhs of the rule is evaluated, and we get the symbol `x`, since that's what
`pred` was locally bound to. Note that we don't get `1`, because we never presented `1` to be pattern-matched.
If on the other hand we had done this:

```
let x = 1;
case ('succ) x of
    succ pred = pred;
    _ = 0;
end;
```

then `x` would have been evaluated to `1` as we built up the value to be pattern matched. So in this case, we'd be
pattern-matching the expression `succ 1`, rather than the expression `succ x`. And here `pred` would be bound to `1`, and that's the
result that the whole `case` expression would return.

So one thing we've observed is that the symbol `succ` in a value matches
against a symbolic pattern expressed by the same symbol. Other symbol values
_won't_ match that symbolic pattern.

Of course, Pure's notion of "the same symbol" is somewhat subtle; see section 10.
But we won't bother with the details about this. We'll just note the general point
that it's not always straightforward when two token lexemes are parsed as occurrences of
the same symbol.

As I said, we've observed that the symbol `succ` in a value matches that same symbol in
a pattern, and other symbols won't. But it's not the case that _nothing_ else
matches that symbolic pattern. A _named function_ defined using the name `succ` will
_also_ match the symbolic pattern `succ`. Notice:

```
> clear succ
> succ x::number = x + 1; // for purposes of this example, we restrict succ's definition to numbers
> let v = succ ('nonsense); // we prevent succ from reducing not by quoting it
>                           // but by giving it an argument for which no reduction rule applies
> case v of
>   s@_ pred = (s === 'succ, s 1, ('succ) 1)
> end;
0,2,succ 1
> case v of
>     succ pred = pred;
>     _ = 0; // for everything that doesn't match the first rule
> end;
nonsense
```

Here the value we're presenting to be pattern matched has as a left-hand
component not _the symbol_ `succ` but rather a named function. This is
demonstrated by the first `case` block: the matched head is not `===` to the
symbol `succ`, and the result of applying it to `1` is `2`, whereas the result
of applying the unevaluated symbol `succ` to `1` is the unevaluated expression
`succ 1`.

However, as the second `case` block demonstrates, the value we're presenting to
be pattern matched _does_ also match against the pattern `succ pred`, just as
the unevaluated expressions `succ x` and `succ 1` did in the previous examples.
So the symbolic pattern `succ` matches _both_ the symbol `succ` itself,
and _also_ the named function that symbol `succ` is bound to, by global
rules in the standard library.

We will discuss this further in section 11.

For now, we will attend to the question of why `succ` is interpreted
symbolically in the pattern `succ pred`, but `pred` is interpreted as a pattern
variable. When is a symbol interpreted the one way, and when another?

In a pattern, _operators_ are always interpreted symbolically:

```
> case '(-) of (+) = 1; (-) = 2; _ = 100; end;
2
```

We have to enclose the `+` and `-` in parentheses here to satisfy the parser that we're not
trying to use them in their usual infix positions. I specify that what I want to be pattern
matched is the symbol `-` by referring to that symbol with the quotation form `'(-)`. As we just noted,
sometimes the named functions bound to a symbol will also match that symbol too; so we could here
also have presented the function `(-)` to be matched, and also gotten the result `2`.
But for now we will focus on cases where we only match symbols against symbols. That is
the most straightforward and easily understood matching behavior.

_Identifiers_ other than `_` also sometimes occur symbolically in patterns, but only in certain
cases: they do so when in head positions, or when they have explicit namespace qualifiers.

So in the following:

```
infix (+) gamma;
nonfix delta;
case x of
    _ (gamma) = 1; // infix operator, though not in head position
    _ delta = 2;   // nonfix operator
    zeta _ = 3;    // identifier in head position
    ::eta = 4;     // identifier with (toplevel) namespace qualifier
    _ theta = 5;
    kappa = 6;
end;
```

all of `gamma`, `delta`, `zeta`, and `eta` are interpreted symbolically in their respective
patterns. The identifiers `theta` and `kappa` on the other hand are interpreted as
_pattern variables_. The pattern `_ theta`
will match _any_ undreduced application, not just one whose argument is the
symbol `theta`. And the pattern `kappa` will match any value that hasn't
already been matched.

I said that `gamma` through `eta` are interpreted symbolically.
But alternatively, if any of them are both _bound as a const_ and also _declared as operators_ (this will only
be jointly possible if they are declared as nonfix operators), then they
contribute _not_ their own symbolic expression but _rather_ the normal form syntax of the values they were definitionally bound to.
So this:

```
const delta = [mu];
const mu = 0;
nonfix delta mu; // now delta and mu are both const and nonfix
foo x = case x of
    delta = 2;
end;
```

is equivalent to:

```
nonfix mu;
foo x = case x of
    [mu] = 2;
end;
```

Note that the pattern `[mu]` here contains the symbol `mu`, not
a pattern variable. Note also that `[mu]` in that pattern doesn't get
substituted with the value `0` that symbol `mu` is bound to in the
original example---even though `mu` there also has a
nonfix const binding. Rather, the symbolic expression that `delta` was bound to
_when its definition was evaluated_ is what has to be matched:

```
> const delta = [mu];
> const mu = 0;
> nonfix delta mu;
> foo x = case x of
>     delta = 2;
>     _ = 100;
> end;
> foo [0];
100
> foo [mu]; // same as previous
100
> foo ['mu];
2
```

When `delta`'s definition was evaluated, `mu` was a literal unbound
symbol---which we now have to refer to with `'mu`. (We could also have used
`delta`.)

For more about this behavior of const nonfixes, see
[ConstsAndThunks](http://code.google.com/p/pure-lang/wiki/ConstsAndThunks#Difference_between_global_variables,_consts,_nullary_macros).


## 10. Namespaces ##

Pure's notion of "the same symbol" is somewhat subtle; it's not the same as just _looking like_ the same symbol.

First, unbound or quoted identifiers from different namespaces count as syntactically distinct, and don't pattern match each other:

```
> namespace one; public x;
> namespace two; public x;
> namespace three; let x = 1;
> namespace;
> one::x === two::x;
0
> one::x === 'three::x;
0
> case one::x 0 of x _ = 1; two::x _ = 2; _ = 0 end;
0
```

Second, the function `val` parses strings into expressions, which may include symbols, but these symbols (if unqualified in the string) will always inhabit the default namespace,
no matter what namespace is then open. Quotation forms, on the other hand, evaluate to symbols inhabiting the current namespace:

```
> namespace one;
> 'x;
one::x
> 'x === val "x";
0
> '::x === val "x";
1
```

Here is an illustration of some other nooks and crannies:

```
> // here y gets bound to a different symbol x than is used later in the namespace
> namespace four; const y = x; let x = 1;
> y, y === 'x;
x,0
> // but not if we predeclare symbol x
> namespace five; public x; const y = x; let x = 1;
> y, y === 'x;
five::x,1
```


## 11. Matching named functions ##

There is a difference between the kinds of
function values created by lambda expressions and the "named functions" created by global or
local rules. The latter remember what symbols they were defined with, and will
subsequently pattern match against those symbols---even though they are
syntactically distinct from any symbol.

```
> // because they're in head positions, alpha and beta in the following patterns
> // are interpreted symbolically
> bar x = case x of (alpha _) = 1; (beta _) = 2; _ = 0 end;
>
> // here we bind sym to the symbol 'beta, and bind that symbol to an anonymous closure
> // only the symbol itself, not the closure it evaluates to, matches against the patterns in bar
> bar (sym 4), bar (beta 4) when sym = 'beta; beta = \x y -> x + y end;
1,0

> // here we bind sym to the symbol 'alpha, and bind that symbol to a named function
> // notice that the named function DOES also match against the patterns in bar
> bar (sym 4), bar (alpha 4) with alpha x y = x + y end when sym = 'alpha end;
1,1,0
> sym === alpha with alpha x y = x + y end when sym = 'alpha end;
0
```

The behavior here of the lambda-generated closure `beta` is straightforward, and is the same as
we see with variables. If a variable `x` is bound to the number `0`, then it matches against `0` and not
against the literal symbol `x`:

```
> let x = 0;
> case x of
>    ::x = 1; // one way of including the symbol x literally in the pattern
>    0 = 2;
>    _ = 3;
> end;
2
> case x 5 of
>    x _ = 1; // another way to include the symbol x literally, as an applied head
>    0 5 = 2;
>    _ = 3;
> end;
2
```

The closure `beta` works the same way. The function value it refers to doesn't pattern-match against
the symbol `beta`.

The behavior of the named function `alpha`, on the other hand, may be surprising. That function
_does_ pattern match against the symbolic pattern `alpha`. And yet at the same time it is not syntactically
identical to that symbol: observe that `sym === alpha` evaluates false.

During pattern-matching, _neither_ the named function `alpha` nor
the envaluated symbol `alpha` are being cast into the other, by quotation or
evaluation:

```
> foo x = case x of f@(alpha _) = f 1; _ = 2 end;
> foo (sym 3), foo (alpha 3) with alpha x y = x + y end when sym = 'alpha end;
alpha 3 1,4
> // when foo's rhs `f 1` is evaluated with `f` bound to the result of `sym 3`,
> //   the head is oversaturated and doesn't reduce
> // whereas when `f` is bound to the result of `alpha 3`,
> //   the head is unsaturated and applying it to the argument 1 reduces to 4
```

Relatedly, the function `alpha` typechecks as satisfying _both_ of the
types `var` and `fun`---and so also `var`'s supertype `symbol` and `fun`'s
supertypes `closure` and `function`. Whereas the unevaluated symbol `alpha`
will _only_ typecheck against `var` and `symbol`. And of these types, the
anonymous closure `beta` will _only_ typecheck against `closure` and
`function`.

So the named function `alpha` is _both_ a symbol and a function---though it is syntatically
distinct from the unevaluated/quoted symbol `alpha`.


With the matching behavior described here, one can do things like this:

```
case max 2 of
    max _ = "max";
    min _ = "min";
end;
```

and this:

```
case 1,2 of
  a,b = a;
  _ = throw failed;
end;
// same as
case (,) 1 2 of
  (,) a b = a;
  _ = throw failed;
end;
```

For the symbols `max` and `,` are bound to named functions, and aren't self-evaluating. If the symbolic
patterns `max` and `,` were restricted to only matching those same _symbols_, the preceding fragments
would no longer work. One would have to do something like this instead:

```
case 'max 2 of
    max _ = "max";
    min _ = "min";
end;
```

Or this:

```
case max 2 of
    head@_ _ = "max" if head === max;
    ...
end;
```

But one can't include function values _literally_ in a pattern:

```
> const clos = \x -> max 2 x;
> nonfix clos;
> foo () = case clos of clos = "max" end;
<stdin>, line 3: pointer or closure not permitted in pattern
```

On the other hand, because there are no rules in the standard library whose head is `:`, that symbol is unbound:

```
> typep (:) function;
0
> (:) === quote (:);
1
```

So this program:

```
case [1] of
  [1] = 1;
  _ = throw failed;
end;
// same as
case (:) 1 [] of
  (:) 1 [] = 1;
  _ = throw failed;
end;
```

does not rely on any matching of a named function.

Here are some oddities that the matching behavior described here makes possible. See [Issue80](https://code.google.com/p/pure-lang/issues/detail?id=80) in the bugtracker:

```
> foo x = case x of max _ = "max"; min _ = "min"; end;
> foo (max 2) with max x y = min x y end;
"max"
> // weird
>
> clear foo
> foo x = case x of
>   1,   max _,   _ = 1;
>   2,   _,       max _ = 2;
>   3,   max _,   max _ = 3;
>   4, f@max _, f@max _ = 4;
>   _ = 0
> end;
> foo (1,max 0,pseudo 0), foo (2,max 0,pseudo 0), foo (3,max 0,pseudo 0), foo (4, max 0, pseudo 0)
>   when pseudo = (max with max x y = x + y end) end;
1,2,3,0
> // so each of max and pseudo match the symbolic pattern max, though they are different named functions
> // and they can even be paired with different occurrences of that pattern in a single match
> // however if a pattern variable is bound to them and repeated, as in the pattern `4, f@max _, f@max _`, then
> // the match will fail since a single value is not matching both pattern elements
```