
=========================================
Gnumeric/Pure: A Pure Plugin for Gnumeric
=========================================

:Author: Albert GrÃ¤f
:Contact: Dr.Graef@t-online.de
:Copyright: Copyright (c) 2009. This software is distributed under the GNU
  Public License V2 or later, see the COPYING file for details.

.. _Gnumeric: http://projects.gnome.org/gnumeric/
.. _Pure: http://pure-lang.googlecode.com/

This package provides a Pure plugin loader and a sample script for use with
Gnumeric_. These work pretty much like the Perl and Python plugin loaders
which are distributed with Gnumeric. However, Gnumeric/Pure brings some
features to the table which aren't found in other Gnumeric scripting plugins:

* Pure is a functional programming language which fits the computational model
  of spreadsheet programs very well.

* Pure is based on term rewriting and thus enables you to do symbolic
  computations in addition to the usual numeric calculations.

* Pure has a built-in MATLAB/Octave-like matrix data structure which makes it
  easy to deal with cell ranges in a spreadsheet in an efficient manner.

* Pure also has built-in support for lazy data structures and thus allows you
  to handle potentially infinite amounts of data such as the list of all prime
  numbers. Gnumeric/Pure lets you turn such lazy values into asynchronous data
  sources computed in the background, which update the spreadsheet
  automatically as results become available.

* Pure is compiled to native code on the fly. This means that, while startup
  times are a bit longer (you'll notice this if you open a spreadsheet using
  Pure functions), the resulting code then typically executes *much* faster
  than equivalent Perl and Python code.

These features turn Pure into a very powerful Gnumeric extension. Adding Pure
functions to Gnumeric is quite easy. Once the plugin is installed and enabled,
you can simply start adding Pure functions to the provided sample
``pure_func.pure`` script, or you can create your own plugin folders with Pure
scripts. Gnumeric/Pure also provides a programming interface which gives you
access to ranges of cells, lets you call other Gnumeric functions from Pure,
and enables you to set up asynchronous data sources. This is all explained in
detail below.

.. contents::
.. sectnum::

Installation
============

Obviously, you need to have both Pure and Gnumeric installed. Pure 0.35 and
Gnumeric >= 0.19.13 are known to work. (Older Gnumeric versions probably work
as well if you're willing to fiddle with the Makefile and/or the sources. See
the beginning of the Makefile for related information.)

As shipped, the Makefile is set up to build Gnumeric/Pure with OpenGL support,
which requires that you have the OpenGL libraries as well as GtkGLExt from
http://gtkglext.sourceforge.net installed. These should be readily available
on most systems, but you can also disable this feature by invoking ``make`` as
``make GLDEPS=``.

Then run ``make``. You might have to adjust the settings at the beginning of
the Makefile to make this work. If you're lucky and the compile goes through,
you should now have a ``pure_loader.so`` file in the ``pure-loader``
subdirectory. You can install the plugin and related stuff with ``sudo make
install`` in the global Gnumeric plugin directory, or if you prefer to install
it into your personal plugin directory then run ``make install-local``
instead.  (We recommend the latter since it lets you adjust ``pure_func.pure``
for your purposes more easily.) Optionally, you might also want to copy the
``gnumeric-pure.html`` file to your Pure library directory so that you can
read it with the ``help`` command of the Pure interpreter or in Emacs Pure
mode.

Typically, ``make install`` and ``make install-local`` will install the
plugins into the following directories by default:

* System-wide installations go into ``/usr/local/gnumeric/1.9.13/plugins`` or
  similar, depending on where Gnumeric is installed.

* User-specific installations go into ``~/.gnumeric/1.9.13/plugins``.

The Makefile tries to guess the installation path and version number of
Gnumeric on its own. If it guesses wrong, you can change these using the
Makefile variables ``prefix`` and ``gnmversion``, respectively. For instance::

  $ make prefix=/usr gnmversion=1.9.13

If ``make install`` doesn't work for some reason, you can also just copy the
``pure-func`` and ``pure-loader`` directories manually to your Gnumeric plugin
directory.

Setup
-----

Once Gnumeric/Pure has been properly installed, you should see it in
Gnumeric's Tools/Plug-ins dialog. As with the Perl and Python plugins, there
are actually two entries, one labelled "Pure functions" and the other one
labelled "Pure plugin loader". You need to enable both before you can start
using Pure functions in your Gnumeric spreadsheets.

Gnumeric doesn't provide much in the way of GUI customization options right
now, but at least it's possible for plugins to install and configure
additional menu and toolbar options. The Pure plugin loader adds three
additional options to the Tools menu which allow you to stop asynchronous data
sources, reload Pure scripts and edit them. After installation, the
definitions of these items can be found in the ``pure-loader/pure-ui.xml``
file in your Gnumeric plugin directory. Have a look at this file and edit is
as desired. E.g., if you want to put the Pure-related options into a submenu
and enable toolbar buttons for these options, then your ``pure-ui.xml`` file
should look as follows::

  <ui>
    <menubar>
      <menu name="Tools" action="MenuTools">
        <separator/>
        <menu name="Pure" action="PureMenu">
          <menuitem action="PureStop"/>
          <menuitem action="PureReload"/>
          <menuitem action="PureEdit"/>
        </menu>
      </menu>
    </menubar>
    <toolbar name="StandardToolbar">
      <separator/>
      <toolitem action="PureStop"/>
      <toolitem action="PureReload"/>
      <toolitem action="PureEdit"/>
    </toolbar>
  </ui>

Basic Usage
===========

With Pure/Gnumeric installed and enabled, you should be ready to join the fun
now. Start up Gnumeric, click on a cell and invoke the "f(x)" dialog. The Pure
functions available for use are shown in the "Pure" category. E.g., click on
``pure_hello``. Now the Pure interpreter will be loaded and the function
description displayed. Click "Insert" and then "Ok". You should now be able to
read the friendly greeting returned by the ``pure_hello`` function.

Of course, you can also enter the function call directly as a formula into a
cell as usual. Click on a cell, then enter the following::

  =pure_hello(getenv("USER"))

The greeting should now be displayed with your login name in it.

Play around a bit with the other Pure functions. These functions are nothing
special; they are just ordinary Pure functions which are defined by the
``pure_func.pure`` script in the ``pure-func`` subdirectory of your Gnumeric
plugin directory. You can have a look at them by invoking the "Edit Pure
Script" option which gets added to the Tools/Pure menu once the Pure plugin
loader is enabled. (This will invoke the emacs editor by default, or the
editor named by the ``EDITOR`` environment variable. You can set this
environment variable in your shell's startup files.) The Tools/Pure menu
contains a second Pure-related option, "Reload Pure Scripts" which can be used
to quickly reload all loaded Pure scripts after edits; more about that later.

Please note that most of the functions in ``pure_func.pure`` are rather
useless, they are only provided for illustrative purposes. However, there are
some useful examples in there, too, in particular:

* ``pure_eval`` lets you evaluate any Pure expression, given as a string in
  its first argument. E.g., try something like ``=pure_eval("foldl (+) 0
  (1..100)")``. Additional parameters are accessible as ``x!0``, ``x!1``,
  etc. For instance: ``=pure_eval("x!0+x!1",A1,B1)``.

* ``pure_echo`` just displays its arguments as a string in Pure syntax, as the
  interpreter sees them. This is useful for debugging purposes. E.g.,
  ``=pure_echo(A1:B10)`` shows the given range as a Pure matrix.

A little example spreadsheet showing the predefined functions in action can be
found in ``pure-examples.gnumeric`` in the Gnumeric/Pure sources.

Defining Your Own Functions
===========================

After playing around with ``pure_func.pure`` for a while, of course you will
want to write your own functions, that's what this plugin is about after all!
For the beginning, you can just add your definitions to the existing
``pure_func.pure`` script. Use the "Edit Pure Script" option to edit the
script in your favourite editor, and see the comments and the examples in the
script for guidance. (This document assumes that you're already familiar with
Pure, if not then you should consult the available Pure documentation.)

Note that if you delete or rename any functions in this file, or add new ones
to it, then you also have to change the list of function names in the
plugin.xml file in the same directory accordingly. This file tells Gnumeric
which functions are provided by the script. Unfortunately, you'll have to
restart Gnumeric to make changes in this file take effect. If you only change
the definition of an existing function then it's usually sufficient to just
invoke "Reload Pure Scripts" afterwards, and maybe run "Recalculate" (``F9``)
to recompute the spreadsheet. However, if you also made changes to the
function descriptions provided via ``gnm_info`` (see the following section for
explanation), then you'll also have to restart Gnumeric so that it picks up
the changes.

Once you understand how this works, you can also create your own plugin
directories with your personal collections of Gnumeric/Pure functions, using
the ``pure-func`` directory as a template. For instance, let's assume that
your Gnumeric/Pure stuff is in a script named ``gnumeric.pure`` under
``/some/path/pure/gnumeric``. The plugin.xml file in that directory might look
as follows::

  <?xml version="1.0" encoding="UTF-8"?>
  <plugin id="Gnumeric_MyPureFunc">
    <information>
      <name>My Pure functions</name>
      <description>My Pure functions for use in Gnumeric.</description>
      <require_explicit_enabling/>
    </information>
    <loader type="Gnumeric_PureLoader:pure">
      <attribute value="gnumeric" name="module_name"/>
    </loader>
    <services>
      <service type="function_group" id="my_pure_func">
        <category>Pure</category>
        <functions>
	  <!-- My Pure functions go here, e.g.: -->
          <function name="my_pure_func"/>
        </functions>
      </service>
    </services>
  </plugin>

The following steps are needed to tell Gnumeric about your new Pure plugin:

* Open the Directories tab in the Tools/Plug-ins dialog and check that the
  ``/some/path/pure`` directory is in your plugin search path. Add it if
  necessary, and restart Gnumeric after that. (Note that you really have to
  add the *parent* directory ``/some/path/pure``, not
  ``/some/path/pure/gnumeric`` itself.)

* The new plugin should now be listed as "My Pure functions" on the Plugin
  List tab in the Tools/Plug-ins dialog. Check it to enable it.

The Pure loader can also load multiple Pure plugins, after creating the
corresponding plugin directories and scripts and telling Gnumeric about
them. Just enable the ones that you want in Tools/Plug-ins. All scripts are
loaded in the same Pure interpreter (and thus are treated like one big script)
so that functions in one script can use the function and variable definitions
in another.

Gnumeric/Pure Interface
=======================

By default, when a Pure function is called from Gnumeric, it receives its
arguments in a list. However, it is possible to tell Gnumeric about the
expected arguments of the function and also specify a help text to be
displayed in the "f(x)" dialog, by giving a definition of the special
``gnm_info`` function as explained below. In further subsections we explain
various other aspects of the Gnumeric/Pure interface that should be useful for
writing your own functions.

Function Descriptions
---------------------

To describe a given function to Gnumeric, define ``gnm_info "<name>"`` (where
``<name>`` is the name of the function) as a pair with the following elements:

* The first element, a string, gives the signature of the function. E.g.,
  ``""`` denotes a function without arguments, ``"f"`` a function taking a
  single float parameter, ``"fs"`` a function taking a float and a string
  argument (in that order), etc. Optional parameters can be indicated using
  ``|``, as in ``"ff|s"`` (two non-optional floats, followed by an optional
  string). See below for a complete list of the supported parameter types.

* The second element is a list of hash pairs ``key=>text`` which together make
  up the help text shown in Gnumeric's "f(x)" dialog. You should at least
  specify the function name along with a short synopsis here, e.g.
  ``GNM_FUNC_HELP_NAME => "frob:the frob function"``. Parameter descriptions
  take the form ``GNM_FUNC_HELP_ARG => "x:integer"``. There are a number of
  other useful elements, see below for details.

Both the signature and the function description are optional. That is,
``gnm_info`` may return either just a signature string, or a list of hash
pairs with the function description, or both. The signature defaults to a
variadic function which takes any number of parameters of any type (see
below), and the description defaults to some boilerplate text which says that
the function hasn't been documented yet.

Note that if no signature is given, then the function accepts any number of
parameters of any type. In that case, or if there are optional parameters, the
function becomes variadic and the (optional) parameters are passed as a Pure
list (in addition to the non-optional parameters).

Here's the list of valid parameter types, as they are documented in the
Gnumeric sources::

    f : float 		no errors, string conversion attempted
    b : boolean		identical to f
    s : string		no errors
    S : scalar		any non-error scalar
    E : scalar		any scalar, including errors

    r : cell range	content may not be evaluated yet
    A : area		array, range (as above), or scalar
    ? : anything        any value (scalars, non-scalars, errors, whatever)

The keys used in the function description may be any of the following, along
with sample text for each type of field::

    GNM_FUNC_HELP_NAME         => "name:synopsis"
    GNM_FUNC_HELP_ARG	       => "name:parameter description"
    GNM_FUNC_HELP_DESCRIPTION  => "Long description."
    GNM_FUNC_HELP_NOTE	       => "Note."
    GNM_FUNC_HELP_EXAMPLES     => "=sample_formula()"
    GNM_FUNC_HELP_SEEALSO      => "foo,bar,..."

The following keys are only supported in the latest Gnumeric versions::

    GNM_FUNC_HELP_EXTREF       => "wiki:en:Trigonometric_functions"
    GNM_FUNC_HELP_EXCEL	       => "Excel compatibility information."
    GNM_FUNC_HELP_ODF	       => "OpenOffice compatibility information."

Note that inside the descriptions, the notation ``@{arg}`` can be used to
refer to a parameter value. For instance, here's a sample description for a
binary function which also includes a help text::

  gnm_info "pure_max" = "ff",
  [GNM_FUNC_HELP_NAME     => "pure_max:maximum of two numbers",
   GNM_FUNC_HELP_ARG	  => "x:number",
   GNM_FUNC_HELP_ARG	  => "y:number",
   GNM_FUNC_HELP_DESCRIPTION =>
   "Computes the maximum of two numbers @{x} and @{y}.",
   GNM_FUNC_HELP_EXAMPLES => "=pure_max(17,22)"];

As you can see, the function descriptions are a bit unwieldy, so it's
convenient to construct them using this little helper function defined in
``pure_func.pure``::

  gnm_help name::string args descr::string notes examples see_also =
    [GNM_FUNC_HELP_NAME         => name] +
    [GNM_FUNC_HELP_ARG          => x | x::string = args ] +
    [GNM_FUNC_HELP_DESCRIPTION  => descr ] +
    [GNM_FUNC_HELP_NOTE         => x | x::string = notes ] +
    [GNM_FUNC_HELP_EXAMPLES     => x | x::string = examples ] +
    (if null see_also then [] else
     [GNM_FUNC_HELP_SEEALSO     => join "," see_also]);

Now the description can be written as follows::

  gnm_info "pure_max" = "ff", gnm_help "pure_max:maximum of two numbers"
    ["x:number", "y:number"]
    "Computes the maximum of two numbers @{x} and @{y}."
    [] ["=pure_max(17,22)"] [];

Since this function only has fixed arguments, it will be called in curried
form, i.e., as ``pure_max x y``. For instance, the actual definition of
``pure_max`` may look as follows::

  pure_max x y = max x y;

Conversely, if no signature is given, then the function accepts any number of
parameters of any type, which are passed as a list. For instance::

  gnm_info "pure_sum" = gnm_help "pure_sum:sum of a collection of numbers"
    [] "Computes the sum of a collection of numbers."
    [] ["=pure_sum(1,2,3,4,5,6)"] ["pure_sums"];

Here the function will be called as ``pure_sum [x1,x2,...]``, where ``x1``,
``x2``, etc. are the arguments the function is invoked with. Note that in this
case there may be any number of arguments (including zero) of any type, so
your function definition must be prepared to handle this. If a function does
not have a ``gnm_info`` description at all then it is treated in the same
fashion. The ``pure_func.pure`` script contains some examples showing how to
write functions which can deal with any numbers of scalars, arrays or ranges,
see the ``pure_sum`` and ``pure_sums`` examples. These employ the following
``ranges`` function to "flatten" a parameter list to a list holding all
denoted values::

  ranges xs = cat [ case x of _::matrix = list x; _ = [x] end | x = xs ];

E.g., the ``pure_sum`` function can now be defined as follows::

  pure_sum xs = foldl (+) 0 (ranges xs);

A function may also have both fixed and optional arguments (note that in what
follows we're going to omit the detailed function descriptions for brevity)::

  gnm_info "foo" = "ff|ff";

In this case the fixed arguments are passed in curried form as usual, while
the optional parameters are passed as a list. That is, ``foo`` may be called
as ``foo x y []``, ``foo x y [z]`` or ``foo x y [z,t]``, depending on whether
it is invoked with two, three or four arguments.

Conversions Between Pure and Gnumeric Values
--------------------------------------------

The marshalling of types between Gnumeric and Pure is pretty straightforward;
basically, Pure numbers, strings and matrices map to Gnumeric numbers, strings
and arrays, respectively. The following table summarizes the available
conversions:

===============================    ===============================
Pure                               Gnumeric
===============================    ===============================
``gnm_error "#N/A"``               error
``4711``, ``4711L``, ``4711.0``    scalar (number)
``"Hello world"``                  string
``()``                             empty
``(1,2,3)``                        array
``[1,2,3]``                        array
``{1,2,3;4,5,6}``                  array (or cell range)
``"A1:B10"``                       cell range (``"r"`` conversion)
===============================    ===============================

These conversions mostly work both ways. Note that on input, cell ranges are
usually passed as matrices to Pure functions (i.e., they are passed "by
value"), unless the function signature specifies a ``"r"`` conversion in which
case the cell ranges themselves are passed to the function in string from.
(Such values can also be passed on to Gnumeric functions which expect a cell
range (``"r"`` ) parameter, see `Calling Gnumeric from Pure`_ below.)

Conversely, matrices, lists and tuples all become Gnumeric arrays on output,
so usually you'll want to enter these as array functions (``Ctrl-Shift-Enter``
in Gnumeric). As a special case, the empty tuple can be used to denote empty
cell values (but note that empty Gnumeric values may become zeros when passed
as float or array arguments to Pure functions).

If a Pure function returns a value that doesn't match any of the above then it
is converted to a string in Pure expression syntax and that string is returned
as the result of the function invocation in Gnumeric. This makes it possible
to return any kind of symbolic Pure value, but note that if such a value is
then fed into another Pure function, that function will have to convert the
string value back to the internal representation if needed; this can be done
very conveniently using Pure's ``eval`` function, see the Pure documentation
for details.

Calling Gnumeric from Pure
--------------------------

It is also possible to call Gnumeric functions from Pure using the
``pure_gnmcall`` function which takes the name of the function (a string) as
its first, and the parameters as the second (list) argument. For instance::

  gnm_info "gnm_bitand" = "ff";
  gnm_bitand x y = pure_gnmcall "bitand" [x,y];

Note that ``pure_gnmcall`` is an external C function provided by the Pure
loader. If you want to use it, it must be declared in your Pure script as
follows::

  extern expr* pure_gnmcall(char* name, expr* args);

Also note that ``pure_gnmcall`` doesn't do any of Gnumeric's automatic
conversions on the parameters, so you have to pass the proper types of
arguments as required by the function.

Asynchronous Data Sources
-------------------------

Gnumeric/Pure makes it easy to set up asynchronous data sources which draw
values from a Pure computation executed in a background process. This facility
is useful to carry out lengthy computations in the background while you can
continue to work with your spreadsheet. It also allows you to process incoming
data and asynchronous events from special devices (MIDI, sensors, stock
tickers, etc.) in (soft) realtime.

To do this, you simply pass an expression to the ``pure_datasource``
function. This is another external C function provided by the Pure loader,
which is declared in your Pure scripts as follows::

  extern expr* pure_datasource(expr* x);

The argument to ``pure_datasource`` is typically a thunk or stream (lazy list)
which is to be evaluated in the background. The call to ``pure_datasource``
initially returns a ``#N/A`` value (``gnm_error "#N/A"``) while the
computation is still in progress. The cell containing the data source gets
updated automatically as soon as the value becomes available, with
``pure_datasource`` now returning the computed value. E.g., here's how you
would wrap up a lengthy calculation as a thunk and submit it to
``pure_datasource`` which carries out the computation as a background task::

  gnm_info "pure_frob" = "f";
  pure_frob x = pure_datasource (lengthy_calculation x&);
  lengthy_calculation x = sleep 3 $$ foldl (*) 1 (1..x);

Note that a cell value may draw values from as many independent data sources
as you want, so the definition of a cell may also involve multiple invocations
of ``pure_datasource``::

  gnm_info "pure_frob2" = "ff";
  pure_frob2 x y = pure_datasource (lengthy_calculation x&),
    pure_datasource (lengthy_calculation y&);

In the case of a (lazy) list, ``pure_datasource`` returns a new value each
time the next list element becomes available. For instance, the following
function uses an infinite stream to count off the seconds starting from a
given initial value::

  gnm_info "pure_counter" = "f";
  pure_counter x = pure_datasource [sleep (i>x) $$ i | i = x..inf];

Note that in this case the cell containing the call will keep changing as long
as new values are produced (i.e., forever in the above example). The "Stop
Data Sources" option in the Tools/Pure menu can be used to stop all active
data sources. "Reload Pure Scripts" also does this. You can then restart the
data sources at any time by using "Recalculate" (``F9``) to recompute the
spreadsheet.

Also note that because of the special way that ``pure_datasource`` handles
list values, you cannot return a list directly as the result of
``pure_datasource``; instead, you'll have to wrap the result in a singleton
list (``pure_datasource [[lengthy_calculation x,lengthy_calculation y]&]``),
or return another aggregate (i.e., a matrix or a tuple).

Finally, note that when the arguments of a call involving ``pure_datasource``
change (because they depend on other cells which may have been updated), the
computation is automatically restarted with the new parameters. The default
behaviour in this case is that the entire computation will be redone from
scratch, but it's also possible to wrap up calls to ``pure_datasource`` in a
manner which enables more elaborate communication between Gnumeric and
background tasks initiated with ``pure_datasource``. This is beyond the scope
of this manual, however, so we leave this as an exercise to the interested
reader.
