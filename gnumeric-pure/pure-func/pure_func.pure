
using system;

/* Gnumeric error values. */

public gnm_error;

/* Externals provided by the Pure plugin loader. pure-gnmcall lets you call a
   Gnumeric function from Pure, and pure_datasource creates an asynchronous
   data source from a Pure expression. See the gnm_bitand and pure_counter
   examples below. */

extern expr* pure_gnmcall(char* name, expr* args);
extern expr* pure_datasource(expr* x);

/* Gnumeric function descriptions. These are optional, but needed if you want
   to tell Gnumeric about the parameters the function is to be invoked with,
   and/or the help text to be displayed for the function.

   To describe a given function to Gnumeric, all you have to do is to define
   gnm_info "<name>" (where <name> is the name of the function) as either:

   - A pair of strings. The first string gives the parameter types (e.g., "f"
     for a single float parameter), the second one is a list of parameter
     names (e.g., "x,y,z"). Optional parameters can be indicated using '|', as
     in "ff|s" (two non-optional floats, followed by an optional string).

   - Just a help string, in the format indicated below.

   - Both parameter types/names and help string, as a triple.

   Here's the list of valid parameter types, straight from the
   writing-functions.sgml file in the Gnumeric sources.

    b : boolean		identical to f
    f : float 		no errors, string conversion attempted, blanks
			converted to int 0
    s : string		no errors, blanks accepted and passed as empty
    S : scalar		any scalar non-error, blanks passed as empty
    E : scalar		any scalar non blank value
    B : scalar		any scalar even a blank

    r : cell range	content is _NOT_ guaranteed to have been evaluated yet
    A : area		array, range, (range as above), or scalar
    a : array
    ? : anything

   Marshalling between Gnumeric and Pure values is pretty straightforward:

   Pure                   Gnumeric
   -------------------    -------------------------------
   gnm_error msg          error
   ()                     empty
   4711, 4711L, 4711.0    scalar (number)
   "Hello world"          string
   [1,2,3]                array
   {1,2,3;4,5,6}          array (or cell range)

   Note that on input, cell ranges are always passed as matrices to Pure
   functions (not the cell references themselves). Conversely, both matrices
   and lists become Gnumeric arrays on output. The empty tuple can be used to
   denote empty Gnumeric values.

   If no parameter types/names are given, then the function accepts any number
   of parameters of any type, so your function definition must be prepared to
   handle that. In that case, or if there are optional parameters, the
   function becomes *variadic* and the (optional) parameters are passed as a
   Pure list (in addition to the non-optional parameters).

   See below for some examples. Note that if no description is given then the
   function defaults to variadic and no help text will be available. */

gnm_info "pure_hello" = "|s", "name", sprintf "@FUNCTION=pure_hello\n\
@SYNTAX=pure_hello(name)\n\
@DESCRIPTION=\
This function demonstrates the Gnumeric/Pure interface. The function takes an optional string parameter @name. It formats a little text and returns it as a string.\n\n\
* Gnumeric/Pure is (c) 2009 by Albert GrÃ¤f, distributed under the GPL V3.\n\
* You're running Pure version %s.\n"
version;

gnm_info "pure_max" = "ff", "x,y", "@FUNCTION=pure_max\n\
@SYNTAX=pure_max(x,y)\n\
@DESCRIPTION=\
Computes the maximum of two numbers @x and @y. This is an example of a function of fixed arity, where arguments are passed in curried form.\n";

gnm_info "pure_sum" = "@FUNCTION=pure_sum\n\
@SYNTAX=pure_sum(...)\n\
@DESCRIPTION=\
Computes the sum of a collection of numbers, using Pure's foldl. Takes any number of scalars or ranges as parameters. This is an example of a variadic function, where arguments are passed as a Pure list.\n";

gnm_info "pure_sums" = "@FUNCTION=pure_sums\n\
@SYNTAX=pure_sums(...)\n\
@DESCRIPTION=\
Computes the partial sums of a collection of numbers, using Pure's scanl. Takes any number of scalars or ranges as parameters. Returns a Pure list of the results, which becomes an array in Gnumeric land, so you'll have to enter this as an array function.\n";

gnm_info "pure_echo" = "@FUNCTION=pure_echo\n\
@SYNTAX=pure_echo(...)\n\
@DESCRIPTION=\
This simply echoes all given arguments as a string in Pure syntax, as Pure sees them. Useful for debugging purposes.\n";

gnm_info "pure_eval" = "@FUNCTION=pure_eval\n\
@SYNTAX=pure_eval(x,...)\n\
@DESCRIPTION=\
Evaluates a Pure expression, given as a string x. Any remaining parameters are available in the evaluated code as a list 'x', so 'x!0' denotes the first argument, x!1 the second, etc. This lets you evaluate any Pure code in a spreadsheet without first having to define a function for it.\n";

gnm_info "gnm_bitand" = "ff", "x,y", "@FUNCTION=gnm_bitand\n\
@SYNTAX=gnm_bitand(x,y)\n\
@DESCRIPTION=\
Computes the bitwise and of two numbers @x and @y, using the corresponding Gnumeric function. This example shows how to call Gnumeric functions from Pure.\n";

gnm_info "pure_counter" = "f", "start", "@FUNCTION=pure_counter\n\
@SYNTAX=pure_counter(start)\n\
@DESCRIPTION=\
Counts off the seconds, beginning with the given @start value. This example demonstrates the use of an asynchronous data source.\n";

namespace pure_func;

/* Helper function to collect the values in a list of scalars and ranges or
   arrays in a single list. */

private ranges;
ranges xs = cat [ case x of _::matrix = list x; _ = [x] end | x = xs ];

/* The actual Pure function definitions. These must match the descriptions
   given above. */

pure_hello []  = sprintf "Hi Gnumeric, this is Pure %s." version;
pure_hello [s] = sprintf "Hi %s, this is Pure %s." (s,version);

pure_max x y = max x y;
pure_sum xs = foldl (+) 0 (ranges xs);
pure_sums xs = scanl (+) 0 (ranges xs);

pure_echo xs = str $ tuple xs;

pure_eval (s::string:args) =
  case eval (sprintf "'[%s]" s) of
    [y] = eval (reduce y) with x = args end;
    _ = throw "pure_eval: syntax error";
  end;

/* This example shows how to call Gnumeric functions from Pure, using the
   pure_gnmcall external defined in the Pure plugin loader. The arguments must
   be given as a list of Pure expressions which can be converted to Gnumeric
   values ((), numbers, strings, lists and matrices). */

gnm_bitand x y = pure_gnmcall "bitand" [x,y];

/* It is also possible to create external data sources using the
   pure_datasource external defined in the Pure plugin loader. The argument to
   pure_datasource is usually a thunk or a Pure stream (lazy list), which is
   evaluated asynchronously in a separate process. The resulting Pure values
   are fed back to Gnumeric as results of the pure_datasource call, as they
   become available. #N/A is returned when no result is available yet. The
   following example shows how to use this function, by counting off seconds
   starting from a given initial value. */

pure_counter x = y
  when y = pure_datasource [count i | i = x..inf] end
  with count i = if i>x then sleep 1 $$ i else i end;

namespace;

/* Just add your own definitions below. (You also have to add the function
   names to plugin.xml to have them show up in Gnumeric.) */
