
using system;

/* Gnumeric error values. */

public gnm_error;

/* Externals provided by the Pure plugin loader. pure-gnmcall lets you call a
   Gnumeric function from Pure, and pure_datasource creates an asynchronous
   data source from a Pure expression. See the gnm_bitand and pure_counter
   examples below. */

extern expr* pure_gnmcall(char* name, expr* args);
extern expr* pure_datasource(expr* x);

/* Gnumeric function descriptions. These are optional, but needed if you want
   to tell Gnumeric about the parameters the function is to be invoked with,
   and/or the help text to be displayed for the function. See below for some
   examples.

   To describe a given function to Gnumeric, you define gnm_info "<name>"
   (where <name> is the name of the function) as a pair with the following
   elements:

   - The first element, a string, gives the signature of the function. E.g.,
     "f" denotes a function taking a single float parameter, "fs" a function
     taking a float and a string argument (in that order), etc. Optional
     parameters can be indicated using '|', as in "ff|s" (two non-optional
     floats, followed by an optional string). See the Gnumeric/Pure
     documentation for a complete list of the supported parameter types.

   - The second element is a list of hash pairs key=>text which together make
     up the help text shown in Gnumeric's f(x) dialog. You should at least
     specify the function name along with a short synopsis here, e.g.
     GNM_FUNC_HELP_NAME => "frob:the frob function". Parameter descriptions
     take the form GNM_FUNC_HELP_ARG => "x:integer". There are a number of
     other useful elements, see the Gnumeric/Pure documentation for details.

   Both the signature and the function description are optional. The signature
   defaults to a variadic function which takes any number of parameters of any
   type (see below), and the description defaults to some boilerplate text
   which says that the function hasn't been documented yet.

   Note that if no signature is given, then the function accepts any number of
   parameters of any type, so your function definition must be prepared to
   handle that. In that case, or if there are optional parameters, the
   function becomes variadic and the (optional) parameters are passed as a
   Pure list (in addition to the non-optional parameters). */

// Here's a boilerplate for the function description:
[GNM_FUNC_HELP_NAME	=> "name:synopsis",
 GNM_FUNC_HELP_ARG	=> "name:description",
 GNM_FUNC_HELP_DESCRIPTION =>
 "Long description.",
 GNM_FUNC_HELP_EXAMPLES	=> "=sample_formula()",
 GNM_FUNC_HELP_SEEALSO	=> "foo,bar"];

gnm_info "pure_hello" = "|s",
[GNM_FUNC_HELP_NAME	=> "pure_hello:Welcome to Gnumeric/Pure!",
 GNM_FUNC_HELP_ARG	=> "name:a string",
 GNM_FUNC_HELP_DESCRIPTION =>
 "This function demonstrates the Gnumeric/Pure interface. The function takes an optional string parameter @{name}. It formats a little text and returns it as a string.",
 GNM_FUNC_HELP_NOTE	=> sprintf "You're running Pure version %s." version,
 GNM_FUNC_HELP_EXAMPLES	=> "=pure_hello()",
 GNM_FUNC_HELP_EXAMPLES	=> "=pure_hello(\"Kilroy\")"];

gnm_info "pure_max" = "ff",
[GNM_FUNC_HELP_NAME	=> "pure_max:maximum of two numbers",
 GNM_FUNC_HELP_ARG	=> "x:number",
 GNM_FUNC_HELP_ARG	=> "y:number",
 GNM_FUNC_HELP_DESCRIPTION =>
 "Computes the maximum of two numbers @{x} and @{y}. This is an example of a function of fixed arity, where arguments are passed in curried form.",
 GNM_FUNC_HELP_EXAMPLES	=> "=pure_max(17,22)"];

gnm_info "pure_sum" = 
[GNM_FUNC_HELP_NAME	=> "pure_sum:sum a collection of numbers",
 GNM_FUNC_HELP_DESCRIPTION =>
 "Computes the sum of a collection of numbers, using Pure's foldl. Takes any number of scalars or ranges as parameters. This is an example of a variadic function, where arguments are passed as a Pure list.",
 GNM_FUNC_HELP_EXAMPLES	=> "=pure_sum(1,2,3,4,5,6)",
 GNM_FUNC_HELP_SEEALSO	=> "pure_sums"];

gnm_info "pure_sums" = 
[GNM_FUNC_HELP_NAME	=> "pure_sum:partial sums of a collection of numbers",
 GNM_FUNC_HELP_DESCRIPTION =>
 "Computes the partial sums of a collection of numbers, using Pure's scanl. Takes any number of scalars or ranges as parameters. Returns a Pure list of the results, which becomes an array in Gnumeric land, so you'll have to enter this as an array function.",
 GNM_FUNC_HELP_EXAMPLES	=> "=pure_sums(1,2,3,4,5,6)",
 GNM_FUNC_HELP_SEEALSO	=> "pure_sum"];

gnm_info "pure_echo" = 
[GNM_FUNC_HELP_NAME	=> "pure_echo:echo all given arguments",
 GNM_FUNC_HELP_DESCRIPTION =>
 "This simply echoes all given arguments as a string in Pure syntax, as Pure sees them. Useful for debugging purposes.",
 GNM_FUNC_HELP_EXAMPLES	=> "=pure_echo(4711,\"abc\")"];

gnm_info "pure_eval" = 
[GNM_FUNC_HELP_NAME	=> "pure_eval:evaluate a Pure expression",
 GNM_FUNC_HELP_ARG	=> "s:string",
 GNM_FUNC_HELP_DESCRIPTION =>
 "Evaluates a Pure expression, given as a string @{s}. Any remaining parameters are available in the evaluated code as a list x, so x!0 denotes the first argument, x!1 the second, etc. This lets you evaluate any Pure code in a spreadsheet without first having to define a function for it.",
 GNM_FUNC_HELP_EXAMPLES	=> "=pure_eval(\"foldl (*) 1 (1..10)\")",
 GNM_FUNC_HELP_EXAMPLES	=> "=pure_eval(\"x!0*x!1\",2,3)",
 GNM_FUNC_HELP_SEEALSO	=> "pure_calc"];

gnm_info "gnm_bitand" = "ff",
[GNM_FUNC_HELP_NAME	=> "gnm_bitand:bitwise and",
 GNM_FUNC_HELP_ARG	=> "x:non-negative integer",
 GNM_FUNC_HELP_ARG	=> "y:non-negative integer",
 GNM_FUNC_HELP_DESCRIPTION =>
 "Computes the bitwise and of two numbers @{x} and @{y}, using the corresponding Gnumeric function. This example shows how to call Gnumeric functions from Pure.",
 GNM_FUNC_HELP_EXAMPLES	=> "=gnm_bitand(17,22)"];

gnm_info "pure_calc" = 
[GNM_FUNC_HELP_NAME	=> "pure_calc:evaluate an expression asynchronously",
 GNM_FUNC_HELP_ARG	=> "s:string",
 GNM_FUNC_HELP_DESCRIPTION =>
 "pure_calc evaluates an expression with parameter substitution, like pure_eval, but it uses an asynchronous data source to carry out the calculation as a background task.",
 GNM_FUNC_HELP_SEEALSO	=> "pure_eval,pure_counter"];

gnm_info "pure_counter" = "f",
[GNM_FUNC_HELP_NAME	=> "pure_count:count off the seconds",
 GNM_FUNC_HELP_ARG	=> "start:integer",
 GNM_FUNC_HELP_DESCRIPTION =>
 "Counts off the seconds, beginning with the given @{start} value. This example demonstrates the use of an asynchronous data source which draws values from a Pure stream.",
 GNM_FUNC_HELP_SEEALSO	=> "pure_calc"];

namespace pure_func;

/* Helper function to collect the values in a list of scalars and ranges or
   arrays in a single list. */

private ranges;
ranges xs = cat [ case x of _::matrix = list x; _ = [x] end | x = xs ];

/* The actual Pure function definitions. These must match the descriptions
   given above. */

pure_hello []  = sprintf "Hi Gnumeric, this is Pure %s." version;
pure_hello [s] = sprintf "Hi %s, this is Pure %s." (s,version);

pure_max x y = max x y;
pure_sum xs = foldl (+) 0 (ranges xs);
pure_sums xs = scanl (+) 0 (ranges xs);

pure_echo xs = str $ tuple xs;

pure_eval (s::string:args) =
  case eval (sprintf "'[%s]" s) of
    [y] = eval (reduce y) with x = args end;
    _ = throw "pure_eval: syntax error";
  end;

/* This example shows how to call Gnumeric functions from Pure, using the
   pure_gnmcall external defined in the Pure plugin loader. The arguments must
   be given as a list of Pure expressions which can be converted to Gnumeric
   values ((), numbers, strings, lists and matrices). */

gnm_bitand x y = pure_gnmcall "bitand" [x,y];

/* It is also possible to create external data sources using the
   pure_datasource external defined in the Pure plugin loader. The argument to
   pure_datasource is usually a thunk or a Pure stream (lazy list), which is
   evaluated asynchronously in a separate process. The resulting Pure values
   are fed back to Gnumeric as results of the pure_datasource call, as they
   become available. #N/A is returned when no result is available yet. The
   following example shows how to use this function to carry out a calculation
   wrapped up in a thunk. This works like pure_eval, only that the evaluation
   actually happens in the background. */

pure_calc (s::string:args) =
  case eval (sprintf "'[%s]" s) of
    [y] = pure_datasource $ (eval (reduce y) with x = args end)&;
    _ = throw "pure_eval: syntax error";
  end;

/* Here's another example which counts off the seconds starting from a given
   initial value. */

pure_counter x = pure_datasource [sleep (i>x) $$ i | i = x..inf];

namespace;

/* Just add your own definitions below. (You also have to add the function
   names to plugin.xml to have them show up in Gnumeric.) */
