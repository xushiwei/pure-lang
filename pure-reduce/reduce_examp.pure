
using math, reduce;

// Initialization (this requires the REDUCE image file in the current dir).
reduce::start "reduce.img" {"-v"};

// Examples:

// Differentiation.
simplify $ df ((x+1)^2) x;
simplify $ df ((x+5)^3) x;
simplify $ df ((x-5)^3) x;

// Integration.
simplify $ intg 2 x;
simplify $ intg (x^2) x;
simplify $ intg (x^2.0) x;
simplify $ intg (x^2.09) x;
// This enables rounded results.
reduce::switch "rounded" 1;
simplify $ intg (x^2) x;
simplify $ intg (x^2.09) x;
// Switch back to exact results.
reduce::switch "rounded" 0;
simplify $ intg (sin x) x;
simplify $ intg (exp (2*x) ) x;

// Equation solving.
simplify $ solve (x^2+7) x;
simplify $ solve (x^2+7==17) x;
reduce::switch "rounded" 1;
simplify $ solve (x^2+7==17) x;
reduce::switch "rounded" 0;
simplify $ solve (log(sin(x+3))^5 == 8) x;

// Multiple equations.
let eqs = [3*x + 5*y == -4, 2*x + y == -10];
let sol:_ = simplify $ solve eqs [x, y]; sol;
// Convert the solution to a list of hash pairs.
let sol = [x=>y | x==y = sol]; sol;
// This format is more convenient to check the result with reduce_with.
map (reduce_with sol) eqs;
map (reduce_with sol) [u-v | u==v = eqs];

// Note the inaccuracies. This happens because the x/y terms evaluate to
// inexact (double) results in Pure. We can fix this with the following little
// helper function which translates x/y to x%y terms.
exact (x/y) = x%y;
exact (x@_ y) = 'x y when x = exact x; y = exact y end;
exact x = x otherwise;

let sol = exact sol; sol;
map (reduce_with sol) eqs;

// Matrix examples.
simplify $ mat [1,2] [3,4];
// You can also write:
simplify {1,2;3,4};

// Symbolic matrices.
simplify $ x*{1,2;3,4};
simplify {(x-1)^2/(x+5)};
simplify {(x-1+cos x)^2/(x+5)};

// Determinants and eigenvectors.
simplify $ det {1,2;3,4};
simplify $ det (x*{1,2;3,4});
simplify $ mateigen {2,5;1,0} λ;
simplify $ mateigen (x*{2,5;1,0}) λ;
