/* stlstruct.pure - named field data structures based on stlvecs

Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stlvec, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stlvec distribution package for details.

defstruct and defstruct_code
----------------------------

The defstruct macro is used to define a "stlstruct", a custom data type that
holds arbitrary Pure expressions in named fields. The macro defines a type tag
for the new type, functions to create instances of it and functions for
setting and accessing field values.

    defstruct name_spec field_spec

The name_spec is used to name the custom data structure and to specifiy
whether all of its instances are mutable or immutable. The field_spec names
each field in the structure and optionally specifies the type of the field and
whether the field is readonly or settable. If the custom data structure is
immutable, the "setter functions" generated by defstruct will
"copy-and-write".

The defstruct_code macro is the same as defstruct except that it generates
code and prints it rather than evaluating it.

Examples
--------

    > using stlstruct;

A simple mutable stlstruct type with mutable instances and settable fields.
 
    > stl::defstruct worker {idnum, name, year};
    ()

    > let w = worker {10, "Fred", 2011}; w;
    worker sv{10,"Fred",2011}

    > typep worker w;
    1

    > name w, idnum w, year w;
    "Fred",10,2011

    > set_year w 2010;
    worker sv{10,"Fred",2010}

A type with immutable instances, typed fields and a readonly field.

    > stl::defstruct (person/stl::immutable) 
                     {idnum.int/stl::readonly, name.string, year.int};
    ()
 
    > let p1 = person {20, "Fred", 2011}; p1;
    person csv{20,"Fred",2011}

    > let p2 = person p1; p2;
    person csv{20,"Fred",2011}

    > let p3 = set_year p2 2012; p3;
    person csv{20,"Fred",2012}

    > p2;
    person csv{20,"Fred",2011}

    > set_year p3 "2014"; // fails
    set_year (person csv{20,"Fred",2012}) "2014"

Print the code generated by defstruct. 

    stl::defstruct_code (person/stl::immutable)
    {
     idnum.int/stl::readonly,  //comment
     name.string,              //comment 
     year.int                  //comment
    };

The output looks like this (except that blank lines have been inserted here
for readability).

    type person (person csv::const_stlvec);

    mk_person x = person (const_stlvec $ mkstlvec x 3);
    person xs@{p0:: int,p1:: string,p2:: int} = person (const_stlvec xs);
    person (person csv::stlvec) = person (const_stlvec $ stlvec csv);

    idnum (person sv::stlvec) = sv!0;

    name (person sv::stlvec) = sv!1;
    set_name (person sv::stlvec) x:: string = person (const_stlvec sv1) when
      sv1 = stlvec sv ;
      update sv1 1 x;
    end;

    year (person sv::stlvec) = sv!2;
    set_year (person sv::stlvec) x:: int = person (const_stlvec sv1) when
      sv1 = stlvec sv ;
      update sv1 2 x;
    end;
    ()

Parameter Syntax
----------------

   access_code ::= "stl::readonly" | "stl::settable"

   mutability_code ::= "stl::mutable" | "stl::immutable"

   field ::= identifier [ .typeguard ] [ /access_code ]

   fields ::= field | fields, field

   name_spec ::= identifier | "(" identifier "/" mutability_code ")"

   field_spec ::=  "{" fields "}"

The default values for access_code is "stl::settable", and the default value
for mutability_code is "stl::mutable".

*/

using system, stlvec, stlutil;

namespace stl;

extern int pure_sym(char* s);
extern int atoi(char* s);

def immutable = 0;
def mutable = 1;
def readonly = 0;
def settable = 1;

nonfix struct_error;

type field_def (field_def sv::stlvec);
mk_field_def x = field_def (mkstlvec x 4);
field_def xs@{p0:: string, p1:: string, p2:: string, p3:: int} = 
  field_def (stlvec xs);
fnamespace (field_def sv::stlvec) = sv!0;
fname (field_def sv::stlvec) = sv!1;
ftype (field_def sv::stlvec) = sv!2;
faccess (field_def sv::stlvec) = sv!3;

struct_err msg = throw (struct_error msg);

private parse_field_spec parse_name_spec parse_field_specs eval_code 
        mk_struct_constructors mk_struct_accessors
        mk_struct;

parse_field_spec default_namespace default_access spec = fdef when
  field_pat ="^[[:space:]]*([^ ./]+)(\\.[^ ./]+)?(/[[:digit:]])?$";
  ri = reg_info $ regex field_pat REG_EXTENDED spec 0;
  if #ri <8 then struct_err (sprintf "bad field def: %s" spec) else ();
  qname = ri!3;
  ftype = ri!5;
  faccess_str = ri!7;
  ri = reg_info $ regex "(([^ ./:]+)::)?([^ ./]+)" REG_EXTENDED qname 0;
  fnamespace, fname = ri!5,ri!7;
  fnamespace = if null fnamespace then default_namespace else fnamespace;
  ftype = if ::null ftype then ftype else substr ftype 1 10000;
  faccess = if ::null faccess_str then default_access 
            else atoi (substr faccess_str 1 1000);
  fdef = field_def {fnamespace ,fname, ftype, faccess};
end;

parse_name_spec name_spec = ns, struct_name, faccess ndef when
  ndef = catch err (parse_field_spec "" mutable name_spec);
  null (ftype ndef) || err ();
  ns = fnamespace ndef;
  struct_name = fname ndef;
end with
  err _ = struct_err (sprintf "bad name spec: %s" name_spec); 
end;

parse_field_specs nspace fields_spec = fdefs when
  fss = split "," (substr fields_spec 1 (#fields_spec-2));
  fdefs = map (parse_field_spec nspace settable) fss;
end;

eval_code print code = () when
  if print then puts (code + ";") else eval code;
end;

mk_struct_constructors print ns name is_mutable fdefs = () when
  ftypes = map ftype fdefs;  
  params = join "," $ zipwith mkparam ftypes (0..inf);
  if is_mutable then mk_mutable ftypes params 
  else mk_immutable ftypes params;
end with
  mk_mutable ftypes params = () when
    eval_code print ("type " + qname + " (" + qname + " sv::stlvec)");
    cd = nsq + "mk_" + name + " x = " +
      qname + " (mkstlvec x " + str (#ftypes) + ")";
    eval_code print cd;
    cd = qname + " xs@{" + params + "} = " + qname + " (stlvec xs)";
    eval_code print cd;
    cd = qname + "(" + qname + " sv::stlvec) = " + qname + " (stlvec sv)";
    eval_code print cd;
  end;
  mk_immutable ftypes params = () when
    eval_code print ("type " + qname + " (" + qname + " csv::const_stlvec)");
    cd = nsq + "mk_" + name + " x = " +
      qname + " (const_stlvec $ mkstlvec x " + str (#ftypes) + ")";
    eval_code print cd;
    cd = qname + " xs@{" + params + "} = " + qname + 
      " (const_stlvec xs)";
    eval_code print cd;
    cd = qname + " (" + qname + " sv::stlvec) = " + qname + 
      " (const_stlvec $ stlvec sv)";
    eval_code print cd;
  end;
  mkparam ftype i = sprintf "p%d%s" (i,tguard) when
    tguard = if null ftype then "" else ":: " + ftype;
  end;
end when
  nsq = if null ns then ns else ns + "::";
  qname = nsq + name;
end;

mk_struct_accessors print ns name is_mutable fdefs = mk_a fdefs 0 with
  mk_a [] _ = ();
  mk_a (fdef:rest) ndx = mk_a rest (ndx+1) when
    qfname = ns_qual fdef + fname fdef;
    pure_sym(qfname);
    cd = qfname + " (" + qname + sv_param + ") = sv!" + str ndx;
    eval_code print cd;
    if faccess fdef == readonly then ()
    else if is_mutable then
      eval_code print (mk_mutable_accessor fdef ndx)
    else
      eval_code print (mk_immutable_accessor fdef ndx);
  end;
  mk_mutable_accessor fdef ndx = beg_set fdef +
    " (update sv " + str ndx + " x)";
  mk_immutable_accessor fdef ndx = beg_set fdef +
    " (const_stlvec (update (stlvec sv) " +  (str ndx) + " x))";
  type_guard fd = if null t then t else ":: " + t when t = ftype fd end;
  beg_set fdef = bs when
    setname = ns_qual fdef + "set_" + fname fdef;
    bs = setname + " (" +  qname + sv_param + ") x" + type_guard fdef + " = " + qname;
    pure_sym(setname);
  end;
  ns_qual fd = if null ns then ns else ns + "::";
end when
  qname = if null ns then name else ns + "::" + name;
  sv_param = if is_mutable then " sv::stlvec" else  " sv::const_stlvec";
end;

mk_struct print name_spec field_specs = () when
  nspace, name, is_mutable = parse_name_spec name_spec;
  fdefs = parse_field_specs nspace field_specs;
  mk_struct_constructors print nspace name is_mutable fdefs;
  mk_struct_accessors print nspace name is_mutable fdefs;
end;

::__show__ (x@_ sv::stlvec) = 
  sprintf "%s %s" (str x, tostr (#sv) sv);

def defstruct name fields = 
  mk_struct 0 (str ('name)) (str ('fields));

def defstruct_code name fields = 
  mk_struct 1 (str ('name)) (str ('fields));

