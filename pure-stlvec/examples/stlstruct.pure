/* stlstruct.pure - named field data structures based on stlvecs

Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stlvec, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stlvec distribution package for details.

defstruct and defstruct_code
----------------------------

The defstruct macro is used to define a "stlstruct", a custom data type that
holds arbitrary Pure expressions in named fields. The macro defines a type tag
for the new type, functions to create instances of it and functions for
setting and accessing field values.

    defstruct name_spec field_spec

The name_spec is used to name the custom data structure and to specifiy
whether all of its instances are mutable or immutable. The field_spec names
each field in the structure and optionally specifies the type of the field and
whether the field is readonly or settable. If the custom data structure is
immutable, the "setter functions" generated by defstruct will
"copy-and-write".

The defstruct_code macro is the same as defstruct except that it generates
code and prints it rather than evaluating it.

Examples
--------

    > using stlstruct;

A simple mutable stlstruct type with mutable instances and settable fields.
 
    > stl::defstruct worker {idnum, name, year};
    ()

    > let w = worker {10, "Fred", 2011}; w;
    worker sv{10,"Fred",2011}

    > typep worker w;
    1

    > name w, idnum w, year w;
    "Fred",10,2011

    > set_year w 2010;
    worker sv{10,"Fred",2010}

A type with immutable instances, typed fields and a readonly field.

    > stl::defstruct (person/stl::immutable) 
                     {idnum.int/stl::readonly, name.string, year.int};
    ()
 
    > let p1 = person {20, "Fred", 2011}; p1;
    person csv{20,"Fred",2011}

    > let p2 = person p1; p2;
    person csv{20,"Fred",2011}

    > let p3 = set_year p2 2012; p3;
    person csv{20,"Fred",2012}

    > p2;
    person csv{20,"Fred",2011}

    > set_year p3 "2014"; // fails
    set_year (person csv{20,"Fred",2012}) "2014"

Print the code generated by defstruct.

    stl::defstruct_code (person/stl::immutable)
                        {idnum.int/stl::readonly, name.string, year.int};
    type person (person csv::const_stlvec);
    mk_person x = person (const_stlvec $ mkstlvec x 3);
    person xs@{p0:: int,p1:: string,p2:: int} = person (const_stlvec xs);
    person (person csv::stlvec) = person (const_stlvec $ stlvec csv);
    idnum (person sv::stlvec) = sv!0;
    name (person sv::stlvec) = sv!1;
    set_name (person sv::stlvec) x:: string = person (const_stlvec sv1) when
      sv1 = stlvec sv ;
      update sv1 1 x;
    end;
    year (person sv::stlvec) = sv!2;
    set_year (person sv::stlvec) x:: int = person (const_stlvec sv1) when
      sv1 = stlvec sv ;
      update sv1 2 x;
    end;
    ()

Parameter Syntax
----------------

   access_code ::= "stl::readonly" | "stl::settable"

   mutability_code ::= "stl::mutable" | "stl::immutable"

   field ::= identifier [ .typeguard ] [ /access_code ]

   fields ::= field | fields, field

   name_spec ::= identifier | "(" identifier "/" mutability_code ")"

   field_spec ::=  "{" fields "}"

   defstruct macro :: "stl::defstruct" name_spec

The default values for access_code is "stl::settable", and the default value
for mutability_code is "stl::mutable".

*/

using system, stlvec, stlutil;

namespace stl;

extern int atoi(char* s);

def immutable = 0;
def mutable = 1;
def readonly = 0;
def settable = 1;

nonfix struct_error;

type field_def (field_def sv::stlvec);
mk_field_def x = field_def (mkstlvec x 4);
field_def xs@{p0:: string, p1:: string, p2:: string, p3:: int} = 
  field_def (stlvec xs);
fnamespace (field_def sv::stlvec) = sv!0;
fname (field_def sv::stlvec) = sv!1;
ftype (field_def sv::stlvec) = sv!2;
faccess (field_def sv::stlvec) = sv!3;

struct_err msg = throw (struct_error msg);

private parse_field_spec parse_name_spec parse_field_specs eval_code 
        mk_struct_constructors mk_struct_accessors
        struct_define;

parse_field_spec default_namespace default_access spec = fdef when
  field_pat ="^[[:space:]]*([^ ./]+)(\\.[^ ./]+)?(/[[:digit:]])?$";
  ri = reg_info $ regex field_pat REG_EXTENDED spec 0;
  if #ri <8 then struct_err (sprintf "bad field def: %s" spec) else ();
  qname = ri!3;
  ftype = ri!5;
  faccess_str = ri!7;
  ri = reg_info $ regex "(([^ ./:]+)::)?([^ ./]+)" REG_EXTENDED qname 0;
  fnamespace, fname = ri!5,ri!7;
  fnamespace = if null fnamespace then default_namespace else fnamespace;
  ftype = if ::null ftype then ftype else substr ftype 1 10000;
  faccess = if ::null faccess_str then default_access 
            else atoi (substr faccess_str 1 1000);
  fdef = field_def {fnamespace ,fname, ftype, faccess};
end;

parse_name_spec name_spec = ns, qname, faccess ndef when
  ndef = catch err (parse_field_spec "" mutable name_spec);
  null (ftype ndef) || err ();
  ns = fnamespace ndef;
  name = fname ndef;
  qname = if null ns then name else ns + "::" + name;
end with
  err _ = struct_err (sprintf "bad name spec: %s" name_spec); 
end;

parse_field_specs nspace fields_spec = fdefs when
  fss = split "," (substr fields_spec 1 (#fields_spec-2));
  fdefs = map (parse_field_spec nspace settable) fss;
end;

eval_code print code = () when
  if print then puts (code + ";") else eval code;
end;

mk_struct_constructors print name struct_mutable fdefs = () when
  ftypes = map ftype fdefs;  
  params = join "," $ zipwith mkparam ftypes (0..inf);
  if struct_mutable then mk_mutable ftypes params 
  else mk_immutable ftypes params;
end with
  mk_mutable ftypes params = () when
    eval_code print ("type " + name + " (" + name + " sv::stlvec)");
    cd = "mk_" + name + " x = " +
      name + " (mkstlvec x " + str (#ftypes) + ")";
    eval_code print cd;
    cd = name + " xs@{" + params + "} = " + name + " (stlvec xs)";
    eval_code print cd;
    cd = name + "(" + name + " sv::stlvec) = " + name + " (stlvec sv)";
    eval_code print cd;
  end;
  mk_immutable ftypes params = () when
    eval_code print ("type " + name + " (" + name + " csv::const_stlvec)");
    cd = "mk_" + name + " x = " +
      name + " (const_stlvec $ mkstlvec x " + str (#ftypes) + ")";
    eval_code print cd;
    cd = name + " xs@{" + params + "} = " + name + 
      " (const_stlvec xs)";
    eval_code print cd;
    cd = name + " (" + name + " csv::stlvec) = " + name + 
      " (const_stlvec $ stlvec csv)";
    eval_code print cd;
  end;
  mkparam ftype i = sprintf "p%d%s" (i,tguard) when
    tguard = if null ftype then "" else ":: " + ftype;
  end;
end;

mk_struct_accessors print struct_name struct_mutable fdefs = mk_a fdefs 0 with
  mk_a [] _ = ();
  mk_a (fdef:rest) ndx = mk_a rest (ndx+1) when
    cd = ns_qual fdef + fname fdef + 
      " (" + struct_name + " sv::stlvec) = sv!" + str ndx;
    eval_code print cd;
    if faccess fdef == readonly then ()
    else if struct_mutable then
      eval_code print (mk_mutable_accessor fdef ndx)
    else
      eval_code print (mk_immutable_accessor fdef ndx);
  end;
  mk_mutable_accessor fdef ndx = ns_qual fdef +
    beg_set fdef + type_guard fdef + " = update sv " + 
    str ndx + " x $$ " + struct_name + " sv";
  mk_immutable_accessor fdef ndx = ns_qual fdef +
    beg_set fdef + type_guard fdef + " = " + struct_name +
    " (const_stlvec sv1) when\n" +
    "  sv1 = stlvec sv ;\n"  + 
    "  update sv1 " + (str ndx) + " x;\nend";
  type_guard fd = if null t then t else ":: " + t when t = ftype fd end;
  ns_qual fd = if null ns then ns else ns + "::" when
    ns = fnamespace fd;
  end;
  beg_set fdef = "set_" + fname fdef + " (" +  struct_name + " sv::stlvec) x";
end;

struct_define print name_spec field_specs = () when
  nspace, struct_name, is_mutable = parse_name_spec name_spec;
  fdefs = parse_field_specs nspace field_specs;
  mk_struct_constructors print struct_name is_mutable fdefs;
  mk_struct_accessors print struct_name is_mutable fdefs;
end;

::__show__ (x@_ sv::stlvec) = 
  sprintf "%s %s" (str x, stlvec_tostr (#sv) sv);

def defstruct name fields = 
  struct_define 0 (str ('name)) (str ('fields));

def defstruct_code name fields = 
  struct_define 1 (str ('name)) (str ('fields));
