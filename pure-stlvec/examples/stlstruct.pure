/* stlstruct.pure - named field data structures based on stlvecs

Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stlvec, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stlvec distribution package for details.

defstruct and defstruct_code
----------------------------

The defstruct macro is used to define a "stlstruct", a custom data type that
holds arbitrary Pure expressions in named fields. The macro defines a type tag
for the new type, functions to create instances of it and functions for
setting and accessing field values.

    defstruct name_spec field_spec

The name_spec is used to name the custom data structure and to specifiy
whether all of its instances are mutable or immutable. The field_spec names
each field in the structure and optionally specifies the type of the field and
whether the field is readonly or settable. If the custom data structure is
immutable, the "setter functions" generated by defstruct will
"copy-and-write".

The defstruct_code macro is the same as defstruct except that it generates
code and prints it rather than evaluating it.

Examples
--------

    > using stlstruct;

A simple mutable stlstruct type with mutable instances and settable fields.
 
    > stl::defstruct worker {idnum, name, year};
    ()

    > let w = worker {10, "Fred", 2011}; w;
    worker sv{10,"Fred",2011}

    > typep worker w;
    1

    > name w, idnum w, year w;
    "Fred",10,2011

    > set_year w 2010;
    worker sv{10,"Fred",2010}

A type with immutable instances, typed fields and a readonly field.

    > stl::defstruct (person/stl::immutable) 
                     {idnum.int/stl::readonly, name.string, year.int};
    ()
 
    > let p1 = person {20, "Fred", 2011}; p1;
    person csv{20,"Fred",2011}

    > let p2 = person p1; p2;
    person csv{20,"Fred",2011}

    > let p3 = set_year p2 2012; p3;
    person csv{20,"Fred",2012}

    > p2;
    person csv{20,"Fred",2011}

    > set_year p3 "2014"; // fails
    set_year (person csv{20,"Fred",2012}) "2014"

Print the code generated by defstruct the "ns" namespace:

    namespace ns;

    stl::defstruct_code (person/stl::immutable)
    {
     idnum.int/stl::readonly,  //comment
     name.string,              //comment 
     year.int                  //comment
    };

The output (slightly reformatted) looks like this:

    type ns::person (ns::struct_person _);
    ns::struct_person = quote ns::struct_person;

    ns::mk_person x = ns::struct_person (mkstlvec x 3);

    ns::person xs@{p0:: int,p1:: string,p2:: int} =
               ns::struct_person (stlvec xs);
    ns::person (ns::struct_person sv) = 
               ns::struct_person (stlvec sv);

    ns::idnum (ns::struct_person sv) = sv!0;

    ns::name (ns::struct_person sv) = sv!1;
    ns::set_name (ns::struct_person sv) x:: string = 
                 ns::struct_person (update (stlvec sv) 1 x);

    ns::year (ns::struct_person sv) = sv!2;
    ns::set_year (ns::struct_person sv) x:: int =
                 ns::struct_person (update (stlvec sv) 2 x);


Parameter Syntax
----------------

   access_code ::= "stl::readonly" | "stl::settable"

   mutability_code ::= "stl::mutable" | "stl::immutable"

   field ::= identifier [ .typeguard ] [ /access_code ]

   fields ::= field | fields, field

   name_spec ::= identifier | "(" identifier "/" mutability_code ")"

   field_spec ::=  "{" fields "}"

The default values for access_code is "stl::settable", and the default value
for mutability_code is "stl::mutable".

*/

using system, stlvec, stlutil;

namespace stl;

extern int pure_sym(char* s);
extern int atoi(char* s);

def immutable = 0;
def mutable = 1;
def readonly = 0;
def settable = 1;

const constructor_prefix = "struct_";

nonfix struct_error;

type field_def (field_def sv::stlvec);
mk_field_def x = field_def (mkstlvec x 4);
field_def xs@{p0:: string, p1:: string, p2:: string, p3:: int} = 
  field_def (stlvec xs);
fnamespace (field_def sv::stlvec) = sv!0;
fname (field_def sv::stlvec) = sv!1;
ftype (field_def sv::stlvec) = sv!2;
faccess (field_def sv::stlvec) = sv!3;

struct_err msg = throw (struct_error msg);

private parse_field_spec parse_name_spec parse_field_specs eval_code 
        mk_struct_constructors mk_struct_accessors
        mk_struct;

parse_field_spec default_namespace default_access spec = fdef when
  field_pat ="^[[:space:]]*([^ ./]+)(\\.[^ ./]+)?(/[[:digit:]])?$";
  ri = reg_info $ regex field_pat REG_EXTENDED spec 0;
  if #ri <8 then struct_err (sprintf "bad field def: %s" spec) else ();
  qname = ri!3;
  ftype = ri!5;
  faccess_str = ri!7;
  ri = reg_info $ regex "(([^ ./:]+)::)?([^ ./]+)" REG_EXTENDED qname 0;
  fnamespace, fname = ri!5,ri!7;
  fnamespace = if null fnamespace then default_namespace else fnamespace;
  ftype = if ::null ftype then ftype else substr ftype 1 10000;
  faccess = if ::null faccess_str then default_access 
            else atoi (substr faccess_str 1 1000);
  fdef = field_def {fnamespace ,fname, ftype, faccess};
end;

parse_name_spec name_spec = ns, struct_name, faccess ndef when
  ndef = catch err (parse_field_spec "" mutable name_spec);
  null (ftype ndef) || err ();
  ns = fnamespace ndef;
  struct_name = fname ndef;
end with
  err _ = struct_err (sprintf "bad name spec: %s" name_spec); 
end;

parse_field_specs nspace fields_spec = fdefs when
  fss = split "," (substr fields_spec 1 (#fields_spec-2));
  fdefs = map (parse_field_spec nspace settable) fss;
end;

eval_code print code = () when
  if print then puts (code + ";") else eval code;
end;

mk_qname ns name = if null ns then "::" +  name else ns + "::" + name;

mk_constr_name ns name = mk_qname ns (constructor_prefix + name);

mk_struct_constructors print ns name fdefs = () when
  constr_name = mk_constr_name ns name;
  qname = mk_qname ns name;  ftypes = map ftype fdefs;  
  params = join "," $ zipwith mkparam ftypes (0..inf);
  eval_code print ("type " + qname + " (" + constr_name + " _)");
  eval_code print (constr_name + " = quote " + constr_name);
  cd = mk_qname ns ("mk_" + name) + " x = " +
    constr_name + " (mkstlvec x " + str (#ftypes) + ")";
  eval_code print cd;
  cd = qname + " xs@{" + params + "} = " + constr_name + " (stlvec xs)";
  eval_code print cd;
  cd = qname + " (" + constr_name + " sv) = " + constr_name + " (stlvec sv)";
  eval_code print cd;
end with
 mkparam ftype i = sprintf "p%d%s" (i,tguard) when
    tguard = if null ftype then "" else ":: " + ftype;
  end;
end;

mk_struct_accessors print ns name is_mutable fdefs = mk_a fdefs 0 with
  mk_a [] _ = ();
  mk_a (fdef:rest) ndx = mk_a rest (ndx+1) when
    qfname = mk_qname ns (fname fdef);
    pure_sym(qfname);
    cd = qfname + " (" + constr_name + " sv) = sv!" + str ndx;
    eval_code print cd;
    (str (qfname, faccess fdef));
    if faccess fdef == readonly then ()
    else if is_mutable then
      eval_code print (mk_mutable_setter fdef ndx)
    else
      eval_code print (mk_immutable_setter fdef ndx);
  end;
  mk_mutable_setter fdef ndx = setter_lhs fdef + " = " +
    constr_name + " (update sv " + str ndx + " x)";
  mk_immutable_setter fdef ndx = setter_lhs fdef + " = " +
    constr_name + " (update (stlvec sv) " +  str ndx + " x)";
  type_guard fd = if null t then t else ":: " + t when t = ftype fd end;
  setter_lhs fdef = lhs when
    setter_name = mk_qname ns ("set_" + fname fdef);
    lhs = setter_name + " (" + constr_name + " sv) x" + type_guard fdef;
    pure_sym(setter_name);
  end;
end when
  constr_name = mk_constr_name ns name;
  qname = mk_qname ns name;  ftypes = map ftype fdefs;  
end;

mk_struct print name_spec field_specs = () when
  nspace, name, is_mutable = parse_name_spec name_spec;
  fdefs = parse_field_specs nspace field_specs;
  mk_struct_constructors print nspace name fdefs;
  mk_struct_accessors print nspace name is_mutable fdefs;
end;

::__show__ (x@_ sv::stlvec) = 
  sprintf "%s %s" (str x, tostr (#sv) sv);

def defstruct name fields = 
  mk_struct 0 (str ('name)) (str ('fields));

def defstruct_code name fields = 
  mk_struct 1 (str ('name)) (str ('fields));

