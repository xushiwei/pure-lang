/* stlstruct.pure - named field data structures based on stlvecs

Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stlvec, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stlvec distribution package for details.

Purpose
-------

This file presents a "simplified" version of the "real" defstruct macro which
is defined in struct.pure (also distributed as an example).

In short, stlstruct.pure shows how to make a custom data structure using the
standard pure-stlvec interface. In contrast, struct.pure shows how one can dig
further and use the dll provided by pure-stlvec. Of course, one has to take
into consideration that the dll might change underneath you.

Please note that this is all experimental. In particular, it is possible that
the "real" version may well go back to using a stlvec as the underlying data
store.

defstruct and defstruct_code
----------------------------

The defstruct macro is used to define a "stlstruct", a custom data type that
holds arbitrary Pure expressions in named fields. The macro defines a type tag
for the new type, functions to create instances of it and functions for
setting and accessing field values.

    defstruct name_spec field_spec

The name_spec is used to name the custom data structure and to specifiy
whether all of its instances are mutable or immutable. The field_spec names
each field in the structure and optionally specifies the type of the field and
whether the field is readonly or settable. If the custom data structure is
immutable, the "setter functions" generated by defstruct will
"copy-and-write".

The defstruct_code macro is the same as defstruct except that it generates
code and prints it rather than evaluating it.

Examples
--------

    > using stlstruct;

A simple mutable stlstruct type with mutable instances and settable fields.
 
    > stl::defstruct worker {idnum, name, year};
    ()

    > let w = worker {10, "Fred", 2011}; w;
    worker sv{10,"Fred",2011}

    > typep worker w;
    1

    > name w, idnum w, year w;
    "Fred",10,2011

    > set_year w 2010;
    worker sv{10,"Fred",2010}

A type with immutable instances, typed fields and a readonly field.

    > stl::defstruct (person/stl::immutable) 
                     {idnum.int/stl::readonly, name.string, year.int};
    ()
 
    > let p1 = person {20, "Fred", 2011}; p1;
    person csv{20,"Fred",2011}

    > let p2 = person p1; p2;
    person csv{20,"Fred",2011}

    > let p3 = set_year p2 2012; p3;
    person csv{20,"Fred",2012}

    > p2;
    person csv{20,"Fred",2011}

    > set_year p3 "2014"; // fails
    set_year (person csv{20,"Fred",2012}) "2014"

Print the code generated by defstruct the "ns" namespace:

    namespace ns;

    stl::defstruct_code (person/stl::immutable)
    {
     idnum.int/stl::readonly,  //comment
     name.string,              //comment 
     year.int                  //comment
    };

The output (slightly reformatted) looks like this:

    nonfix ns::STRUCT_person;
    type ns::person (ns::STRUCT_person _);
    ns::STRUCT_person = quote ns::STRUCT_person;

    ns::mk_person x = ns::STRUCT_person (mkstlvec x 3);

    ns::person xs@{p0:: int,p1:: string,p2:: int} =
               ns::STRUCT_person (stlvec xs);
    ns::person (ns::STRUCT_person sv) = 
               ns::STRUCT_person (stlvec sv);

    ns::idnum (ns::STRUCT_person sv) = sv!0;

    ns::name (ns::STRUCT_person sv) = sv!1;
    ns::set_name (ns::STRUCT_person sv) x:: string = 
                 ns::STRUCT_person (update (stlvec sv) 1 x);

    ns::year (ns::STRUCT_person sv) = sv!2;
    ns::set_year (ns::STRUCT_person sv) x:: int =
                 ns::STRUCT_person (update (stlvec sv) 2 x);


Parameter Syntax
----------------

   access_code ::= "stl::readonly" | "stl::settable"

   mutability_code ::= "stl::mutable" | "stl::immutable"

   field ::= identifier [ .typeguard ] [ /access_code ]

   fields ::= field | fields, field

   name_spec ::= identifier | "(" identifier "/" mutability_code ")"

   field_spec ::=  "{" fields "}"

The default values for access_code is "stl::settable", and the default value
for mutability_code is "stl::mutable".

Explicit Namespaces
-------------------

Sometimes it is necessary to specify a namespace. For example, see
ut_stlstruct.pure, in which the worker stlstruct is defined first in the
global namespace and then in the "fo" namespace. In the second definition the
fo:: namespace qualifier is required. Note that the namespace qualifier is not
required for the "executive" stlstruct because it was not previously defined.

It is not a bad idea to always specify the namespace in the name-spec. For one
thing you might change from the global namespace to a private namespace as you
are writing a program, and you might still intend for a particular stlstruct
to be in the global namespace. Also, this seems to eliminate those annoying
implicit declaration warnings that you may have noticed if you run Pure with
the -w option. E.g.,

    > stl::defstruct sa {fa};
    <stdin>, line 2: warning: implicit declaration of 'sa'
    <stdin>, line 2: warning: implicit declaration of 'fa'
    ()

    > stl::defstruct ::sb {::fb};

defstruct silently forces all of the field names to reside in the same
namespace as the name of the stlstruct being defined.


*/

using system, stlvec, stlutil;

namespace stl;

private extern int pure_sym(char* s);
private extern int atoi(char* s);

def immutable = 0;
def mutable = 1;
def readonly = 0;
def settable = 1;

const constructor_prefix = "STRUCT_";

nonfix struct_error;

struct_err msg = throw (struct_error msg);

nonfix STRUCT_field_def;
type field_def (STRUCT_field_def _);
STRUCT_field_def = quote STRUCT_field_def;
mk_field_def x = STRUCT_field_def (mkstlvec x 4);
field_def xs@{p0:: string,p1:: string,p2:: string,p3:: int} = 
  STRUCT_field_def (stlvec xs);
field_def (STRUCT_field_def sv) = STRUCT_field_def (stlvec sv);
fnamespace (STRUCT_field_def sv) = sv!0;
fname (STRUCT_field_def sv) = sv!1;
ftype (STRUCT_field_def sv) = sv!2;
faccess (STRUCT_field_def sv) = sv!3;

private parse_field_spec parse_name_spec parse_field_specs eval_code 
        mk_struct_constructors mk_struct_accessors
        mk_struct;

parse_field_spec default_namespace default_access spec = fdef when
  field_pat ="^[[:space:]]*([^ ./]+)(\\.[^ ./]+)?(/[[:digit:]])?$";
  ri = reg_info $ regex field_pat REG_EXTENDED spec 0;
  if #ri <8 then struct_err (sprintf "bad field def: %s" spec) else ();
  qname = ri!3;
  ftype = ri!5;
  faccess_str = ri!7;
  ri = reg_info $ regex "(([^ ./:]+)::)?([^ ./]+)" REG_EXTENDED qname 0;
  fnamespace, fname = ri!5,ri!7;
  fnamespace = if null fnamespace then default_namespace else fnamespace;
  ftype = if ::null ftype then ftype else substr ftype 1 10000;
  faccess = if ::null faccess_str then default_access 
            else atoi (substr faccess_str 1 1000);
  fdef = field_def {fnamespace ,fname, ftype, faccess};
end;

parse_name_spec name_spec = ns, struct_name, faccess ndef when
  ndef = catch err (parse_field_spec "" mutable name_spec);
  null (ftype ndef) || err ();
  ns = fnamespace ndef;
  struct_name = fname ndef;
end with
  err _ = struct_err (sprintf "bad name spec: %s" name_spec); 
end;

parse_field_specs nspace fields_spec = fdefs when
  fss = split "," (substr fields_spec 1 (#fields_spec-2));
  fdefs = map (parse_field_spec nspace settable) fss;
end;

eval_code print code = () when
  if print then puts (code + ";") else eval code;
end;

mk_qname ns name = if null ns then "::" +  name else ns + "::" + name;

mk_constr_name ns name = mk_qname ns (constructor_prefix + name);

mk_struct_constructors print ns name fdefs = () when
  constr_name = mk_constr_name ns name;
  qname = mk_qname ns name;  ftypes = map ftype fdefs;  
  params = join "," $ zipwith mkparam ftypes (0..inf);
  eval_code print ("nonfix " + constr_name);
  eval_code print ("type " + qname + " (" + constr_name + " _)");
  eval_code print (constr_name + " = quote " + constr_name);
  cd = mk_qname ns ("mk_" + name) + " x = " +
    constr_name + " (mkstlvec x " + str (#ftypes) + ")";
  eval_code print cd;
  cd = qname + " xs@{" + params + "} = " + constr_name + " (stlvec xs)";
  eval_code print cd;
  cd = qname + " (" + constr_name + " sv) = " + constr_name + " (stlvec sv)";
  eval_code print cd;
end with
 mkparam ftype i = sprintf "p%d%s" (i,tguard) when
    tguard = if null ftype then "" else ":: " + ftype;
  end;
end;

mk_struct_accessors print ns name is_mutable fdefs = mk_a fdefs 0 with
  mk_a [] _ = ();
  mk_a (fdef:rest) ndx = mk_a rest (ndx+1) when
    qfname = mk_qname ns (fname fdef);
    pure_sym(qfname);
    cd = qfname + " (" + constr_name + " sv) = sv!" + str ndx;
    eval_code print cd;
    (str (qfname, faccess fdef));
    if faccess fdef == readonly then ()
    else if is_mutable then
      eval_code print (mk_mutable_setter fdef ndx)
    else
      eval_code print (mk_immutable_setter fdef ndx);
  end;
  mk_mutable_setter fdef ndx = setter_lhs fdef + " = " +
    constr_name + " (update sv " + str ndx + " x)";
  mk_immutable_setter fdef ndx = setter_lhs fdef + " = " +
    constr_name + " (update (stlvec sv) " +  str ndx + " x)";
  type_guard fd = if null t then t else ":: " + t when t = ftype fd end;
  setter_lhs fdef = lhs when
    setter_name = mk_qname ns ("set_" + fname fdef);
    lhs = setter_name + " (" + constr_name + " sv) x" + type_guard fdef;
    pure_sym(setter_name);
  end;
end when
  constr_name = mk_constr_name ns name;
  qname = mk_qname ns name;  ftypes = map ftype fdefs;  
end;

mk_struct print name_spec field_specs = () when
  nspace, name, is_mutable = parse_name_spec name_spec;
  fdefs = parse_field_specs nspace field_specs;
  mk_struct_constructors print nspace name fdefs;
  mk_struct_accessors print nspace name is_mutable fdefs;
end;

::__show__ (x@_ sv::stlvec) = 
  sprintf "%s %s" (str x, tostr (#sv) sv);

def defstruct name fields = 
  mk_struct 0 (str ('name)) (str ('fields));

def defstruct_code name fields = 
  mk_struct 1 (str ('name)) (str ('fields));

