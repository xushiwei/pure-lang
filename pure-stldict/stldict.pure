/* stldict.pure: Pure interface to C++ STL map
    
--- DRAFT - FOR DISCUSSON PURPOSES ONLY ---

Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stldict, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stldict distribution package for details.

*/
 
using stlbase;
using "lib:stldict";

// stldict constuctors
nonfix STLDICT;
STLDICT = 'STLDICT;

// stldict types
type stlset (STLDICT _);
type stldict (STLDICT _);
type sdit (STLDICT _);
type sdit (STLDICT _, _);

namespace stl;

/*** C++ support *****************************************************/

private extern void* sd_make_empty(expr* comp, int keys_only);
private extern void  sd_delete(void* dict);
private extern bool  sd_is_set(expr* tpl);
private extern expr* sd_set_default(void* dict, expr* val);
private extern expr* sd_get_default(void* dict);
private extern void* sd_setop(int op, expr* it1, expr* it2);
private extern expr* sd_make_vector(expr* tpl);
private extern void* sd_make_stlvec(expr* tpl);
private extern int   sd_size(expr* tpl);
private extern expr* sd_bounds(expr* tpl);
private extern int   sd_member(void* dict, expr* key);
private extern expr* sd_next(void* dict, expr* key);
private extern expr* sd_prev(void* dict, expr* key);
private extern expr* sd_get(void* dict, expr* key);
private extern expr* sd_first(expr* tpl);
private extern expr* sd_last(expr* tpl);
private extern void  sd_update(void* dict, expr* key, expr* val);
private extern void  sd_update_with(void* dict, expr* key, expr* unaryfun);
private extern void  sd_insert(void* dict, expr* kv);
private extern void  sd_insert_elms_xs(void* dict, expr* src);
private extern void  sd_insert_elms_stlvec(void* dict, expr* tpl);
private extern void  sd_insert_elms_stldict(void* dict, expr* tpl);
private extern void  sd_rmfirst(expr* tpl);
private extern void  sd_rmlast(expr* tpl);
private extern void  sd_erase(expr* it);
private extern void  sd_clear(void* dict);
private extern void  sd_remove(void* dict, expr* x);
private extern int   sd_remove_all(void* dict, expr* x);
private extern void  sd_remove_kv(void* dict, expr* x);
private extern int   sd_allpairs(expr* fun, expr* it, expr* it);
private extern expr* sd_listmap(expr* fun, expr* it, int what);
private extern expr* sd_listcatmap(expr* fun, expr* it, int what);
private extern expr* sd_foldl(expr* fun, expr* val, expr* it);
private extern expr* sd_foldl1(expr* fun, expr* it);
private extern expr* sd_foldr(expr* fun, expr* val, expr* it);
private extern expr* sd_foldr1(expr* fun, expr* it);
private extern expr* stl_begin();
private extern expr* stl_end();
private extern expr* stl_insert();

extern void stl_set_sd_trace(bool enable) = set_sd_trace;
extern bool stl_sd_trace_enabled() = sd_trace_enabled;


/*** Constants used to specify "iterator tuples" **************************/

const sdbeg  = stl_begin;    // corresponds to C++ first element iterator
const sdend  = stl_end;      // corresponds to C++ past-end iterator

nonfix sdbeg;       // to make sdbeg and sdend usable as beg and end markers
nonfix sdend;       // in C++ style looping over a stldict's contents using 

/*** Helpers **************************************************************/

private sd_keys sd_vals sd_both sd_union sd_difference
  sd_intersection sd_symmetric_difference wrap_sd wrap_sv;

const sd_keys = 1;
const sd_vals = 2;
const sd_both = 3;

const sd_union = 1;
const sd_difference = 2;
const sd_intersection = 3;
const sd_symmetric_difference = 4;

wrap_sd d = STLDICT (sentry sd_delete d);
wrap_sv d = STLVEC (sentry sd_delete d);

kv_equal k1 v1 k2 v2 = k1 == k2 && v1 == v2;

/*** Public functions on stldict *****************************************/

::emptystlset comp = wrap_sd $ sd_make_empty comp 1;

::emptystldict comp = wrap_sd $ sd_make_empty comp 0;

insert_elms sd@(STLDICT d) xs::list = sd_insert_elms_xs d xs $$ sd;

insert_elms sd@(STLDICT d) xs::matrix = sd_insert_elms_xs d xs $$ sd;

insert_elms sd@(STLDICT d) it::sdit = sd_insert_elms_stldict d it $$ sd;

insert_elms sd@(STLDICT d) it::svit = sd_insert_elms_stlvec d it $$ sd;

::stldict comp xs = sd when
  sd = ::emptystldict comp;
  insert_elms sd xs;
end if listp xs || matrixp xs;

::stldict comp it::svit = sd when
  sd = ::emptystldict comp;
  insert_elms sd it;
end;

::stldict comp it::sdit = sd when
  sd = ::emptystldict comp;
  insert_elms sd it;
end;

::mkstldict comp y ks::list = do add ks $$ sd with
  add k = ::update sd k y;
end when
  sd = emptystldict comp;  
end;

::stlset comp xs = sd when
  sd = ::emptystlset comp;
  insert_elms sd xs;
end if listp xs || matrixp xs;

::stlset comp it::svit = sd when
  sd = ::emptystlset comp;
  insert_elms sd it;
end;

::stlset comp it::sdit = sd when
  sd = ::emptystlset comp;
  insert_elms sd it;
end;

set_default (STLDICT d) val = sd_set_default d val;

get_default (STLDICT d) = sd_get_default d; // bool, default

::stlvec it::sdit = wrap_sv $ sd_make_stlvec it;

vector it::sdit = sd_make_vector it;

::update sd@(STLDICT d) key x = sd_update d key x $$ sd;

::update_with f sd@(STLDICT d) key x = sd_update_with d key (f x) $$ sd;

(::!) (STLDICT d) key = sd_get d key;

(::+) it1::sdit it2::sdit = wrap_sd $ sd_setop sd_union  it1 it2;

(::-) it1::sdit it2::sdit = wrap_sd $ sd_setop sd_difference it1 it2;

(::*) it1::sdit it2::sdit = wrap_sd $ sd_setop sd_intersection it1 it2;

(::/) it1::sdit it2::sdit = wrap_sd $ 
  sd_setop sd_symmetric_difference it1 it2;

(::#) sd::stldict = sd_size sd;

size it::sdit = sd_size it;

null it::sdit = sd_size it == 0;

bounds (STLDICT d) = (STLDICT d), sdbeg, sdend;

bounds it@(STLDICT d, _) = (STLDICT d), sd_bounds it;

::member (STLDICT d) key = sd_member d key;

::next_key (STLDICT d) key = sd_next d key;

::prev_key (STLDICT d) key = sd_prev d key;

::members it::sdit = sd_listmap 0 it sd_both; 

::list sd::stldict = members sd;

::keys it::sdit = sd_listmap 0 it sd_keys; 

::vals it::sdit = sd_listmap 0 it sd_vals;

::first it::sdit = sd_first it;

::last it::sdit = sd_last it;

::rmfirst it::sdit = sd_rmfirst it;

::rmlast it::sdit = sd_rmlast it;

::erase it@(STLDICT d, f, e) = sd_erase it $$ STLDICT d;

::erase sd@(STLDICT d) = sd_clear d $$ sd;

::delete sd@(STLDICT d) k = sd_remove d k $$ sd;

//::delete_val sd@(STLDICT d) kv = sd_remove_kv d kv $$ sd;

//::delete_all sd@(STLDICT d) k = sd_remove_all d k;

::insert sd@(STLDICT d) rk = sd_insert d rk $$ sd;

// for sets
allpairs fun it1::sdit it2::sdit = sd_allpairs fun it1 it2 
  if sd_is_set it1 && sd_is_set it2 && functionp fun && nargs fun == 2 ;

// for dicts
allpairs fun it1::sdit it2::sdit = sd_allpairs fun it1 it2
  if ~sd_is_set it1 && ~sd_is_set it2 && functionp fun && nargs fun == 4;

(::==) sd1::stldict sd2::stldict = allpairs kv_equal sd1 sd2 
  if ~sd_is_set sd1 && ~sd_is_set sd2;

(::~=) sd1::stldict sd2::stldict = ~allpairs kv_equal sd1 sd2
  if ~sd_is_set sd1 && ~sd_is_set sd2;

(::==) sd1::stldict sd2::stldict = allpairs (==) sd1 sd2 
  if sd_is_set sd1 && sd_is_set sd2;

(::~=) sd1::stldict sd2::stldict = ~allpairs (==) sd1 sd2
  if sd_is_set sd1 && sd_is_set sd2;

::map_keys f it::sdit = sd_listmap f it sd_keys;

::map_vals f it::sdit = sd_listmap f it sd_vals;

::map f it::sdit = sd_listmap f it sd_both;

::listmap f it::sdit = sd_listmap f it sd_both;

::catmap f it::sdit = sd_listcatmap f it sd_both;

::catmap_keys f it::sdit = sd_listcatmap f it sd_keys;

::catmap_vals f it::sdit = sd_listcatmap f it sd_vals;

::foldl f x it::sdit = sd_foldl f x it;

::foldl1 f it::sdit = sd_foldl1 f it;

::foldr f x it::sdit = sd_foldr f x it;

::foldr1 f it::sdit = sd_foldr1 f it;

::do f it::sdit = sd_foldl (\_ x->f x) () it $$ ();

::filter p it::sdit = sd_foldr f [] it with
  f x xs = res when
    res = case p x of
      1 = x:xs;
      0 = xs;
      y = throw failed_cond;
    end;
  end;
end;

::rowmap f it::sdit = rowcat (sd_listmap f it sd_both);

::rowcatmap f it::sdit = rowcat (sd_listmap f it sd_both);

::colmap f it::sdit = colcat (sd_listmap f it sd_both);

::colcatmap f it::sdit = colcat (sd_listmap f it sd_both);

