/* stldict.pure: Pure interface to C++ STL map
    
--- DRAFT - FOR DISCUSSON PURPOSES ONLY ---

Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stldict, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stldict distribution package for details.

*/
 
using stlbase;
using "lib:stldict";

// stldict constuctors
nonfix STLDICT;
STLDICT = 'STLDICT;

// stldict types
type stlset (STLDICT _);
type stldict (STLDICT _);
type sdit (STLDICT _);
type sdit (STLDICT _, _);

namespace stl;

/*** C++ support *****************************************************/

private extern void* sd_make_empty(expr* comp, int keys_only);
private extern void  sd_delete(void* dict);
private extern bool  sd_is_set(expr* tpl);
private extern expr* sd_set_default(void* dict, expr* val);
private extern expr* sd_get_default(void* dict);
private extern void* sd_setop(int op, expr* it1, expr* it2);
private extern expr* sd_make_vector(expr* tpl);
private extern void* sd_make_stlvec(expr* tpl);
private extern int   sd_size(expr* tpl);
private extern expr* sd_bounds(expr* tpl);
private extern int   sd_member(void* dict, expr* key);
private extern expr* sd_next(void* dict, expr* key);
private extern expr* sd_prev(void* dict, expr* key);
private extern expr* sd_get(void* dict, expr* key);
private extern expr* sd_first(expr* tpl);
private extern expr* sd_last(expr* tpl);
private extern expr* sd_update(void* dict, expr* key, expr* val);
private extern expr* sd_update_with(void* dict, expr* key, expr* unaryfun);
private extern void  sd_insert_elm(void* dict, expr* kv);
private extern void  sd_insert_elms_xs(void* dict, expr* src);
private extern void  sd_insert_elms_stlvec(void* dict, expr* tpl);
private extern void  sd_insert_elms_stldict(void* dict, expr* tpl);
private extern void  sd_rmfirst(expr* tpl);
private extern void  sd_rmlast(expr* tpl);
private extern void  sd_erase(expr* it);
private extern void  sd_clear(void* dict);
private extern void  sd_remove(void* dict, expr* x);
//private extern int   sd_remove_all(void* dict, expr* x);
//private extern void  sd_remove_kv(void* dict, expr* x);
private extern int   sd_allpairs(expr* fun, expr* it, expr* it);
private extern expr* sd_listmap(expr* fun, expr* it, int what);
private extern expr* sd_listcatmap(expr* fun, expr* it, int what);
private extern expr* sd_foldl(expr* fun, expr* val, expr* it);
private extern expr* sd_foldl1(expr* fun, expr* it);
private extern expr* sd_foldr(expr* fun, expr* val, expr* it);
private extern expr* sd_foldr1(expr* fun, expr* it);

extern void stl_set_sd_trace(bool enable) = set_sd_trace;
extern bool stl_sd_trace_enabled() = sd_trace_enabled;

/*** Helpers **************************************************************/

private sd_keys sd_vals sd_both sd_union sd_difference
  sd_intersection sd_symmetric_difference wrap_sd wrap_sv;

const sd_keys = 1;
const sd_vals = 2;
const sd_both = 3;

const sd_union = 1;
const sd_difference = 2;
const sd_intersection = 3;
const sd_symmetric_difference = 4;

wrap_sd d = STLDICT (sentry sd_delete d);
wrap_sv d = STLVEC (sentry sd_delete d);

kv_equal k1 v1 k2 v2 = k1 == k2 && v1 == v2;

both_sets it1 it2 = sd_is_set it1 && sd_is_set it2;

both_dicts it1 it2 = ~sd_is_set it1 && ~sd_is_set it2;

/*** Public functions for stldict and stlset ******************************/

::stlvec it::sdit = wrap_sv $ sd_make_stlvec it;

vector it::sdit = sd_make_vector it;

(::!) (STLDICT d) key = sd_get d key;

(::#) sd::stldict = sd_size sd;

size it::sdit = sd_size it;

null it::sdit = sd_size it == 0;

empty it::sdit = sd_size it == 0;

bounds (STLDICT d) = (STLDICT d), stlbeg, stlend;

bounds it@(STLDICT d, _) = (STLDICT d), sd_bounds it;

::member (STLDICT d) key = sd_member d key;

::members it::sdit = sd_listmap 0 it sd_both; 

// ::list sd::stldict = members sd;  // use members

::first it::sdit = sd_first it;

::last it::sdit = sd_last it;

::rmfirst it::sdit = sd_rmfirst it;

::rmlast it::sdit = sd_rmlast it;

::insert sd@(STLDICT d) rk = sd_insert_elm d rk $$ sd;

::insert_elms sd@(STLDICT d) xs::list = sd_insert_elms_xs d xs $$ sd;

::insert_elms sd@(STLDICT d) xs::matrix = sd_insert_elms_xs d xs $$ sd;

::insert_elms sd@(STLDICT d) it::sdit = sd_insert_elms_stldict d it $$ sd;

::insert_elms sd@(STLDICT d) it::svit = sd_insert_elms_stlvec d it $$ sd;

::erase it@(STLDICT d, f, e) = sd_erase it $$ STLDICT d;

::erase sd@(STLDICT d) = sd_clear d $$ sd;

::delete sd@(STLDICT d) k = sd_remove d k $$ sd;

allpairs fun it1::sdit it2::sdit = sd_allpairs fun it1 it2 
  if both_sets it1 it2 && functionp fun && nargs fun == 2 ;

allpairs fun it1::sdit it2::sdit = sd_allpairs fun it1 it2
  if ~sd_is_set it1 && ~sd_is_set it2 && functionp fun && nargs fun == 4;

(::==) sd1::stldict sd2::stldict = allpairs kv_equal sd1 sd2
  if both_dicts sd1 sd2;

(::~=) sd1::stldict sd2::stldict = ~allpairs kv_equal sd1 sd2
  if both_dicts sd1 sd2;

(::==) sd1::stldict sd2::stldict = allpairs (==) sd1 sd2 
  if both_sets sd1 sd2;

(::~=) sd1::stldict sd2::stldict = ~allpairs (==) sd1 sd2
  if both_sets sd1 sd2;

::map f it::sdit = sd_listmap f it sd_both; // => sd_key for sets

::listmap f it::sdit = sd_listmap f it sd_both;

::catmap f it::sdit = sd_listcatmap f it sd_both;

::foldl f x it::sdit = sd_foldl f x it;

::foldl1 f it::sdit = sd_foldl1 f it;

::foldr f x it::sdit = sd_foldr f x it;

::foldr1 f it::sdit = sd_foldr1 f it;

::do f it::sdit = sd_foldl (\_ x->f x) () it $$ ();

::filter p it::sdit = sd_foldr f [] it with
  f x xs = res when
    res = case p x of
      1 = x:xs;
      0 = xs;
      y = throw failed_cond;
    end;
  end;
end;

::rowmap f it::sdit = rowcat (sd_listmap f it sd_both);

::rowcatmap f it::sdit = rowcat (sd_listmap f it sd_both);

::colmap f it::sdit = colcat (sd_listmap f it sd_both);

::colcatmap f it::sdit = colcat (sd_listmap f it sd_both);

/*** Functions for stldict *******************************************/

::emptystldict = wrap_sd $ sd_make_empty (<) 0;

::emptystldict_with comp = wrap_sd $ sd_make_empty comp 0;

::stldict xs = sd when
  sd = ::emptystldict;
  insert_elms sd xs;
end if listp xs || matrixp xs;

::stldict it::svit = sd when
  sd = ::emptystldict;
  insert_elms sd it;
end;

::stldict it::sdit = sd when
  sd = ::emptystldict;
  insert_elms sd it;
end;

::mkstldict y ks::list = do add ks $$ sd with
  add k = ::update sd k y;
end when
  sd = emptystldict;  
end;

set_default sd@(STLDICT d) val = sd_set_default d val if ~sd_is_set sd;

// bool, default
get_default sd@(STLDICT d) = sd_get_default d if ~sd_is_set sd;

::update sd@(STLDICT d) key x = sd_update d key x $$ sd if ~sd_is_set sd;

::update_with f sd@(STLDICT d) key x = 
  sd_update_with d key (f x) $$ sd if ~sd_is_set sd;

::next_key sd@(STLDICT d) key = sd_next d key; // if ~sd_is_set s;

::prev_key sd@(STLDICT d) key = sd_prev d key; // if ~sd_is_set sd;

::keys it::sdit = sd_listmap 0 it sd_keys if ~sd_is_set it;

::vals it::sdit = sd_listmap 0 it sd_vals if ~sd_is_set it;

::map_keys f it::sdit = sd_listmap f it sd_keys if ~sd_is_set it;

::map_vals f it::sdit = sd_listmap f it sd_vals if ~sd_is_set it;

::catmap_keys f it::sdit = sd_listcatmap f it sd_keys if ~sd_is_set it;;

::catmap_vals f it::sdit = sd_listcatmap f it sd_vals if ~sd_is_set it;

/*** Functions for stlset ************************************************/

::emptystlset = wrap_sd $ sd_make_empty (<) 1;

::emptystlset_with comp = wrap_sd $ sd_make_empty comp 1;

::stlset xs = sd when
  sd = ::emptystlset;
  insert_elms sd xs;
end if listp xs || matrixp xs;

::stlset it::svit = sd when
  sd = ::emptystlset;
  insert_elms sd it;
end;

::stlset it::sdit = sd when
  sd = ::emptystlset;
  insert_elms sd it;
end;

::next_elm (STLDICT d) elm = sd_next d elm;

::prev_elm (STLDICT d) elm = sd_prev d elm;

(::+) it1::sdit it2::sdit = 
  wrap_sd $ sd_setop sd_union it1 it2 if both_sets it1 it2;

(::-) it1::sdit it2::sdit = 
  wrap_sd $ sd_setop sd_difference it1 it2 if both_sets it1 it2;

(::*) it1::sdit it2::sdit = 
  wrap_sd $ sd_setop sd_intersection it1 it2 if both_sets it1 it2;

(::/) it1::sdit it2::sdit = 
  wrap_sd $ sd_setop sd_symmetric_difference it1 it2 if both_sets it1 it2;

(::<=) it1::sdit it2::sdit = size (it1 - it2) == 0 if both_sets it1 it2;

(::<) it1::sdit it2::sdit = 
  it1 <= it2 && size it1 < size it2 if both_sets it1 it2;

