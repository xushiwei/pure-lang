
--- DRAFT - FOR DISCUSSON PURPOSES ONLY ---


A. General

1. This is *NOT* ready for public consumption!

2. Both stldict and stlset are mutable only. There are no immutable
   versions. O(log n) access, insert. Elements ordered.

3. See stldict.pure for functions provided. Most are just what one might expect.

B. Notable features

1. stlsets only have single values (that can be seen). You can add (k=>v)
   as a member of a stlset. stldicts only have pairs of values (k=>v).

2. stlsets and stldicts are not meant to intermix, conceptually at least. 
   Of course a stlset can be used to make a stldict ans vis a versa, the
   same as with a vector, list or stlvec. But that is supposed to be all.

3. By default, stlsets and stldicts are constructed (<) as the ordering
   function. Other ordering functions can be used if desired.

4. For a stldict, sd, sd!k returns v if (k=>v) is in sd. If not, see 5. For
   a stlset, ss, ss!k is the same as (member ss k).

5. stldicts can be given a default value (al la C++ T()).

   a. Generally, sd!k will throw out_of_bounds if k not the key of an element
      of stldict sd. So will st!k if k is not an element of stlset st.

   b. If sd!k would otherwise be out_of_bounds, and if sd has a default value
      dv, (k=>dv) will be inserted into sd and dv will be returned.

   c. stlsets do not have default values.

6. The function "update_with f sd k v" is pure-stldict's answer to the fact
   that in C++ map[k] is a reference into the map. The function acts like
   update sd k $ f v (sd!k), except that it does it in one visit into the
   map. This is typically used when sd has a default value - say 0, an
   emptystlvec, or [].

7. The set operations use the native STL algorithms, which take full advantage
   of the fact that stldicts and stlsets have ordered elements.

8. The insert and insert_elms functions follow STL semantics. This means, for
   example, that if (k=>v1) is a member of stldict sd then insert sd (k=>v2)
   will *not* change sd. sd!k will still be v1. Use update to change the
   values of existing members. E.g., after (update sd k v2), sd!k will be v2.

9. Most of the functions act on ranges of members, denoted by (sd,k1,k2),
   similar to (sv,i,j) for stlvec. I.e., (sd,"0","z") would be all (k=v) where
   k >= "0" and k < "z".

D. Cached iterators

1. The last C++ iterator used in selected operations is cached. Only one
   iterator is cached at any one time. Operations that invalidate the cached
   iterator cause the iterator to be removed from the cache.

2. The following operations cause an iterator to be cached:

3. The following operations cause an iterator to be deleted from the cache:

4 In certain commonly occuring sequences caching can eliminate an O(lob N)
  lookup. E.g., "member sd k" followed by "sd!k" or "update sd k v" only
  requires only one lookup. Caching also allows efficient traversal of the
  elements in sd using "next sd k" and "prev sd k".

D. Examples/Testing

1. To run the example/test scripts:

     $> pure -q -w
     > run check_eval.pure 
     > check "ut_stldict_script_a.pure";

2. ut_stldict_script_a.pure is a target file for check_eval that tests stldict
   functions.

3. ut_stldict_script_b.pure is a target file for log_eval that tests stlset
   functions.

4. More testing needs to be done.


