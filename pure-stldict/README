
============
pure-stldict
============

.. default-domain:: pure
.. module:: hashdict
.. module:: orddict

Version @version@, |today|

Albert Graef <Dr.Graef@t-online.de>

This package provides a light-weight, no frills interface to the C++
dictionary-like containers, ``map`` and ``unordered_map``, see the `C++
standard library documentation`_ for details. (The C++ containers were
originally based on the `Standard Template Library`_, so they are also
sometimes referred to as "STL containers"; hence the name of this package.)

The package includes the ``hashdict`` and ``orddict`` modules which make these
data structures available in Pure land and equip them with a (more or less)
idiomatic Pure container interface.

.. _C++ standard library documentation: http://en.cppreference.com/w/cpp
.. _Standard Template Library: http://www.sgi.com/tech/stl/

Copying
=======

Copyright (c) 2011 by Albert Graef.

pure-stldict is free software: you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option) any
later version.

pure-stldict is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
details.

You should have received a copy of the GNU Lesser General Public License along
with this program.  If not, see <http://www.gnu.org/licenses/>.

Installation
============

Get the latest source from
http://pure-lang.googlecode.com/files/pure-stldict-@version@.tar.gz.

Run ``make`` to compile the modules and ``make install`` (as root) to install
them in the Pure library directory. This requires GNU make, and of course you
need to have Pure (and a C++ library which includes the STL) installed.

``make`` tries to guess your Pure installation directory and platform-specific
setup. If it gets this wrong, you can set some variables manually, please
check the Makefile for details.

.. note:: This module requires Pure 0.49 or later and a recent version of the
   C++ library (GNU libstdc++ v3 has been tested). All proper C++11 libraries
   should work out of the box, while (recent) C++0x implementations may
   require some fiddling with the sources and/or the compilation options. Pre
   C++0x library versions surely require considerably more work, especially in
   the hashdict module.

Usage
=====

After installation, you can use the operations of this package by placing one
or both of the following import declarations in your Pure programs::

  using hashdict;
  using orddict;

In Pure land, the C++ ``map`` and ``unordered_map`` containers and their
``multimap`` variants are made available as a collection of four data
structures:

* ``hashdict``, ``hashmdict``: Hashed (unordered) dictionary data structures.
  These work with arbitrary key (and value) types, like the hashed dictionary
  and set data structures in the standard library, and can be found in the
  ``hashdict.pure`` module. In addition, the ``hashxdict`` type is defined as
  the union of the ``hashdict`` and ``hashmdict`` types so that it can be used
  to match any kind of hashed dictionary.

* ``orddict``, ``ordmdict``: Ordered dictionary data structures. These require
  the keys to be ordered by the standard ``<`` predicate, like the ordered
  dictionary and set data structures in the standard library, and can be found
  in the ``orddict.pure`` module. In addition, the ``ordxdict`` type is
  defined as the union of the ``orddict`` and ``ordmdict`` types so that it
  can be used to match any kind of ordered dictionary.

Note that ``hashdict`` and ``hashmdict`` differ in that the former has exactly
one key-value association for each key in the dictionary, while the latter is
a "multidict" which allows multiple values to be associated with a key. The
same applies to the ``orddict`` and ``ordmdict`` types.

All data structures offer most of the usual Pure container interface and can
be used either as dictionaries (holding key => value pairs) or sets (holding
only keys, without associated values). The data structures are very thin
wrappers around the C++ container types; in fact, they are just pointers to
the C++ containers. Memory management of these objects is automatic, and
customizable pretty-printing is provided as well.

The most important difference to the dictionary and set types in the standard
library is that the hashdict and orddict containers are *mutable* data
structures; inserting and deleting members really modifies the underlying C++
containers. (However, it is possible to take copies of the containers in
situations where it's necessary to preserve value semantics.)

Also note that not the full standard dictionary and set interface is provided;
in particular, subdict comparisons and set union/difference/intersection
operations are missing right now, but it's easy to define them yourself if
needed (please see the included examples).

Documentation of the types and functions provided by the modules is still to
be written, so for the time being please refer to the module sources and the
included examples instead.

Examples
========

Some basic examples showing hashdicts in action::

  > using hashdict;
  > let m = hashdict [foo=>99, bar=>bar 4711L, baz=>1..5]; m;
  hashdict [foo=>99,bar=>bar 4711L,baz=>[1,2,3,4,5]]
  > m!bar;
  bar 4711L
  > keys m;
  [foo,bar,baz]
  > vals m;
  [99,bar 4711L,[1,2,3,4,5]]
  > list m;
  [foo=>99,bar=>bar 4711L,baz=>[1,2,3,4,5]]
  > member m foo, member m bar;
  1,1
  > [x,y | x=>y = m];
  [(foo,99),(bar,bar 4711L),(baz,[1,2,3,4,5])]

Hashed multidicts (``hashmdict``)::

  > let m = hashmdict [foo=>99,baz=>1..5,baz=>bar 4711L]; m;
  hashmdict [foo=>99,baz=>[1,2,3,4,5],baz=>bar 4711L]
  > m!baz;
  [[1,2,3,4,5],bar 4711L]
  > m!foo;
  [99]

The following example illustrates how to employ ordered dictionaries as a set
data structure (note that we use the ``ordxdict`` type here so that these
definitions work with both ``orddict`` and ``ordmdict``)::

  > using orddict;
  > x::ordxdict + y::ordxdict = foldl insert (copy x) (list y);
  > x::ordxdict - y::ordxdict = foldl delete (copy x) (list y);
  > x::ordxdict * y::ordxdict = x-(x-y);

  > let m1 = orddict [5,1,3,11,3];
  > let m2 = orddict (3..6);
  > m1;m2;
  orddict [1,3,5,11]
  orddict [3,4,5,6]
  > m1+m2;
  orddict [1,3,4,5,6,11]
  > m1-m2;
  orddict [1,11]
  > m1*m2;
  orddict [3,5]

  > let m1 = ordmdict [5,1,3,11,3];
  > let m2 = ordmdict (3..6);
  > m1;m2;
  ordmdict [1,3,3,5,11]
  ordmdict [3,4,5,6]
  > m1+m2;
  ordmdict [1,3,3,3,4,5,5,6,11]
  > m1-m2;
  ordmdict [1,3,11]
  > m1*m2;
  ordmdict [3,5]

All dictionary containers can be used as generators in list and matrix
comprehensions::

  > [x y | x=>y = m];
  [foo 99,baz [1,2,3,4,5],baz (bar 4711L)]
  > {{x;y} | x=>y = m};
  {foo,baz,baz;99,[1,2,3,4,5],bar 4711L}

Note that in the current implementation this always computes the full member
list of the dictionary. This may use lots of extra memory in the case of large
dictionaries. As a remedy, you can also use the ``stream`` function to convert
the dictionary to a lazy list instead. This will often be slower, but in the
case of big dictionaries the tradeoff between memory usage and execution speed
may be worth considering. For instance::

  > let m = hashdict [foo i => i | i = 1..1000];
  > stream m;
  (foo 891=>891):#<thunk 0x7f10d31679f0>
  > stats -m
  > #list m;
  10000
  0.01s, 40001 cells
  > #stream m;
  10000
  0.11s, 16 cells
  > #[y | x=>y = m; gcd y 767~=1];
  925
  0.05s, 61853 cells
  > #[y | x=>y = stream m; gcd y 767~=1];
  925
  0.18s, 10969 cells
