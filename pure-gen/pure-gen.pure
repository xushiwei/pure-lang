#! /usr/local/bin/pure -x

using system, getopt, dict;

/* Command to invoke the C preprocessor. We use this to extract #defines from
   an input file as well as all its includes, so the -fdirectives-only option
   is required to keep those intact. This is pretty much tied to gcc right
   now, but as dump-ast also uses gcc you'll need it anyway. */
let cpp = "gcc -E -fdirectives-only";

// This path is set at installation time. For the uninstalled version we
// assume the current directory.
let dumper = "./dump-ast";

// This is also set at installation time.
let version = "@version@";

// for testing purposes
//let argv = ["pure-gen.pure","-v","-fc","-nffi","-pffi_","/usr/include/ffi.h"];

// Command line options and parameters.

let opts = [("--help", "-h", NOARG),
            ("--version", "-V", NOARG),
            ("--all", "-a", NOARG),
            ("--interface", "-f", REQARG),
            ("--output", "-o", REQARG),
            ("--c-name", "-c", REQARG),
            ("--lib-name", "-l", REQARG),
            ("--namespace", "-n", REQARG),
            ("--prefix", "-p", REQARG),
            ("--select", "-s", REQARG),
            ("--warnings", "-w", OPTARG),
            ("--verbose", "-v", OPTARG)];

let dfls = ["--interface" => "extern",
            "--namespace" => "",
            "--prefix" => "",
            "--select" => "",
            "--all" => "0",
            "--warnings" => "1",
            "--verbose" => "0"];

invalid_option x = fprintf stderr "Error: unrecognized option '%s'\nType 'pure-gen -h for help.\n" x $$ exit 1;

warning n::int s::string = fprintf stderr "Warning: %s\n" s if n<=warn;
echo s::string = puts s if verbose;

let cache = ref emptydict;
msgcache msg::string = 0 if member (get cache) msg;
		     = put cache (insert (get cache) (msg=>())) $$ 1;

basename s::string = last path if ~null path when path = split "/" s end;
		   = s otherwise;
dirname s::string = join "/" $ init path if ~null path when path = split "/" s end;
		  = "" otherwise;
strip_ext s::string = head name if ~null name when name = split "." s end;
		    = s otherwise;

let prog, args = case argv of
                   prog:args = prog, args;
                   _ = "pure-gen.pure", []
                 end;
let opts, args = catch invalid_option $ getopt opts args;

let opts = foldl insert (dict dfls) opts;

if member opts "--version" then
printf "pure-gen version %s\n" version $$ exit 0
else ();

if member opts "--help" then
printf "pure-gen version %s\n" version $$
puts $ "Usage: pure-gen [options] input-file\n" +
"--help, -h       Print this message and exit.\n" +
"--version, -V    Print version number and exit.\n" +
"--all, -a        Include \"hidden\" declarations.\n" +
"--interface, -f  Interface type (extern [default], c or ffi).\n" +
"--output, -o     Output filename (.pure).\n" +
"--c-name, -c     C filename (.c).\n" +
"--lib-name, -l   Shared library module to be imported.\n" +
"--namespace, -n  Module namespace in which symbols should be declared.\n" +
"--prefix, -p     Module name prefix to be removed from symbols.\n" +
"--select, -s     Select symbols to be included (extended regex).\n" +
"--warnings, -w   Display warnings (level = 0, 1 [default] or 2).\n" +
"--verbose, -v    Progress information (level = 0 [default] or 1).\n" +
"Default output filename (-o) is input filename with new extension .pure.\n" +
"Default C filename (-c) is input filename with new extension .c.\n" +
"Default library name (-l) is empty, or the basename of the C filename." $$
exit 0
else ();

if #args~=1 then
fprintf stderr "Error: %s source file specified\nType 'pure-gen -h for help.\n" (if null args then "no" else "more than one") $$ exit 1
else ();

if member opts "--interface" &&
  all ((~=) (opts!"--interface")) ["extern","c","ffi"] then
fprintf stderr "Error: invalid interface type (-f) '%s'\nType 'pure-gen -h for help.\n" (opts!"--interface") $$ exit 1
else ();

// Get options, provide reasonable defaults.

extern int atoi(char*);
defnum x opt::string = atoi opt if ~null opt;
defnum x _ = x otherwise;

let iface_opt = opts!"--interface";
let in_name = head args;
let base = strip_ext $ basename in_name;
let out_name = if member opts "--output" then opts!"--output"
               else base + ".pure";
let c_name = if member opts "--c-name" then opts!"--c-name"
             else base + ".c";
let c_base = strip_ext $ basename c_name;
let lib_name = if member opts "--lib-name" then opts!"--lib-name"
               else if opts!"--interface" == "c" then c_base else "";
let nmspace = opts!"--namespace";
let funpfx = opts!"--prefix";
let funpat = opts!"--select";
let cstpfx = opts!"--prefix";
let cstpat = opts!"--select";
let all_opt = defnum 1 $ opts!"--all";
let warn = defnum 1 $ opts!"--warnings";
let verbose = defnum 1 $ opts!"--verbose";

echo $ sprintf "Interface type:     %s" iface_opt;
echo $ sprintf "Library import:     %s" (if null lib_name then "none" else sprintf "using \"lib:%s\"" lib_name);
echo $ sprintf "Module namespace:   %s" nmspace;
echo $ sprintf "Module name prefix: %s" (opts!"--prefix");

/******************************************************************/


nullary Nothing;

// Language.C AST terminals
nullary CVoidType;
nullary CCharType;
nullary CShortType;
nullary CIntType;
nullary CLongType;
nullary CFloatType;
nullary CDoubleType;
nullary CSignedType;
nullary CUnsigType;
nullary CBoolType;
nullary CStructTag;
nullary CUnionTag;
nullary CPlusOp;
nullary CMinOp ;
nullary CNegOp ;
nullary CAddOp ;
nullary CSubOp ;
nullary CMulOp ;
nullary CDivOp ;
nullary CRmdOp ;
nullary CShlOp ;
nullary CShrOp ;
nullary CLeOp  ;
nullary CGrOp  ;
nullary CLeqOp ;
nullary CGeqOp ;
nullary CEqOp  ;
nullary CNeqOp ;
nullary CAndOp ;
nullary COrOp  ;
nullary CLndOp ;
nullary CLorOp ;
nullary CXorOp ;


nullary unknown_decl_type;
nullary not_found;

//these mirror the ffi type values
nullary void_t;
nullary uint8_t;
nullary sint8_t;
nullary uint16_t;
nullary sint16_t;
nullary uint32_t;
nullary sint32_t;
nullary uint64_t;
nullary sint64_t;
nullary float_t;
nullary double_t;
nullary pointer_t;
nullary uchar_t;
nullary schar_t;
nullary ushort_t;
nullary sshort_t;
nullary uint_t;
nullary sint_t;
nullary ulong_t;
nullary slong_t;

// to_ffi_type does a preliminary conversion from Language.C types (types
// specified in the C spec) to ffi types (real types on the machine.)
// short, long, signed and unsigned can also be used as modifiers, 
// in which case the _t suffix is dropped.

to_ffi_type x =
  case x of
  //these come from Language.C
  CVoidType     = void_t;
  CCharType     = schar_t;
  CShortType    = sshort_t;
  CIntType      = sint_t;
  CLongType     = slong_t;
  CFloatType    = float_t;
  CDoubleType   = double_t;
  CSignedType   = sint_t;
  CUnsigType    = uint_t;
  CBoolType     = sint_t; //??? char?
  CTypeDef str  = CTypeDef str; //these are resolved in a second pass
  CEnumType (CEnum (Just tag) (Just enum_defs) _)
	        = enum_type tag (scan_enums enum_defs);
  CEnumType (CEnum Nothing (Just enum_defs) _)
	        = enum_type "anonymous" (scan_enums enum_defs);
  CEnumType (CEnum _ _ _)
	        = sint_t;
  CSUType (CStructUnion _ (Just tag) _ _) = struct_or_union tag;
  CSUType (CStructUnion _ Nothing _ _) = struct_or_union "anonymous";
  _             = (warning 1 $ "unknown type "+str x+", defaulting to void")
    $$ void_t;
  end;

scan_enums defs =
  [constant n v | n=>v = list $ calc_enum_values emptydict () defs];

enum_vals (basic_type t) = enum_vals t;
enum_vals (enum_type _ v) = v;
enum_vals _ = [];

// pure_type takes an ffi type and makes a string suitable for a pure
// extern declaration

//these mirror the ffi type values
pure_type t =
  case t of
  void_t     = "void";
  uint8_t    = "char";
  sint8_t    = "char";
  uint16_t   = "short";
  sint16_t   = "short";
  uint32_t   = "int";
  sint32_t   = "int";
  uint64_t   = "long";
  sint64_t   = "long";
  float_t    = "float";
  double_t   = "double";
  pointer_t  = "void*";
  uchar_t    = "char";
  schar_t    = "char";
  ushort_t   = "short";
  sshort_t   = "short";
  uint_t     = "int";
  sint_t     = "int";
  ulong_t    = "int";
  slong_t    = "int";
  ptr_type (func_type _ _) = "void*";
  ptr_type t = pure_type t + "*";
  _          = puts ("pure_type error : "+str t) $$ "void";
  end;


// complete_ffi_type finishes the conversion by collecting typespecifiers such
// as long, unsigned, etc. This also strips away the "basic_type" specifier,
// which is used mostly for typedef resolution.

complete_ffi_type (basic_type x)  = complete_ffi_type x;



// ffi only knows "pointer_t" but pure's extern decls can take typed pointers
//complete_ffi_type (ptr_type _)    = pointer_t; 
complete_ffi_type (ptr_type t) = ptr_type ( complete_ffi_type t );

complete_ffi_type (func_type r a) = func_type (complete_ffi_type r)
                                            (map complete_ffi_type a);
complete_ffi_type (structure n f) = 
  structure n (zip ns (map complete_ffi_type fs))
  when (ns,fs) = unzip f end;

complete_ffi_type x =
  case x of
  //this is kind of a mess, due to all the different ways one might 
  //specify an int: int, long int, long, singed long, signed long int...
  void_t   = void_t;
  schar_t  = schar_t;
  sshort_t = sshort_t;
  slong_t  = slong_t;
  sint_t   = sint_t;
  uint_t   = uint_t;
  (long (sint_t))      = slong_t; 
  (long (slong_t))     = sint64_t; 
  (long (long sint_t)) = sint64_t; 
  float_t  = float_t;
  double_t = double_t;
  signed schar_t    = schar_t;  
  signed sshort_t   = sshort_t; 
  signed sint_t     = sint_t;   
  signed slong_t    = sint_t;
  signed (long (sint_t))      = slong_t; 
  signed (long (slong_t))     = sint64_t; 
  signed (long (long sint_t)) = sint64_t; 
  long (signed (sint_t))      = slong_t; 
  long (signed (slong_t))     = sint64_t; 
  long (signed (long sint_t)) = sint64_t; 
  unsigned schar_t  = uchar_t;  
  unsigned sshort_t = ushort_t; 
  unsigned sint_t   = uint_t; 
  unsigned slong_t  = uint_t; 
  unsigned (long (sint_t))      = ulong_t; 
  unsigned (long (slong_t))     = uint64_t; 
  unsigned (long (long sint_t)) = uint64_t; 
  long (unsigned (sint_t))      = ulong_t; 
  long (unsigned (slong_t))     = uint64_t; 
  long (unsigned (long sint_t)) = uint64_t; 

  enum_type _ _ = sint_t;
  
  _ = warning 2 ("unknown type "+str x+", defaulting to void") 
        $$ void_t;

  end;
   
  


// The primitive type of a declaration. Returns an ffi type, with specifiers.
type_spec ( (CTypeQual _) : more ) = type_spec more;
  //skip things like const, volatile, etc.

type_spec ( (CTypeSpec CShortType) :  []  ) = sshort_t;
type_spec ( (CTypeSpec CShortType) : more ) = short $ type_spec more;

type_spec ( (CTypeSpec CLongType) :  []  ) = slong_t;
type_spec ( (CTypeSpec CLongType) : more ) = long $ type_spec more;

type_spec ( (CTypeSpec CUnsigType) :  []  ) = uint_t;
type_spec ( (CTypeSpec CUnsigType) : more ) = unsigned $ type_spec more;

type_spec ( (CTypeSpec CSignedType) :  []  ) = sint_t;
type_spec ( (CTypeSpec CSignedType) : more ) = signed $ type_spec more;

type_spec ( (CTypeSpec t) : _ ) = to_ffi_type t; 
 //I don't really know what else could be in the list here

type_spec ( _ : more ) = type_spec more;
type_spec [] = throw unknown_decl_type;



// decl_type : Grab a simplified type representation from a declaration.
// Result is a list of the following terms: 
//    basic_type t      : t is a c primitive type or a typedef
//    ptr_type t        : t is again one of basic_type, ptr_type or func_type
//    func_type ret args: ret is again one basic_type, ptr_type or func_type, 
//                        and args is a list of such terms.
// If the type cannot be described in the above terms, an exception
// "unknown_decl_type" is thrown.
// 
// The returned list contains one type for each object declared in this
// declaration, e.g. "int *x, y;" yields 
// [ ptr_type(basic_type sint_t), basic_type sint_t ]

decl_types (CDeclExt d _) = decl_types d ;

decl_types d@(CDecl decl_specs [] ) = [ basic_type (type_spec decl_specs) ];
decl_types d@(CDecl decl_specs init_declr_list ) = decl_types2 d;

decl_types2 d@(CDecl decl_specs init_declr_list) = 
  case init_declr_list of 
    (Just (CDeclr _ derivs _ arg_attrs), Nothing, Nothing) : more =
        apply_derivs (type_spec decl_specs) derivs : decl_types2 (CDecl decl_specs more);
    [] = [];
    _ = [];
  end
  with 
    //basic_type : get the type of a declaration, ignoring storage and access
    //modifiers
    apply_derivs t [] = basic_type t;
    apply_derivs t ( (CPtrDeclr _  ) : derivs ) |
    apply_derivs t ( (CArrDeclr _ _) : derivs ) = //treat arrays as pointers, 
      ptr_type $ apply_derivs t derivs;           //even if they are proper array objects
    apply_derivs t ( (CFunDeclr args _) : derivs ) = 
      case args of 
        Right (arg_decls,_) = 
          func_type (apply_derivs t derivs) (catmap decl_types arg_decls);
        Left _      = //old-style K&R declaration.
          throw unknown_decl_type;
      end;
  end;



// decl_idents : Grab the names of things declared in a declaration. Returns a
// list of strings (identifiers) which may be empty the the declaration is
// anonymous (i.e., a function parameter) or may contain multiple identifiers
// if the declaration declares multiple things, e.g. "int x,y,z;"

decl_idents (CDeclExt d _) = decl_idents d;
decl_idents d@(CDecl _ init_declr_list) = 
  case init_declr_list of 
    (Just (CDeclr (Just ident) _ _ _), _, _) : more =
        ident : decl_idents (CDecl decl_specs more);
    _ = [];
  end;



is_typedef ( (CStorageSpec CTypedef) : decl_specs) = 1;
is_typedef ( _ : decl_specs) = is_typedef decl_specs;
is_typedef [] = 0;


// typedef : returns a list of (name=>type) bindings, possibly empty if this
// declaration was not a typedef
typedefs (CDeclExt d _) = typedefs d;
typedefs d@(CDecl decl_specs _) =
  if is_typedef decl_specs 
  then zip (decl_idents d) (decl_types d)
  else [];


// func_decl : returns a list containing a single (name,type) binding if
// this declaration declares a function, otherwise [].
func_decl (CDeclExt d _) = func_decl d;
func_decl d@(CDecl _ _) =
  case decl_types d of
    f@([func_type ret args]) = zip (decl_idents d) f;
    _ = [];
  end;

//resolve a typedef : d is a dictionary 
resolve_typedef d t = lookup t
  with
    lookup (basic_type (CTypeDef n)) =
      catch ( \_ -> puts $ "could not resolve typedef: "+n+
                           ", defaulting to int" $$ sint_t  ) 
            ( lookup (d!n) );

    lookup (basic_type (CSUType _ (CStructUnion _ (Just name) _ _))) = 
      basic_type (struct_or_union name);
    lookup t@(struct_or_union n) = t;
    lookup (basic_type (CEnumType (CEnum (Just tag) (Just enum_defs) _))) =
      basic_type (enum_type tag (scan_enums enum_defs));
    lookup (basic_type (CEnumType n)) = sint_t;
    lookup t@(enum_type n _) = t;
    lookup t@(basic_type _) = t;
    lookup (ptr_type t) = ptr_type (lookup t);
    lookup (func_type ret args) = func_type (lookup ret) (map lookup args);
    lookup x = puts ("resolve_typedef error: "+str x) $$ void_t;
  end;
    
resolve_decl_typedefs tydefs decls = 
  map (\(n,t) -> (n , resolve_typedef tydefs t) ) decls;

resolve_struct_typedefs tydefs (structure name fields) = 
  structure name $ resolve_decl_typedefs tydefs fields;





// Gather the declared structs or unions. C allows structs to be declared just
// about anywhere but we only grab them from three toplevel declarations:
//   struct X { .. };
//   typedef struct Y { .. } X;
//   typedef struct { .. } X;
// In any case, the struct is bound to the name X.
//
// The result is either [] or [structure name fields] where
// fields are a list of (name,type) tuples
//
// Does not handle nested structs or unions yet.

decl_struct (CDeclExt d _) = decl_struct d;
decl_struct d@(CDecl ( (CStorageSpec CTypeDef ) : 
                       (CTypeSpec (CSUType strct)) : _ ) 
                     init_declr_list) 
    =
  case strct of
    //struct name
    CStructUnion _ (Just _) (Just fields) _  | //struct has a tag
    CStructUnion _ Nothing (Just fields)  _  = //struct is anonymous. 
      [ structure name $ 
        zip (catmap decl_idents fields) (catmap decl_types fields) ];
    _ = [];
  end
  when 
    name = head $ decl_idents d;
  end;

decl_struct d@(CDecl ( (CTypeSpec (CSUType strct)) : _ ) [] ) =
  case strct of
    CStructUnion _ (Just name) (Just fields) _  = 
      [ structure name $ 
        zip (catmap decl_idents fields) (catmap decl_types fields) ];
    _ = [];
  end;

decl_struct d = [];
  


  
// Scrape enum constants. Takes a list of top-level declarations (CDeclExt)
// and produces a dictionary of name=>value pairs. This has to be run over the
// whole list because some constants will be defined in terms of others. 
decl_enums = 
  foldl get_enum emptydict;

get_enum dict (CDeclExt d _) = get_enum dict d;

get_enum dict d@(CDecl ( (CStorageSpec CTypeDef ) : 
                         (CTypeSpec (CEnumType enum)) : _ ) 
                       init_declr_list) 
    =
  case enum of
    CEnum _ (Just vals) _ = calc_enum_values dict () vals
  end ;
  
get_enum dict d@(CDecl ( (CTypeSpec (CEnumType enum)) : _ ) []) =
  case enum of
    CEnum _ (Just vals) _ = calc_enum_values dict () vals
  end;

get_enum dict _ = dict;


calc_enum_values dict prev ((name,Just e):more) = 
  case eval_expr dict e of
    val::int = calc_enum_values (insert dict (name => val)) val more;
    x = puts $ "Couldn't evaluate enum expression for "+name+" : "+str e 
          $$ calc_enum_values dict prev more;
  end;

calc_enum_values dict () ((name,Nothing):more) = 
   calc_enum_values (insert dict (name=>0)) 0 more;

calc_enum_values dict prev ((name,Nothing):more) = 
    calc_enum_values (insert dict (name=>(prev+1))) (prev+1) more;
 
calc_enum_values dict _ [] = dict;

eval_expr d (CVar n) = 
  catch 
  (\e  -> 
    puts$"Couldn't lookup name "+n+" in enum definition. Defaulting to 0."$$0
  ) (d!n);

eval_expr d (CConst (CIntConst x)) = x;

eval_expr d (CUnary  CPlusOp x) =     eval_expr d x;
eval_expr d (CUnary  CMinOp x) = neg (eval_expr d x);
eval_expr d (CUnary  CNegOp x) = not (eval_expr d x);

eval_expr d (CBinary CAddOp e1 e2) = (eval_expr d e1) +   (eval_expr d e2);
eval_expr d (CBinary CSubOp e1 e2) = (eval_expr d e1) -   (eval_expr d e2);
eval_expr d (CBinary CMulOp e1 e2) = (eval_expr d e1) *   (eval_expr d e2);
eval_expr d (CBinary CDivOp e1 e2) = (eval_expr d e1) /   (eval_expr d e2);
eval_expr d (CBinary CRmdOp e1 e2) = (eval_expr d e1) mod (eval_expr d e2);
eval_expr d (CBinary CShlOp e1 e2) = (eval_expr d e1) <<  (eval_expr d e2);
eval_expr d (CBinary CShrOp e1 e2) = (eval_expr d e1) >>  (eval_expr d e2);
eval_expr d (CBinary CLeOp  e1 e2) = (eval_expr d e1) <   (eval_expr d e2);
eval_expr d (CBinary CGrOp  e1 e2) = (eval_expr d e1) >   (eval_expr d e2);
eval_expr d (CBinary CLeqOp e1 e2) = (eval_expr d e1) <=  (eval_expr d e2);
eval_expr d (CBinary CGeqOp e1 e2) = (eval_expr d e1) >=  (eval_expr d e2);
eval_expr d (CBinary CEqOp  e1 e2) = (eval_expr d e1) ==  (eval_expr d e2);
eval_expr d (CBinary CNeqOp e1 e2) = (eval_expr d e1) ~=  (eval_expr d e2);
eval_expr d (CBinary CAndOp e1 e2) = (eval_expr d e1) &&  (eval_expr d e2);
eval_expr d (CBinary COrOp  e1 e2) = (eval_expr d e1) ||  (eval_expr d e2);
eval_expr d (CBinary CLndOp e1 e2) = (eval_expr d e1) and (eval_expr d e2);
eval_expr d (CBinary CLorOp e1 e2) = (eval_expr d e1) or  (eval_expr d e2);
eval_expr d (CBinary CXorOp e1 e2) = xor (eval_expr d e1) (eval_expr d e2)
  with 
  xor a b = (a and not b) or (not a and b); // why exclude poor xor?
  end;
                  






// Grab all #define'd constants. lns is a list of strings, the 
// lines of the file. Thus, this can't deal with #defines that span
// multiple lines.
scrape_defines lns = 
  foldr 
    (\ln out -> 
      case catmap (split_ "\t") $ split_ " " ln of
        [define,name,val] =
          case define of
            "#define" = 
              catch 
                (\_ -> (warning 2 $ sprintf "Can't parse %s" ln) $$ out)
                ( check_constant name val : out );
            _ = out;
          end if ~null val;
        _ = out;
      end when ln = init ln end
    ) [] lns;

// Check for a constant value (either another #define'd constant, or a number).
check_constant name val::string
  = check_string name val
      if regex "^\".*\"$" REG_NOSUB val 0;
  = indirect name val if regex "^[A-Za-z_][A-Za-z_0-9]*$" REG_NOSUB val 0;
  = check_number name val;
check_number name val::string
  = check_number name (substr val 1 (#val-2))
      if regex "^(.*)$" REG_NOSUB val 0;
  = constant name (sscanf val "%i") otherwise;
check_string name val::string
  = constant name str when str::string = eval val end;

// Some constants are defined in terms of others.  Here we resolve those
// indirections.
resolve_indirects constants =
  filter (\i -> case i of not_found = 0; _ = 1; end) $
    map (lookup dict) constants 
  when
    dict = foldl build emptydict constants;
  end
  with
  build d i@(indirect n _) = 
    /*puts ("adding ["+n+"] to dict") $$*/ 
    insert d (n=>i) ;
  build d c@(constant n _) = 
    /*puts ("adding ["+n+"] to dict") $$*/ 
    insert d (n=>c) ;
  lookup _ c@(constant _ _) = c;
  lookup d (indirect n c) = 
    catch
      (\_ -> 
          warning 2 $ "Target of indirected constant not found: \""+
                      n+"\" => \""+c+"\"" $$ 
          not_found )
      ( case d!c of
        (constant _ v) = constant n v;
        (indirect _ i) = lookup d (indirect n i);
        end );
  end;



nmspacepfx nmspace = if null nmspace then "" else nmspace+"::";


// Output a constant declaration.
// If after stripping the prefix the constant name starts with a number, then
// add a leading underscore.
const_decl pfx nmspace (constant name val) = 
  case strip_prefix pfx name of
    name =
      if regex "^[0-9]" REG_NOSUB name 0 
        then "const "+nmspacepfx nmspace+"_"+name+" = "+str val+";\n"
        else "const "+nmspacepfx nmspace+name+" = "+str val+";\n"
      ;
  end;

//output a function declaration for the ffi interface
ffi_extern_decl pfx::string nmspace::string (name, func_type ret args) =
  "let "+nmspacepfx nmspace+strip_prefix pfx name+" = fcall \""+
    name+"\" FFI_DEFAULT_ABI "+str ret+" ("+str(tuple args)+");";

//output a function declaration for the native pure extern interface
pure_extern_decl pfx::string nmspace::string (name, func_type ret args) =
  "extern "+pure_type ret+" "+name+"("+arg_str args+") = "+
    strip_prefix pfx name+";"
  with
  arg_str [void_t] = "";
  arg_str args = join "," $ map pure_type args;
  end;

//output a function declaration for the native pure extern interface,
//appending the prefix "Pure_" to the function name
Pure_extern_decl pfx::string nmspace::string (name, func_type ret args) =
  "extern "+pure_type ret+" Pure_"+name+"("+arg_str args+") = "+
    strip_prefix pfx name+";"
  with
  arg_str [void_t] = "";
  arg_str args = join "," $ map pure_type args;
  end;




//output the C portion of a function
//TODO: at this point the typedefs have been resolved. It would be better
//if they were not.
c_impl (name, func_type ret args) = 
ret_str+" Pure_"+name+"("+formal_params+") {\n"+
"  return "+name+"("+arg_names+");\n}\n\n"
  when
    ret_str = pure_type ret;

    formal_params = 
      if args === [void_t] then "" else 
      join ", " $ zipwith (\x y -> pure_type x+" arg"+str y) args (0..inf);

    arg_names = 
      if args === [void_t] then "" else 
      join "," $ map (\y -> "arg" + str y) (take (#args) (0..inf));

    arg_types = 
      if args === [void_t] then "" else 
      join "," $ map pure_type args;
    
  end;


//select constant and function declarations based on a regex match
const cflags = REG_NOSUB or REG_EXTENDED;
matches pat (constant name _) = valid_name name &&
  regchk pat (regex pat cflags name 0);
matches pat (name, _) = valid_name name &&
  regchk pat (regex pat cflags name 0);
// make regex just always return 1 in case of an error
regchk pat (regerr _ _) = warning 0 msg $$ 1 if msgcache msg
when msg = sprintf "error in regular expression '%s'" pat end;
			= 1 otherwise;
regchk _ x = x;

// Filter out builtins and stuff commonly found in system header files.
valid_name name = true if all_opt;
		= substr name 0 1 ~= "_" && name ~= "linux" && name ~= "unix";



//misc helpful stuff


//get all lines in a file
fgetlines f = reverse $ get [] 
  with 
  get a = 
    case fgets f of 
    s::string = get (s:a); 
    _ = a; 
    end 
  end;

//a better split
split_ delim s = filter (\s -> s ~= "") $ split delim s;

//inverse of split
join sep (x:y:z) = join sep ((x+sep+y):z);
join _ [x] = x ;
join _ [] = "";

// convert string to uppercase
extern int toupper(int) = ctoupper;
toupper s::string = string $ map (chr.ctoupper.ord) s;

strip_prefix pfx::string str::string =
  if str ~= pfx && toupper (substr str 0 (#pfx)) == toupper pfx then
    strip_us $ substr str (#pfx) (#str)
  else str
with
  strip_us str = if null str || str == "_" ||str!0 ~= "_" then str
                 else tail str;
end;


//need these for nub
constant a _ < constant b _ = a < b;
constant a _ > constant b _ = a > b;
constant a _ == constant b _ = a == b;

nub xs = reverse $ go [] emptydict xs
  with
  go a d (x:xs) = go a d xs if member d x;
                = go (x:a) (insert d (x=>x)) xs otherwise;
  go a _ [] = a;
  end;


/******************************************************************/

// read the source and its includes, this is needed to grab the #defines
let lines = fgetlines $ popen (sprintf "%s %s" (cpp,in_name)) "r";

//build the AST

echo "Loading AST";
let ast = fgetlines $ popen (sprintf "%s %s" (dumper,in_name)) "r";

echo "Parsing";
let declarations = filter ((~=) ()) $ map eval ast;

echo "Building typedef dictionary";
let tydefs = 
      foldl (\d (n,t) -> insert d (n=>t)) emptydict $
        catmap typedefs declarations;


echo "Building #define dictionary";
let defines = 
  nub $ resolve_indirects $ scrape_defines lines +
        catmap enum_vals (vals tydefs);


echo "Gathering function prototypes";
//all function prototypes
let func_protos =
      mapsnd complete_ffi_type $
        resolve_decl_typedefs tydefs $
          catmap func_decl declarations
  with
    mapsnd f = map (\(a,b) -> a,f b)
  end;


//Output the Pure part
let out_pure   = fopen out_name "w";

let extern_decl = case iface_opt of
  "ffi" = fputs "using ffi;\n" out_pure $$ ffi_extern_decl;
  "c" = Pure_extern_decl
  when
    //Output the C part
    out_c = fopen c_name "w";
    echo $ sprintf "Writing %s" c_name;

    fprintf out_c "#include \"%s\"\n\n" in_name; 
    do (flip fputs out_c) $
      map c_impl $ filter (matches funpat) func_protos;
  end;
  _ = pure_extern_decl;
end;
echo $ sprintf "Writing %s" out_name;
if ~null lib_name then fprintf out_pure "using \"lib:%s\";\n" lib_name else ();
if ~null nmspace then fprintf out_pure "\nnamespace %s;\n" nmspace else ();

do (flip fputs out_pure . const_decl cstpfx nmspace) $
  filter (matches cstpat) defines;

do (flip fputs out_pure) $
  map (\x -> extern_decl funpfx nmspace x + "\n") $
  filter (matches funpat) func_protos;
