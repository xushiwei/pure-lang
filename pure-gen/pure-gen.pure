#! /usr/local/bin/pure -x

using system, getopt, dict;

/* Command to invoke the C preprocessor. We use this to extract #defines from
   an input file as well as all its includes, so the -fdirectives-only option
   is required to keep those intact. This is pretty much tied to gcc right
   now, but as dump-ast also uses gcc you'll need it anyway. */
let cpp = "gcc -E -fdirectives-only";

// This path is set at installation time. For the uninstalled version we
// assume the current directory.
let dumper = "./dump-ast";

// This is also set at installation time.
let version = "@version@";

// for testing purposes
//let argv = ["pure-gen.pure","-v","-fc","-s/usr/include/ffi.h,/usr/include/ffitarget.h::","-mffi","-pffi_","/usr/include/ffi.h"];

/* Default template for C code generation.

   %r = return type, %w = wrapper function name, %p = formal params, %n =
   real function name, %a = arguments, %% escapes a single %.

   A %% on a line by itself separates the "frontmatter" (code to be inserted
   at the beginning of the C file, right after the #include of the header
   file) from the function template in the main part of the code. */

let default_template = "%r %w(%p) {\n  return %n(%a);\n}\n\n";

split_template template::string = frontmatter, template when
  lines = split "\n" template;
  lines1 = takewhile (\x->x~="%%") lines;
  lines2 = dropwhile (\x->x~="%%") lines;
  lines1,lines2 = if null lines2 then lines2,lines1 else lines1,tail lines2;
  frontmatter = join "\n" lines1;
  template = join "\n" lines2;
end;

// Command line options and parameters.

let opts = [("--help", "-h", NOARG),
            ("--version", "-V", NOARG),
            ("--all", "-a", NOARG),
            ("--cpp-options", "-O", REQARG),
            ("--interface", "-f", REQARG),
            ("--output", "-o", REQARG),
            ("--c-name", "-c", REQARG),
            ("--lib-name", "-l", REQARG),
            ("--noclobber", "-N", NOARG),
            ("--namespace", "-m", REQARG),
            ("--prefix", "-p", REQARG),
            ("--select", "-s", REQARG),
            ("--wrap", "-P", REQARG),
            ("--template", "-t", REQARG),
            ("--dry-run", "-n", OPTARG),
            ("--warnings", "-w", OPTARG),
            ("--verbose", "-v", OPTARG),
            ("--echo", "-e", OPTARG)];

let dfls = ["--interface" => "extern",
            "--cpp-options" => "",
            "--namespace" => "",
            "--prefix" => "",
            "--select" => "",
            "--wrap" => "Pure_",
            "--all" => "0",
            "--noclobber" => "0",
            "--dry-run" => "0",
            "--warnings" => "1",
            "--verbose" => "0",
            "--echo" => "0"];

invalid_option x = fprintf stderr "Error: unrecognized option '%s'\nType 'pure-gen -h for help.\n" x $$ exit 1;

warning n::int s::string = fprintf stderr "Warning: %s\n" s if n<=warn;
echo 1 s::string = puts s if verbose;
echo 2 s::string = puts s if echo_cpp;

let cache = ref emptydict;
msgcache msg::string = 0 if member (get cache) msg;
		     = put cache (insert (get cache) (msg=>())) $$ 1;

basename s::string = last path if ~null path when path = split "/" s end;
		   = s otherwise;
dirname s::string = join "/" $ init path if ~null path when path = split "/" s end;
		  = "" otherwise;
strip_ext s::string = head name if ~null name when name = split "." s end;
		    = s otherwise;

let prog, args = case argv of
                   prog:args = prog, args;
                   _ = "pure-gen.pure", []
                 end;
let opts, args = catch invalid_option $ getopt opts args;

let opts = foldl insert (dict dfls) opts;

if member opts "--version" then
printf "pure-gen version %s\n" version $$ exit 0
else ();

if member opts "--help" then
printf "pure-gen version %s\n" version $$
puts $ "Usage: pure-gen [options] <input-file>.h\n" +
"-h, --help        Print this message and exit.\n" +
"-V, --version     Print version number and exit.\n" +
"-a, --all         Include \"hidden\" declarations.\n" +
"-f, --interface   Interface type ('extern', 'c' or 'ffi').\n" +
"-O, --cpp-options Options to pass to the C preprocessor (-I, -D etc.).\n" +
"-o, --output      Pure output (.pure) filename.\n" +
"-c, --c-name      C wrapper (.c) filename for -fc.\n" +
"-l, --lib-name    Shared library module to be imported.\n" +
"-n, --dry-run     Only parse without generating any output.\n" +
"-N, --noclobber   Append output to existing files.\n" +
"-m, --namespace   Module namespace in which symbols should be declared.\n" +
"-p, --prefix      Module name prefix to be removed from C symbols.\n" +
"-P, --wrap        Prefix to be prepended to C wrapper symbols.\n" +
"-s, --select      Filter of valid C symbols (see README for details).\n" +
"-t, --template    Specify C template file (see README for details).\n" +
"-e, --echo        Echo preprocessor lines.\n" +
"-v, --verbose     Show parameters and progress information.\n" +
"-w, --warnings    Display warnings (level = 0, 1 [default] or 2).\n" +
"Defaults: -f extern, -P Pure_, -o <input-file>.pure, -c <input-file>.c.\n" +
"Defaults: -l <c-file> (without extension) for -fc, otherwise empty." $$
exit 0
else ();

if #args~=1 then
fprintf stderr "Error: %s source file specified\nType 'pure-gen -h for help.\n" (if null args then "no" else "more than one") $$ exit 1
else ();

if member opts "--interface" &&
  all ((~=) (opts!"--interface")) ["extern","c","ffi"] then
fprintf stderr "Error: invalid interface type (-f) '%s'\nType 'pure-gen -h for help.\n" (opts!"--interface") $$ exit 1
else ();

// Get options, provide reasonable defaults.

extern int atoi(char*);
defnum x opt::string = atoi opt if ~null opt;
defnum x _ = x otherwise;

let cpp_opts = opts!"--cpp-options";
let iface_opt = opts!"--interface";
let in_name = head args;
let base = strip_ext $ basename in_name;
let out_name = if member opts "--output" then opts!"--output"
               else base + ".pure";
let c_name = if member opts "--c-name" then opts!"--c-name"
             else base + ".c";
let c_base = strip_ext $ basename c_name;
let lib_name = if member opts "--lib-name" then opts!"--lib-name"
               else if opts!"--interface" == "c" then c_base else "";
let glob_pat, regex_pat = case split "::" $ opts!"--select" of
                            [] = "", "";
                            [x] = "", x;
                            x:xs = x, join "::" xs;
                          end;
let nmspace = opts!"--namespace";
let funpfx = opts!"--prefix";
let funpat = regex_pat;
let cstpfx = opts!"--prefix";
let cstpat = regex_pat;
let fnpat = split "," glob_pat;
let wrap_prefix = opts!"--wrap";
let all_opt = defnum 1 $ opts!"--all";
let noclobber = defnum 1 $ opts!"--noclobber";
let dry_run = defnum 1 $ opts!"--dry-run";
let warn = defnum 1 $ opts!"--warnings";
let verbose = defnum 1 $ opts!"--verbose";
let echo_cpp = defnum 1 $ opts!"--echo";

let frontmatter, template = split_template template
when
  template = if member opts "--template" then
               fget (fopen (opts!"--template") "r")
             else default_template;
  template = if stringp template then template
             else fprintf stderr
               "Template file '%s' not found, using default template\n"
               (opts!"--template") $$ default_template;
end;

if dry_run then echo 1 "** Dry run." else ();
echo 1 $ sprintf "Interface type:     %s" iface_opt;
echo 1 $ sprintf "Library import:     %s" (if null lib_name then "(none)" else sprintf "using \"lib:%s\"" lib_name);
echo 1 $ sprintf "Module namespace:   %s" nmspace;
echo 1 $ sprintf "Module name prefix: %s" (opts!"--prefix");
echo 1 $ sprintf "Symbol selection:   %s" (if null sel then "(all)" else sel when sel = opts!"--select" end);
echo 1 $ sprintf "CPP options:        %s" (if null cpp_opts then "(none)" else cpp_opts);
if member opts "--template" then
echo 1 $ sprintf "C template file:    %s" (opts!"--template")
else ();

/******************************************************************/

// Haskell Maybe type constructor
nullary Nothing;

// Language.C AST terminals
// typedef storage spec, denotes typedefs
nullary CTypedef;
// basic C types
nullary CVoidType CCharType CShortType CIntType CLongType CFloatType
  CDoubleType CSignedType CUnsigType CBoolType;
// struct/union types (these aren't used right now)
nullary CStructTag CUnionTag;
// constant expressions, we evaluate these
nullary CPlusOp CMinOp CNegOp CAddOp CSubOp CMulOp CDivOp CRmdOp CShlOp
  CShrOp CLeOp CGrOp CLeqOp CGeqOp CEqOp CNeqOp CAndOp COrOp CLndOp CLorOp
  CXorOp;

// these mirror the ffi type values
nullary void_t uint8_t sint8_t uint16_t sint16_t uint32_t sint32_t
  uint64_t sint64_t float_t double_t pointer_t string_t uchar_t schar_t
  ushort_t sshort_t uint_t sint_t ulong_t slong_t;
// special pure_expr and GSL matrix types
nullary expr_t;
nullary dmatrix_t cmatrix_t imatrix_t;

// to_ffi_type does a preliminary conversion from Language.C types (types
// specified in the C spec) to ffi types (real types on the machine.)
// short, long, signed and unsigned can also be used as modifiers, 
// in which case the _t suffix is dropped.

to_ffi_type x fname =
  case x of
  //these come from Language.C
  CVoidType     = void_t;
  CCharType     = schar_t;
  CShortType    = sshort_t;
  CIntType      = sint_t;
  CLongType     = slong_t;
  CFloatType    = float_t;
  CDoubleType   = double_t;
  CSignedType   = sint_t;
  CUnsigType    = uint_t;
  CBoolType     = sint_t; //??? char?
  CTypeDef str  = CTypeDef str; //these are resolved in a second pass
  CEnumType (CEnum (Just tag) (Just enum_defs) _)
	        = enum_type tag (scan_enums enum_defs) fname;
  CEnumType (CEnum Nothing (Just enum_defs) _)
	        = enum_type "anonymous" (scan_enums enum_defs) fname;
  CEnumType (CEnum _ _ _)
	        = sint_t;
  CSUType (CStructUnion _ (Just tag) _ _) = struct_or_union tag;
  CSUType (CStructUnion _ Nothing _ _) = struct_or_union "anonymous";
  _             = (warning 1 $ "unknown type "+str x+", defaulting to void")
    $$ void_t;
  end;

/* FIXME: This dictionary *must* be properly initialized using decl_enums
   before scan_enums gets invoked through any of the other declaration
   processing functions. We should really make this an argument to scan_enums,
   but the necessary plumbing is just horrible, so we prefer to have this as a
   global here. */
let enumdefs = emptydict;
scan_enums defs =
  /* We need to take care of the case of an unresolved enum symbol here.
     Assume that it's a #defined symbol which will hopefully be resolved in
     resolve_indirects. */
  [(if stringp v then indirect else constant) n v |
   n=>v = list $ calc_enum_values enumdefs () defs];

enum_vals (basic_type t) = enum_vals t;
enum_vals (enum_type _ v fname) = [x fname | x = v];
enum_vals _ = [];

// pure_type takes an ffi type and makes a string suitable for a pure
// extern declaration

//these mirror the ffi type values
pure_type t =
  case t of
  void_t     = "void";
  uint8_t    = "char";
  sint8_t    = "char";
  uint16_t   = "short";
  sint16_t   = "short";
  uint32_t   = "int";
  sint32_t   = "int";
  uint64_t   = "long";
  sint64_t   = "long";
  float_t    = "float";
  double_t   = "double";
  pointer_t  = "void*";
  uchar_t    = "char";
  schar_t    = "char";
  ushort_t   = "short";
  sshort_t   = "short";
  uint_t     = "int";
  sint_t     = "int";
  ulong_t    = "int";
  slong_t    = "int";
  expr_t     = "expr";
  dmatrix_t  = "dmatrix";
  cmatrix_t  = "cmatrix";
  imatrix_t  = "imatrix";
  ptr_type (func_type _ _) = "void*";
  ptr_type t = pure_type t + "*";
  _          = warning 0 ("pure_type error : "+str t) $$ "void";
  end;

// The corresponding C types are exactly the same, except in the case of
// pure_expr and matrix pointers.
c_type t =
  case t of
  ptr_type (func_type _ _) = "void*";
  ptr_type t = c_type t + "*";
  expr_t = "pure_expr";
  dmatrix_t = "gsl_matrix";
  cmatrix_t = "gsl_matrix_complex";
  imatrix_t = "gsl_matrix_int";
  _ = pure_type t;
  end;


// complete_ffi_type finishes the conversion by collecting typespecifiers such
// as long, unsigned, etc. This also strips away the "basic_type" specifier,
// which is used mostly for typedef resolution.

complete_ffi_type (basic_type x)  = complete_ffi_type x;



// ffi only knows "pointer_t" but pure's extern decls can take typed pointers
//complete_ffi_type (ptr_type _)    = pointer_t; 
complete_ffi_type (ptr_type t) = ptr_type ( complete_ffi_type t );

complete_ffi_type (func_type r a) = func_type (complete_ffi_type r)
				    (map complete_ffi_type a);
complete_ffi_type (struct_or_union "_pure_expr") = expr_t;
complete_ffi_type (struct_or_union "gsl_matrix") = dmatrix_t;
complete_ffi_type (struct_or_union "gsl_matrix_complex") = cmatrix_t;
complete_ffi_type (struct_or_union "gsl_matrix_int") = imatrix_t;
complete_ffi_type (structure n f) = 
  structure n (zip ns (map complete_ffi_type fs))
  when (ns,fs) = unzip f end;

complete_ffi_type x =
  case x of
  //this is kind of a mess, due to all the different ways one might 
  //specify an int: int, long int, long, singed long, signed long int...
  void_t   = void_t;
  schar_t  = schar_t;
  sshort_t = sshort_t;
  slong_t  = slong_t;
  sint_t   = sint_t;
  uint_t   = uint_t;
  (long (sint_t))      = slong_t; 
  (long (slong_t))     = sint64_t; 
  (long (long sint_t)) = sint64_t; 
  float_t  = float_t;
  double_t = double_t;
  signed schar_t    = schar_t;  
  signed sshort_t   = sshort_t; 
  signed sint_t     = sint_t;   
  signed slong_t    = sint_t;
  signed (long (sint_t))      = slong_t; 
  signed (long (slong_t))     = sint64_t; 
  signed (long (long sint_t)) = sint64_t; 
  long (signed (sint_t))      = slong_t; 
  long (signed (slong_t))     = sint64_t; 
  long (signed (long sint_t)) = sint64_t; 
  unsigned schar_t  = uchar_t;  
  unsigned sshort_t = ushort_t; 
  unsigned sint_t   = uint_t; 
  unsigned slong_t  = uint_t; 
  unsigned (long (sint_t))      = ulong_t; 
  unsigned (long (slong_t))     = uint64_t; 
  unsigned (long (long sint_t)) = uint64_t; 
  long (unsigned (sint_t))      = ulong_t; 
  long (unsigned (slong_t))     = uint64_t; 
  long (unsigned (long sint_t)) = uint64_t; 

  enum_type _ _ _ = sint_t;
  
  _ = warning 2 ("unknown type "+str x+", defaulting to void") $$ void_t;

  end;
   
  
// exception value signifying an unknown or unrecognized C type
nullary unknown_decl_type;

// The primitive type of a declaration. Returns an ffi type, with specifiers.
type_spec ( (CTypeQual _) : more ) fname = type_spec more fname;
  //skip things like const, volatile, etc.

type_spec ( (CTypeSpec CShortType) :  []  ) _ = sshort_t;
type_spec ( (CTypeSpec CShortType) : more ) fname = short $ type_spec more fname;

type_spec ( (CTypeSpec CLongType) :  []  ) _ = slong_t;
type_spec ( (CTypeSpec CLongType) : more ) fname = long $ type_spec more fname;

type_spec ( (CTypeSpec CUnsigType) :  []  ) _ = uint_t;
type_spec ( (CTypeSpec CUnsigType) : more ) fname = unsigned $ type_spec more fname;

type_spec ( (CTypeSpec CSignedType) :  []  ) _ = sint_t;
type_spec ( (CTypeSpec CSignedType) : more ) fname = signed $ type_spec more fname;

type_spec ( (CTypeSpec t) : _ ) fname = to_ffi_type t fname; 
 //I don't really know what else could be in the list here

type_spec ( _ : more ) fname = type_spec more fname;
type_spec [] _ = throw unknown_decl_type;



// decl_type : Grab a simplified type representation from a declaration.
// Result is a list of the following terms: 
//    basic_type t      : t is a c primitive type or a typedef
//    ptr_type t        : t is again one of basic_type, ptr_type or func_type
//    func_type ret args: ret is again one basic_type, ptr_type or func_type, 
//                        and args is a list of such terms.
// If the type cannot be described in the above terms, an exception
// "unknown_decl_type" is thrown.
// 
// The returned list contains one type for each object declared in this
// declaration, e.g. "int *x, y;" yields 
// [ ptr_type(basic_type sint_t), basic_type sint_t ]

decl_types (CFDefExt _) = [];
decl_types (CDeclExt d fname) = decl_types1 d fname;

decl_types1 d@(CDecl decl_specs [] ) fname = [ basic_type (type_spec decl_specs fname) ];
decl_types1 d@(CDecl decl_specs init_declr_list ) fname = decl_types2 d fname;

decl_types2 d@(CDecl decl_specs init_declr_list) fname = 
  case init_declr_list of 
    (Just (CDeclr _ derivs _ arg_attrs), Nothing, Nothing) : more =
        apply_derivs (type_spec decl_specs fname) derivs : decl_types2 (CDecl decl_specs more) fname;
    [] = [];
    _ = [];
  end
  with 
    //basic_type : get the type of a declaration, ignoring storage and access
    //modifiers
    apply_derivs t [] = basic_type t;
    apply_derivs t ( (CPtrDeclr _  ) : derivs ) |
    apply_derivs t ( (CArrDeclr _ _) : derivs ) = //treat arrays as pointers, 
      ptr_type $ apply_derivs t derivs;           //even if they are proper array objects
    apply_derivs t ( (CFunDeclr args _) : derivs ) = 
      case args of 
        Right (arg_decls,_) = 
          func_type (apply_derivs t derivs) (catmap (flip decl_types1 fname) arg_decls);
        Left _      = //old-style K&R declaration.
          throw unknown_decl_type;
      end;
  end;



// decl_idents : Grab the names of things declared in a declaration. Returns a
// list of strings (identifiers) which may be empty the the declaration is
// anonymous (i.e., a function parameter) or may contain multiple identifiers
// if the declaration declares multiple things, e.g. "int x,y,z;"

decl_idents (CFDefExt _) = [];
decl_idents (CDeclExt d _) = decl_idents d;
decl_idents d@(CDecl _ init_declr_list) = 
  case init_declr_list of 
    (Just (CDeclr (Just ident) _ _ _), _, _) : more =
        ident : decl_idents (CDecl decl_specs more);
    _ = [];
  end;



is_typedef ( (CStorageSpec CTypedef) : decl_specs) = 1;
is_typedef ( _ : decl_specs) = is_typedef decl_specs;
is_typedef [] = 0;


// typedef : returns a list of (name=>type) bindings, possibly empty if this
// declaration was not a typedef
typedefs (CFDefExt _) = [];
typedefs (CDeclExt d fname) = typedefs1 d fname;
typedefs1 d@(CDecl decl_specs _) fname =
  if is_typedef decl_specs 
  then zip (decl_idents d) (decl_types1 d fname)
  else [];


// func_decl : returns a list containing a single (name,type,fname) binding if
// this declaration declares a function, otherwise [].
func_decl (CFDefExt _) = [];
func_decl (CDeclExt d fname) = func_decl1 d fname;
func_decl1 d@(CDecl decl_specs _) fname
= [] if is_typedef decl_specs; // skip typedefs
= case decl_types1 d fname of
    f@([func_type ret args]) = [fundecls,fname | fundecls = zip (decl_idents d) f];
    _ = [];
  end;

//resolve a typedef : d is a dictionary 
resolve_typedef d t fname = lookup t
  with
    lookup (basic_type (CTypeDef n)) =
      catch ( \_ -> warning 2 $ "could not resolve typedef: "+n+
                                ", defaulting to int" $$ sint_t  ) 
            ( patch_typedef n $ lookup (d!n) );

    lookup (basic_type (CSUType _ (CStructUnion _ (Just name) _ _))) = 
      basic_type (struct_or_union name);
    lookup t@(struct_or_union _ _) = t;
    lookup (basic_type (CEnumType (CEnum (Just tag) (Just enum_defs) _))) =
      basic_type (enum_type tag (scan_enums enum_defs) fname);
    lookup (basic_type (CEnumType n)) = sint_t;
    lookup t@(enum_type n _ _) = t;
    lookup t@(basic_type _) = t;
    lookup (ptr_type t) = ptr_type (lookup t);
    lookup (func_type ret args) = func_type (lookup ret) (map lookup args);
    lookup x = warning 0 ("resolve_typedef error: "+str x) $$ void_t;

    // Patch up typedefs for anonymous structs, so that we use the typedef
    // name for the struct instead. This is needed to make the gsl matrix
    // typemapping work.
    patch_typedef n (basic_type (struct_or_union "anonymous")) =
      basic_type (struct_or_union n);
    patch_typedef n t = t otherwise;
  end;
    
resolve_decl_typedefs tydefs decls = 
  map (\(n,t,fname) -> (n , resolve_typedef tydefs t fname, fname) ) decls;

resolve_struct_typedefs tydefs (structure name fields) = 
  structure name $ resolve_decl_typedefs tydefs fields;





// Gather the declared structs or unions. C allows structs to be declared just
// about anywhere but we only grab them from three toplevel declarations:
//   struct X { .. };
//   typedef struct Y { .. } X;
//   typedef struct { .. } X;
// In any case, the struct is bound to the name X.
//
// The result is either [] or [structure name fields] where
// fields are a list of (name,type) tuples
//
// Does not handle nested structs or unions yet.

decl_struct (CFDefExt _) = [];
decl_struct (CDeclExt d fname) = decl_struct1 d fname;
decl_struct1 d@(CDecl ( (CStorageSpec CTypedef ) : 
                        (CTypeSpec (CSUType strct)) : _ ) 
		init_declr_list) fname
    =
  case strct of
    //struct name
    CStructUnion _ (Just _) (Just fields) _  | //struct has a tag
    CStructUnion _ Nothing (Just fields)  _  = //struct is anonymous. 
      [ structure name $ 
        zip (catmap decl_idents fields) (catmap (flip decl_types1 fname) fields) ];
    _ = [];
  end
  when 
    name = head $ decl_idents d;
  end;

decl_struct1 d@(CDecl ( (CTypeSpec (CSUType strct)) : _ ) [] ) fname =
  case strct of
    CStructUnion _ (Just name) (Just fields) _  = 
      [ structure name $ 
        zip (catmap decl_idents fields) (catmap (flip decl_types1 fname) fields) ];
    _ = [];
  end;

decl_struct1 d _ = [];
  


  
// Scrape enum constants. Takes a list of top-level declarations (CDeclExt)
// and produces a dictionary of name=>value pairs. This has to be run over the
// whole list because some constants will be defined in terms of others. 
decl_enums = 
  foldl get_enum emptydict;

get_enum dict (CFDefExt _) = dict;

get_enum dict (CDeclExt d _) = get_enum dict d;

get_enum dict d@(CDecl ( (CStorageSpec CTypedef ) : 
                         (CTypeSpec (CEnumType enum)) : _ ) 
                       init_declr_list) 
    =
  case enum of
    CEnum _ (Just vals) _ = calc_enum_values dict () vals
  end ;
  
get_enum dict d@(CDecl ( (CTypeSpec (CEnumType enum)) : _ ) []) =
  case enum of
    CEnum _ (Just vals) _ = calc_enum_values dict () vals
  end;

get_enum dict _ = dict;


calc_enum_values dict prev ((name,Just e):more) = 
  case eval_expr dict e of
    val::int = calc_enum_values (insert dict (name => val)) val more;
    x = warning 0 $ "Couldn't evaluate enum expression for "+name+" : "+str e 
          $$ calc_enum_values dict prev more;
  end;

calc_enum_values dict () ((name,Nothing):more) = 
   calc_enum_values (insert dict (name=>0)) 0 more;

calc_enum_values dict prev ((name,Nothing):more) = 
    calc_enum_values (insert dict (name=>(prev+1))) (prev+1) more;
 
calc_enum_values dict _ [] = dict;

eval_expr d (CVar n) = 
  catch 
  (\e  -> 
   // If we can't resolve this enum then it's probably a #defined symbol which
   // will hopefully be resolved in resolve_indirects later.
   warning 2$"Couldn't lookup name "+n+" in enum definition."$$n
  ) (d!n);

eval_expr d (CConst (CIntConst x)) = x;

eval_expr d (CUnary  CPlusOp x) =     eval_expr d x;
eval_expr d (CUnary  CMinOp x) = neg (eval_expr d x);
eval_expr d (CUnary  CNegOp x) = ~ (eval_expr d x);
eval_expr d (CUnary  CCompOp x) = not (eval_expr d x);

eval_expr d (CBinary CAddOp e1 e2) = (eval_expr d e1) +   (eval_expr d e2);
eval_expr d (CBinary CSubOp e1 e2) = (eval_expr d e1) -   (eval_expr d e2);
eval_expr d (CBinary CMulOp e1 e2) = (eval_expr d e1) *   (eval_expr d e2);
eval_expr d (CBinary CDivOp e1 e2) = (eval_expr d e1) /   (eval_expr d e2);
eval_expr d (CBinary CRmdOp e1 e2) = (eval_expr d e1) mod (eval_expr d e2);
eval_expr d (CBinary CShlOp e1 e2) = (eval_expr d e1) <<  (eval_expr d e2);
eval_expr d (CBinary CShrOp e1 e2) = (eval_expr d e1) >>  (eval_expr d e2);
eval_expr d (CBinary CLeOp  e1 e2) = (eval_expr d e1) <   (eval_expr d e2);
eval_expr d (CBinary CGrOp  e1 e2) = (eval_expr d e1) >   (eval_expr d e2);
eval_expr d (CBinary CLeqOp e1 e2) = (eval_expr d e1) <=  (eval_expr d e2);
eval_expr d (CBinary CGeqOp e1 e2) = (eval_expr d e1) >=  (eval_expr d e2);
eval_expr d (CBinary CEqOp  e1 e2) = (eval_expr d e1) ==  (eval_expr d e2);
eval_expr d (CBinary CNeqOp e1 e2) = (eval_expr d e1) ~=  (eval_expr d e2);
eval_expr d (CBinary CAndOp e1 e2) = (eval_expr d e1) &&  (eval_expr d e2);
eval_expr d (CBinary COrOp  e1 e2) = (eval_expr d e1) ||  (eval_expr d e2);
eval_expr d (CBinary CLndOp e1 e2) = (eval_expr d e1) and (eval_expr d e2);
eval_expr d (CBinary CLorOp e1 e2) = (eval_expr d e1) or  (eval_expr d e2);
eval_expr d (CBinary CXorOp e1 e2) = xor (eval_expr d e1) (eval_expr d e2)
  with 
  xor a b = (a and not b) or (not a and b); // why exclude poor xor?
  end;
eval_expr d x = warning 0$"Unknown expression type "+str x+" in enum definition. Defaulting to 0." $$ 0;


// Dissect cpp lines (#define's and # lineno only).
split_cpp_line s = regexg (process.tail.tail.regs)
"^#( (([0-9]+) \\\"([^\"]+)\\\"( .*)?)|[ \t]*define[ \t]+([A-Za-z_0-9]+)[ \t]+([^ \t].*))$" REG_EXTENDED s 0
with
  process ((2,_,_):(3,_,lno):(4,_,fname):_) = cpp_line (atoi lno) fname;
  process [(6,_,name),(7,_,val)] = cpp_define name val;
  process _ = ();
end;

// Grab all #define'd constants. lns is a list of strings, the 
// lines of the file. Thus, this can't deal with #defines that span
// multiple lines.
scrape_defines lns = reverse defs
when defs,_ = foldl scrape_define ([],"") lns end
with
  scrape_define (out,fname) ln =
    case split_cpp_line ln of
      [cpp_define name val] = echo 2 $ sprintf "#define %s %s" (name,val) $$ 
        catch 
          (\_ -> (warning 2 $ sprintf "Can't parse %s" ln) $$ (out,fname))
          ( check_constant name val fname : out, fname );
      [cpp_line lno fname] = echo 2 $ sprintf "# %d \"%s\"" (lno,fname) $$
        (out,fname);
      _ = (out,fname);
    end when ln = trim ln end;
  trim ln = if null ln || last ln~="\n" then ln else init ln;
end;

// Check for a constant value (either another #define'd constant, or a number).
check_constant name val::string fname
  = check_string name val fname
      if regex "^\".*\"$" REG_NOSUB val 0;
  = indirect name val fname
      if regex "^[A-Za-z_][A-Za-z_0-9]*$" REG_NOSUB val 0;
  = check_number name val fname;
check_number name val::string fname
  = check_number name (substr val 1 (#val-2)) fname
      if regex "^(.*)$" REG_NOSUB val 0;
  = constant name (sscanf val "%i") fname otherwise;
check_string name val::string fname
  = constant name str fname when str::string = eval val end;

// Some constants are defined in terms of others.  Here we resolve those
// indirections.
nullary unknown_const;
resolve_indirects constants =
  filter ((~==) unknown_const) $ map (lookup dict) constants 
  when
    dict = foldl build emptydict constants;
  end
  with
  build d i@(indirect n _ _) = 
    /*puts ("adding ["+n+"] to dict") $$*/ 
    insert d (n=>i) ;
  build d c@(constant n _ _) = 
    /*puts ("adding ["+n+"] to dict") $$*/ 
    insert d (n=>c) ;
  lookup _ c@(constant _ _ _) = c;
  lookup d (indirect n c src) = if n==c then unknown_const // #define x x
    else catch
      (\_ -> 
          warning 2 $ "Target of indirected constant not found: \""+
                      n+"\" => \""+c+"\"" $$ 
          unknown_const )
      ( case d!c of
        (constant _ v _) = constant n v src;
        (indirect _ i _) = lookup d (indirect n i src);
        end );
  end;



nmspacepfx nmspace = if null nmspace then "" else nmspace+"::";


// Output a constant declaration.
// If after stripping the prefix the constant name starts with a number, then
// add a leading underscore.
const_decl pfx nmspace (constant name val _) = 
  case strip_prefix pfx name of
    name =
      if regex "^[0-9]" REG_NOSUB name 0 
        then "const "+nmspacepfx nmspace+"_"+name+" = "+str val+";\n"
        else "const "+nmspacepfx nmspace+name+" = "+str val+";\n"
      ;
  end;

//output a function declaration for the ffi interface
ffi_extern_decl pfx::string nmspace::string (name, func_type ret args, _) =
  "let "+nmspacepfx nmspace+strip_prefix pfx name+" = fcall \""+
    name+"\" FFI_DEFAULT_ABI "+
    str (fix ret)+" ("+str(tuple (map fix args))+");"
with
  fix (ptr_type schar_t) = string_t;
  fix (ptr_type uchar_t) = string_t;
  fix (ptr_type _) = pointer_t;
  fix t = t otherwise;
end;

//output a function declaration for the native pure extern interface
pure_extern_decl pfx::string nmspace::string (name, func_type ret args, _) =
  "extern "+pure_type ret+" "+name+"("+arg_str args+")"+
  (if alias == name then "" else " = "+alias)+";"
  when alias = strip_prefix pfx name end
  with
  arg_str [void_t] = "";
  arg_str args = join "," $ map pure_type args;
  end;

//output a function declaration for the native pure extern interface,
//prepending the prefix "Pure_" (or the prefix specified with -P) to the
//function name
Pure_extern_decl pfx::string nmspace::string (name, func_type ret args, _) =
  "extern "+pure_type ret+" "+wrap_prefix+name+"("+arg_str args+")"+
  (if alias == wrap_prefix+name then "" else " = "+alias)+";"
  when alias = strip_prefix pfx name end
  with
  arg_str [void_t] = "";
  arg_str args = join "," $ map pure_type args;
  end;




//output the C portion of a function
//TODO: at this point the typedefs have been resolved. It would be better
//if they were not.

replace_template template ret_type wrapper_name formal_params name arg_names
  = regsub repl "(%%)|(%r)|(%w)|(%p)|(%n)|(%a)" REG_EXTENDED template 0
with
  repl info = subst!(regs info!1!0-1)
  when subst = ["%",ret_type,wrapper_name,formal_params,name,arg_names] end;
end;

c_impl (name, func_type ret args, _) = code
when
  ret_str = c_type ret;

  formal_params = 
    if args === [void_t] then "" else 
    join ", " $ zipwith (\x y -> c_type x+" arg"+str y) args (0..inf);

  arg_names = 
    if args === [void_t] then "" else 
    join ", " $ map (\y -> "arg" + str y) (take (#args) (0..inf));

  code = replace_template template ret_str (wrap_prefix+name)
    formal_params name arg_names;
end;


/* Select constant and function declarations based on a regex match on the
   symbol, as well as a glob pattern match on the filename. */

const cflags = REG_NOSUB or REG_EXTENDED;
const fnflags = FNM_PATHNAME;
matches fnpat pat (constant name _ fname) = valid_name fname name &&
  fnmatches fnpat fname fnflags && regchk pat (regex pat cflags name 0);
matches fnpat pat (name, _, fname) = valid_name fname name &&
  fnmatches fnpat fname fnflags && regchk pat (regex pat cflags name 0);

fnmatches pats name flags = true if null pats;
			  = any (\pat->fnmatch pat name flags) pats;

// make regex just always return 1 in case of an error
regchk pat (regerr _ _) = warning 0 msg $$ 1 if msgcache msg
when msg = sprintf "error in regular expression '%s'" pat end;
			= 1 otherwise;
regchk _ x = x;

// Filter out builtins and stuff commonly found in system header files.
const sys_excludes = ["","<built-in>"];
valid_name fname name = true if all_opt;
		      = false if substr name 0 1 == "_";
		      = ~any ((==) fname) sys_excludes;

//misc helpful stuff


//get all lines in a file
fgetlines f = reverse $ get [] 
  with 
  get a = 
    case fgets f of 
    s::string = get (s:a); 
    _ = a; 
    end 
  end;

// convert string to uppercase
extern int toupper(int) = ctoupper;
toupper s::string = string $ map (chr.ctoupper.ord) s;

strip_prefix pfx::string str::string =
  if str ~= pfx && toupper (substr str 0 (#pfx)) == toupper pfx then
    strip_us $ substr str (#pfx) (#str)
  else str
with
  strip_us str = if null str || str == "_" ||str!0 ~= "_" then str
                 else tail str;
end;


//need these for nub
constant a _ _ < constant b _ _ = a < b;
constant a _ _ > constant b _ _ = a > b;
constant a _ _ == constant b _ _ = a == b;

nub xs = reverse $ go [] emptydict xs
  with
  go a d (x:xs) = go a d xs if member d x;
                = go (x:a) (insert d (x=>x)) xs otherwise;
  go a _ [] = a;
  end;


/******************************************************************/

// read the source and its includes, this is needed to grab the #defines
let lines = fgetlines $ popen (sprintf "%s %s %s" (cpp,cpp_opts,in_name)) "r";

//build the AST

echo 1 "Loading AST";
let ast = fgetlines $ popen (sprintf "%s %s %s" (dumper,cpp_opts,in_name)) "r";

echo 1 "Parsing";
let declarations = filter ((~=) ()) $ map eval ast;

// This has to be done before processing the other declarations.
echo 1 "Building enum dictionary";
let enumdefs = decl_enums declarations;


echo 1 "Building typedef dictionary";
let tydefs = 
      foldl (\d (n,t) -> insert d (n=>t)) emptydict $
        catmap typedefs declarations;


echo 1 "Gathering constant definitions";
let defines = 
  nub $ resolve_indirects $ scrape_defines lines +
        catmap enum_vals (vals tydefs);


echo 1 "Gathering function prototypes";
//all function prototypes
let func_protos =
      mapsnd complete_ffi_type $
        resolve_decl_typedefs tydefs $
          catmap func_decl declarations
  with
    mapsnd f = map (\(a,b,c) -> a,f b,c)
  end;


//Output the Pure part
let w = if dry_run then __none__ else if noclobber then "a" else "w";
let out_pure   = fopen out_name w;

let extern_decl = case iface_opt of
  "ffi" = fputs "using ffi;\n" out_pure $$ ffi_extern_decl;
  "c" = Pure_extern_decl
  when
    //Output the C part
    out_c = fopen c_name w;
    if dry_run then () else echo 1 $ sprintf "Writing %s" c_name;

    fprintf out_c "#include \"%s\"\n%s\n" (in_name,frontmatter); 
    do (flip fputs out_c) $
      map c_impl $ filter (matches fnpat funpat) func_protos;
  end;
  _ = pure_extern_decl;
end;
if dry_run then () else echo 1 $ sprintf "Writing %s" out_name;
if ~null lib_name then fprintf out_pure "using \"lib:%s\";\n" lib_name else ();
if ~null nmspace then fprintf out_pure "\nnamespace %s;\n" nmspace else ();

do (flip fputs out_pure . const_decl cstpfx nmspace) $
  filter (matches fnpat cstpat) defines;

do (flip fputs out_pure) $
  map (\x -> extern_decl funpfx nmspace x + "\n") $
  filter (matches fnpat funpat) func_protos;
