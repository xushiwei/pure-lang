
pure-gen 
========

A Pure C bindings generator. Written by Albert Graef, based on Scott Dillard's
OpenGL bindings generator.

License
=======

Please check the COPYING file for licensing information. The generator
contains significant portions of the Language.C Haskell library; see
dump-ast.hs for pertinent license and copyright information.

Installation
============

Normally you just run 'make && sudo make install'. This will install the
program under $(prefix)/lib/pure-gen-x.y and create a link to the executable
in $(prefix)/bin. (See The Makefile for further options.)

The generator uses the Language.C parser for Haskell, available here:

http://hackage.haskell.org/cgi-bin/hackage-scripts/package/language-c

To compile the dump-ast module, you need a Haskell compiler (GHC) and this
library. The Haskell program dump-ast.hs parses a C file given on the command
line and writes the AST to stdout. It calls GCC to do the preprocessing, so on
Windows you will probably need MinGW installed. C preprocessor options can be
passed to dump-ast as well, but the C file must always be the last argument.

For Linux users, Scott has uploaded statically linked binaries of dump-ast,
both 32 and 64 bits, to the Pure-lang Google Group files area. (These still
need libgmp, but so does Pure so you should already have that.) Thus, if you
can't/don't want to install GHC, you can just put the appropriate binary into
the source directory, rename it to 'dump-ast' and then run 'sudo make install'
without running 'make'.

Usage
=====

The pure-gen script generates bindings for C functions from a C header file.
Try 'pure-gen -h' for help. Basically,

	pure-gen foo.h

generates a Pure module foo.pure with 'extern' declarations for the constants
('#define's and enums) and C routines declared in the given C header file and
(recursively) its includes.

When invoked with the -n option, pure-gen performs a dry run in which it only
parses the input without actually generating any output files.

The -I, -D and -U options are passed to the C preprocessor. This is handy if
you need to define additional preprocessor symbols and add directories to the
include search path, see cpp(1) for details.

There are some other options which affect the generated output. In particular,
'-f c' generates a C wrapper module along with the Pure module (see
"Generating C Code" below), and '-f ffi' generates a wrapper using Pure's ffi
module. Moreover, '-l libfoo' generates a 'using "lib:libfoo"' declaration in
the Pure source, for modules which require a shared library to be loaded.
Any number of -l options can be specified.

Note that pure-gen always parses the given header file as well as *all* its
includes. If the header file '#include's system headers, by default you will
get those declarations as well. This is often undesirable. As a remedy,
pure-gen normally excludes built-in '#define's of the C compiler, as well as
identifiers with a leading underscore (which are often found in system
headers) from processing. You can use the -a option to disable this.

In addition, the -s option enables you to filter C symbols using the source
filename and the symbol as search criteria. This option takes an argument of
the form 'glob-patterns::regex-pattern' denoting a comma-separated list of
glob patterns to be matched against the source filename and an extended regex
to be matched against the symbol itself. The 'glob-patterns::' part can also
be omitted in which case it defaults to '::' which matches any source file.
Similarly, the regex can be empty, in which case it matches any symbol. The
generated output will contain only the constant and function symbols matching
the given regex from source files matching any of the the glob patterns. Thus,
for instance, the option '-s foo.h,bar.h::^(foo|bar)_' pulls all symbols
prefixed with either 'foo_' or 'bar_' from the files foo.h and bar.h in the
current directory. Note that in order to match include files in the system
directories you also have to specify the path in the glob patterns, just as
with shell glob patterns. Thus, e.g., if the foo.h file actually lives in
/usr/include, it can be matched with a glob pattern like '/*/*/foo.h', but not
with just 'foo.h' or '*/foo.h'.

The -s option is often used in conjuction with the -p option, which lets you
specify a "module name prefix" which should be stripped off from C symbols.
Case is insignificant and a trailing underscore will be removed as well, so
'-p foo' turns 'fooBar' into 'Bar' and 'FOO_BAR' into 'BAR'. Moreover, the -m
option allows you to specify the name of a Pure namespace in which the
resulting constants and functions are to be declared. So, for instance, 
'-s "^(foo|FOO)" -p foo -m foo' will select all symbols staring with the 'foo'
or 'FOO' prefix, stripping the prefix from the selected symbols and finally
adding a 'foo::' namespace qualifier to them instead.

This usually works pretty well. Nevertheless, some headers defy fully
automatic wrapper generation and may thus require manual editing of the
generated output to get a nice wrapper module. Also, in some cases it may be
necessary to assemble the output of several runs of pure-gen for different
combinations of header files, symbol selections and namespace/prefix
settings. In such a case it is usually possible to just concatenate the
various output files produced by pure-gen to consolidate them into a single
wrapper module. To make this easier, pure-gen provides the -N a.k.a.
--noclobber option which appends the output to existing files instead of
overwriting them.

Finally, note that only C bindings can be generated at this time. Thus, in
order to wrap C++ modules, you'll first have to obtain a corresponding C
wrapper, or write one yourself. If your C compiler knows how to call other
languages like Fortran or Ada, then modules written in these languages can
also be dealt with, by writing a fake C header for the module and generating a
C wrapper with a custom code template (see "Generating C Code" below).

Generating C Code
========== = ====

As already mentioned, pure-gen can be invoked with the '-fc' option to create
a C wrapper module along with the Pure module it generates. This is useful to
create boilerplate code for new modules, and to interface to existing modules
which, for whatever reason, can't be called directly through Pure 'extern's. 
(This might be the case, e.g., if the module uses non-standard calling
conventions, or if some of the module's operations are actually implemented as
macros.)

You can adjust the C wrapper code generated with the '-fc' option by providing
your own template file, which has the following format:

#include <stdio.h>

void bar()
{
  printf("Hello, bar\n");
}
%%

%r %w(%p)
{
  return %n(%a);
}

Note that the code up to the symbol '%%' on a line by itself denotes
"frontmatter" which gets inserted at the beginning of the C file, right after
the #include of the parsed header file. (The frontmatter section can also be
empty or missing altogether if you don't need it.)

The rest of the template is the code for each wrapper function. Substitutions
of various syntactical fragments of the function definition is performed using
the following placeholders:

%r = return type of the function
%w = the name of the wrapper function
%p = declaration of the formal parameters of the wrapper function
%n = the name of the real function (i.e., the target C function to be called)
%a = the arguments of the function call (formal parameters with types stripped)
%% = escapes a single %

A default template is provided if you don't specify one (which looks pretty
much like the template above, minus the frontmatter).

For instance, suppose that we place the sample template above into a file
'foo.templ' and invoke pure-gen on the foo.h header file as follows:

pure-gen -fc -t foo.templ foo.h

Then in foo.c you'd get C output code like the following:

#include "foo.h"
#include <stdio.h>

void bar()
{
  printf("Hello, bar\n");
}

void Pure_foo(int arg0, void* arg2)
{
  return foo(arg0,arg1);
}

As indicated, the wrapper function names are usually stropped with the 'Pure_'
prefix. You can change this with the '-P' option.

This also works great to create boilerplate code for new modules. For this
purpose the following template will do the trick (you might wish to invoke
this with '-P ""' so that the wrapper function names are just the names
declared in the header file):

/* Add #include's etc. here. */
%%

%r %w(%p)
{
  /* Enter code of %w here. */
}
