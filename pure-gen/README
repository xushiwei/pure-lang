
pure-gen 
========

A Pure C bindings generator. Written by Albert Graef, based on Scott Dillard's
OpenGL bindings generator.

License
=======

Please check the COPYING file for licensing information. The generator
contains significant portions of the Language.C Haskell library; see
dump-ast.hs for pertinent license and copyright information.

Installation
============

Normally you just run 'make && sudo make install'. This will install the
program under $(prefix)/lib/pure-gen-x.y and create a link to the executable
in $(prefix)/bin. (See The Makefile for further options.)

The generator uses the Language.C parser for Haskell, available here:

http://hackage.haskell.org/cgi-bin/hackage-scripts/package/language-c

To compile the dump-ast module, you need a Haskell compiler (GHC) and this
library. The Haskell program dump-ast.hs parses a C file (its only command
line argument) and writes the AST to stdout. It calls GCC to do the
preprocessing, so on Windows you will probably need MinGW installed.

For Linux users, Scott has uploaded statically linked binaries of dump-ast,
both 32 and 64 bits, to the Pure-lang Google Group files area. (These still
need libgmp, but so does Pure so you should already have that.) Thus, if you
can't/don't want to install GHC, you can just put the appropriate binary into
the source directory, rename it to 'dump-ast' and then run 'sudo make install'
without running 'make'.

Usage
=====

The pure-gen script generates bindings for C functions from a C header file.
Try 'pure-gen -h' for help. Basically,

	pure-gen foo.h

generates a Pure module foo.pure with 'extern' declarations for the constants
('#define's and enums) and C routines declared in the given C header file and
(recursively) its includes.

There are some options which affect the generated output. In particular,
'-f c' generates a C wrapper module along with the Pure module (see
"Generating C Code" below), and '-f ffi' generates a wrapper using Pure's ffi
module. Moreover, '-l libfoo' generates a 'using "lib:libfoo"' declaration in
the Pure source, for modules which require a shared library to be loaded.

Note that pure-gen scans the given header file as well as all its includes. If
the header file '#include's system headers you will get those declarations as
well. This is usually undesirable. As a remedy, pure-gen excludes identifiers
with a leading underscore and other names which are are commonly found in
system headers from processing (you can use the -a option to disable this). In
addition, the -s option, followed by an extended regular expression, allows
you to explicitly select the symbols which should be included.

The -s option is often used in conjuction with the -p option, which lets you
specify a "module name prefix" which should be stripped off from C symbols.
Case is insignificant and a trailing underscore will be removed as well, so
'-p foo' turns 'fooBar' into 'Bar' and 'FOO_BAR' into 'BAR'. Moreover, the -n
option allows you to specify the name of a Pure namespace in which the
resulting constants and functions are to be declared. So, for instance, 
'-s "^(foo|FOO)" -p foo -n foo' will select all symbols staring with the 'foo'
or 'FOO' prefix, stripping the prefix from the selected symbols and finally
adding a 'foo::' namespace qualifier to them instead.

This usually works pretty well. Nevertheless, many headers (and/or the
generated output) will still require manual editing to get a nice wrapper
module.

Also note that only C bindings can be generated at this time. Thus, in order
to wrap C++ modules, you'll first have to obtain a corresponding C wrapper, or
write one yourself. If your C compiler knows how to call other languages like
Fortran or Ada, then modules written in these languages can also be dealt
with, by writing a fake C header for the module and generating a C wrapper
with a custom code template (see "Generating C Code" below).

Generating C Code
========== = ====

As already mentioned, pure-gen can be invoked with the '-fc' option to create
a C wrapper module along with the Pure module it generates. This is useful to
create boilerplate code for new modules, and to interface to existing modules
which, for whatever reason, can't be called directly through Pure 'extern's. 
(This might be the case, e.g., if the module uses non-standard calling
conventions, or if some of the module's operations are actually implemented as
macros.)

You can adjust the C wrapper code generated with the '-fc' option by providing
your own template file, which has the following format:

#include <stdio.h>

void bar()
{
  printf("Hello, bar\n");
}
%%

%r %w(%p)
{
  return %n(%a);
}

Note that the code up to the symbol '%%' on a line by itself denotes
"frontmatter" which gets inserted at the beginning of the C file, right after
the #include of the parsed header file. (The frontmatter section can also be
empty or missing altogether if you don't need it.)

The rest of the template is the code for each wrapper function. Substitutions
of various syntactical fragments of the function definition is performed using
the following placeholders:

%r = return type of the function
%w = the name of the wrapper function
%p = declaration of the formal parameters of the wrapper function
%n = the name of the real function (i.e., the target C function to be called)
%a = the arguments of the function call (formal parameters with types stripped)
%% = escapes a single %

A default template is provided if you don't specify one (which looks pretty
much like the template above, minus the frontmatter).

For instance, suppose that we place the sample template above into a file
'foo.templ' and invoke pure-gen on the foo.h header file as follows:

pure-gen -fc -t foo.templ foo.h

Then in foo.c you'd get C output code like the following:

#include "foo.h"
#include <stdio.h>

void bar()
{
  printf("Hello, bar\n");
}

void Pure_foo(int arg0, void* arg2)
{
  return foo(arg0,arg1);
}

As indicated, the wrapper function names are usually stropped with the 'Pure_'
prefix. You can change this with the '-P' option.

This also works great to create boilerplate code for new modules. For this
purpose the following template will do the trick (you might wish to invoke
this with '-P ""' so that the wrapper function names are just the names
declared in the header file):

/* Add #include's etc. here. */
%%

%r %w(%p)
{
  /* Enter code of %w here. */
}
