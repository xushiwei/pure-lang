
pure-gen 
========

A Pure C bindings generator. Written by Albert Graef, based on Scott Dillard's
OpenGL bindings generator.

License
=======

Please check the COPYING file for licensing information. The generator
contains significant portions of the Language.C Haskell library; see
dump-ast.hs for pertinent license and copyright information.

Installation
============

Normally you just run 'make && sudo make install'. This will install the
program under $(prefix)/lib/pure-gen-x.y and create a link to the executable
in $(prefix)/bin. (See The Makefile for further options.)

The generator uses the Language.C parser for Haskell, available here:

http://hackage.haskell.org/cgi-bin/hackage-scripts/package/language-c

To compile the dump-ast module, you need a Haskell compiler (GHC) and this
library. The Haskell program dump-ast.hs parses a C file given on the command
line and writes the AST to stdout. It calls GCC to do the preprocessing, so on
Windows you will probably need MinGW installed. C preprocessor options can be
passed to dump-ast as well, but the C file must always be the last argument.

For Linux users, Scott has uploaded statically linked binaries of dump-ast,
both 32 and 64 bits, to the Pure-lang Google Group files area. (These still
need libgmp, but so does Pure so you should already have that.) Thus, if you
can't/don't want to install GHC, you can just put the appropriate binary into
the source directory, rename it to 'dump-ast' and then run 'sudo make install'
without running 'make'.

Usage
=====

The pure-gen script generates bindings for C functions from a C header file.
Try 'pure-gen -h' for help. Basically,

	pure-gen foo.h

generates a Pure module foo.pure with 'extern' declarations for the constants
('#define's and enums) and C routines declared in the given C header file and
(recursively) its includes.

When invoked with the -n option, pure-gen performs a dry run in which it only
parses the input without actually generating any output files.

The -I, -D and -U options are passed to the C preprocessor. This is handy if
you need to define additional preprocessor symbols and add directories to the
include search path, see cpp(1) for details.

There are some other options which affect the generated output. In particular,
'-f c' generates a C wrapper module along with the Pure module (see
"Generating C Code" below), and '-f ffi' generates a wrapper using Pure's ffi
module. Moreover, '-l libfoo' generates a 'using "lib:libfoo"' declaration in
the Pure source, for modules which require a shared library to be loaded.
Any number of -l options can be specified.

Note that pure-gen always parses the given header file as well as *all* its
includes. If the header file '#include's system headers, by default you will
get those declarations as well. This is often undesirable. As a remedy,
pure-gen normally excludes built-in '#define's of the C compiler, as well as
identifiers with a leading underscore (which are often found in system
headers) from processing. You can use the -a option to disable this.

In addition, the -s option enables you to filter C symbols using the source
filename and the symbol as search criteria. This option takes an argument of
the form 'glob-patterns::regex-pattern' denoting a comma-separated list of
glob patterns to be matched against the source filename and an extended regex
to be matched against the symbol itself. The 'glob-patterns::' part can also
be omitted in which case it defaults to '::' which matches any source file.
Similarly, the regex can be empty, in which case it matches any symbol. The
generated output will contain only the constant and function symbols matching
the given regex from source files matching any of the the glob patterns. Thus,
for instance, the option '-s foo.h,bar.h::^(foo|bar)_' pulls all symbols
prefixed with either 'foo_' or 'bar_' from the files foo.h and bar.h in the
current directory. Note that in order to match include files in the system
directories you also have to specify the path in the glob patterns, just as
with shell glob patterns. Thus, e.g., if the foo.h file actually lives in
/usr/include, it can be matched with a glob pattern like '/*/*/foo.h', but not
with just 'foo.h' or '*/foo.h'.

The -s option is often used in conjuction with the -p option, which lets you
specify a "module name prefix" which should be stripped off from C symbols.
Case is insignificant and a trailing underscore will be removed as well, so
'-p foo' turns 'fooBar' into 'Bar' and 'FOO_BAR' into 'BAR'. Moreover, the -m
option allows you to specify the name of a Pure namespace in which the
resulting constants and functions are to be declared. So, for instance, 
'-s "^(foo|FOO)" -p foo -m foo' will select all symbols staring with the 'foo'
or 'FOO' prefix, stripping the prefix from the selected symbols and finally
adding a 'foo::' namespace qualifier to them instead.

This usually works pretty well. Nevertheless, some headers defy fully
automatic wrapper generation and may thus require manual editing of the
generated output to get a nice wrapper module. Also, in some cases it may be
necessary to assemble the output of several runs of pure-gen for different
combinations of header files, symbol selections and namespace/prefix
settings. In such a case it is usually possible to just concatenate the
various output files produced by pure-gen to consolidate them into a single
wrapper module. To make this easier, pure-gen provides the -N a.k.a.
--noclobber option which appends the output to existing files instead of
overwriting them.

Finally, note that only C bindings can be generated at this time. Thus, in
order to wrap C++ modules, you'll first have to obtain a corresponding C
wrapper, or write one yourself. If your C compiler knows how to call other
languages like Fortran or Ada, then modules written in these languages can
also be dealt with, by writing a fake C header for the module and generating a
C wrapper with a custom code template (see "Generating C Code" below).

Generating C Code
========== = ====

As already mentioned, pure-gen can be invoked with the '-fc' option to create
a C wrapper module along with the Pure module it generates. There are various
situations in which this is preferable, e.g.:

- You are about to create a new module for which you want to generate some
boilerplate code.

- The C routines to be wrapped aren't available in a shared library, but in
some other form (e.g., object file or static library).

- You need to inject some custom code into the wrapper functions (e.g., to
handle dynamic loading).

- The C routines can't be called directly through Pure 'extern's.

The latter case might arise, e.g., if the module uses non-C linkage or calling
conventions, or if some of the operations to be wrapped are actually
implemented as macros. Another important case is if some of the C routines
pass C structs by value or return them as results. This is discussed in more
detail in the following section.

For instance, let's say that we want to generate a wrapper foo.c from the
foo.h header file whose operations are implemented in some library libfoo.a or
libfoo.so. A command like the following generates both the C wrapper and the
corresponding Pure module:

	pure-gen -fc foo.h

This creates foo.pure and foo.c, with an import clause for "lib:foo" at the
beginning of the Pure module. The generated wrapper is just an ordinary C file
which should be compiled to a shared object (dll on Windows) as usual. E.g.,
using gcc on Linux:

	gcc -shared -o foo.so foo.c -lfoo

That's all. You should now be able to use the foo module by just putting
'using foo;' in your programs.

The same approach also works with the ffi interface if you replace the -fc
option with -fc-ffi.

You can also adjust the C wrapper code to some extent by providing your own
template file, which has the following format:

#include <stdio.h>

void bar()
{
  printf("Hello, bar\n");
}
%%

%r %w(%p)
{
  return %n(%a);
}

Note that the code up to the symbol '%%' on a line by itself denotes
"frontmatter" which gets inserted at the beginning of the C file, right after
the #include of the parsed header file. (The frontmatter section can also be
empty or missing altogether if you don't need it.)

The rest of the template is the code for each wrapper function. Substitutions
of various syntactical fragments of the function definition is performed using
the following placeholders:

%r = return type of the function
%w = the name of the wrapper function
%p = declaration of the formal parameters of the wrapper function
%n = the name of the real function (i.e., the target C function to be called)
%a = the arguments of the function call (formal parameters with types stripped)
%% = escapes a single %

A default template is provided if you don't specify one (which looks pretty
much like the template above, minus the frontmatter).

For instance, suppose that we place the sample template above into a file
'foo.templ' and invoke pure-gen on the foo.h header file as follows:

pure-gen -fc -t foo.templ foo.h

Then in foo.c you'd get C output code like the following:

#include "foo.h"
#include <stdio.h>

void bar()
{
  printf("Hello, bar\n");
}

void Pure_foo(int arg0, void* arg1)
{
  return foo(arg0, arg1);
}

As indicated, the wrapper function names are usually stropped with the 'Pure_'
prefix. You can change this with the '-P' option.

This also works great to create boilerplate code for new modules. For this
purpose the following template will do the trick (you might wish to invoke
this with '-P ""' so that the wrapper function names are just the names
declared in the header file):

/* Add #include's etc. here. */
%%

%r %w(%p)
{
  /* Enter code of %w here. */
}

Dealing with C Structs
======= ==== = =======

Modern C compilers allow you to pass C structs by value or return them as
results from a C function. This represents a problem, because Pure doesn't
provide any support for that in its 'extern' declarations. Even Pure's libffi
interface only has limited support for C structs (no unions, no bit fields),
and at present pure-gen itself does not keep track of the internal structure
of C structs either.

Hence pure-gen will bark if you try to wrap an operation which passes or
returns a C struct, printing a warning message like the following which
indicates that the given function could not be wrapped:

Warning: foo: struct argument or return type, try -fc

What Pure *does* know is how to pass and return *pointers* to C structs in its
C interface. This makes it possible to deal with struct arguments and return
values in the C wrapper. To these ends, you need to invoke pure-gen with the
-fc or -fc-ffi option as described in the previous section. Struct arguments
in the original C function then become struct pointers in the wrapper
function. E.g., if the function is declared in the header as follows:

typedef struct { double x, y; } point;
extern double foo(point p);

Then the generated wrapper code becomes:

double Pure_foo(point* arg0)
{
  return foo(*arg0);
}

Which is declared in the Pure interface as:

extern double Pure_foo(point*) = foo;

Struct return values are handled by returning a pointer to a static variable
holding the return value. E.g.,

extern point bar(double x, double y);

becomes:

point* Pure_bar(double arg0, double arg1)
{
  static point ret;
  ret = bar(arg0, arg1); return &ret;
}

Which is declared in the Pure interface as:

extern point* Pure_bar(double, double) = bar;

(Note that the generated code in this case comes from an alternate template.
It's possible to configure the laternate template using the -T option instead
of -t.)

In a Pure script you can now call foo and bar as:

> foo (bar 0.0 1.0);

Note, however, that the pointer returned by bar points to static storage which
will be overwritten each time you invoke the bar function. Thus in the
following example *both* u and v will point to the same 'point' struct:

> let u = bar 1.0 0.0; let v = bar 0.0 1.0;

Which most likely is *not* what you want. To avoid this, you'll have to take
dynamic copies of returned structs. It's possible to do this manually by
fiddling around with malloc and memcpy, but the most convenient way is to
employ the struct functions provided by Pure's ffi module:

> using ffi;
> let point_t = struct_t (double_t, double_t);
> let u = copy_struct point_t (bar 1.0 0.0);
> let v = copy_struct point_t (bar 0.0 1.0);

Now u and v point to different, dynamically allocated structs which even take
care of garbage-collecting themselves when they are no longer needed.
Moreover, the ffi module also allows you to access the members of the structs
in a direct fashion. Please refer to the pure-ffi documentation for further
details.
