.TH PURE-GEN 1 "2009-02-13" "Pure" "Pure Manual"
.hw name-space
.hw name-spaces
.SH NAME
pure-gen \- Pure interface generator
.SH SYNOPSIS
\fBpure-gen\fP [\fIoptions\fP ...] \fIinput-file\fP
.SH OPTIONS
.SS General Options
.TP
\fB-h\fP, \fB--help\fP
Print a brief help message and exit.
.TP
\fB-V\fP, \fB--version\fP
Print version number and exit.
.TP
\fB-e\fP, \fB--echo\fP
Echo preprocessor lines.
.TP
\fB-v\fP, \fB--verbose\fP
Show parameters and progress information.
.TP
\fB-w\fP, \fB--warnings\fP
Display warnings, \fIlevel\fP = 0, 1 (default) or 2.
.SS Preprocessor Options
.TP
\fB-I\fP, \fB--include\fP
Add include path.
.TP
\fB-D\fP, \fB--define\fP
Define symbol.
.TP
\fB-U\fP, \fB--undefine\fP
Undefine symbol.
.SS Generator Options
.TP
\fB-f\fP, \fB--interface\fP
Interface type (`extern', `c', `ffi' or `c-ffi'). Default is `extern'.
.TP
\fB-l\fP, \fB--lib-name\fP
Add library module to be imported. Default is \fB-l\fP \fIc-file\fP (the
filename specified with \fB-c\fP, see below, without filename extension) for
\fB-fc\fP, otherwise empty.
.TP
\fB-m\fP, \fB--namespace\fP
Module namespace in which symbols should be declared.
.TP
\fB-p\fP, \fB--prefix\fP
Module name prefix to be removed from C symbols.
.TP
\fB-P\fP, \fB--wrap\fP
Prefix to be prepended to C wrapper symbols. Default is `Pure_'.
.TP
\fB-a\fP, \fB--all\fP
Include ``hidden'' symbols.
.TP
\fB-s\fP, \fB--select\fP
Filter of valid C symbols.
.TP
\fB-t\fP, \fB--template\fP
Specify C template file.
.TP
\fB-T\fP, \fB--alt-template\fP
Specify alternate C template file.
.SS Output Options
.TP
\fB-n\fP, \fB--dry-run\fP
Only parse without generating any output.
.TP
\fB-N\fP, \fB--noclobber\fP
Append output to existing files.
.TP
\fB-o\fP, \fB--output\fP
Pure output (.pure) filename. Default is \fIinput-file\fP with new extension .pure.
.TP
\fB-c\fP, \fB--c-name\fP
C wrapper (.c) filename (-fc). Default is \fIinput-file\fP with new extension .c.
.SH DESCRIPTION
.B pure-gen
generates Pure bindings for C functions from a C header file. Basically,
.sp
.nf
pure-gen foo.h
.fi
.sp
generates a Pure module foo.pure with
.B extern
declarations for the constants (#defines and enums) and C routines declared in
the given C header file and (recursively) its includes.
.PP
.B pure-gen
only accepts a single header file on the command line. If you need to parse
more than one header in a single run, you can just create a dummy header with
all the necessary #includes in it and pass that to
.B pure-gen
instead.
.PP
When invoked with the
.B -n
option,
.B pure-gen
performs a dry run in which it only parses the input without actually
generating any output files.
.PP
The \fB-I\fP, \fB-D\fP and \fB-U\fP options are passed to the C
preprocessor. This is handy if you need to define additional preprocessor
symbols and add directories to the include search path, see
.BR cpp (1)
for details.
.PP
There are some other options which affect the generated output. In particular,
\fB-f c\fP generates a C wrapper module along with the Pure module (see
\fIGENERATING C CODE\fP below), and \fB-f ffi\fP generates a wrapper using
Pure's ffi module. Moreover, \fB-l libfoo\fP generates a `using "lib:libfoo"'
declaration in the Pure source, for modules which require a shared library to
be loaded. Any number of \fB-l\fP options can be specified.
.PP
Note that
.B pure-gen
always parses the given header file as well as \fIall\fP its includes. If the
header file #includes system headers, by default you will get those
declarations as well. This is often undesirable. As a remedy,
.B pure-gen
normally excludes built-in #defines of the C compiler, as well as identifiers
with a leading underscore (which are often found in system headers) from
processing. You can use the \fB-a\fP option to disable this, so that all these
symbols are included as well.
.PP
In addition, the \fB-s\fP option enables you to filter C symbols using the
source filename and the symbol as search criteria. For instance, to just
generate code for a single header foo.h and none of the other headers included
in foo.h, you can invoke pure-gen as follows:
.sp
.nf
pure-gen -s foo.h:: foo.h
.fi
.sp
In general, the \fB-s\fP option takes an argument of the form
\fIglob-patterns\fP::\fIregex-pattern\fP denoting a comma-separated list of
glob patterns to be matched against the source filename, and an extended regex
to be matched against the symbol itself. The \fIglob-patterns\fP:: part can
also be omitted in which case it defaults to `::' which matches any source
file. The regex can also be empty, in which case it matches any symbol. The
generated output will contain only the constant and function symbols matching
the given regex, from source files matching any of the the glob
patterns. Thus, for instance, the option `-s foo.h,bar.h::^(foo|bar)_' pulls
all symbols prefixed with either `foo_' or `bar_' from the files foo.h and
bar.h in the current directory. Note that in order to match include files in
the system directories you also have to specify the path in the glob patterns,
just as with shell glob patterns. Thus, e.g., if the foo.h file actually lives
in /usr/include, it can be matched with a glob pattern like `/*/*/foo.h', but
not with just `foo.h' or `*/foo.h'.
.PP
The \fB-s\fP option is often used in conjuction with the \fB-p\fP option,
which lets you specify a ``module name prefix'' which should be stripped off
from C symbols. Case is insignificant and a trailing underscore will be
removed as well, so `-p foo' turns `fooBar' into `Bar' and `FOO_BAR' into
`BAR'. Moreover, the \fB-m\fP option allows you to specify the name of a Pure
namespace in which the resulting constants and functions are to be
declared. So, for instance, `-s "^(foo|FOO)" -p foo -m foo' will select all
symbols starting with the `foo' or `FOO' prefix, stripping the prefix from the
selected symbols and finally adding a `foo::' namespace qualifier to them
instead.
.PP
This usually works pretty well. Nevertheless, some headers defy fully
automatic wrapper generation and may thus require manual editing of the
generated output to get a nice wrapper module. Also, in some cases it may be
necessary to assemble the output of several runs of
.B pure-gen
for different combinations of header files, symbol selections and
namespace/prefix settings. In such a case it is usually possible to just
concatenate the various output files produced by
.B pure-gen
to consolidate them into a single wrapper module. To make this easier,
.B pure-gen
provides the \fB-N\fP a.k.a. \fB--noclobber\fP option which appends the output
to existing files instead of overwriting them.
.PP
Also note that only C bindings can be generated at this time. Thus, in order
to wrap C++ modules, you'll first have to obtain a corresponding C wrapper, or
write one yourself. If your C compiler knows how to call other languages like
Fortran or Ada, then modules written in these languages can also be dealt
with, by writing a fake C header for the module and generating a C wrapper
with a custom code template (see \fIGENERATING C CODE\fP below).
.SH GENERATING C CODE
As already mentioned, pure-gen can be invoked with the \fB-fc\fP option to
create a C wrapper module along with the Pure module it generates. There are
various situations in which this is preferable, e.g.:
.IP *
You are about to create a new module for which you want to generate some
boilerplate code.
.IP *
The C routines to be wrapped aren't available in a shared library, but in some
other form (e.g., object file or static library).
.IP *
You need to inject some custom code into the wrapper functions (e.g., to
implement lazy dynamic loading).
.IP *
The C routines can't be called directly through Pure externs.
.PP
The latter case might arise, e.g., if the module uses non-C linkage or calling
conventions, or if some of the operations to be wrapped are actually
implemented as C macros. Another important case is if some of the C routines
pass C structs by value or return them as results. This is discussed in more
detail in the following section.
.PP
For instance, let's say that we want to generate a wrapper foo.c from the
foo.h header file whose operations are implemented in some library libfoo.a or
libfoo.so. A command like the following generates both the C wrapper and the
corresponding Pure module:
.sp
.nf
pure-gen -fc foo.h
.fi
.sp
This creates foo.pure and foo.c, with an import clause for "lib:foo" at the
beginning of the Pure module. (You can also change the name of the Pure and C
output files using the \fB-o\fP and \fB-c\fP options, respectively.)
.PP
The generated wrapper is just an ordinary C file which should be compiled to a
shared object (dll on Windows) as usual. E.g., using gcc on Linux:
.sp
.nf
gcc -shared -o foo.so foo.c -lfoo
.fi
.sp
That's all. You should now be able to use the foo module by just putting the
declaration `\fBusing\fP foo;' into your programs. The same approach also
works with the ffi interface if you replace the \fB-fc\fP option with
\fB-fc-ffi\fP.
.PP
You can also adjust the C wrapper code to some extent by providing your own
template file, which has the following format:
.sp
.nf
#include <stdio.h>

void bar()
{
  printf("Hello, bar\en");
}
%%

%r %w(%p)
{
  return %n(%a);
}
.fi
.sp
Note that the code up to the symbol `%%' on a line by itself denotes
``frontmatter'' which gets inserted at the beginning of the C file, right
after the #include of the parsed header file. (The frontmatter section can
also be empty or missing altogether if you don't need it.)
.PP
The rest of the template is the code for each wrapper function. Substitutions
of various syntactical fragments of the function definition is performed using
the following placeholders:
.TP
%r
return type of the function
.TP
%w
the name of the wrapper function
.TP
%p
declaration of the formal parameters of the wrapper function
.TP
%n
the name of the real function (i.e., the target C function to be called)
.TP
%a
the arguments of the function call (formal parameters with types stripped off)
.TP
%%
escapes a literal %
.PP
A default template is provided if you don't specify one (which looks pretty
much like the template above, minus the frontmatter).
.PP
For instance, suppose that we place the sample template above into a file
foo.templ and invoke
.B pure-gen
on the foo.h header file as follows:
.sp
.nf
pure-gen -fc -t foo.templ foo.h
.fi
.sp
Then in foo.c you'd get C output code like the following:
.sp
.nf
#include "foo.h"
#include <stdio.h>

void bar()
{
  printf("Hello, bar\en");
}

void Pure_foo(int arg0, void* arg1)
{
  return foo(arg0, arg1);
}
.fi
.sp
As indicated, the wrapper function names are usually stropped with the `Pure_'
prefix. You can change this with the \fB-P\fP option.
.PP
This also works great to create boilerplate code for new modules. For this
purpose the following template will do the trick (you might wish to invoke
this with \fB-P\fP "" so that the wrapper function names are just the names
declared in the header file):
.sp
.nf
/* Add #include's etc. here. */
%%

%r %w(%p)
{
  /* Enter code of %w here. */
}
.fi
.SH DEALING WITH C STRUCTS
Modern C compilers allow you to pass C structs by value or return them as
results from a C function. This represents a problem, because Pure doesn't
provide any support for that in its extern declarations. Even Pure's libffi
interface only has limited support for C structs (no unions, no bit fields),
and at present
.B pure-gen
itself does not keep track of the internal structure of C structs either.
.PP
Hence
.B pure-gen
will bark if you try to wrap an operation which passes or returns a C struct,
printing a warning message like the following which indicates that the given
function could not be wrapped:
.sp
.nf
Warning: foo: struct argument or return type, try -fc
.fi
.sp
What Pure \fIdoes\fP know is how to pass and return \fIpointers\fP to C
structs in its C interface. This makes it possible to deal with struct
arguments and return values in the C wrapper. To these ends, you need to
invoke
.B pure-gen
with the \fB-fc\fP or \fB-fc-ffi\fP option as described in the previous
section. Struct arguments in the original C function then become struct
pointers in the wrapper function. E.g., if the function is declared in the
header as follows:
.sp
.nf
typedef struct { double x, y; } point;
extern double foo(point p);
.fi
.sp
Then the generated wrapper code becomes:
.sp
.nf
double Pure_foo(point* arg0)
{
  return foo(*arg0);
}
.fi
.sp
Which is declared in the Pure interface as:
.sp
.nf
extern double Pure_foo(point*) = foo;
.fi
.sp
Struct return values are handled by returning a pointer to a static variable
holding the return value. E.g.,
.sp
.nf
extern point bar(double x, double y);
.fi
.sp
becomes:
.sp
.nf
point* Pure_bar(double arg0, double arg1)
{
  static point ret;
  ret = bar(arg0, arg1); return &ret;
}
.fi
.sp
Which is declared in the Pure interface as:
.sp
.nf
extern point* Pure_bar(double, double) = bar;
.fi
.sp
(Note that the generated code in this case comes from an alternate template.
It's possible to configure the alternate template just like the normal one,
using the \fB-T\fP option instead of \fB-t\fP. See the \fIGENERATING C CODE\fP
section above for details about code templates.)
.PP
In a Pure script you can now call foo and bar as:
.sp
.nf
> foo (bar 0.0 1.0);
.fi
.sp
Note, however, that the pointer returned by `bar' points to static storage
which will be overwritten each time you invoke the `bar' function. Thus in the
following example \fIboth\fP u and v will point to the same `point' struct:
.sp
.nf
> let u = bar 1.0 0.0; let v = bar 0.0 1.0;
.fi
.sp
Which most likely is \fInot\fP what you want. To avoid this, you'll have to
take dynamic copies of returned structs. It's possible to do this manually by
fiddling around with malloc and memcpy, but the most convenient way is to
employ the struct functions provided by Pure's ffi module:
.sp
.nf
> using ffi;
> let point_t = struct_t (double_t, double_t);
> let u = copy_struct point_t (bar 1.0 0.0);
> let v = copy_struct point_t (bar 0.0 1.0);
.fi
.sp
Now u and v point to different, malloc'd structs which even take care of
freeing themselves when they are no longer needed. Moreover, the ffi module
also allows you to access the members of the structs in a direct
fashion. Please refer to the
.B pure-ffi
documentation for further details.
.SH AUTHORS
Scott E. Dillard and Albert Graef.
.SH SEE ALSO
.BR pure (1)
