.. We use docutils to produce the documentation. Docstrings are extracted
.. with pure-doc. Please see the pure-doc documentation for details.

.. This module is always the first in the library docs, so produce the
.. title here.

===================
Pure Library Manual
===================

.. Add all pertaining author and copyright information here.

:Author: Albert Graef <Dr.Graef@t-online.de>
:Copyright: Copyright (c) 2009

.. Add all global docutils declarations here.

.. role:: dfn(strong)
.. default-role:: dfn

.. |GPL| replace:: GNU General Public License
.. |FDL| replace:: GNU Free Documentation License
.. _FDL: http://www.gnu.org/copyleft/fdl.html
.. _GPL: http://www.gnu.org/copyleft/gpl.html

.. _Pure Manual: file:pure.html

This document is available under the |FDL|_.

This manual describes the operations in the standard Pure library,
including the prelude and the other library modules which come bundled with
the interpreter. It is woefully incomplete right now, but this is being
worked on.

There is a companion to this manual, the `Pure Manual`_ which describes the
Pure language and the operation of the Pure interpreter.

.. Table of contents, switch on section numbering.

.. contents::
.. sectnum::

Prelude
=======

TODO

..

Mathematical Functions
======================

The math.pure module provides Pure's basic math routines. It also defines
complex and rational numbers.

TODO

..

Container Types
===============

The standard library provides a variety of efficient container data
structures for different purposes. Note that these are all purely
functional, i.e., immutable data structures implemented using different
flavours of binary trees. Nevertheless operations are performed
efficiently, in logarithmic time where possible.

Arrays
------

The array.pure module implements an efficient functional array data
structure which allows to access and update individual array members, as
well as to add and remove elements at the beginning and end of an
array. All these operations are carried out in logarithmic time.

Imports
~~~~~~~

To use the operations of this module, add the following import declaration
to your program::

  using array;

Operations
~~~~~~~~~~

.. _array:

``emptyarray``
  return the empty array
``array xs``
  create an array from a list ``xs``
``array2 xs``
  create a two-dimensional array from a list of lists
``mkarray x n``
  create an array consisting of ``n`` ``x``'s
``mkarray2 x (n,m)``
  create a 2D array of ``n*m`` ``x``'s
``arrayp x``
  check whether ``x`` is an array

``#a``
  size of ``a``
``a!i``
  return the ``i``\ th member of ``a``
``a!(i,j)``
  two-dimensional subscript

``null a``
  test whether ``a`` is the empty array
``members a``, ``list a``
  list of values stored in ``a``
``members2 a``, ``list2 a``
  list of members in a two-dimensional array

``first a``, ``last a``
  first and last member of ``a``
``rmfirst a``, ``rmlast a``
  remove first and last member from ``a``
``insert a x``
  insert ``x`` at the beginning of ``a``
``append a x``
  append ``x`` to the end of ``a``
``update a i x``
  replace the ``i``\ th member of ``a`` by ``x``
``update2 a (i,j) x``
  update two-dimensional array

Examples
~~~~~~~~

Import the module::

  > using array;

A one-dimensional array::

  > let a = array (0.0:0.1..1.0);
  > #a; members a;
  11
  [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
  > a!5;
  0.5

Updating a member of an array produces a new array::

  > let b = update a 1 2.0;
  > members b;
  [0.0,2.0,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]

Two-dimensional arrays can be created with ``array2`` from a list of
lists::

  > let a2 = array2 [[i,x | x = [u,v,w]] | i = 1..2];
  > members2 a2;
  [[(1,u),(1,v),(1,w)],[(2,u),(2,v),(2,w)]]
  > a2!(1,2);
  2,w

Here's how to convert an array to a Pure matrix::

  > matrix $ members a;
  {0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0}
  > matrix $ members2 a2;
  {(1,u),(1,v),(1,w);(2,u),(2,v),(2,w)}

Converting back from a matrix to an array::

  > let b2 = array2 $ list2 {(1,u),(1,v),(1,w);(2,u),(2,v),(2,w)};
  > members2 b2;
  [[(1,u),(1,v),(1,w)],[(2,u),(2,v),(2,w)]]

..

Heaps
-----

Heaps allow quick (constant time) access to the smallest member, and to
remove the smallest nember and insert new elements in logarithmic time.
This implementation does not allow quick update of heap members; if
such functionality is required, bags should be used instead
(see bag_ in `Sets and Bags`_).

Heap members *must* be ordered by the ``<=`` predicate. Multiple instances
of the same element may be stored in a heap; however, the order in which
equal elements are retrieved is not specified.

Imports
~~~~~~~

To use the operations of this module, add the following import declaration
to your program::

  using heap;

Operations
~~~~~~~~~~

.. _heap:

``emptyheap``
  return the empty heap
``heap xs``
  create a heap from a list ``xs``
``heapp x``
  check whether ``x`` is a heap

``#h``
  size of a heap

``null h``
  test whether ``h`` is the empty heap
``members h``, ``list h``
  list the members of ``h`` in ascending order

``first h``
  the first (i.e., smallest) member of ``h``
``rmfirst h``
  remove the first (i.e., smallest) member from ``h``
``insert h x``
  insert ``x`` into ``h``

Examples
~~~~~~~~

::

  > let h = heap [5,1,3,11,3];
  > members h;
  [1,3,3,5,11]
  > first h;
  1
  > members $ rmfirst h;
  [3,3,5,11]

..

Dictionaries
------------

The dict.pure module provides Pure's ``dict`` and ``hdict`` data types
based on AVL trees. ``dict`` is an ordered dictionary (assuming an ordered
key type), ``hdict`` a hashed dictionary which works with any (mixture of)
key types but stores members in an apparently random order.

The used AVL tree algorithm has its origin in the SWI-Prolog implementation
of association lists. The original file was created by R. A. O'Keefe and
updated for the SWI-Prolog by Jan Wielemaker. For the original file see
http://www.swi-prolog.org.

The port from SWI-Prolog and the deletion stuff (``rmfirst``, ``rmlast``,
``delete``) missing in the original file was provided by Jiri Spitz.

..

Imports
~~~~~~~

To use the operations of this module, add the following import declaration
to your program::

  using dict;

Data Structure
~~~~~~~~~~~~~~

A tree for ``dict`` and ``hdict`` takes the form ``Dict T`` or ``HDict T``
where ``T`` is either:

``nil``
  the empty tree; or

``bin key value balance left right``
  a nonempty tree with given ``key`` and ``value`` in the root node, where
  ``left`` and ``right`` are the left and right subtree, and ``balance``
  is either 1, 0 or -1, denoting ``|left|-|right|`` = 1, 0, or -1,
  respectively.

The tree constructors are private.

Operations
~~~~~~~~~~

.. _hdict:
.. _dict:

``emptydict``, ``emptyhdict``
  return the empty dict or hdict

``dict xs``, ``hdict xs``
  create a dict or hdict from list ``xs`` of key-value pairs in the form
  ``key=>value``

``dictp d``, ``hdictp d``
  check whether ``x`` is a dict or hdict

``mkdict y xs``, ``mkhdict y xs``
  create dict or hdict from a list of keys and a constant value

``#d``
  size of dict or hdict ``d``

``d!x``
  get value from ``d`` by key ``x``

``null d``
  test whether ``d`` is the empty dict or hdict

``member d x``
  test whether ``d`` contains a member with key ``x``

``members d``, ``list d``
  list members of ``d`` (in ascending order for dict)

``keys d``
  list keys of ``d`` (in ascending order for dict)

``values d``
  list values of ``d``

``first d``, ``last d``
  return first and last member of ``d``

``rmfirst d``, ``rmlast d``
  remove first and last member from ``d``

``insert d (x=>y)``, ``update d x y``
  insert ``x=>y`` into ``d`` (replace any existing element); ``update`` is
  a fully curried version of ``insert``

``delete d x``
  remove ``x`` from ``d``

Examples
~~~~~~~~

A normal (ordered) dictionary::

  > using dict;
  > let d = dict ["foo"=>77,"bar"=>99.1];
  > keys d; vals d; members d;
  ["bar","foo"]
  [99.1,77]
  ["bar"=>99.1,"foo"=>77]
  > d!"foo";
  77

A hashed dictionary can be used with any key values, which are stored in a
seemingly random order::

  > let h = hdict [foo=>77,42=>99.1];
  > keys h; vals h; members h;
  [42,foo]
  [99.1,77]
  [42=>99.1,foo=>77]
  > h!foo;
  77

..

Sets and Bags
-------------

The set.pure module implements Pure's set and bag (multiset) data types
based on AVL trees. Set and bag elements must be ordered, i.e., the
predicates ``==``, ``<`` and ``>`` must be defined on them. The used AVL
tree algorithm has its origin in the SWI-Prolog implementation of
association lists, see Dictionaries_ for details.

..

Imports
~~~~~~~

To use the operations of this module, add the following import declaration
to your program::

  using set;

Data Structure
~~~~~~~~~~~~~~

A tree for ``set`` and ``bag`` takes the form ``Set T`` or ``Bag T`` where
``T`` is either:

``nil``
  the empty tree; or

``bin key balance left right``
  a nonempty tree with given ``key`` (set element) in the root node, where
  ``left`` and ``right`` are the left and right subtree, and ``balance`` is
  either 1, 0 or -1, denoting ``|left|-|right|`` = 1, 0, or -1,
  respectively.

The tree constructors are private.

Operations
~~~~~~~~~~

.. _set:
.. _bag:

``emptyset``, ``emptybag``
  return the empty set or bag
``set xs``, ``bag xs``
  create a set or bag from a list ``xs``
``setp x``, ``bagp x``
  check whether ``x`` is a set or bag

``#m``
  size of set or bag ``m``

``null m``
  test whether ``m`` is the empty set or bag
``member m x``
  test whether ``m`` contains ``x``
``members m``, ``list m``
  list members of ``m`` in ascending order

``first m``, ``last m``
  return first and last member of ``m``
``rmfirst m``, ``rmlast m``
  remove first and last member from ``m``
``insert m x``
  insert ``x`` into ``m`` (replaces an existing element in the ``set`` case)
``delete m x``
  remove ``x`` from ``m`` (in the ``bag`` case, only a single instance of
  ``x`` is removed)

Examples
~~~~~~~~

::

  > let m = set [5,1,3,11,3];
  > members m;
  [1,3,5,11]
  > map (member m) (1..5);
  [1,0,1,0,1]
  > let m = bag [5,1,3,11,3];
  > members m;
  [1,3,3,5,11]
  > members $ delete m 3;
  [1,3,5,11]
  > members $ insert m 1;
  [1,1,3,3,5,11]

..

System Interface
================

This module offers some useful system routines, straight from the C
library, as well as some convenience functions for wrapping these up in
Pure. Even the "purest" program needs to do some basic I/O every once in a
while, and this module provides the necessary stuff to do just that. The
interface is rather minimalistic and preliminary right now, but will
probably grow over time.

TODO

.. 

Getopt
======

This is a quick-and-dirty replacement for the GNU getopt functions, ported
from the Q library.

Imports
-------

To use the operations of this module, add the following import declaration
to your program::

  using getopt;

Operations
----------

``getopt opts args``
   get program options from the ``args`` variable

The ``getopt`` function takes two arguments: ``opts``, a list of option
descriptions in the format described below, and ``args``, a list of strings
containing the command line parameters to be parsed for options. The result
is a pair ``(opts_return,args_return)`` where ``opts_return`` is a list of
options and their values, and ``args_return`` is the list of remaining
(non-option) arguments. Options are parsed using the rules of GNU
getopt(1). If an invalid option is encountered (unrecognized option,
missing or extra argument, etc.), ``getopt`` throws the offending option
string as an exception.

The ``opts_return`` value is a list of "hash pairs" ``opt=>val`` where
``opt`` is the (long) option name (as given by the ``long_opt`` field given
in the ``opts`` argument, see below) and ``val`` is the corresponding value
(``()`` if none). Note that this format is ready to be passed to the dict_
or hdict_ function, cf. Dictionaries_, which makes it easy to retrieve
option values or check for the presence of options.

The ``opts`` argument of ``getopt`` must be a list of triples ``(long_opt,
short_opt, flag)``, where ``long_opt`` denotes the long option,
``short_opt`` the equivalent short option, and ``flag`` is one of the
symbolic integer values ``NOARG``, ``OPTARG`` and ``REQARG`` which
specifies whether the option has no argument, an optional argument or a
required argument, respectively. Either ``long_opt`` or ``short_opt``
should be a string value of the form ``"--abc"`` or ``"-x"``,
respectively. Note that since the ``long_opt`` value is always used to
denote the corresponding option in the ``opts_return`` list, you always
have to specify a sensible value for that field. If no separate long option
name is needed, you can specify the same value as in the ``short_opt``
field, or some other convenient value (e.g., an integer) which designates
the option. Conversely, to indicate that an option has no short option
equivalent, simply specify an empty option string for the ``short_opt``
field.

Examples
--------

::

  > let opts = [("--help", "-h", NOARG),       // no argument
  >             ("--version", "", NOARG),      // no short option
  >             ("--filename", "-f", REQARG),  // required argument
  >             ("--count", "-n", OPTARG)];    // optional argument
  > getopt opts ["foo", "-h", "--filename", "bar", "-n0", "baz"];
  ["--help"=>(),"--filename"=>"bar","--count"=>"0"],["foo","baz"]
  > catch invalid_option $ getopt opts ["-h","-v"];
  invalid_option "-v"
  > getopt opts [foo, "-h", bar];
  ["--help"=>()],[foo,bar]

As the last example shows, non-option arguments (as well as option values
specified as separate arguments) can actually be any values which are just
copied to the result lists as is.

