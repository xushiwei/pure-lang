.. We use docutils to produce the documentation. Docstrings are extracted
.. with pure-doc. Please see the pure-doc documentation for details.

.. This module is always the first in the library docs, so produce the
.. title here.

===================
Pure Library Manual
===================

.. Add all pertaining author and copyright information here.

:Author: Albert Graef <Dr.Graef@t-online.de>
:Copyright: Copyright (c) 2009
:Date: |date|

.. Add all global docutils declarations here.

.. role:: dfn(strong)
.. default-role:: dfn

.. |date| date::
.. |time| date:: %H:%M

.. |GPL| replace:: GNU General Public License
.. |FDL| replace:: GNU Free Documentation License
.. _FDL: http://www.gnu.org/copyleft/fdl.html
.. _GPL: http://www.gnu.org/copyleft/gpl.html

.. _Pure Manual: pure.html

This document is available under the |FDL|_.

This manual describes the operations in the standard Pure library,
including the prelude and the other library modules which come bundled with
the interpreter. It is woefully incomplete right now, but this is being
worked on.

There is a companion to this manual, the `Pure Manual`_ which describes the
Pure language and the operation of the Pure interpreter.

.. Table of contents, switch on section numbering.

.. contents::
.. sectnum::

Prelude
=======

The prelude defines the basic operations of the Pure language. This
includes the basic arithmetic and logical operations, string, list and
matrix functions, as well as the support operations required to implement
list and matrix comprehensions. (The string and matrix operations are in
separate modules string.pure and matrix.pure, the primitive arithmetic and
logical operations can be found in primitives.pure.)

The prelude also declares a signature of commonly used constant and
operator symbols. This comprises:

.. raw:: html

   <a name="failed_cond">

.. raw:: html

   <a name="failed_match">

.. raw:: html

   <a name="stack_fault">

.. raw:: html

   <a name="bad_matrix_value">

.. _failed_cond:
.. _failed_match:
.. _stack_fault:
.. _bad_matrix_value:

* The built-in exception values ``failed_cond`` (failed conditional in
  guard or if-then-else), ``failed_match`` (failed pattern match in lambda,
  ``case`` expression, etc.), ``stack_fault`` (not enough stack space,
  ``PURE_STACK`` limit exceeded) and ``bad_matrix_value x`` (error in
  matrix construction).

.. raw:: html

   <a name="bad_list_value">

.. raw:: html

   <a name="bad_tuple_value">

.. raw:: html

   <a name="out_of_bounds">

.. raw:: html

   <a name="malloc_error">

.. _bad_list_value:
.. _bad_tuple_value:
.. _out_of_bounds:
.. _malloc_error:

* Other predefined exceptions: ``bad_list_value x``, ``bad_tuple_value x``
  (which are thrown by some list and tuple operations when they fail to
  find an expected list or tuple value), ``out_of_bounds`` (which is thrown
  by the index operator ``!`` if a list, tuple or matrix index is out of
  bounds), and ``malloc_error`` which indicates a memory allocation error.

.. raw:: html

   <a name="true">

.. raw:: html

   <a name="false">

.. _true:
.. _false:

* The truth values ``true`` and ``false``. These are actually just integers
  in Pure, but sometimes it's convenient to refer to them using these
  symbolic constants. Note that if you also want to use these on the
  left-hand side of equations, you still have to declare them as
  ``nullary`` symbols yourself, using a declaration like: ``nullary false
  true;``

.. raw:: html

   <a name="operators">

.. _operators:

Here's the list of predefined operator symbols. Note that the parser will
automagically give unary minus the same precedence level as the
corresponding binary operator. Also note that the "mapsto" operator
a.k.a. "hash rocket" ``=>`` doesn't have a predefined meaning in Pure; the
prelude only implements the relations ``==`` and ``~=`` to check such "hash
pairs" ``x=>y`` for equality and inequality. The hash rocket is used in
several libraries, however, which usually employ it to denote some kind of
key-value associations. See, e.g., Dictionaries_ for an example.

::

  infixl  0   $$ ;                // sequence operator
  infixr  0   $ ;                 // right-associative application
  infixr  1   , ;                 // pair (tuple)
  infix   2   .. ;                // arithmetic sequences
  infix   2   => ;                // mapsto constructor
  infixr  2   || ;                // logical or (short-circuit)
  infixr  3   && ;                // logical and (short-circuit)
  prefix  3   ~ ;                 // logical negation
  infix   4   < > <= >= == ~= ;   // relations
  infix   4   === ~== ;           // syntactic equality
  infixr  4   : ;                 // list cons
  infix   5   +: <: ;             // complex numbers (cf. math.pure)
  infixl  5   << >> ;             // bit shifts
  infixl  6   + - or ;            // addition, bitwise or
  infixl  7   * / div mod and ;   // multiplication, bitwise and
  infixl  7   % ;                 // exact division (cf. math.pure)
  prefix  7   not ;               // bitwise not
  postfix 7   ' ;                 // matrix transposition
  infixr  8   ^ ;                 // exponentiation
  prefix  8   # ;                 // size operator
  infixl  9   ! !! ;              // indexing, slicing
  infixr  9   . ;                 // function composition
  postfix 9   & ;                 // thunk

..

Basic Combinators
-----------------

.. raw:: html

   <a name="combinators">

.. raw:: html

   <a name="$">

.. raw:: html

   <a name=".">

.. _combinators:
.. _$:
.. _.:

The most important function combinators are ``$`` (right-associative
application) and ``.`` (function composition), which are also defined as
macros so that saturated calls of these are eliminated automatically.
Examples::

  > foo $ bar 99;
  foo (bar 99)
  > (foo.bar) 99;
  foo (bar 99)

.. raw:: html

   <a name="id">

.. raw:: html

   <a name="cst">

.. _id:
.. _cst:

The customary identity and constant combinators from the combinatorial
calculus are also available, in Pure these are named ``id`` and ``cst``,
respectively::

  > map id (1..5);
  [1,2,3,4,5]
  > map (cst 0) (1..5);
  [0,0,0,0,0]

.. raw:: html

   <a name="void">

.. _void:

There's also a combinator ``void`` which is basically equivalent to ``cst
()``, but with the special twist that it is also defined as a macro
optimizing the case of "throwaway" list and matrix comprehensions. This is
useful if a comprehension is evaluated solely for its side effects. E.g.::

  > using system;
  > extern int rand();
  > foo = void [printf "%d\n" rand | _ = 1..3];
  > show foo
  foo = do (\_ -> printf "%d\n" rand) (1..3);
  > foo;
  1714636915
  1957747793
  424238335
  ()

Note that the above list comprehension is actually implemented using do_
(instead of map_, which would normally be the case), so that the
intermediate list value of the comprehension is never constructed. This is
described in more detail in section `Optimization Rules`_ of the Pure
Manual.

.. _Optimization Rules: pure.html#optimization-rules

..

In addition, Pure also provides the following combinators adopted from
Haskell:

.. raw:: html

   <a name="flip">

.. _flip:

* ``flip f`` swaps arguments of a binary function ``f``, e.g.::

    > map (flip (/) 2) (1..3);
    [0.5,1.0,1.5]

  This idiom is used much more frequently in Pure than in Haskell because
  Pure doesn't have Haskell's operator sections. Note, however, that the
  same effect can also be achieved with a lambda::

    > map (\x -> x/2) (1..3);
    [0.5,1.0,1.5]

.. raw:: html

   <a name="curry">

.. _curry:

* ``curry f`` turns a function ``f`` expecting a pair of values into a
  curried function of two arguments::

    > using system;
    > dowith (curry (printf "%d: %g\n")) (0..2) [0.0,2.718,3.14];
    0: 0
    1: 2.718
    2: 3.14
    ()

.. raw:: html

   <a name="uncurry">

.. _uncurry:

* Conversely, ``uncurry f`` turns a curried function ``f`` expecting two
  arguments into a function processing a single pair argument::

    > map (uncurry (*)) [(2,3),(4,5),(6,7)];
    [6,20,42]

.. raw:: html

   <a name="curry3">

.. raw:: html

   <a name="uncurry3">

.. _curry3:
.. _uncurry3:

* ``curry3`` and ``uncurry3`` work analogously, but are used to work with
  ternary functions.

.. raw:: html

   <a name="fix">

.. _fix:

* The (normal order) fixed point combinator ``fix`` allows you to create
  recursive anonymous functions. It takes another function ``f`` as its
  argument and applies ``f`` to ``fix f`` itself::

    > let fact = fix (\f n -> if n<=0 then 1 else n*f (n-1));
    > map fact (1..5);
    [1,2,6,24,120]

.. _Fixed point combinator: http://en.wikipedia.org/wiki/Fixed_point_combinator

  See `Fixed point combinator`_ for an explanation of how this magic
  works. Just like in Haskell, ``fix`` can be used to produce least fixed
  points of arbitrary functions. For instance::

    > fix (cst bar);
    bar
    > let xs = fix (\x -> 1:x);
    > xs;
    1:#<thunk 0x7fe537fe2f90>
    > xs!!(0..10);
    [1,1,1,1,1,1,1,1,1,1,1]

..

Quasiquote
----------

The prelude also defines a general Lisp-like ``quasiquote`` macro which is
used to construct quoted expressions by unquoting and splicing subterms
indicated with the ``unquote`` and ``splice`` constructors. For instance::

  > quasiquote (2*42+unquote (2^12));
  2*42+4096.0
  > quasiquote (foo 1 2 (splice [2/3,3/4]) (5/6));
  foo 1 2 (2/3) (3/4) (5/6)

Lisp weenies might want to add some syntactic sugar for convenience. This
isn't in the prelude, so you'll have to define it yourself. Also note that
we cannot have ``,`` for unquoting, so we use ``,,`` instead::

  prefix 9 ` ,, ,@ ;
  def â€˜x = quasiquote x; def ,,x = unquote x; def ,@x = splice x;

Examples::

  > `(2*42+2^12);
  2*42+2^12
  > `(2*42+,,(2^12));
  2*42+4096.0
  > `foo 1 2 (,@[2/3,3/4]) (5/6);
  foo 1 2 (2/3) (3/4) (5/6)
  > `foo 1 2 (,@args) (5/6) when args = quote [2/3,3/4] end;
  foo 1 2 (2/3) (3/4) (5/6)

This is discussed in more detail in section `Recursive Macros`_ of the Pure
Manual.

.. _Recursive Macros: pure.html#recursive-macros

..

Lists and Tuples
----------------

.. raw:: html

   <a name="lists">

.. raw:: html

   <a name="tuples">

.. raw:: html

   <a name="list size">

.. raw:: html

   <a name="tuple size">

.. raw:: html

   <a name="null">

.. raw:: html

   <a name="reverse">

.. raw:: html

   <a name="#">

.. raw:: html

   <a name="\:">

.. raw:: html

   <a name=",">

.. _lists:
.. _tuples:
.. _list size:
.. _tuple size:
.. _null:
.. _reverse:
.. _#:
.. _\::
.. _,:

The prelude defines the list and tuple constructors (``x:y``, ``x,y``), as
well as equality (``==``) and inequality (``~=``) on these structures. It
also provides the predicate ``null x`` which tests whether ``x`` is the
empty list or tuple, the function ``reverse x`` which reverses a list or
tuple, and the operators ``#x`` (size of a list or tuple), ``x!i``
(indexing), ``x!!is`` (slicing) and ``x+y`` (list concatenation).

Note that list and tuple equality use the equality of their members to
decide equality of lists and tuples, so ``==`` must be defined on the list
or tuple members.

Also note that there isn't a separate operation for concatenating tuples,
since the pairing operator already does this::

  > (1,2,3),(10,9,8);
  1,2,3,10,9,8

This works because the ``(,)`` constructor is associative in Pure and will
always produce right-recursive pairs. This also implies that tuples are
always flat in Pure and can't be nested; if you need this, you should use
lists instead. Also note that the empty tuple ``()`` acts as a neutral
element with respect to ``(,)``::

  > (),(a,b,c);
  a,b,c
  > (a,b,c),();
  a,b,c

.. raw:: html

   <a name="list concatenation">

.. _list concatenation:

Lists are the usual right-recursive aggregates, pretty much the same as in
Lisp or Prolog except that they use a Haskell-like syntax. In difference to
Haskell, list concatenation is denoted ``+``, and lists may contain an
arbitrary mixture of arguments, i.e., they are fully polymorphic::

  > 1:2:3:[];
  [1,2,3]
  > [1,2,3]+[u,v,w]+[3.14];
  [1,2,3,u,v,w,3.14]

Lists are `eager` in Pure by default, but they can also be made `lazy`, see
section `Lazy Evaluation and Streams`_ in the Pure Manual.

.. _Lazy Evaluation and Streams: pure.html#lazy-evaluation-and-streams

.. raw:: html

   <a name="arithmetic sequences">

.. raw:: html

   <a name="..">

.. _arithmetic sequences:
.. _..:

Arithmetic sequences can be constructed with the infix ``..`` operator::

  > 1..5;
  [1,2,3,4,5]
  > 1:3..11;
  [1,3,5,7,9,11]

Note that the Pure syntax differs slightly from Haskell in that a step
width is indicated by specifying the first two elements as ``x:y`` instead
of ``x,y``. Also, to specify infinite sequences you have to use an infinite
upper bound (``inf`` or ``-inf``)::

  > 1:3..inf;
  1:#<thunk 0x7f696cd2dbd8>
  > -1:-3..-inf;
  -1:#<thunk 0x7f696cd2fde8>

.. raw:: html

   <a name="list">

.. raw:: html

   <a name="tuple">

.. _list:
.. _tuple:

You can convert between (finite) lists and tuples using the ``list`` and
``tuple`` operations::

  > tuple (1..5);
  1,2,3,4,5
  > list (a,b,c);
  [a,b,c]

The ``list`` function can also be used to turn a finite lazy list into an
eager one::

  > list $ take 10 (-1:-3..-inf);
  [-1,-3,-5,-7,-9,-11,-13,-15,-17,-19]

You can also achieve the same effect by slicing a finite part from a
stream (see below)::

  > (-1:-3..-inf)!!(0..9);
  [-1,-3,-5,-7,-9,-11,-13,-15,-17,-19]

.. raw:: html

   <a name="stream">

.. _stream:

Conversely, it is also possible to convert a list to a stream::

  > stream (1..10);
  1:#<thunk 0x7fe537fe2b58>

This might appear a bit useless at first sight, since all elements of the
stream are in fact already known. However, this operation then allows you
to apply other functions to the list and have them evaluated in a lazy
fashion.

.. raw:: html

   <a name="list indexing">

.. raw:: html

   <a name="tuple indexing">

.. raw:: html

   <a name="!">

.. _list indexing:
.. _tuple indexing:
.. _!:

Indexing of lists and tuples is always zero-based (i.e., indices run from
``0`` to ``#x-1``), and an exception will be raised if the index is out of
bounds::

  > [1,2,3]!2;
  3
  > [1,2,3]!4;
  <stdin>, line 34: unhandled exception 'out_of_bounds' while evaluating
  '[1,2,3]!4'

.. raw:: html

   <a name="list slicing">

.. raw:: html

   <a name="tuple slicing">

.. raw:: html

   <a name="!!">

.. _list slicing:
.. _tuple slicing:
.. _!!:

The slicing operator ``!!`` takes a list or tuple and a list of indices and
returns the list or tuple of the corresponding elements, respectively.
Indices which are out of the valid range are silently ignored::

  > (1..5)!!(3..10);
  [4,5]
  > (1,2,3,4,5)!!(3..10);
  4,5

Indices can actually be specified in any order, so that you can retrieve
any permutation of the members, also with duplicates. E.g.::

  > (1..5)!![2,4,4,1];
  [3,5,5,2]

This is less efficient than the case of contiguous index ranges (which is
optimized so that it always works in linear time), because it requires
repeated traversals of the list for each index. For larger lists you should
hence use vectors or matrices instead, to avoid the quadratic complexity.

..

List Functions
--------------

This mostly comes straight from the Q prelude which in turn was based on
the first edition of the Bird/Wadler book, and is very similar to what you
can find in the Haskell prelude. Some functions have slightly different
names, though, and of course everything is typed dynamically.

Common List Functions
~~~~~~~~~~~~~~~~~~~~~

.. raw:: html

   <a name="any">

.. _any:

``any p xs``
  tests whether the predicate ``p`` holds for any of the members of ``xs``

.. raw:: html

   <a name="all">

.. _all:

``all p xs``
  tests whether the predicate ``p`` holds for all of the members of ``xs``

.. raw:: html

   <a name="cat">

.. _cat:

``cat xs``
  concatenate a list of lists

.. raw:: html

   <a name="catmap">

.. _catmap:

``catmap f xs``
  convenience function which combines cat_ and map_

.. raw:: html

   <a name="do">

.. _do:

``do f xs``
  apply ``f`` to all members of ``xs``, like map_, but throw away all
  intermediate results and return ``()``

.. raw:: html

   <a name="drop">

.. _drop:

``drop n xs``
  remove ``n`` elements from the front of ``xs``

.. raw:: html

   <a name="dropwhile">

.. _dropwhile:

``dropwhile p xs``
  remove elements from the front of ``xs`` while the predicate ``p`` is
  satisfied

.. raw:: html

   <a name="filter">

.. _filter:

``filter p xs``
  return the list of all members of ``xs`` satisfying the predicate ``p``

.. raw:: html

   <a name="foldl">

.. _foldl:

``foldl f a xs``
  accumulate the binary function ``f`` over all members of ``xs``,
  starting from the initial value ``a`` and working from the front of the
  list towards its end

.. raw:: html

   <a name="foldl1">

.. _foldl1:

``foldl1 f xs``
  accumulate the binary function ``f`` over all members of ``xs``,
  starting from the value ``head xs`` and working from the front of the
  list towards its end; ``xs`` must be nonempty

.. raw:: html

   <a name="foldr">

.. _foldr:

``foldr f a xs``
  accumulate the binary function ``f`` over all members of ``xs``,
  starting from the initial value ``a`` and working from the end of the
  list towards its front

.. raw:: html

   <a name="foldr1">

.. _foldr1:

``foldr1 f xs``
  accumulate the binary function ``f`` over all members of ``xs``,
  starting from the value ``last xs`` and working from the end of the
  list towards its front; ``xs`` must be nonempty

.. raw:: html

   <a name="head">

.. _head:

``head xs``
  return the first element of ``xs``; ``xs`` must be nonempty

.. raw:: html

   <a name="index">

.. _index:

``index xs x``
  search for an occurrence of ``x`` in ``xs`` and return the index of the
  first occurrence, if any, ``-1`` otherwise

  Note: This uses equality (``==``) to decide whether a member of ``xs`` is
  an occurrence of ``x``, so ``==`` must have an appropriate definition on
  the list members.

.. raw:: html

   <a name="init">

.. _init:

``init xs``
  return all but the last element of ``xs``; ``xs`` must be nonempty

.. raw:: html

   <a name="last">

.. _last:

``last xs``
  return the last element of ``xs``; ``xs`` must be nonempty

.. raw:: html

   <a name="map">

.. _map:

``map f xs``
  apply ``f`` to each member of ``xs``

.. raw:: html

   <a name="scanl">

.. _scanl:

``scanl f a xs``
  accumulate the binary function ``f`` over all members of ``xs``,
  as with ``foldl``, but return all intermediate results as a list

.. raw:: html

   <a name="scanl1">

.. _scanl1:

``scanl1 f xs``
  accumulate the binary function ``f`` over all members of ``xs``,
  as with ``foldl1``, but return all intermediate results as a list

.. raw:: html

   <a name="scanr">

.. _scanr:

``scanr f a xs``
  accumulate the binary function ``f`` over all members of ``xs``,
  as with ``foldr``, but return all intermediate results as a list

.. raw:: html

   <a name="scanr1">

.. _scanr1:

``scanr1 f xs``
  accumulate the binary function ``f`` over all members of ``xs``,
  as with ``foldr1``, but return all intermediate results as a list

.. raw:: html

   <a name="tail">

.. _tail:

``tail xs``
  return all but the first element of ``xs``; ``xs`` must be nonempty

.. raw:: html

   <a name="take">

.. _take:

``take n xs``
  take ``n`` elements from the front of ``xs``

.. raw:: html

   <a name="takewhile">

.. _takewhile:

``takewhile p xs``
  take elements from the front of ``xs`` while the predicate ``p`` is
  satisfied

..

List Generators
~~~~~~~~~~~~~~~

.. raw:: html

   <a name="cycle">

.. _cycle:

``cycle xs``
  cycles through the elements of the nonempty list ``xs``, ad infinitum

.. raw:: html

   <a name="cyclen">

.. _cyclen:

``cyclen n xs``
  eager version of ``cycle``, returns the first ``n`` elements of
  ``cycle xs``

.. raw:: html

   <a name="iterate">

.. _iterate:

``iterate f x``
  returns the stream containing ``x``, ``f x``, ``f (f x)``, etc.,
  ad infinitum

.. raw:: html

   <a name="repeat">

.. _repeat:

``repeat x``
  returns an infinite stream of ``x``\ s

.. raw:: html

   <a name="repeatn">

.. _repeatn:

``repeatn n x``
  eager version of ``repeat``, returns a list with ``n`` ``x``\ s

.. raw:: html

   <a name="while">

.. _while:

``while p f x``
  eager version of ``iterate``, returns the list of all elements from
  the front of ``iterate f xs`` for which the predicate ``p`` holds

..

Zip and Friends
~~~~~~~~~~~~~~~

.. raw:: html

   <a name="unzip">

.. _unzip:

``unzip xys``
  takes a list of pairs to a pair of lists of corresponding elements

.. raw:: html

   <a name="unzip3">

.. _unzip3:

``unzip3 xyzs``
  ``unzip`` with triples

.. raw:: html

   <a name="zip">

.. _zip:

``zip xs ys``
  return the list of corresponding pairs ``(x,y)`` where ``x`` runs
  through the elements of ``xs`` and ``y`` runs through the elements
  of ``y``

.. raw:: html

   <a name="zip3">

.. _zip3:

``zip3 xs ys zs``
  ``zip`` with three lists, returns a list of triples

.. raw:: html

   <a name="zipwith">

.. _zipwith:

``zipwith f xs ys``
  apply the binary function ``f`` to corresponding elements of ``xs``
  and ``ys``

.. raw:: html

   <a name="zipwith3">

.. _zipwith3:

``zipwith3 f xs ys zs``
  apply the ternary function ``f`` to corresponding elements of ``xs``,
  ``ys`` and ``zs``

Pure also has the following variations of ``zipwith``/``zipwith3`` which
throw away all intermediate results and return ``()``. That is, these work
like do_ but pull arguments from two or three lists, respectively:

.. raw:: html

   <a name="dowith">

.. _dowith:

``dowith f xs ys``
  apply the binary function ``f`` to corresponding elements of ``xs``
  and ``ys``, return ``()``

.. raw:: html

   <a name="dowith3">

.. _dowith3:

``dowith3 f xs ys zs``
  apply the ternary function ``f`` to corresponding elements of ``xs``,
  ``ys`` and ``zs``, return ``()``

..

String Functions
----------------

Pure strings are null-terminated character strings encoded in UTF-8, see
the `Pure Manual`_ for details. The prelude provides various operations on
strings, including a complete set of list-like operations, so that strings
can be used mostly as if they were lists, although they are really
implemented as C character arrays for reasons of efficiency.

Basic String Functions
~~~~~~~~~~~~~~~~~~~~~~

.. raw:: html

   <a name="string concatenation">

.. raw:: html

   <a name="string indexing">

.. raw:: html

   <a name="string slicing">

.. _string concatenation:
.. _string indexing:
.. _string slicing:

Concatenation, indexing and slicing works just like with lists::

  > "abc"+"xyz";
  "abcxyz"
  > let s = "The quick brown fox jumps over the lazy dog.";
  > s!5;
  "u"
  > s!!(20..24);
  "jumps"

.. raw:: html

   <a name="string size">

.. raw:: html

   <a name="string null">

.. _string size:
.. _string null:

Checking for empty strings and determining the size of a string also works
as expected::

  > null "";
  1
  > null s;
  0
  > #s;
  44

You can search for the location of a substring in a string, and extract a
substring of a given length:

.. raw:: html

   <a name="string index">

.. _string index:

``index s u``
  Returns the (zero-based) index of the first occurrence of the substring
  ``u`` in ``s``, or -1 if ``u`` is not found in ``s``.

.. raw:: html

   <a name="substr">

.. _substr:

``substr s i n``
  Extracts a substring of (at most) ``n`` characters at position ``i`` in
  ``s``. This takes care of all corner cases, adjusting index and number of
  characters so that the index range stays confined to the source string.

Example::

  > index s "jumps";
  20
  > substr s 20 10;
  "jumps over"

Note that Pure doesn't have a separate type for individual characters.
Instead, these are represented as strings ``c`` containing exactly one
(UTF-8) character (i.e., ``#c==1``). It is possible to convert such single
character strings to the corresponding integer character codes, and vice
versa:

.. raw:: html

   <a name="ord">

.. _ord:

``ord c``
  Ordinal number of a single character string ``c``. This is the
  character's code point in the Unicode character set.

.. raw:: html

   <a name="chr">

.. _chr:

``chr n``
  Converts an integer back to the character with the corresponding code
  point.

.. raw:: html

   <a name="character arithmetic">

.. _character arithmetic:

In addition, the usual character arithmetic works, including arithmetic
sequences of characters, so that you can write stuff like the following::

  > "a"-"A";
  32
  > "u"-32;
  "U"
  > "a".."k";
  ["a","b","c","d","e","f","g","h","i","j","k"]

Strings are also ordered lexicographically based on their character codes::

  > "awe">"awesome";
  0
  > "foo">="bar";
  1

For convenience, the prelude provides the following functions to convert
between strings and lists (or other aggregates) of characters.

.. raw:: html

   <a name="chars">

.. raw:: html

   <a name="string list">

.. _chars:
.. _string list:

``chars s``, ``list s``
  Convert a string ``s`` to a list of characters.

.. raw:: html

   <a name="string tuple">

.. raw:: html

   <a name="string matrix">

.. _string tuple:
.. _string matrix:

``tuple s``, ``matrix s``
  Convert a string ``s`` to a tuple or (symbolic) matrix of characters,
  respectively.

.. raw:: html

   <a name="strcat">

.. _strcat:

``strcat xs``
  Concatenate a list ``xs`` of strings (in particular, this converts a
  list of characters back to a string).

.. raw:: html

   <a name="string">

.. _string:

``string xs``
  Convert a list, tuple or (symbolic) matrix of strings to a string.
  In the case of a list, this is synonymous with strcat_, but it also
  works with the other types of aggregates.

For instance::

  > list "abc";
  ["a","b","c"]
  > string ("a".."z");
  "abcdefghijklmnopqrstuvwxyz"

The following functions are provided to deal with strings of "tokens"
separated by a given delimiter string.

.. raw:: html

   <a name="split">

.. _split:

``split delim s``
  Splits ``s`` into a list of substrings delimited by ``delim``.

.. raw:: html

   <a name="join">

.. _join:

``join delim xs``
  Joins the list of strings ``xs`` to a single string, interpolating the
  given ``delim`` string.

Example::

  > let xs = split " " s; xs;
  ["The","quick","brown","fox","jumps","over","the","lazy","dog."]
  > join ":" xs;
  "The:quick:brown:fox:jumps:over:the:lazy:dog."

We mention in passing here that more elaborate string matching, splitting
and replacement operations based on regular expressions are provided by the
system module, see `System Interface`_.

If that isn't enough already, most generic list operations carry over to
strings in the obvious way, treating the string like a list of
characters. For instance::

  > filter (\x->x>="k") s;
  "qukrownoxumpsovrtlzyo"
  > map pred ["i","b","m"];
  ["h","a","l"]

This also provides for list comprehensions drawing values from strings::

  > string [x+1 | x="HAL"];
  "IBM"

Eval and Friends
~~~~~~~~~~~~~~~~

Pure provides some rather powerful operations to convert between Pure
expressions and their string representation. This is useful for
metaprogramming purposes. It also provides a convenient means to serialize
Pure expressions, e.g., when they are transferred from/to persistant
storage or transmitted over a socket. (Note, however, that this has its
limitations. Specifically, some objects like pointers and local or
anonymous functions do not have a parseable string representation.)

.. raw:: html

   <a name="str">

.. _str:

``str x``
  Yields the print representation of an expression in Pure syntax, as a
  string.

.. raw:: html

   <a name="eval">

.. _eval:

``eval x``
  Parses an expression, specified as a string in Pure syntax, and returns
  its value. In fact, ``eval`` can also parse and execute arbitrary Pure
  code. In that case it will return the last computed expression, if any.

  Alternatively, ``eval`` can also be invoked on a (quoted) Pure
  expression, which is recompiled and then evaluated. (If the expression
  cannot be compiled for some reason then ``eval`` just returns it as
  is. Also, exceptions during evaluation are reported back to the
  caller.)

.. raw:: html

   <a name="evalcmd">

.. _evalcmd:

``evalcmd x``
  Like eval_, but allows execution of interactive commands and returns
  their captured output as a string. No other results are returned, so this
  operation is most useful for executing Pure definitions and interactive
  commands for their side-effects. (At this time, only the regular output
  of a few commands can be captured, most notably ``clear``, ``save`` and
  ``show``; otherwise the result string will be empty.)

.. raw:: html

   <a name="lasterr">

.. _lasterr:

``lasterr``
  Reports errors in eval_ and evalcmd_. This string value will be nonempty
  iff a compilation or execution error was encountered during the most
  recent invokation of ``eval`` and ``evalcmd``. In that case each reported
  error message is terminated with a newline character.

Examples::

  > str (1/3);
  "0.333333333333333"
  > eval "1/3";
  0.333333333333333
  > eval (quote (1/3));
  0.333333333333333
  > evalcmd "show evalcmd";
  "extern expr* evalcmd(expr*);\n"
  > eval "1/3)";
  eval "1/3)"
  > lasterr;
  "<stdin>, line 1: syntax error, unexpected ')', expecting '=' or '|'\n"

..

Low-Level Operations
~~~~~~~~~~~~~~~~~~~~

The following routines are provided by the runtime to turn raw C ``char*``
pointers (also called `byte strings` in Pure parlance, to distinguish them
from Pure's "cooked" UTF-8 string values) into corresponding Pure
strings. Normally you don't have to worry about this, because the C
interface already takes care of the necessary marshalling, but in some
low-level code these operations are useful. Also note that here and in the
following, the ``cstring`` routines also convert the string between the
system encoding and Pure's internal UTF-8 representation.

.. raw:: html

   <a name="string from pointer">

.. raw:: html

   <a name="cstring">

.. _string from pointer:
.. _cstring:

``string s``, ``cstring s``
  Convert a pointer ``s`` to a Pure string. ``s`` must point to a
  null-terminated C string. These routines take ownership of the original
  string value, assuming it to be ``malloc``\ ed, so you should only use
  these for C strings which are specifically intended to be freed by the
  user.

.. raw:: html

   <a name="string_dup">

.. raw:: html

   <a name="cstring_dup">

.. _string_dup:
.. _cstring_dup:

``string_dup s``, ``cstring_dup s``
  Convert a pointer ``s`` to a Pure string. Like above, but these functions
  take a copy of the string, leaving the original C string untouched.

..

The reverse transformations are also provided. These take a Pure string to
a byte string (raw ``char*``).

.. raw:: html

   <a name="byte_string">

.. raw:: html

   <a name="byte_cstring">

.. _byte_string:
.. _byte_cstring:

``byte_string s``, ``byte_cstring s``
  Construct a byte string from a Pure string ``s``. The result is a raw
  pointer object pointing to the converted string. The original Pure string
  is always copied (and, in the case of ``byte_cstring``, converted to the
  system encoding). The resulting byte string is a ``malloc``\ ed pointer
  which can be used like a C ``char*``, and has to be freed explicitly by
  the caller when no longer needed.

..

Finally, it is also possible to convert Pure string lists to byte string
vectors and vice versa. These are useful if you need to pass an
``argv``-like string vector (i.e., a ``char**`` or ``char*[]``) to C
routines. The computed C vectors are ``malloc``\ ed pointers which have an
extra ``NULL`` pointer as the last entry, and should thus be usable for
almost any purpose which requires such a string vector in C. They also take
care of garbage-collecting themselves. The original string data is always
copied. As usual, the ``cstring`` variants do automatic conversions to the
system encoding.

.. raw:: html

   <a name="byte_string_pointer">

.. raw:: html

   <a name="byte_cstring_pointer">

.. _byte_string_pointer:
.. _byte_cstring_pointer:

``byte_string_pointer xs``, ``byte_cstring_pointer xs``
  Convert a list of Pure strings to a C ``char**``.

.. raw:: html

   <a name="string_list">

.. raw:: html

   <a name="cstring_list">

.. _string_list:
.. _cstring_list:

``string_list n p``, ``cstring_list n p``
  Convert a C ``char**`` to a list of Pure strings.

Note that the back conversions take an additional first argument which
denotes the number of strings to retrieve. If you know that the vector is
``NULL``-terminated then this can also be an infinite value (``inf``) in
which case the number of elements will be figured out automatically.
Processing always stops at the first ``NULL`` pointer encountered.

..

Matrix Functions
----------------

TODO

..

Primitives
----------

This prelude module is a collection of various lowlevel operations, which
are implemented either directly by machine instructions or by C functions
provided in the runtime. In particular, this module defines the basic
arithmetic operations on machine integers, bigints and floating point
numbers, as well as various type checking predicates and conversions
between different types. Some low-level pointer operations are also
provided, as well as "sentries" (Pure's flavour of object finalizers) and
"references" (mutable expression pointers).

TODO

..

Mathematical Functions
======================

The math.pure module provides Pure's basic math routines. It also defines
complex and rational numbers.

TODO

..

Container Types
===============

The standard library provides a variety of efficient container data
structures for different purposes. Note that these are all purely
functional, i.e., immutable data structures implemented using different
flavours of binary trees. Nevertheless operations are performed
efficiently, in logarithmic time where possible.

Arrays
------

The array.pure module implements an efficient functional array data
structure which allows to access and update individual array members, as
well as to add and remove elements at the beginning and end of an
array. All these operations are carried out in logarithmic time.

Imports
~~~~~~~

To use the operations of this module, add the following import declaration
to your program::

  using array;

Operations
~~~~~~~~~~

.. raw:: html

   <a name="array">

.. _array:

``emptyarray``
  return the empty array
``array xs``
  create an array from a list ``xs``
``array2 xs``
  create a two-dimensional array from a list of lists
``mkarray x n``
  create an array consisting of ``n`` ``x``'s
``mkarray2 x (n,m)``
  create a 2D array of ``n*m`` ``x``'s
``arrayp x``
  check whether ``x`` is an array

``#a``
  size of ``a``
``a!i``
  return the ``i``\ th member of ``a``
``a!(i,j)``
  two-dimensional subscript

``null a``
  test whether ``a`` is the empty array
``members a``, ``list a``
  list of values stored in ``a``
``members2 a``, ``list2 a``
  list of members in a two-dimensional array

``first a``, ``last a``
  first and last member of ``a``
``rmfirst a``, ``rmlast a``
  remove first and last member from ``a``
``insert a x``
  insert ``x`` at the beginning of ``a``
``append a x``
  append ``x`` to the end of ``a``
``update a i x``
  replace the ``i``\ th member of ``a`` by ``x``
``update2 a (i,j) x``
  update two-dimensional array

Examples
~~~~~~~~

Import the module::

  > using array;

A one-dimensional array::

  > let a = array (0.0:0.1..1.0);
  > #a; members a;
  11
  [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
  > a!5;
  0.5

Updating a member of an array produces a new array::

  > let b = update a 1 2.0;
  > members b;
  [0.0,2.0,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]

Two-dimensional arrays can be created with ``array2`` from a list of
lists::

  > let a2 = array2 [[i,x | x = [u,v,w]] | i = 1..2];
  > members2 a2;
  [[(1,u),(1,v),(1,w)],[(2,u),(2,v),(2,w)]]
  > a2!(1,2);
  2,w

Here's how to convert an array to a Pure matrix::

  > matrix $ members a;
  {0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0}
  > matrix $ members2 a2;
  {(1,u),(1,v),(1,w);(2,u),(2,v),(2,w)}

Converting back from a matrix to an array::

  > let b2 = array2 $ list2 {(1,u),(1,v),(1,w);(2,u),(2,v),(2,w)};
  > members2 b2;
  [[(1,u),(1,v),(1,w)],[(2,u),(2,v),(2,w)]]

..

Heaps
-----

Heaps allow quick (constant time) access to the smallest member, and to
remove the smallest nember and insert new elements in logarithmic time.
This implementation does not allow quick update of heap members; if
such functionality is required, bags should be used instead
(see bag_ in `Sets and Bags`_).

Heap members *must* be ordered by the ``<=`` predicate. Multiple instances
of the same element may be stored in a heap; however, the order in which
equal elements are retrieved is not specified.

Imports
~~~~~~~

To use the operations of this module, add the following import declaration
to your program::

  using heap;

Operations
~~~~~~~~~~

.. raw:: html

   <a name="heap">

.. _heap:

``emptyheap``
  return the empty heap
``heap xs``
  create a heap from a list ``xs``
``heapp x``
  check whether ``x`` is a heap

``#h``
  size of a heap

``null h``
  test whether ``h`` is the empty heap
``members h``, ``list h``
  list the members of ``h`` in ascending order

``first h``
  the first (i.e., smallest) member of ``h``
``rmfirst h``
  remove the first (i.e., smallest) member from ``h``
``insert h x``
  insert ``x`` into ``h``

Examples
~~~~~~~~

::

  > let h = heap [5,1,3,11,3];
  > members h;
  [1,3,3,5,11]
  > first h;
  1
  > members $ rmfirst h;
  [3,3,5,11]

..

Dictionaries
------------

The dict.pure module provides Pure's ``dict`` and ``hdict`` data types
based on AVL trees. ``dict`` is an ordered dictionary (assuming an ordered
key type), ``hdict`` a hashed dictionary which works with any (mixture of)
key types but stores members in an apparently random order.

The used AVL tree algorithm has its origin in the SWI-Prolog implementation
of association lists. The original file was created by R. A. O'Keefe and
updated for SWI-Prolog by Jan Wielemaker. For the original file see
http://www.swi-prolog.org.

The port from SWI-Prolog and the deletion stuff (``rmfirst``, ``rmlast``,
``delete``) missing in the original file was provided by Jiri Spitz.

..

Imports
~~~~~~~

To use the operations of this module, add the following import declaration
to your program::

  using dict;

Data Structure
~~~~~~~~~~~~~~

A tree for ``dict`` and ``hdict`` takes the form ``Dict T`` or ``HDict T``
where ``T`` is either:

``nil``
  the empty tree; or

``bin key value balance left right``
  a nonempty tree with given ``key`` and ``value`` in the root node, where
  ``left`` and ``right`` are the left and right subtree, and ``balance``
  is either 1, 0 or -1, denoting ``|left|-|right|`` = 1, 0, or -1,
  respectively.

The tree constructors are private.

Operations
~~~~~~~~~~

.. raw:: html

   <a name="hdict">

.. raw:: html

   <a name="dict">

.. _hdict:
.. _dict:

``emptydict``, ``emptyhdict``
  return the empty dict or hdict

``dict xs``, ``hdict xs``
  create a dict or hdict from list ``xs`` of key-value pairs in the form
  ``key=>value``

``dictp d``, ``hdictp d``
  check whether ``x`` is a dict or hdict

``mkdict y xs``, ``mkhdict y xs``
  create dict or hdict from a list of keys and a constant value

``#d``
  size of dict or hdict ``d``

``d!x``
  get value from ``d`` by key ``x``

``null d``
  test whether ``d`` is the empty dict or hdict

``member d x``
  test whether ``d`` contains a member with key ``x``

``members d``, ``list d``
  list members of ``d`` (in ascending order for dict)

``keys d``
  list keys of ``d`` (in ascending order for dict)

``values d``
  list values of ``d``

``first d``, ``last d``
  return first and last member of ``d``

``rmfirst d``, ``rmlast d``
  remove first and last member from ``d``

``insert d (x=>y)``, ``update d x y``
  insert ``x=>y`` into ``d`` (replace any existing element); ``update`` is
  a fully curried version of ``insert``

``delete d x``
  remove ``x`` from ``d``

Examples
~~~~~~~~

A normal (ordered) dictionary::

  > using dict;
  > let d = dict ["foo"=>77,"bar"=>99.1];
  > keys d; vals d; members d;
  ["bar","foo"]
  [99.1,77]
  ["bar"=>99.1,"foo"=>77]
  > d!"foo";
  77

A hashed dictionary can be used with any key values, which are stored in a
seemingly random order::

  > let h = hdict [foo=>77,42=>99.1];
  > keys h; vals h; members h;
  [42,foo]
  [99.1,77]
  [42=>99.1,foo=>77]
  > h!foo;
  77

..

Sets and Bags
-------------

The set.pure module implements Pure's set and bag (multiset) data types
based on AVL trees. Set and bag elements must be ordered, i.e., the
predicates ``==``, ``<`` and ``>`` must be defined on them. The used AVL
tree algorithm has its origin in the SWI-Prolog implementation of
association lists, see Dictionaries_ for details.

..

Imports
~~~~~~~

To use the operations of this module, add the following import declaration
to your program::

  using set;

Data Structure
~~~~~~~~~~~~~~

A tree for ``set`` and ``bag`` takes the form ``Set T`` or ``Bag T`` where
``T`` is either:

``nil``
  the empty tree; or

``bin key balance left right``
  a nonempty tree with given ``key`` (set element) in the root node, where
  ``left`` and ``right`` are the left and right subtree, and ``balance`` is
  either 1, 0 or -1, denoting ``|left|-|right|`` = 1, 0, or -1,
  respectively.

The tree constructors are private.

Operations
~~~~~~~~~~

.. raw:: html

   <a name="set">

.. raw:: html

   <a name="bag">

.. _set:
.. _bag:

``emptyset``, ``emptybag``
  return the empty set or bag
``set xs``, ``bag xs``
  create a set or bag from a list ``xs``
``setp x``, ``bagp x``
  check whether ``x`` is a set or bag

``#m``
  size of set or bag ``m``

``null m``
  test whether ``m`` is the empty set or bag
``member m x``
  test whether ``m`` contains ``x``
``members m``, ``list m``
  list members of ``m`` in ascending order

``first m``, ``last m``
  return first and last member of ``m``
``rmfirst m``, ``rmlast m``
  remove first and last member from ``m``
``insert m x``
  insert ``x`` into ``m`` (replaces an existing element in the ``set`` case)
``delete m x``
  remove ``x`` from ``m`` (in the ``bag`` case, only a single instance of
  ``x`` is removed)

Examples
~~~~~~~~

::

  > let m = set [5,1,3,11,3];
  > members m;
  [1,3,5,11]
  > map (member m) (1..5);
  [1,0,1,0,1]
  > let m = bag [5,1,3,11,3];
  > members m;
  [1,3,3,5,11]
  > members $ delete m 3;
  [1,3,5,11]
  > members $ insert m 1;
  [1,1,3,3,5,11]

..

System Interface
================

This module offers some useful system routines, straight from the C
library, as well as some convenience functions for wrapping these up in
Pure. Even the "purest" program needs to do some basic I/O every once in a
while, and this module provides the necessary stuff to do just that. The
interface is rather minimalistic and preliminary right now, but will
probably grow over time.

TODO

.. 

Getopt
======

This is a quick-and-dirty replacement for the GNU getopt functions, ported
from the Q library.

Imports
-------

To use the operations of this module, add the following import declaration
to your program::

  using getopt;

Operations
----------

This module provides one operation: ``getopt opts args``

The ``getopt`` function takes two arguments: ``opts``, a list of option
descriptions in the format described below, and ``args``, a list of strings
containing the command line parameters to be parsed for options. The result
is a pair ``(opts_return,args_return)`` where ``opts_return`` is a list of
options and their values, and ``args_return`` is the list of remaining
(non-option) arguments. Options are parsed using the rules of GNU
getopt(1). If an invalid option is encountered (unrecognized option,
missing or extra argument, etc.), ``getopt`` throws the offending option
string as an exception.

The ``opts_return`` value is a list of "hash pairs" ``opt=>val`` where
``opt`` is the (long) option name (as given by the ``long_opt`` field given
in the ``opts`` argument, see below) and ``val`` is the corresponding value
(``()`` if none). Note that this format is ready to be passed to the dict_
or hdict_ function, cf. Dictionaries_, which makes it easy to retrieve
option values or check for the presence of options.

The ``opts`` argument of ``getopt`` must be a list of triples ``(long_opt,
short_opt, flag)``, where ``long_opt`` denotes the long option,
``short_opt`` the equivalent short option, and ``flag`` is one of the
symbolic integer values ``NOARG``, ``OPTARG`` and ``REQARG`` which
specifies whether the option has no argument, an optional argument or a
required argument, respectively. Either ``long_opt`` or ``short_opt``
should be a string value of the form ``"--abc"`` or ``"-x"``,
respectively. Note that since the ``long_opt`` value is always used to
denote the corresponding option in the ``opts_return`` list, you always
have to specify a sensible value for that field. If no separate long option
name is needed, you can specify the same value as in the ``short_opt``
field, or some other convenient value (e.g., an integer) which designates
the option. Conversely, to indicate that an option has no short option
equivalent, simply specify an empty option string for the ``short_opt``
field.

Examples
--------

::

  > let opts = [("--help", "-h", NOARG),       // no argument
  >             ("--version", "", NOARG),      // no short option
  >             ("--filename", "-f", REQARG),  // required argument
  >             ("--count", "-n", OPTARG)];    // optional argument
  > getopt opts ["foo", "-h", "--filename", "bar", "-n0", "baz"];
  ["--help"=>(),"--filename"=>"bar","--count"=>"0"],["foo","baz"]
  > catch invalid_option $ getopt opts ["-h","-v"];
  invalid_option "-v"
  > getopt opts [foo, "-h", bar];
  ["--help"=>()],[foo,bar]

As the last example shows, non-option arguments (as well as option values
specified as separate arguments) can actually be any values which are just
copied to the result lists as is.

.. This is the last module in the manual, so we include the index here.

Index
=====

* `!`_
* `!!`_
* `#`_
* `$`_
* `,`_
* `.`_
* `..`_
* `\:`_
* `all`_
* `any`_
* `arithmetic sequences`_
* `array`_
* `bad_list_value`_
* `bad_matrix_value`_
* `bad_tuple_value`_
* `bag`_
* `byte_cstring`_
* `byte_cstring_pointer`_
* `byte_string`_
* `byte_string_pointer`_
* `cat`_
* `catmap`_
* `character arithmetic`_
* `chars`_
* `chr`_
* `combinators`_
* `cst`_
* `cstring`_
* `cstring_dup`_
* `cstring_list`_
* `curry`_
* `curry3`_
* `cycle`_
* `cyclen`_
* `dict`_
* `do`_
* `dowith`_
* `dowith3`_
* `drop`_
* `dropwhile`_
* `eval`_
* `evalcmd`_
* `failed_cond`_
* `failed_match`_
* `false`_
* `filter`_
* `fix`_
* `flip`_
* `foldl`_
* `foldl1`_
* `foldr`_
* `foldr1`_
* `hdict`_
* `head`_
* `heap`_
* `id`_
* `index`_
* `init`_
* `iterate`_
* `join`_
* `last`_
* `lasterr`_
* `list`_
* `list concatenation`_
* `list indexing`_
* `list size`_
* `list slicing`_
* `lists`_
* `malloc_error`_
* `map`_
* `null`_
* `operators`_
* `ord`_
* `out_of_bounds`_
* `repeat`_
* `repeatn`_
* `reverse`_
* `scanl`_
* `scanl1`_
* `scanr`_
* `scanr1`_
* `set`_
* `split`_
* `stack_fault`_
* `str`_
* `strcat`_
* `stream`_
* `string`_
* `string concatenation`_
* `string from pointer`_
* `string index`_
* `string indexing`_
* `string list`_
* `string matrix`_
* `string null`_
* `string size`_
* `string slicing`_
* `string tuple`_
* `string_dup`_
* `string_list`_
* `substr`_
* `tail`_
* `take`_
* `takewhile`_
* `true`_
* `tuple`_
* `tuple indexing`_
* `tuple size`_
* `tuple slicing`_
* `tuples`_
* `uncurry`_
* `uncurry3`_
* `unzip`_
* `unzip3`_
* `void`_
* `while`_
* `zip`_
* `zip3`_
* `zipwith`_
* `zipwith3`_


