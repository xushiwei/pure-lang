<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.6: http://docutils.sourceforge.net/" />
<title>The Pure Manual</title>
<meta name="author" content="Albert Gräf &lt;Dr.Graef&#64;t-online.de&gt;" />
<meta name="date" content="2009-08-01" />
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 5631 2008-08-24 13:01:23Z goodger $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="the-pure-manual">
<h1 class="title">The Pure Manual</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Albert Gräf &lt;<a class="reference external" href="mailto:Dr.Graef&#64;t-online.de">Dr.Graef&#64;t-online.de</a>&gt;</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>2009-08-01</td></tr>
</tbody>
</table>
<!-- Note: This document is formatted using docutils. The Makefile has rules -->
<!-- to build the documentation in html and pdf format. The latter needs TeX -->
<!-- and relies on the preamble.tex file to adjust the formatting. You might -->
<!-- have to edit preamble.tex to make this work with your local TeX -->
<!-- installation. -->
<!-- Teach TeX how to hyphenate 'namespace'. -->
<p>Copyright (c) 2009 by Albert Gräf. This document is available under the
<a class="reference external" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License</a>. Also see the <a class="reference internal" href="#copying">Copying</a> section for licensing information of the
software.</p>
<p>This manual describes the Pure programming language and how to invoke the Pure
interpreter program. To read the manual inside the interpreter, just type
<tt class="docutils literal"><span class="pre">help</span></tt> at the command prompt. See the <a class="reference internal" href="#online-help">Online Help</a> section for details.</p>
<p>There is a companion to this manual, the <a class="reference external" href="purelib.html">Pure Library Manual</a> which contains
the description of the standard library operations. More information about
Pure can be found under the following URLs:</p>
<ul class="simple">
<li>Pure website: <a class="reference external" href="http://pure-lang.googlecode.com">http://pure-lang.googlecode.com</a></li>
<li>Pure mailing list: <a class="reference external" href="http://groups.google.com/group/pure-lang">http://groups.google.com/group/pure-lang</a></li>
</ul>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#introduction" id="id3">1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference internal" href="#invoking-the-pure-interpreter" id="id4">2&nbsp;&nbsp;&nbsp;Invoking the Pure Interpreter</a><ul class="auto-toc">
<li><a class="reference internal" href="#options" id="id5">2.1&nbsp;&nbsp;&nbsp;Options</a></li>
<li><a class="reference internal" href="#overview-of-operation" id="id6">2.2&nbsp;&nbsp;&nbsp;Overview of Operation</a></li>
<li><a class="reference internal" href="#compiling-scripts" id="id7">2.3&nbsp;&nbsp;&nbsp;Compiling Scripts</a></li>
<li><a class="reference internal" href="#running-interactively" id="id8">2.4&nbsp;&nbsp;&nbsp;Running Interactively</a></li>
<li><a class="reference internal" href="#verbosity-and-debugging-options" id="id9">2.5&nbsp;&nbsp;&nbsp;Verbosity and Debugging Options</a></li>
<li><a class="reference internal" href="#startup-files" id="id10">2.6&nbsp;&nbsp;&nbsp;Startup Files</a></li>
<li><a class="reference internal" href="#environment" id="id11">2.7&nbsp;&nbsp;&nbsp;Environment</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pure-overview" id="id12">3&nbsp;&nbsp;&nbsp;Pure Overview</a><ul class="auto-toc">
<li><a class="reference internal" href="#lexical-matters" id="id13">3.1&nbsp;&nbsp;&nbsp;Lexical Matters</a></li>
<li><a class="reference internal" href="#definitions-and-expression-evaluation" id="id14">3.2&nbsp;&nbsp;&nbsp;Definitions and Expression Evaluation</a></li>
<li><a class="reference internal" href="#parameters-in-equations" id="id15">3.3&nbsp;&nbsp;&nbsp;Parameters in Equations</a></li>
<li><a class="reference internal" href="#expression-syntax" id="id16">3.4&nbsp;&nbsp;&nbsp;Expression Syntax</a></li>
<li><a class="reference internal" href="#operators-and-precedence" id="id17">3.5&nbsp;&nbsp;&nbsp;Operators and Precedence</a></li>
<li><a class="reference internal" href="#special-forms" id="id18">3.6&nbsp;&nbsp;&nbsp;Special Forms</a></li>
<li><a class="reference internal" href="#toplevel" id="id19">3.7&nbsp;&nbsp;&nbsp;Toplevel</a></li>
<li><a class="reference internal" href="#scoping-rules" id="id20">3.8&nbsp;&nbsp;&nbsp;Scoping Rules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rule-syntax" id="id21">4&nbsp;&nbsp;&nbsp;Rule Syntax</a><ul class="auto-toc">
<li><a class="reference internal" href="#patterns" id="id22">4.1&nbsp;&nbsp;&nbsp;Patterns</a></li>
<li><a class="reference internal" href="#general-rules" id="id23">4.2&nbsp;&nbsp;&nbsp;General Rules</a></li>
<li><a class="reference internal" href="#simple-rules" id="id24">4.3&nbsp;&nbsp;&nbsp;Simple Rules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples" id="id25">5&nbsp;&nbsp;&nbsp;Examples</a><ul class="auto-toc">
<li><a class="reference internal" href="#list-comprehensions" id="id26">5.1&nbsp;&nbsp;&nbsp;List Comprehensions</a></li>
<li><a class="reference internal" href="#lazy-evaluation-and-streams" id="id27">5.2&nbsp;&nbsp;&nbsp;Lazy Evaluation and Streams</a></li>
<li><a class="reference internal" href="#matrix-computations" id="id28">5.3&nbsp;&nbsp;&nbsp;Matrix Computations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#macros" id="id29">6&nbsp;&nbsp;&nbsp;Macros</a><ul class="auto-toc">
<li><a class="reference internal" href="#optimization-rules" id="id30">6.1&nbsp;&nbsp;&nbsp;Optimization Rules</a></li>
<li><a class="reference internal" href="#recursive-macros" id="id31">6.2&nbsp;&nbsp;&nbsp;Recursive Macros</a></li>
<li><a class="reference internal" href="#user-defined-special-forms" id="id32">6.3&nbsp;&nbsp;&nbsp;User-Defined Special Forms</a></li>
<li><a class="reference internal" href="#macro-hygiene" id="id33">6.4&nbsp;&nbsp;&nbsp;Macro Hygiene</a></li>
</ul>
</li>
<li><a class="reference internal" href="#declarations" id="id34">7&nbsp;&nbsp;&nbsp;Declarations</a><ul class="auto-toc">
<li><a class="reference internal" href="#symbol-declarations" id="id35">7.1&nbsp;&nbsp;&nbsp;Symbol Declarations</a></li>
<li><a class="reference internal" href="#modules-and-imports" id="id36">7.2&nbsp;&nbsp;&nbsp;Modules and Imports</a></li>
<li><a class="reference internal" href="#namespaces" id="id37">7.3&nbsp;&nbsp;&nbsp;Namespaces</a></li>
<li><a class="reference internal" href="#using-namespaces" id="id38">7.4&nbsp;&nbsp;&nbsp;Using Namespaces</a></li>
<li><a class="reference internal" href="#private-symbols" id="id39">7.5&nbsp;&nbsp;&nbsp;Private Symbols</a></li>
<li><a class="reference internal" href="#hierarchical-namespaces" id="id40">7.6&nbsp;&nbsp;&nbsp;Hierarchical Namespaces</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exception-handling" id="id41">8&nbsp;&nbsp;&nbsp;Exception Handling</a></li>
<li><a class="reference internal" href="#c-interface" id="id42">9&nbsp;&nbsp;&nbsp;C Interface</a></li>
<li><a class="reference internal" href="#standard-library" id="id43">10&nbsp;&nbsp;&nbsp;Standard Library</a></li>
<li><a class="reference internal" href="#interactive-usage" id="id44">11&nbsp;&nbsp;&nbsp;Interactive Usage</a><ul class="auto-toc">
<li><a class="reference internal" href="#online-help" id="id45">11.1&nbsp;&nbsp;&nbsp;Online Help</a></li>
<li><a class="reference internal" href="#interactive-commands" id="id46">11.2&nbsp;&nbsp;&nbsp;Interactive Commands</a></li>
<li><a class="reference internal" href="#last-result" id="id47">11.3&nbsp;&nbsp;&nbsp;Last Result</a></li>
<li><a class="reference internal" href="#specifying-symbol-selections" id="id48">11.4&nbsp;&nbsp;&nbsp;Specifying Symbol Selections</a></li>
<li><a class="reference internal" href="#the-show-command" id="id49">11.5&nbsp;&nbsp;&nbsp;The show Command</a></li>
<li><a class="reference internal" href="#definition-levels" id="id50">11.6&nbsp;&nbsp;&nbsp;Definition Levels</a></li>
<li><a class="reference internal" href="#debugging" id="id51">11.7&nbsp;&nbsp;&nbsp;Debugging</a></li>
<li><a class="reference internal" href="#interactive-startup" id="id52">11.8&nbsp;&nbsp;&nbsp;Interactive Startup</a></li>
</ul>
</li>
<li><a class="reference internal" href="#caveats-and-notes" id="id53">12&nbsp;&nbsp;&nbsp;Caveats and Notes</a><ul class="auto-toc">
<li><a class="reference internal" href="#purity" id="id54">12.1&nbsp;&nbsp;&nbsp;Purity</a></li>
<li><a class="reference internal" href="#backward-compatibility" id="id55">12.2&nbsp;&nbsp;&nbsp;Backward Compatibility</a></li>
<li><a class="reference internal" href="#error-recovery" id="id56">12.3&nbsp;&nbsp;&nbsp;Error Recovery</a></li>
<li><a class="reference internal" href="#batch-compilation" id="id57">12.4&nbsp;&nbsp;&nbsp;Batch Compilation</a></li>
<li><a class="reference internal" href="#the-show-function" id="id58">12.5&nbsp;&nbsp;&nbsp;The __show__ Function</a></li>
<li><a class="reference internal" href="#as-patterns" id="id59">12.6&nbsp;&nbsp;&nbsp;&quot;As&quot; Patterns</a></li>
<li><a class="reference internal" href="#head-function" id="id60">12.7&nbsp;&nbsp;&nbsp;Head = Function</a></li>
<li><a class="reference internal" href="#namespaces-and-implicit-declarations" id="id61">12.8&nbsp;&nbsp;&nbsp;Namespaces and Implicit Declarations</a></li>
<li><a class="reference internal" href="#with-or-when" id="id62">12.9&nbsp;&nbsp;&nbsp;With or when?</a></li>
<li><a class="reference internal" href="#numeric-calculations" id="id63">12.10&nbsp;&nbsp;&nbsp;Numeric Calculations</a></li>
<li><a class="reference internal" href="#constant-definitions" id="id64">12.11&nbsp;&nbsp;&nbsp;Constant Definitions</a></li>
<li><a class="reference internal" href="#external-c-functions" id="id65">12.12&nbsp;&nbsp;&nbsp;External C Functions</a></li>
<li><a class="reference internal" href="#id2" id="id66">12.13&nbsp;&nbsp;&nbsp;Special Forms</a></li>
<li><a class="reference internal" href="#the-quote" id="id67">12.14&nbsp;&nbsp;&nbsp;The Quote</a></li>
<li><a class="reference internal" href="#laziness" id="id68">12.15&nbsp;&nbsp;&nbsp;Laziness</a></li>
<li><a class="reference internal" href="#reflection" id="id69">12.16&nbsp;&nbsp;&nbsp;Reflection</a></li>
<li><a class="reference internal" href="#hygienic-macros" id="id70">12.17&nbsp;&nbsp;&nbsp;Hygienic Macros</a></li>
<li><a class="reference internal" href="#stack-size-and-tail-recursion" id="id71">12.18&nbsp;&nbsp;&nbsp;Stack Size and Tail Recursion</a></li>
<li><a class="reference internal" href="#handling-of-asynchronous-signals" id="id72">12.19&nbsp;&nbsp;&nbsp;Handling of Asynchronous Signals</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copying" id="id73">13&nbsp;&nbsp;&nbsp;Copying</a></li>
<li><a class="reference internal" href="#author" id="id74">14&nbsp;&nbsp;&nbsp;Author</a></li>
<li><a class="reference internal" href="#see-also" id="id75">15&nbsp;&nbsp;&nbsp;See Also</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id3">1&nbsp;&nbsp;&nbsp;Introduction</a></h1>
<p>Pure is a modern-style functional programming language based on term
rewriting. Pure programs are basically collections of equational rules used to
evaluate expressions in a symbolic fashion by reducing them to normal form. An
overview of the language can be found in the <a class="reference internal" href="#pure-overview">Pure Overview</a> section below,
and subsequent sections discuss most language features in detail.</p>
<p>The Pure interpreter has an <a class="reference internal" href="#llvm">LLVM</a> backend which JIT-compiles Pure programs to
machine code, hence programs run blazingly fast and interfacing to C modules
is easy, while the interpreter still provides a convenient, fully interactive
environment for running Pure scripts and evaluating expressions. You can also
compile your scripts to standalone executables if you prefer that.</p>
<p>Pure programs (a.k.a. scripts) are just ordinary text files containing Pure
code. They must be encoded in UTF-8 (which subsumes 7 bit ASCII), other
encodings such as Latin-1 are not supported. A bunch of syntax highlighting
files and programming modes for various popular text editors are included in
the Pure sources. There's no difference between the Pure programming language
and the input language accepted by the interpreter, except that the
interpreter also understands some special commands when running in interactive
mode; see the <a class="reference internal" href="#interactive-usage">Interactive Usage</a> section for details.</p>
<p>(In case you're wondering, the name &quot;Pure&quot; actually refers to the
adjective. But you can also write it as &quot;PURE&quot; and take this as a recursive
acronym for the &quot;Pure Universal Rewriting Engine&quot;.)</p>
</div>
<div class="section" id="invoking-the-pure-interpreter">
<h1><a class="toc-backref" href="#id4">2&nbsp;&nbsp;&nbsp;Invoking the Pure Interpreter</a></h1>
<p>The Pure interpreter is invoked as follows:</p>
<pre class="literal-block">
pure [options ...] [script ...] [-- args ...]
pure [options ...] -x script [args ...]
</pre>
<div class="section" id="options">
<h2><a class="toc-backref" href="#id5">2.1&nbsp;&nbsp;&nbsp;Options</a></h2>
<p>The interpreter accepts various options which are described in more detail
below:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">-c</span></tt></dt>
<dd>Batch compilation.</dd>
<dt><tt class="docutils literal"><span class="pre">-g</span></tt></dt>
<dd>Enable symbolic debugging.</dd>
<dt><tt class="docutils literal"><span class="pre">--help</span></tt>, <tt class="docutils literal"><span class="pre">-h</span></tt></dt>
<dd>Print help message and exit.</dd>
<dt><tt class="docutils literal"><span class="pre">-i</span></tt></dt>
<dd>Force interactive mode (read commands from stdin).</dd>
<dt><tt class="docutils literal"><span class="pre">-I</span> <span class="pre">directory</span></tt></dt>
<dd>Add a directory to be searched for included source scripts.</dd>
<dt><tt class="docutils literal"><span class="pre">-L</span> <span class="pre">directory</span></tt></dt>
<dd>Add a directory to be searched for dynamic libraries.</dd>
<dt><tt class="docutils literal"><span class="pre">-l</span> <span class="pre">libname</span></tt></dt>
<dd>Library to be linked in batch compilation.</dd>
<dt><tt class="docutils literal"><span class="pre">--noediting</span></tt></dt>
<dd>Do not use readline for command-line editing.</dd>
<dt><tt class="docutils literal"><span class="pre">--noprelude</span></tt>, <tt class="docutils literal"><span class="pre">-n</span></tt></dt>
<dd>Do not load the prelude.</dd>
<dt><tt class="docutils literal"><span class="pre">--norc</span></tt></dt>
<dd>Do not run the interactive startup files.</dd>
<dt><tt class="docutils literal"><span class="pre">-o</span> <span class="pre">filename</span></tt></dt>
<dd>Output filename for batch compilation.</dd>
<dt><tt class="docutils literal"><span class="pre">-q</span></tt></dt>
<dd>Quiet startup (suppresses sign-on message in interactive mode).</dd>
<dt><tt class="docutils literal"><span class="pre">-v[level]</span></tt></dt>
<dd>Set verbosity level. See below for details.</dd>
<dt><tt class="docutils literal"><span class="pre">--version</span></tt></dt>
<dd>Print version information and exit.</dd>
<dt><tt class="docutils literal"><span class="pre">-x</span></tt></dt>
<dd>Execute script with given command line arguments.</dd>
<dt><tt class="docutils literal"><span class="pre">--</span></tt></dt>
<dd>Stop option processing and pass the remaining command line arguments in
the <tt class="docutils literal"><span class="pre">argv</span></tt> variable.</dd>
</dl>
</div>
<div class="section" id="overview-of-operation">
<h2><a class="toc-backref" href="#id6">2.2&nbsp;&nbsp;&nbsp;Overview of Operation</a></h2>
<p>If any source scripts are specified on the command line, they are loaded and
executed, after which the interpreter exits. Otherwise the interpreter enters
the interactive read-eval-print loop, see <a class="reference internal" href="#running-interactively">Running Interactively</a> below. You
can also use the -i option to enter the interactive loop (continue reading
from stdin) even after processing some source scripts.</p>
<p>Options and source files are processed in the order in which they are given on
the command line. Processing of options and source files ends when either the
-- or the -x option is encountered. The -x option must be followed by the name
of a script to be executed, which becomes the &quot;main script&quot; of the
application. In either case, any remaining parameters are passed to the
executing script by means of the global <tt class="docutils literal"><span class="pre">argc</span></tt> and <tt class="docutils literal"><span class="pre">argv</span></tt> variables,
denoting the number of arguments and the list of the actual parameter strings,
respectively. In the case of -x this also includes the script name as
<tt class="docutils literal"><span class="pre">argv!0</span></tt>. The -x option is useful, in particular, to turn Pure scripts into
executable programs by including a &quot;shebang&quot; like the following as the first
line in your main script. (This trick only works with Unix shells, though.)</p>
<pre class="literal-block">
#!/usr/local/bin/pure -x
</pre>
<p>On startup, the interpreter also defines the <tt class="docutils literal"><span class="pre">version</span></tt> variable, which is
set to the version string of the Pure interpreter, and the <tt class="docutils literal"><span class="pre">sysinfo</span></tt>
variable, which provides a string identifying the host system. These are
useful if parts of your script depend on the particular version of the
interpreter and the system it runs on. (Moreover, Pure 0.21 and later also
define the variable <tt class="docutils literal"><span class="pre">compiling</span></tt> which indicates whether the program is
executed in a batch compilation, see below.)</p>
<p>If available, the prelude script prelude.pure is loaded by the interpreter
prior to any other definitions, unless the -n or --noprelude option is
specified. The prelude is searched for in the directory specified with the
PURELIB environment variable. If the PURELIB variable is not set, a
system-specific default is used. Relative pathnames of other source scripts
specified on the command line are interpreted relative to the current working
directory. In addition, the executed program may load other scripts and
libraries via a <tt class="docutils literal"><span class="pre">using</span></tt> declaration in the source, which are searched for in
a number of locations, including the directories named with the -I and -L
options; see the <a class="reference internal" href="#declarations">Declarations</a> and <a class="reference internal" href="#c-interface">C Interface</a> sections for details.</p>
</div>
<div class="section" id="compiling-scripts">
<h2><a class="toc-backref" href="#id7">2.3&nbsp;&nbsp;&nbsp;Compiling Scripts</a></h2>
<p>If the -c option is specified, it forces the interpreter to non-interactive
mode (unless -i is specified as well, which overrides -c). Any scripts
specified on the command line are then executed as usual, but after execution
the interpreter takes a snapshot of the program and compiles it to either an
LLVM assembler (.ll) file, a native object (.o) file, or a native executable,
depending on the output filename specified with -o. If the output filename
ends in the .ll extension, an LLVM assembler file is created which can then be
processed with the LLVM toolchain (llvmc, llvm-gcc, etc.). If the output
filename is just '-', the assembler file is written to standard output, which
is useful if you want to pass the generated code to the LLVM tools in a
pipeline. Otherwise the interpreter automatically invokes llvmc to compile the
program to either a native object file (if the output filename ends in the .o
extension) or a native executable with the given name. You can also specify
additional libraries to be linked into the executable with the -l option, and
pass extra options to llvmc with the PURE_COPTS environment variable. If the
output filename is omitted, it defaults to <tt class="docutils literal"><span class="pre">a.out</span></tt> (<tt class="docutils literal"><span class="pre">a.exe</span></tt> on Windows).</p>
<p>The -c option provides a convenient way to quickly turn a Pure script into a
standalone executable which can be invoked directly from the shell. One
advantage of compiling your script is that this eliminates the JIT compilation
time and thus considerably reduces the startup time of the program. Another
reason to prefer a standalone executable is that it lets you deploy the
program on systems without a full Pure installation (usually only the runtime
library is required on the target system). On the other hand, compiled scripts
also have some limitations, mostly concerning the use of the built-in <tt class="docutils literal"><span class="pre">eval</span></tt>
function. Please see <a class="reference internal" href="#batch-compilation">Batch Compilation</a> in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section
for details.</p>
<p>The -v64 (or -v0100) verbosity option can be used to have the interpreter
print the commands it executes during compilation, see <a class="reference internal" href="#verbosity-and-debugging-options">Verbosity and
Debugging Options</a> below. When creating an object file, this also prints the
suggested linker command (including all the dynamic modules loaded by the
script, which also have to be linked in to create a working executable), to
which you only have to add the options describing the desired output file.</p>
</div>
<div class="section" id="running-interactively">
<h2><a class="toc-backref" href="#id8">2.4&nbsp;&nbsp;&nbsp;Running Interactively</a></h2>
<p>If the interpreter runs in interactive mode, it repeatedly prompts you for
input (which may be any legal Pure code or some special interpreter commands
provided for interactive usage), and prints computed results. This is also
known as the <strong class="dfn">read-eval-print</strong> loop and is described in much more detail in
the <a class="reference internal" href="#interactive-usage">Interactive Usage</a> section. To exit the interpreter, just type the
<tt class="docutils literal"><span class="pre">quit</span></tt> command or the end-of-file character (<tt class="docutils literal"><span class="pre">^D</span></tt> on Unix) at the
beginning of the command line.</p>
<p>The interpreter may also source a few additional interactive startup files
immediately before entering the interactive loop, unless the --norc option is
specified. First .purerc in the user's home directory is read, then .purerc in
the current working directory. These are ordinary Pure scripts which can be
used to provide additional definitions for interactive usage. Finally, a .pure
file in the current directory (containing a dump from a previous interactive
session) is loaded if it is present.</p>
<p>When the interpreter is in interactive mode and reads from a tty, unless the
--noediting option is specified, commands are read using readline(3)
(providing completion for all commands listed under <a class="reference internal" href="#interactive-usage">Interactive Usage</a>, as
well as for symbols defined in the running program). When exiting the
interpreter, the command history is stored in ~/.pure_history, from where it
is restored the next time you run the interpreter.</p>
<p>As of Pure 0.22, the interpreter also provides a simple source level debugger
when run in interactive mode, see <a class="reference internal" href="#debugging">Debugging</a> for details. To enable the
interactive debugger, you need to specify the -g option when invoking the
interpreter. This option causes your script to run <em>much</em> slower and also
disables tail call optimization, so you should only use this option if you
want to run the debugger.</p>
</div>
<div class="section" id="verbosity-and-debugging-options">
<h2><a class="toc-backref" href="#id9">2.5&nbsp;&nbsp;&nbsp;Verbosity and Debugging Options</a></h2>
<p>The -v option is most useful for debugging the interpreter, or if you are
interested in the code your program gets compiled to. The level argument is
optional; it defaults to 1. Seven different levels are implemented at this
time (one more bit is reserved for future extensions). For most purposes, only
the first two levels will be useful for the average Pure programmer; the
remaining levels are most likely to be used by the Pure interpreter
developers.</p>
<dl class="docutils">
<dt>1 (0x1, 001)</dt>
<dd>denotes echoing of parsed definitions and expressions.</dd>
<dt>2 (0x2, 002)</dt>
<dd>adds special annotations concerning local bindings (de Bruijn indices,
subterm paths; this can be helpful to debug tricky variable binding
issues).</dd>
<dt>4 (0x4, 004)</dt>
<dd>adds descriptions of the matching automata for the left-hand sides of
equations (you probably want to see this only when working on the guts of
the interpreter).</dd>
<dt>8 (0x8, 010)</dt>
<dd>dumps the &quot;real&quot; output code (LLVM assembler, which is as close to the
native machine code for your program as it gets; you definitely don't want
to see this unless you have to inspect the generated code for bugs or
performance issues).</dd>
<dt>16 (0x10, 020)</dt>
<dd>adds debugging messages from the bison(1) parser; useful for debugging the
parser.</dd>
<dt>32 (0x20, 040)</dt>
<dd>adds debugging messages from the flex(1) lexer; useful for debugging the
lexer.</dd>
<dt>64 (0x40, 0100)</dt>
<dd>turns on verbose batch compilation; this is useful if you want to see
exactly which commands get executed during batch compilation (-c).</dd>
</dl>
<p>These values can be or'ed together, and, for convenience, can be specified in
either decimal, hexadecimal or octal. Thus 0xff or 0777 always gives you full
debugging output (which isn't likely to be used by anyone but the Pure
developers). Some useful flag combinations for experts are (in octal) 007
(echo definitions along with de Bruijn indices and matching automata), 011
(definitions and assembler code) and 021 (parser debugging output along with
parsed definitions).</p>
<p>Note that the -v option is only applied after the prelude has been loaded. If
you want to debug the prelude, use the -n option and specify the prelude.pure
file explicitly on the command line. Verbose output is also suppressed for
modules imported through a <tt class="docutils literal"><span class="pre">using</span></tt> clause. As a remedy, you can use the
interactive <tt class="docutils literal"><span class="pre">show</span></tt> command (see the <a class="reference internal" href="#interactive-usage">Interactive Usage</a> section) to list
definitions along with additional debugging information.</p>
</div>
<div class="section" id="startup-files">
<h2><a class="toc-backref" href="#id10">2.6&nbsp;&nbsp;&nbsp;Startup Files</a></h2>
<p>The interpreter may source various files during its startup. These are:</p>
<dl class="docutils">
<dt>~/.pure_history</dt>
<dd>Interactive command history.</dd>
<dt>~/.purerc, .purerc, .pure</dt>
<dd>Interactive startup files. The latter is usually a dump from a previous
interactive session.</dd>
<dt>prelude.pure</dt>
<dd>Standard prelude. If available, this script is loaded before any other
definitions, unless -n was specified.</dd>
</dl>
</div>
<div class="section" id="environment">
<h2><a class="toc-backref" href="#id11">2.7&nbsp;&nbsp;&nbsp;Environment</a></h2>
<p>Various aspects of the interpreter can be configured through the following
shell environment variables:</p>
<dl class="docutils">
<dt>BROWSER</dt>
<dd>If the PURE_HELP variable is not set (see below), this specifies a
colon-separated list of browsers to try for reading the online
documentation. See <a class="reference external" href="http://www.catb.org/~esr/BROWSER/">http://www.catb.org/~esr/BROWSER/</a>.</dd>
<dt>PURELIB</dt>
<dd>Directory to search for library scripts, including the prelude. If PURELIB
is not set, it defaults to some default location specified at installation
time.</dd>
<dt>PURE_COPTS</dt>
<dd>Extra options to be passed to llvmc in a batch compilation (-c).</dd>
<dt>PURE_HELP</dt>
<dd>Command used to browse the Pure manual. This must be a browser capable of
displaying html files. Default is w3m(1).</dd>
<dt>PURE_INCLUDE</dt>
<dd>Additional directories (in colon-separated format) to be searched for
included scripts.</dd>
<dt>PURE_LIBRARY</dt>
<dd>Additional directories (in colon-separated format) to be searched for
dynamic libraries.</dd>
<dt>PURE_MORE</dt>
<dd>Shell command to be used for paging through output of the show command,
when the interpreter runs in interactive mode.</dd>
<dt>PURE_PS</dt>
<dd>Command prompt used in the interactive command loop (&quot;&gt; &quot; by default).</dd>
<dt>PURE_STACK</dt>
<dd>Maximum stack size in kilobytes (default: 0 = unlimited).</dd>
</dl>
</div>
</div>
<div class="section" id="pure-overview">
<h1><a class="toc-backref" href="#id12">3&nbsp;&nbsp;&nbsp;Pure Overview</a></h1>
<p>Pure is a fairly simple yet powerful language. Programs are basically
collections of rewriting rules and expressions to be evaluated. For
convenience, it is also possible to define global variables and constants, and
for advanced uses Pure offers macro functions as a kind of preprocessing
facility. These are all described below and in the following sections.</p>
<p>Here's a first example which demonstrates how to define a simple recursive
function in Pure, entered interactively in the interpreter (note that the
'<tt class="docutils literal"><span class="pre">&gt;</span></tt>' symbol at the beginning of each input line is the interpreter's
default command prompt):</p>
<pre class="literal-block">
&gt; // my first Pure example
&gt; fact 0 = 1;
&gt; fact n::int = n*fact (n-1) if n&gt;0;
&gt; let x = fact 10; x;
3628800
</pre>
<div class="section" id="lexical-matters">
<h2><a class="toc-backref" href="#id13">3.1&nbsp;&nbsp;&nbsp;Lexical Matters</a></h2>
<p>Pure is a free-format language; whitespace is insignificant, except if it
serves to delimit other symbols. Hence, as shown above, definitions and
expressions at the toplevel have to be terminated with a semicolon, even in
interactive mode.</p>
<p>Comments have the same syntax as in C++ (using <tt class="docutils literal"><span class="pre">//</span></tt> for line-oriented and
<tt class="docutils literal"><span class="pre">/*</span> <span class="pre">...</span> <span class="pre">*/</span></tt> for multiline comments; the latter may not be nested). Lines
beginning with <tt class="docutils literal"><span class="pre">#!</span></tt> are treated as comments, too; as already discussed
above, on Unix-like systems this allows you to add a &quot;shebang&quot; to your main
script in order to turn it into an executable program.</p>
<p>There are a few reserved keywords which cannot be used as identifiers:</p>
<pre class="literal-block">
case const def else end extern if infix infixl infixr let namespace
nonfix of otherwise outfix postfix prefix private public then using
when with
</pre>
<p>The customary notations for identifiers, numbers and strings are all
provided. In addition, Pure also allows you to define your own operator
symbols. Pure fully supports Unicode, so that you can write your programs in
almost any language and make good use of the special symbols in the Unicode
character set, provided that you encode your scripts in UTF-8. To keep this
simple, besides the ASCII punctuation characters, Pure also considers the
following code points in the Unicode repertoire as punctuation: U+00A1 through
U+00BF, U+00D7, U+00F7, and U+20D0 through through U+2BFF. This comprises the
special symbols in the Latin-1 repertoire, as well as the Combining
Diacritical Marks for Symbols, Letterlike Symbols, Number Forms, Arrows,
Mathematical Symbols, Miscellaneous Technical Symbols, Control Pictures, OCR,
Enclosed Alphanumerics, Box Drawing, Blocks, Geometric Shapes, Miscellaneous
Symbols, Dingbats, Miscellaneous Mathematical Symbols A, Supplemental Arrows
A, Supplemental Arrows B, Miscellaneous Mathematical Symbols B, Supplemental
Mathematical Operators, and Miscellaneous Symbols and Arrows. This should
cover almost everything you'd ever want to use in an operator symbol. All
other extended Unicode characters are effectively treated as &quot;letters&quot; which
can be used as identifier constituents.</p>
</div>
<div class="section" id="definitions-and-expression-evaluation">
<h2><a class="toc-backref" href="#id14">3.2&nbsp;&nbsp;&nbsp;Definitions and Expression Evaluation</a></h2>
<p>On the surface, Pure is quite similar to other modern functional languages
like <a class="reference internal" href="#haskell">Haskell</a> and <a class="reference internal" href="#ml">ML</a>. But under the hood it is a much more dynamic language,
more akin to Lisp. In particular, Pure is dynamically typed, so functions can
be fully polymorphic and you can add to the definition of an existing function
at any time. For instance, we can extend the example above to make the
<tt class="docutils literal"><span class="pre">fact</span></tt> function work with floating point numbers, too:</p>
<pre class="literal-block">
&gt; fact 0.0 = 1.0;
&gt; fact n::double = n*fact (n-1) if n&gt;0;
&gt; fact 10.0;
3628800.0
&gt; fact 10;
3628800
</pre>
<p>Expressions are generally evaluated from left to right, innermost expressions
first, i.e., using call by value semantics. Pure also has a few built-in
special forms (most notably, conditional expressions, the short-circuit
logical connectives <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt> and <tt class="docutils literal"><span class="pre">||</span></tt>, the sequencing operator <tt class="docutils literal"><span class="pre">$$</span></tt>, the
lazy evaluation operator <tt class="docutils literal"><span class="pre">&amp;</span></tt>, and the <tt class="docutils literal"><span class="pre">quote</span></tt>) which take some or all of
their arguments unevaluated, using call by name. (User-defined special forms
can be created with macros. More about that later.)</p>
<p>Like in Haskell and ML, functions are often defined by pattern-matching, i.e.,
the left-hand side of a definition is compared to the target expression,
binding the variables in the pattern to their actual values accordingly:</p>
<pre class="literal-block">
&gt; foo (bar x) = x-1;
&gt; foo (bar 99);
98
</pre>
<p>Due to its term rewriting semantics, Pure goes beyond most other functional
languages in that it can do symbolic evaluations just as well as &quot;normal&quot;
computations:</p>
<pre class="literal-block">
&gt; square x = x*x;
&gt; square 4;
16
&gt; square (a+b);
(a+b)*(a+b)
</pre>
<p>Leaving aside the built-in support for some common data structures such as
numbers and strings, all the Pure interpreter really does is evaluating
expressions in a symbolic fashion, rewriting expressions using the equations
supplied by the programmer, until no more equations are applicable. The result
of this process is called a <strong class="dfn">normal form</strong> which represents the &quot;value&quot; of the
original expression. Keeping with the tradition of term rewriting, there's no
distinction between &quot;defined&quot; and &quot;constructor&quot; function symbols in Pure; that
is, Pure does <em>not</em> enforce the so-called &quot;constructor discipline&quot; which
stipulates that only pure constructor symbols (without any defining equations)
may occur as a subterm on the left-hand side of an equation. In Pure, any
function symbol (or operator) also acts as a constructor if it happens to
occur in a normal form term. This enables you to apply algebraic rules
violating the constructor discipline, like the following:</p>
<pre class="literal-block">
&gt; (x+y)*z = x*z+y*z; x*(y+z) = x*y+x*z;
&gt; x*(y*z) = (x*y)*z; x+(y+z) = (x+y)+z;
&gt; square (a+b);
a*a+a*b+b*a+b*b
</pre>
</div>
<div class="section" id="parameters-in-equations">
<h2><a class="toc-backref" href="#id15">3.3&nbsp;&nbsp;&nbsp;Parameters in Equations</a></h2>
<p>Taking a look at the above examples, you might have been wondering how the
Pure interpreter figures out what the parameters (a.k.a. &quot;variables&quot;) in an
equation are. This is quite obvious in rules involving just variables and
special operator symbols, such as <tt class="docutils literal"><span class="pre">(x+y)*z</span> <span class="pre">=</span> <span class="pre">x*z+y*z</span></tt>. However, what about
an equation like <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">(foo</span> <span class="pre">bar)</span> <span class="pre">=</span> <span class="pre">bar</span></tt>? Since most of the time we don't
declare any symbols in Pure, how does the interpreter know that <tt class="docutils literal"><span class="pre">foo</span></tt> is a
literal function symbol here, while <tt class="docutils literal"><span class="pre">bar</span></tt> is a variable?</p>
<p>The answer is that the interpreter considers the different positions in the
left-hand side expression of an equation. Basically, a Pure expression is just
a tree formed by applying expressions to other expressions, with the atomic
subexpressions like numbers and symbols at the leaves of the tree. (This is
even true for infix expressions like <tt class="docutils literal"><span class="pre">x+y</span></tt>, since in Pure these are always
equivalent to a function application of the form <tt class="docutils literal"><span class="pre">(+)</span> <span class="pre">x</span> <span class="pre">y</span></tt> which has the
atomic subterms <tt class="docutils literal"><span class="pre">(+)</span></tt>, <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> at its leaves.)</p>
<p>Now the interpreter divides the leaves of the expression tree into &quot;head&quot; (or
&quot;function&quot;) and &quot;parameter&quot; (or &quot;variable&quot;) positions based on which leaves
are leftmost in a function application or not. Thus, in an expression like <tt class="docutils literal"><span class="pre">f</span>
<span class="pre">x</span> <span class="pre">y</span> <span class="pre">z</span></tt>, <tt class="docutils literal"><span class="pre">f</span></tt> is in the head or function position, while <tt class="docutils literal"><span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">y</span></tt> and
<tt class="docutils literal"><span class="pre">z</span></tt> are in parameter or variable positions. (Note that in an infix
expression like <tt class="docutils literal"><span class="pre">x+y</span></tt>, <tt class="docutils literal"><span class="pre">(+)</span></tt> is the head symbol, not <tt class="docutils literal"><span class="pre">x</span></tt>, as the
expression is really parsed as <tt class="docutils literal"><span class="pre">(+)</span> <span class="pre">x</span> <span class="pre">y</span></tt>, see above.)</p>
<p>Identifiers in head positions are taken as literal function symbols by the
interpreter, while identifiers in variable positions denote, well,
variables. We also refer to this convention as the the <strong class="dfn">head = function
rule</strong>. It is quite intuitive and lets us get away without declaring the
variables in equations. (There are some corner cases not covered here,
however. In particular, Pure allows you to declare special constant symbols,
if you need a symbol to be recognized as a literal even if it occurs in a
variable position. This is done by means of a <tt class="docutils literal"><span class="pre">nonfix</span></tt> declaration, see
<a class="reference internal" href="#symbol-declarations">Symbol Declarations</a> for details.)</p>
</div>
<div class="section" id="expression-syntax">
<h2><a class="toc-backref" href="#id16">3.4&nbsp;&nbsp;&nbsp;Expression Syntax</a></h2>
<p>The Pure language provides built-in support for machine integers (32 bit),
bigints (implemented using <a class="reference internal" href="#gmp">GMP</a>), floating point values (double precision IEEE
754), character strings (UTF-8 encoded) and generic C pointers (these don't
have a syntactic representation in Pure, though, so they need to be created
with external C functions). Truth values are encoded as machine integers (as
you might expect, zero denotes <em>false</em> and any non-zero value <em>true</em>). Pure
also provides some built-in support for lists and matrices, although most of
the corresponding operations are actually defined in the prelude.</p>
<p>Expressions consist of the following elements:</p>
<dl class="docutils">
<dt>Constants: <tt class="docutils literal"><span class="pre">4711</span></tt>, <tt class="docutils literal"><span class="pre">4711L</span></tt>, <tt class="docutils literal"><span class="pre">1.2e-3</span></tt>, <tt class="docutils literal"><span class="pre">&quot;Hello,</span> <span class="pre">world!\n&quot;</span></tt></dt>
<dd><p class="first">The usual C'ish notations for integers (decimal: <tt class="docutils literal"><span class="pre">1000</span></tt>, hexadecimal:
<tt class="docutils literal"><span class="pre">0x3e8</span></tt>, octal: <tt class="docutils literal"><span class="pre">01750</span></tt>), floating point values and double-quoted
strings are all provided, although the Pure syntax differs in some minor
ways, as discussed in the following. First, there is a special notation
for denoting bigints. Integer constants that are too large to fit into
machine integers are promoted to bigints automatically. Moreover, integer
literals immediately followed by the uppercase letter <tt class="docutils literal"><span class="pre">L</span></tt> are always
interpreted as bigint constants, even if they fit into machine integers.
This notation is also used when printing bigint constants.</p>
<p class="last">Second, character escapes in Pure strings have a more flexible syntax
borrowed from the author's Q language, which provides notations to specify
any Unicode character. In particular, the notation <tt class="docutils literal"><span class="pre">\</span></tt><em>n</em>, where <em>n</em>
is an integer literal written in decimal (no prefix), hexadecimal (<tt class="docutils literal"><span class="pre">0x</span></tt>
prefix) or octal (<tt class="docutils literal"><span class="pre">0</span></tt> prefix) notation, denotes the Unicode character
(code point) #<em>n</em>. Since these escapes may consist of a varying number
of digits, parentheses may be used for disambiguation purposes; thus,
e.g. <tt class="docutils literal"><span class="pre">&quot;\(123)4&quot;</span></tt> denotes character #123 followed by the character
<tt class="docutils literal"><span class="pre">4</span></tt>. The usual C-like escapes for special non-printable characters such
as <tt class="docutils literal"><span class="pre">\n</span></tt> are also supported. Moreover, you can use symbolic character
escapes of the form <tt class="docutils literal"><span class="pre">\&amp;</span></tt><em>name</em><tt class="docutils literal"><span class="pre">;</span></tt>, where <em>name</em> is any of the XML
single character entity names specified in the <a class="reference external" href="http://www.w3.org/TR/xml-entity-names/">XML Entity definitions for
Characters</a>. Thus, e.g., <tt class="docutils literal"><span class="pre">&quot;\&amp;copy;&quot;</span></tt> denotes the copyright character
(code point 0x000A9).</p>
</dd>
</dl>
<dl class="docutils">
<dt>Function and variable symbols: <tt class="docutils literal"><span class="pre">foo</span></tt>, <tt class="docutils literal"><span class="pre">foo_bar</span></tt>, <tt class="docutils literal"><span class="pre">BAR</span></tt>, <tt class="docutils literal"><span class="pre">foo::bar</span></tt></dt>
<dd>These consist of the usual sequence of letters (including the underscore)
and digits, starting with a letter. Case is significant, thus <tt class="docutils literal"><span class="pre">foo</span></tt>,
<tt class="docutils literal"><span class="pre">Foo</span></tt> and <tt class="docutils literal"><span class="pre">FOO</span></tt> are distinct identifiers. The '<tt class="docutils literal"><span class="pre">_</span></tt>' symbol, when
occurring on the left-hand side of an equation, is special; it denotes the
<strong class="dfn">anonymous variable</strong> which matches any value without actually binding a
variable. Identifiers can also be prefixed with a namespace identifier,
like in <tt class="docutils literal"><span class="pre">foo::bar</span></tt>. (This requires that the given namespace has already
been created, as explained under <a class="reference internal" href="#namespaces">Namespaces</a> in the <a class="reference internal" href="#declarations">Declarations</a> section.)</dd>
<dt>Operator and constant symbols: <tt class="docutils literal"><span class="pre">x+y</span></tt>, <tt class="docutils literal"><span class="pre">x==y</span></tt>, <tt class="docutils literal"><span class="pre">not</span> <span class="pre">x</span></tt></dt>
<dd><p class="first">For convenience, Pure also provides you with a limited means to extend the
syntax of the language with special operator and constant symbols by means
of a corresponding <strong class="dfn">fixity</strong> declaration, as discussed in section
<a class="reference internal" href="#symbol-declarations">Symbol Declarations</a>. Besides the usual infix, prefix and postfix
operators, Pure also provides outfix (bracket) and nonfix (constant)
symbols. (Nonfix symbols actually work more or less like ordinary
identifiers, but the <tt class="docutils literal"><span class="pre">nonfix</span></tt> attribute tells the compiler that when
such a symbol occurs on the left-hand side of an equation, it is always to
be interpreted as a literal constant, cf. <a class="reference internal" href="#parameters-in-equations">Parameters in Equations</a>.)</p>
<p class="last">Operator and constant symbols may take the form of an identifier or a
sequence of punctuation characters. They must always be declared before
use. Once declared, they are always special, and can't be used as ordinary
identifiers any more. However, like in Haskell, by enclosing an operator
in parentheses, such as <tt class="docutils literal"><span class="pre">(+)</span></tt> or <tt class="docutils literal"><span class="pre">(not)</span></tt>, you can turn it into an
ordinary function symbol. Also, operators and constant symbols can be
qualified with a namespace just like normal identifiers.</p>
</dd>
<dt>Lists: <tt class="docutils literal"><span class="pre">[x,y,z]</span></tt>, <tt class="docutils literal"><span class="pre">x:xs</span></tt>, <tt class="docutils literal"><span class="pre">x..y</span></tt>, <tt class="docutils literal"><span class="pre">x:y..z</span></tt></dt>
<dd><p class="first">Pure's basic list syntax is the same as in Haskell, thus <tt class="docutils literal"><span class="pre">[]</span></tt> is the
empty list and <tt class="docutils literal"><span class="pre">x:xs</span></tt> denotes a list with head element <tt class="docutils literal"><span class="pre">x</span></tt> and tail
list <tt class="docutils literal"><span class="pre">xs</span></tt>. (The infix constructor symbol '<tt class="docutils literal"><span class="pre">:</span></tt>' is declared in the
prelude.) The usual syntactic sugar for list values in brackets is
provided, thus <tt class="docutils literal"><span class="pre">[x,y,z]</span></tt> is exactly the same as <tt class="docutils literal"><span class="pre">x:y:z:[]</span></tt>.</p>
<p class="last">There's also a way to denote arithmetic sequences such as <tt class="docutils literal"><span class="pre">1..5</span></tt>, which
denotes the list <tt class="docutils literal"><span class="pre">[1,2,3,4,5]</span></tt>. (Haskell users should note the missing
brackets. In difference to Haskell, Pure doesn't use any special syntax
for arithmetic sequences, the '<tt class="docutils literal"><span class="pre">..</span></tt>' symbol is just an ordinary infix
operator declared and defined in the prelude.) Sequences with arbitrary
stepsizes can be written by denoting the first two sequence elements using
the '<tt class="docutils literal"><span class="pre">:</span></tt>' operator, as in <tt class="docutils literal"><span class="pre">1.0:1.2..3.0</span></tt>. (To prevent unwanted
artifacts due to rounding errors, the upper bound in a floating point
sequence is always rounded to the nearest grid point. Thus, e.g.,
<tt class="docutils literal"><span class="pre">0.0:0.1..0.29</span></tt> actually yields <tt class="docutils literal"><span class="pre">[0.0,0.1,0.2,0.3]</span></tt>, as does
<tt class="docutils literal"><span class="pre">0.0:0.1..0.31</span></tt>.)</p>
</dd>
<dt>Tuples: <tt class="docutils literal"><span class="pre">x,y,z</span></tt></dt>
<dd>Pure's tuples are a bit unusual: They are constructed by just &quot;pairing&quot;
things using the '<tt class="docutils literal"><span class="pre">,</span></tt>' operator, for which the empty tuple <tt class="docutils literal"><span class="pre">()</span></tt> acts
as a neutral element (i.e., <tt class="docutils literal"><span class="pre">(),x</span></tt> is just <tt class="docutils literal"><span class="pre">x</span></tt>, as is <tt class="docutils literal"><span class="pre">x,()</span></tt>). Pairs
always associate to the right, meaning that <tt class="docutils literal"><span class="pre">x,y,z</span> <span class="pre">==</span> <span class="pre">x,(y,z)</span> <span class="pre">==</span>
<span class="pre">(x,y),z</span></tt>, where <tt class="docutils literal"><span class="pre">x,(y,z)</span></tt> is the normalized representation. This
implies that tuples are always flat, i.e., there are no nested tuples
(tuples of tuples); if you need such constructs then you should use lists
instead. Also note that parentheses are generally only used to group
expressions and are <em>not</em> part of the tuple syntax in Pure, <em>except</em> if
you need to include a tuple in a list or matrix. E.g., <tt class="docutils literal"><span class="pre">[(1,2),3,(4,5)]</span></tt>
is a three element list consisting of the tuple <tt class="docutils literal"><span class="pre">1,2</span></tt>, the integer
<tt class="docutils literal"><span class="pre">3</span></tt>, and another tuple <tt class="docutils literal"><span class="pre">4,5</span></tt>. Likewise, <tt class="docutils literal"><span class="pre">[(1,2,3)]</span></tt> is a list with a
single element, the tuple <tt class="docutils literal"><span class="pre">1,2,3</span></tt>.</dd>
<dt>Matrices: <tt class="docutils literal"><span class="pre">{1.0,2.0,3.0}</span></tt>, <tt class="docutils literal"><span class="pre">{1,2;3,4}</span></tt>, <tt class="docutils literal"><span class="pre">{1L,y+1;foo,bar}</span></tt></dt>
<dd><p class="first">Pure also offers matrices, a kind of arrays, as a built-in data structure
which provides efficient storage and element access. These work more or
less like their Octave/MATLAB equivalents, but using curly braces instead
of brackets. As indicated, commas are used to separate the columns of a
matrix, semicolons for its rows. In fact, the <tt class="docutils literal"><span class="pre">{...}</span></tt> construct is
rather general, allowing you to construct new matrices from individual
elements and/or submatrices, provided that all dimensions match up. E.g.,
<tt class="docutils literal"><span class="pre">{{1;3},{2;4}}</span></tt> is another way to write a 2x2 matrix in &quot;column-major&quot;
form (however, internally all matrices are stored in C's row-major
format).</p>
<p>Note that, while the <tt class="docutils literal"><span class="pre">[...]</span></tt> and <tt class="docutils literal"><span class="pre">{...}</span></tt> constructs look superficially
similar, they work in very different ways. The former is just syntactic
sugar for a corresponding constructor term and can thus be used as a
pattern on the left-hand side of an equation. In contrast, the latter is a
built-in operation which creates objects of a special matrix type. These
can <em>not</em> be used as patterns (instead, matrix values can be matched using
the special <tt class="docutils literal"><span class="pre">::matrix</span></tt> type tag, see the <a class="reference internal" href="#rule-syntax">Rule Syntax</a> section for
details).</p>
<p>If the interpreter was built with support for the <a class="reference internal" href="#gnu-scientific-library">GNU Scientific
Library</a> (GSL) then both numeric and symbolic matrices are available. The
former are thin wrappers around GSL's homogeneous arrays of double,
complex double or (machine) int matrices, while the latter can contain any
mixture of Pure expressions. Pure will pick the appropriate type for the
data at hand. If a matrix contains values of different types, or Pure
values which cannot be stored in a numeric matrix, then a symbolic matrix
is created instead (this also includes the case of bigints, which are
considered as symbolic values as far as matrix construction is concerned).
If the interpreter was built without GSL support then symbolic matrices
are the only kind of matrices supported by the interpreter.</p>
<p class="last">More information about matrices and corresponding examples can be found in
the <a class="reference internal" href="#examples">Examples</a> section below.</p>
</dd>
<dt>Comprehensions: <tt class="docutils literal"><span class="pre">[x,y</span> <span class="pre">|</span> <span class="pre">x=1..n;</span> <span class="pre">y=1..m;</span> <span class="pre">x&lt;y]</span></tt>, <tt class="docutils literal"><span class="pre">{i~=j</span> <span class="pre">|</span> <span class="pre">i=1..n;</span> <span class="pre">j=1..m}</span></tt></dt>
<dd><p class="first">Pure provides the usual comprehension syntax as a convenient means to
construct both list and matrix values from a &quot;template&quot; expression and
one or more &quot;generator&quot; and &quot;filter&quot; clauses. The former bind a
pattern to values drawn from a list or matrix, the latter are just
predicates determining which generated elements should actually be added
to the result. Both list and matrix comprehensions are in fact syntactic
sugar for a combination of nested lambdas, conditional expressions and
&quot;catmaps&quot; (a collection of operations which combine list or matrix
construction and mapping a function over a list or matrix, defined in the
prelude), but they are often much easier to write.</p>
<p class="last">Matrix comprehensions work pretty much like list comprehensions, but
produce matrices instead of lists. List generators in matrix
comprehensions alternate between row and column generation so that most
common mathematical abbreviations carry over quite easily. Examples of
both kinds of comprehensions can be found in the <a class="reference internal" href="#examples">Examples</a> section below.</p>
</dd>
<dt>Function and operator applications: <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">z</span></tt>, <tt class="docutils literal"><span class="pre">-x</span></tt>, <tt class="docutils literal"><span class="pre">x+y</span></tt>, <tt class="docutils literal"><span class="pre">(+x)</span></tt></dt>
<dd><p class="first">As in other modern FPLs, function applications are written simply as
juxtaposition (i.e., in &quot;curried&quot; form) and associate to the left. This
means that in fact all functions only take a single argument.
Multi-argument functions are represented as chains of single-argument
functions. For instance, in <tt class="docutils literal"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">(f</span> <span class="pre">x)</span> <span class="pre">y</span></tt> first the function <tt class="docutils literal"><span class="pre">f</span></tt>
is applied to the first argument <tt class="docutils literal"><span class="pre">x</span></tt>, yielding the function <tt class="docutils literal"><span class="pre">f</span> <span class="pre">x</span></tt>
which in turn gets applied to the second argument <tt class="docutils literal"><span class="pre">y</span></tt>. This makes it
possible to derive new functions from existing ones using <strong class="dfn">partial
applications</strong> which only specify some but not all arguments of a
function. For instance, taking the <tt class="docutils literal"><span class="pre">max</span></tt> function from the prelude as an
example, <tt class="docutils literal"><span class="pre">max</span> <span class="pre">0</span></tt> is the function which, for a given <tt class="docutils literal"><span class="pre">x</span></tt>, returns <tt class="docutils literal"><span class="pre">x</span></tt>
itself if it is nonnegative and zero otherwise. This works because
<tt class="docutils literal"><span class="pre">(max</span> <span class="pre">0)</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">max</span> <span class="pre">0</span> <span class="pre">x</span></tt> is the maximum of <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p class="last">Operator applications are written using prefix, postfix, outfix or infix
notation, as the declaration of the operator demands, but are just
ordinary function applications in disguise. As already mentioned,
enclosing an operator in parentheses turns it into an ordinary function
symbol, thus <tt class="docutils literal"><span class="pre">x+y</span></tt> is exactly the same as <tt class="docutils literal"><span class="pre">(+)</span> <span class="pre">x</span> <span class="pre">y</span></tt>. For convenience,
partial applications of infix operators can also be written using
so-called <strong class="dfn">operator sections</strong>. A <em>left section</em> takes the form <tt class="docutils literal"><span class="pre">(x+)</span></tt>
which is equivalent to the partial application <tt class="docutils literal"><span class="pre">(+)</span> <span class="pre">x</span></tt>. A <em>right
section</em> takes the form <tt class="docutils literal"><span class="pre">(+x)</span></tt> and is equivalent to the term <tt class="docutils literal"><span class="pre">flip</span> <span class="pre">(+)</span>
<span class="pre">x</span></tt>. (This uses the <tt class="docutils literal"><span class="pre">flip</span></tt> combinator from the prelude which is defined
as <tt class="docutils literal"><span class="pre">flip</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">y</span> <span class="pre">x</span></tt>.) For instance, <tt class="docutils literal"><span class="pre">(1/)</span></tt> denotes the reciprocal
and <tt class="docutils literal"><span class="pre">(+1)</span></tt> the successor function. (Note, however, that <tt class="docutils literal"><span class="pre">(-x)</span></tt> always
denotes an application of unary minus; the section <tt class="docutils literal"><span class="pre">(+-x)</span></tt> can be used
to indicate a function which subtracts <tt class="docutils literal"><span class="pre">x</span></tt> from its argument.)</p>
</dd>
<dt>Conditional expressions: <tt class="docutils literal"><span class="pre">if</span> <span class="pre">x</span> <span class="pre">then</span> <span class="pre">y</span> <span class="pre">else</span> <span class="pre">z</span></tt></dt>
<dd>Evaluates to <tt class="docutils literal"><span class="pre">y</span></tt> or <tt class="docutils literal"><span class="pre">z</span></tt> depending on whether <tt class="docutils literal"><span class="pre">x</span></tt> is &quot;true&quot; (i.e., a
nonzero integer). An exception is generated if the condition is not an
integer.</dd>
<dt>Lambdas: <tt class="docutils literal"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">y</span></tt></dt>
<dd>These work pretty much like in Haskell. More than one variable may be
bound (e.g, <tt class="docutils literal"><span class="pre">\x</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">x*y</span></tt>), which is equivalent to a nested lambda
(<tt class="docutils literal"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">\y</span> <span class="pre">-&gt;</span> <span class="pre">x*y</span></tt>). Pure also fully supports pattern-matching lambda
abstractions which match a pattern against the lambda argument and bind
multiple lambda variables in one go, such as <tt class="docutils literal"><span class="pre">\(x,y)</span> <span class="pre">-&gt;</span> <span class="pre">x*y</span></tt>.</dd>
<dt>Case expressions: <tt class="docutils literal"><span class="pre">case</span> <span class="pre">x</span> <span class="pre">of</span> <span class="pre">rule;</span> <span class="pre">...</span> <span class="pre">end</span></tt></dt>
<dd>Matches an expression, discriminating over a number of different cases,
similar to the Haskell case construct. The expression <tt class="docutils literal"><span class="pre">x</span></tt> is matched in
turn against each left-hand side pattern in the rule list, and the first
pattern which matches <tt class="docutils literal"><span class="pre">x</span></tt> gives the value of the entire expression, by
evaluating the corresponding right-hand side with the variables in the
pattern bound to their corresponding values.</dd>
<dt>When expressions: <tt class="docutils literal"><span class="pre">x</span> <span class="pre">when</span> <span class="pre">rule;</span> <span class="pre">...</span> <span class="pre">end</span></tt></dt>
<dd>An alternative way to bind local variables by matching a collection of
subject terms against corresponding patterns. Similar to <a class="reference internal" href="#aardappel">Aardappel</a>'s
<tt class="docutils literal"><span class="pre">when</span></tt> construct. A single binding such as <tt class="docutils literal"><span class="pre">x</span> <span class="pre">when</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">v</span> <span class="pre">end</span></tt> is
equivalent to <tt class="docutils literal"><span class="pre">case</span> <span class="pre">v</span> <span class="pre">of</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">end</span></tt>, but the former is often more
convenient to write. In difference to Aardappel, Pure also allows multiple
definitions in a single when clause, which are processed from left to
right, so that later definitions may refer to the variables in earlier
ones. In fact, a <tt class="docutils literal"><span class="pre">when</span></tt> expression with multiple definitions is treated
like several nested <tt class="docutils literal"><span class="pre">when</span></tt> expressions, with the first binding being the
&quot;outermost&quot; one.</dd>
<dt>With expressions: <tt class="docutils literal"><span class="pre">x</span> <span class="pre">with</span> <span class="pre">rule;</span> <span class="pre">...</span> <span class="pre">end</span></tt></dt>
<dd>Defines local functions. Like Haskell's <tt class="docutils literal"><span class="pre">where</span></tt> construct, but it can be
used anywhere inside an expression (just like Aardappel's <tt class="docutils literal"><span class="pre">where</span></tt>, but
Pure uses the keyword <tt class="docutils literal"><span class="pre">with</span></tt> which better lines up with <tt class="docutils literal"><span class="pre">case</span></tt> and
<tt class="docutils literal"><span class="pre">when</span></tt>). Several functions can be defined in a single <tt class="docutils literal"><span class="pre">with</span></tt> clause,
and the definitions may consist of as many equations as you want.</dd>
</dl>
</div>
<div class="section" id="operators-and-precedence">
<h2><a class="toc-backref" href="#id17">3.5&nbsp;&nbsp;&nbsp;Operators and Precedence</a></h2>
<p>Expressions are parsed according to the following precedence rules: Lambda
binds most weakly, followed by <tt class="docutils literal"><span class="pre">when</span></tt>, <tt class="docutils literal"><span class="pre">with</span></tt> and <tt class="docutils literal"><span class="pre">case</span></tt>, followed by
conditional expressions (<tt class="docutils literal"><span class="pre">if</span></tt>-<tt class="docutils literal"><span class="pre">then</span></tt>-<tt class="docutils literal"><span class="pre">else</span></tt>), followed by the <strong class="dfn">simple
expressions</strong>, i.e., all other kinds of expressions involving operators,
function applications, constants, symbols and other primary
expressions. Precedence and associativity of operator symbols are given by
their declarations (cf. <a class="reference internal" href="#symbol-declarations">Symbol Declarations</a>), and function application
binds stronger than all operators. Parentheses can be used to override default
precedences and associativities as usual.</p>
<p>Operands in operator sections must be well-formed simple expressions which
respect the usual precedence rules. This means that if the operand is a
compound expression then it must be parenthesized, unless it has a higher
precedence than the section operator. For instance, <tt class="docutils literal"><span class="pre">(+x*2)</span></tt> works, as does
<tt class="docutils literal"><span class="pre">(+(x+2))</span></tt>, but <tt class="docutils literal"><span class="pre">(+x+2)</span></tt> will give a syntax error. (Due to some
ambiguities in the grammar, the interpreter will try to parse the latter
expression as <tt class="docutils literal"><span class="pre">((+x)+2)</span></tt> and bail out, reporting that <tt class="docutils literal"><span class="pre">+</span></tt> is not a unary
operator. In fact this will even happen with right-associative operators at
the same precedence level, so that you must always parenthesize the operand of
a right section in such cases.)</p>
<p>The common operator symbols like <tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">/</span></tt> etc. are all
declared at the beginning of the prelude, see the <a class="reference external" href="purelib.html">Pure Library Manual</a> for a
list of these. Arithmetic and relational operators mostly follow C
conventions. However, out of necessity (<tt class="docutils literal"><span class="pre">!</span></tt>, <tt class="docutils literal"><span class="pre">&amp;</span></tt> and <tt class="docutils literal"><span class="pre">|</span></tt> are used for
other purposes in Pure) the logical and bitwise operations, as well as the
negated equality predicates are named a bit differently: <tt class="docutils literal"><span class="pre">~</span></tt>, <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt> and
<tt class="docutils literal"><span class="pre">||</span></tt> denote logical negation, conjunction and disjunction, while the
corresponding bitwise operations are named <tt class="docutils literal"><span class="pre">not</span></tt>, <tt class="docutils literal"><span class="pre">and</span></tt> and
<tt class="docutils literal"><span class="pre">or</span></tt>. Moreover, following these conventions, inequality is denoted
<tt class="docutils literal"><span class="pre">~=</span></tt>. Also note that <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt> and <tt class="docutils literal"><span class="pre">||</span></tt> are special forms which are evaluated
in short-circuit mode like in C (see below), whereas the bitwise connectives
receive their arguments using call-by-value, just like the other arithmetic
operations.</p>
</div>
<div class="section" id="special-forms">
<h2><a class="toc-backref" href="#id18">3.6&nbsp;&nbsp;&nbsp;Special Forms</a></h2>
<p>As already mentioned, some operations are actually implemented as special
forms. In particular, the conditional expression <tt class="docutils literal"><span class="pre">if</span> <span class="pre">x</span> <span class="pre">then</span> <span class="pre">y</span> <span class="pre">else</span> <span class="pre">z</span></tt> is a
special form with call-by-name arguments <tt class="docutils literal"><span class="pre">y</span></tt> and <tt class="docutils literal"><span class="pre">z</span></tt>; only one of the
branches is actually evaluated, depending on the value of <tt class="docutils literal"><span class="pre">x</span></tt>. Similarly,
the logical connectives <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt> and <tt class="docutils literal"><span class="pre">||</span></tt> evaluate their operands in
short-circuit mode just like in C. Thus, e.g., <tt class="docutils literal"><span class="pre">x&amp;&amp;y</span></tt> immediately becomes
false if <tt class="docutils literal"><span class="pre">x</span></tt> evaluates to false, without ever evaluating <tt class="docutils literal"><span class="pre">y</span></tt>. Also note
that <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt> and <tt class="docutils literal"><span class="pre">||</span></tt> only work with machine int arguments and always raise
an exception in case of argument mismatch, so they cannot be used for symbolic
evaluations unless you explicitly &quot;quote&quot; them using the <tt class="docutils literal"><span class="pre">quote</span></tt> primitive
discussed below. In contrast, the bitwise connectives (<tt class="docutils literal"><span class="pre">not</span></tt>, <tt class="docutils literal"><span class="pre">and</span></tt>,
<tt class="docutils literal"><span class="pre">or</span></tt>) use the standard call-by-value argument passing, and the prelude
defines these operations only for machine int and bigint operands, so that
they can be used in symbolic expressions like <tt class="docutils literal"><span class="pre">a</span> <span class="pre">and</span> <span class="pre">b</span> <span class="pre">or</span> <span class="pre">c</span></tt>.</p>
<p>The sequencing operator <tt class="docutils literal"><span class="pre">$$</span></tt> evaluates its left operand, immediately throws
the result away and then goes on to evaluate the right operand which gives the
result of the entire expression. This operator is useful to write
imperative-style code such as the following prompt-input interaction:</p>
<pre class="literal-block">
&gt; using system;
&gt; puts &quot;Enter a number:&quot; $$ scanf &quot;%g&quot;;
Enter a number:
21
21.0
</pre>
<p>We mention in passing here that the same effect can be achieved with a
<tt class="docutils literal"><span class="pre">when</span></tt> clause, which also allows you to execute a function solely for its
side-effects and just ignore the return value:</p>
<pre class="literal-block">
&gt; scanf &quot;%g&quot; when puts &quot;Enter a number:&quot; end;
Enter a number:
21
21.0
</pre>
<p>The <tt class="docutils literal"><span class="pre">&amp;</span></tt> operator does lazy evaluation. This is the only postfix operator
defined in the standard prelude, written as <tt class="docutils literal"><span class="pre">x&amp;</span></tt>, where <tt class="docutils literal"><span class="pre">x</span></tt> is an
arbitrary Pure expression. The <tt class="docutils literal"><span class="pre">&amp;</span></tt> operator binds stronger than any other
operation except function application. It turns its operand into a kind of
parameterless anonymous closure, deferring its evaluation. These kinds of
objects are also commonly known as <strong class="dfn">thunks</strong> or <strong class="dfn">futures</strong>. When the value of a
future is actually needed (during pattern-matching, or when the value becomes
an argument of a C call), it is evaluated automagically and gets memoized,
i.e., the computed result replaces the thunk so that it only has to be
computed once. Futures are useful to implement all kinds of lazy data
structures in Pure, in particular: lazy lists a.k.a. streams. A <strong class="dfn">stream</strong> is
simply a list with a thunked tail, which allows it to be infinite. The Pure
prelude defines many functions for creating and manipulating these kinds of
objects; further details and examples can be found in the <a class="reference internal" href="#examples">Examples</a> section
below.</p>
<p>Last but not least, the special form <tt class="docutils literal"><span class="pre">quote</span></tt> quotes an expression, i.e.,
<tt class="docutils literal"><span class="pre">quote</span> <span class="pre">x</span></tt> returns just <tt class="docutils literal"><span class="pre">x</span></tt> itself without evaluating it. For convenience,
the single quote <tt class="docutils literal"><span class="pre">'</span></tt> can be used as an alias for <tt class="docutils literal"><span class="pre">quote</span></tt>, so instead of
<tt class="docutils literal"><span class="pre">quote</span> <span class="pre">x</span></tt> you can also write <tt class="docutils literal"><span class="pre">'x</span></tt>. The prelude also provides a function
<tt class="docutils literal"><span class="pre">eval</span></tt> which can be used to evaluate a quoted expression at a later
time. For instance:</p>
<pre class="literal-block">
&gt; let x = '(2*42+2^12); x;
2*42+2^12
&gt; eval x;
4180.0
</pre>
<p>The quote also inhibits evaluation inside matrix values, including the
&quot;splicing&quot; of embedded submatrices:</p>
<pre class="literal-block">
&gt; '{1,2+3,2*3};
{1,2+3,2*3}
&gt; '{1,{2,3},4};
{1,{2,3},4}
</pre>
<p>The <tt class="docutils literal"><span class="pre">quote</span></tt> should be well familiar to Lisp programmers. However, there are
some notable differences, please see <a class="reference internal" href="#the-quote">The Quote</a> in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a>
section for details and more examples.</p>
</div>
<div class="section" id="toplevel">
<h2><a class="toc-backref" href="#id19">3.7&nbsp;&nbsp;&nbsp;Toplevel</a></h2>
<p>At the toplevel, a Pure program basically consists of rewriting rules (which
are used to define functions and macros), constant and variable definitions,
and expressions to be evaluated:</p>
<dl class="docutils">
<dt>Rules: <tt class="docutils literal"><span class="pre">lhs</span> <span class="pre">=</span> <span class="pre">rhs;</span></tt></dt>
<dd>Rewriting rules always combine a left-hand side pattern (which must be a
simple expression) and a right-hand side (which can be any kind of Pure
expression described above). The same format is also used in <tt class="docutils literal"><span class="pre">with</span></tt>,
<tt class="docutils literal"><span class="pre">when</span></tt> and <tt class="docutils literal"><span class="pre">case</span></tt> expressions. In toplevel rules, <tt class="docutils literal"><span class="pre">with</span></tt> and
<tt class="docutils literal"><span class="pre">case</span></tt> expressions, this basic form can also be augmented with a
condition <tt class="docutils literal"><span class="pre">if</span> <span class="pre">guard</span></tt> tacked on to the end of the rule, where <tt class="docutils literal"><span class="pre">guard</span></tt>
is an integer expression which determines whether the rule is applicable.
Moreover, the keyword <tt class="docutils literal"><span class="pre">otherwise</span></tt> may be used to denote an empty guard
which is always true (this is syntactic sugar to point out the &quot;default&quot;
case of a definition; the interpreter just treats this as a comment). Pure
also provides some abbreviations for factoring out common left-hand or
right-hand sides in collections of rules; see the <a class="reference internal" href="#rule-syntax">Rule Syntax</a> section
for details.</dd>
<dt>Macro rules: <tt class="docutils literal"><span class="pre">def</span> <span class="pre">lhs</span> <span class="pre">=</span> <span class="pre">rhs;</span></tt></dt>
<dd>A rule starting with the keyword <tt class="docutils literal"><span class="pre">def</span></tt> defines a macro function. No
guards or multiple left-hand and right-hand sides are permitted
here. Macro rules are used to preprocess expressions on the right-hand
side of other definitions at compile time, and are typically employed to
implement user-defined special forms and simple kinds of optimization
rules. See the <a class="reference internal" href="#macros">Macros</a> section below for details and examples.</dd>
<dt>Global variable bindings: <tt class="docutils literal"><span class="pre">let</span> <span class="pre">lhs</span> <span class="pre">=</span> <span class="pre">rhs;</span></tt></dt>
<dd>Binds every variable in the left-hand side pattern to the corresponding
subterm of the right-hand side (after evaluating it). This works like a
<tt class="docutils literal"><span class="pre">when</span></tt> clause, but serves to bind global variables occurring free on the
right-hand side of other function and variable definitions.</dd>
<dt>Constant bindings: <tt class="docutils literal"><span class="pre">const</span> <span class="pre">lhs</span> <span class="pre">=</span> <span class="pre">rhs;</span></tt></dt>
<dd>An alternative form of <tt class="docutils literal"><span class="pre">let</span></tt> which defines constants rather than
variables. (These are not to be confused with nonfix symbols which simply
stand for themselves!) Like <tt class="docutils literal"><span class="pre">let</span></tt>, this construct binds the variable
symbols on the left-hand side to the corresponding values on the
right-hand side (after evaluation). The difference is that <tt class="docutils literal"><span class="pre">const</span></tt>
symbols can only be defined once, after which their values are substituted
directly into the right-hand sides of other definitions, rather than being
looked up at runtime.</dd>
<dt>Toplevel expressions: <tt class="docutils literal"><span class="pre">expr;</span></tt></dt>
<dd>A singleton expression at the toplevel, terminated with a semicolon,
simply causes the given value to be evaluated (and the result to be
printed, when running in interactive mode).</dd>
</dl>
</div>
<div class="section" id="scoping-rules">
<h2><a class="toc-backref" href="#id20">3.8&nbsp;&nbsp;&nbsp;Scoping Rules</a></h2>
<p>A few remarks about the scope of identifiers and other symbols are in order
here. Like most modern functional languages, Pure uses <strong class="dfn">lexical</strong> or <strong class="dfn">static</strong>
binding for local functions and variables. What this means is that the binding
of a local name is completely determined at compile time by the surrounding
program text, and does not change as the program is being executed. In
particular, if a function returns another (anonymous or local) function, the
returned function captures the environment it was created in, i.e., it becomes
a (lexical) <strong class="dfn">closure</strong>. For instance, the following function, when invoked with
a single argument <tt class="docutils literal"><span class="pre">x</span></tt>, returns another function which adds <tt class="docutils literal"><span class="pre">x</span></tt> to its
argument:</p>
<pre class="literal-block">
&gt; foo x = bar with bar y = x+y end;
&gt; let f = foo 99; f;
bar
&gt; f 10, f 20;
109,119
</pre>
<p>This works the same no matter what other bindings of <tt class="docutils literal"><span class="pre">x</span></tt> may be in effect
when the closure is invoked:</p>
<pre class="literal-block">
&gt; let x = 77; f 10, (f 20 when x = 88 end);
109,119
</pre>
<p>Global bindings of variable and function symbols work a bit differently,
though. Like many languages which are to be used interactively, Pure binds
global symbols <strong class="dfn">dynamically</strong>, so that the bindings can be changed easily at
any time during an interactive session. This is mainly a convenience for
interactive usage, but works the same no matter whether the source code is
entered interactively or being read from a script, in order to ensure
consistent behaviour between interactive and batch mode operation.</p>
<p>So, for instance, you can easily bind a global variable to a new value by just
entering a corresponding <tt class="docutils literal"><span class="pre">let</span></tt> command:</p>
<pre class="literal-block">
&gt; foo x = c*x;
&gt; foo 99;
c*99
&gt; let c = 2; foo 99;
198
&gt; let c = 3; foo 99;
297
</pre>
<p>This works pretty much like global variables in imperative languages, but note
that in Pure the value of a global variable can only be changed with a <tt class="docutils literal"><span class="pre">let</span></tt>
command at the toplevel. Thus referential transparency is unimpaired; while
the value of a global variable may change between different toplevel
expressions, it will always take the same value in a single evaluation.</p>
<p>Similarly, you can also add new equations to an existing function at any
time:</p>
<pre class="literal-block">
&gt; fact 0 = 1;
&gt; fact n::int = n*fact (n-1) if n&gt;0;
&gt; fact 10;
3628800
&gt; fact 10.0;
fact 10.0
&gt; fact 1.0 = 1.0;
&gt; fact n::double = n*fact (n-1) if n&gt;1;
&gt; fact 10.0;
3628800.0
&gt; fact 10;
3628800
</pre>
<p>(In interactive mode, it is even possible to completely erase a definition,
see section <a class="reference internal" href="#interactive-usage">Interactive Usage</a> for details.)</p>
<p>So, while the meaning of a local symbol never changes once its definition has
been processed, toplevel definitions may well evolve while the program is
being processed, and the interpreter will always use the latest definitions at
a given point in the source when an expression is evaluated. This means that,
even in a script file, you have to define all symbols needed in an evaluation
before entering the expression to be evaluated.</p>
</div>
</div>
<div class="section" id="rule-syntax">
<h1><a class="toc-backref" href="#id21">4&nbsp;&nbsp;&nbsp;Rule Syntax</a></h1>
<p>Basically, the same rule syntax is used in all kinds of global and local
definitions. However, some constructs (specifically, <tt class="docutils literal"><span class="pre">when</span></tt>, <tt class="docutils literal"><span class="pre">let</span></tt>,
<tt class="docutils literal"><span class="pre">const</span></tt> and <tt class="docutils literal"><span class="pre">def</span></tt>) use a restricted rule syntax where no guards or
multiple left-hand and right-hand sides are permitted. When matching against a
function or macro call, or the subject term in a <tt class="docutils literal"><span class="pre">case</span></tt> expression, the
rules are always considered in the order in which they are written, and the
first matching rule (whose guard evaluates to a nonzero value, if applicable)
is picked. (Again, the <tt class="docutils literal"><span class="pre">when</span></tt> construct is treated differently, because each
rule is actually a separate definition.)</p>
<div class="section" id="patterns">
<h2><a class="toc-backref" href="#id22">4.1&nbsp;&nbsp;&nbsp;Patterns</a></h2>
<p>In any case, the left-hand side of a rule is a special kind of simple
expression, called a <strong class="dfn">pattern</strong>. Patterns consist of function and operator
applications as well as any of the &quot;atomic&quot; expression types (symbols,
numbers, strings and list values). <em>Not</em> permitted are any of the special
expression types (lambda, <tt class="docutils literal"><span class="pre">case</span></tt>, <tt class="docutils literal"><span class="pre">when</span></tt>, <tt class="docutils literal"><span class="pre">with</span></tt>, conditional
expressions). Note that, since list and matrix comprehensions expand into
lambdas, these aren't permitted in patterns either. Also note that in the
current implementation matrix values aren't allowed in patterns, but it is
possible to match a matrix value as a whole using the <tt class="docutils literal"><span class="pre">::matrix</span></tt> type tag,
see below.</p>
<p>In addition, patterns must not contain repeated variables, i.e., rules must be
&quot;left-linear&quot;. The only exception to this rule is the <strong class="dfn">anonymous variable</strong>
'<tt class="docutils literal"><span class="pre">_</span></tt>' which matches an arbitrary value (independently for all occurrences)
without binding a variable symbol.</p>
<p>Patterns may contain the following special elements which are not permitted in
right-hand side expressions:</p>
<ul class="simple">
<li>A left-hand side variable (including the anonymous variable) may be followed
by one of the special type tags <tt class="docutils literal"><span class="pre">::int</span></tt>, <tt class="docutils literal"><span class="pre">::bigint</span></tt>, <tt class="docutils literal"><span class="pre">::double</span></tt>,
<tt class="docutils literal"><span class="pre">::string</span></tt>, <tt class="docutils literal"><span class="pre">::matrix</span></tt>, <tt class="docutils literal"><span class="pre">::pointer</span></tt>, to indicate that it can only
match a constant value of the corresponding built-in type. This is useful if
you want to write rules matching any object of one of these types. Note that
there is no way to write out all &quot;constructors&quot; for the built-in types, as
there are infinitely many. (Or none, as in the case of <tt class="docutils literal"><span class="pre">matrix</span></tt> and
<tt class="docutils literal"><span class="pre">pointer</span></tt> which are constructed using special primitives.)</li>
<li>Pure also supports Haskell-style &quot;as&quot; patterns of the form
<tt class="docutils literal"><span class="pre">variable&#64;pattern</span></tt> which binds the given variable to the expression
matched by the subpattern <tt class="docutils literal"><span class="pre">pattern</span></tt> (in addition to the variables bound by
<tt class="docutils literal"><span class="pre">pattern</span></tt> itself). This is convenient if the value matched by the
subpattern is to be used on the right-hand side of an
equation.</li>
</ul>
<p>Note that, syntactically, both type tags and &quot;as&quot; patterns are primary
expressions. Thus, if the subpattern of an &quot;as&quot; pattern is a compound
expression, it must be parenthesized. For instance, the following function
duplicates the head element of a list:</p>
<pre class="literal-block">
foo xs&#64;(x:_) = x:xs;
</pre>
</div>
<div class="section" id="general-rules">
<h2><a class="toc-backref" href="#id23">4.2&nbsp;&nbsp;&nbsp;General Rules</a></h2>
<p>The most general type of rule, used in function definitions and <tt class="docutils literal"><span class="pre">case</span></tt>
expressions, consists of a left-hand side pattern, a right-hand side
expression and an optional guard. The left-hand side of a rule can be omitted
if it is the same as for the previous rule. This provides a convenient means
to write out a collection of equations for the same left-hand side which
discriminates over different conditions:</p>
<pre class="literal-block">
lhs       = rhs if guard;
          = rhs if guard;
          ...
          = rhs otherwise;
</pre>
<p>For instance:</p>
<pre class="literal-block">
fact n  = n*fact (n-1) if n&gt;0;
        = 1 otherwise;
</pre>
<p>Pure also allows a collection of rules with different left-hand sides but the
same right-hand side(s) to be abbreviated as follows:</p>
<pre class="literal-block">
lhs       |
          ...
lhs       = rhs;
</pre>
<p>This is useful if you need different specializations of the same rule which
use different type tags on the left-hand side variables. For instance:</p>
<pre class="literal-block">
fact n::int    |
fact n::double |
fact n         = n*fact(n-1) if n&gt;0;
               = 1 otherwise;
</pre>
<p>In fact, the left-hand sides don't have to be related at all, so that you can
also write something like:</p>
<pre class="literal-block">
foo x | bar y = x*y;
</pre>
<p>However, this construct is most useful when using an &quot;as&quot; pattern to bind a
common variable to a parameter value after checking that it matches one of
several possible argument patterns (which is slightly more efficient than
using an equivalent type-checking guard). E.g., the following definition binds
the <tt class="docutils literal"><span class="pre">xs</span></tt> variable to the parameter of <tt class="docutils literal"><span class="pre">foo</span></tt>, if it is either the empty
list or a list starting with an integer:</p>
<pre class="literal-block">
foo xs&#64;[] | foo xs&#64;(_::int:_) = ... xs ...;
</pre>
<p>The same construct also works in <tt class="docutils literal"><span class="pre">case</span></tt> expressions, which is convenient if
different cases should be mapped to the same value, e.g.:</p>
<pre class="literal-block">
case ans of &quot;y&quot; | &quot;Y&quot; = 1; _ = 0; end;
</pre>
<p>Sometimes it is useful if local definitions (<tt class="docutils literal"><span class="pre">when</span></tt> and <tt class="docutils literal"><span class="pre">with</span></tt>) can be
shared by the right-hand side and the guard of a rule. This can be done by
placing the local definitions behind the guard, as follows (we only show the
case of a single <tt class="docutils literal"><span class="pre">when</span></tt> clause here, but of course there may be any number
of <tt class="docutils literal"><span class="pre">when</span></tt> and <tt class="docutils literal"><span class="pre">with</span></tt> clauses behind the guard):</p>
<pre class="literal-block">
lhs = rhs if guard when defns end;
</pre>
<p>Note that this is different from the following, which indicates that the
definitions only apply to the guard but not the right-hand side of the rule:</p>
<pre class="literal-block">
lhs = rhs if (guard when defns end);
</pre>
<p>Conversely, definitions placed <em>before</em> the guard only apply to the right-hand
side but not the guard (no parentheses are required in this case):</p>
<pre class="literal-block">
lhs = rhs when defns end if guard;
</pre>
<p>An example showing the use of a local variable binding spanning both the
right-hand side and the guard of a rule is the following quadratic equation
solver, which returns the (real) solutions of the equation <tt class="docutils literal"><span class="pre">x^2+p*x+q</span> <span class="pre">=</span> <span class="pre">0</span></tt>
if the discriminant <tt class="docutils literal"><span class="pre">d</span> <span class="pre">=</span> <span class="pre">p^2/4-q</span></tt> is nonnegative:</p>
<pre class="literal-block">
&gt; using math;
&gt; solve p q = -p/2+sqrt d,-p/2-sqrt d if d&gt;=0 when d = p^2/4-q end;
&gt; solve 4 2; solve 2 4;
-0.585786437626905,-3.41421356237309
solve 2 4
</pre>
<p>Note that the above definition leaves the case of a negative discriminant
undefined.</p>
</div>
<div class="section" id="simple-rules">
<h2><a class="toc-backref" href="#id24">4.3&nbsp;&nbsp;&nbsp;Simple Rules</a></h2>
<p>As already mentioned, <tt class="docutils literal"><span class="pre">when</span></tt>, <tt class="docutils literal"><span class="pre">let</span></tt> and <tt class="docutils literal"><span class="pre">const</span></tt> use a simplified kind of
rule syntax which just consists of a left-hand and a right-hand side separated
by the equals sign. In this case the meaning of the rule is to bind the
variables in the left-hand side of the rule to the corresponding subterms of
the value of the right-hand side. This is also called a <strong class="dfn">pattern binding</strong>.</p>
<p>Guards or multiple left-hand or right-hand sides are not permitted in these
rules. However, it is possible to omit the left-hand side if it is just the
anonymous variable '<tt class="docutils literal"><span class="pre">_</span></tt>' by itself, indicating that you don't care about the
result. The right-hand side is still evaluated, if only for its side-effects,
which is handy, e.g., for adding debugging statements to your code. For
instance, here is a variation of the quadratic equation solver which also
prints the discriminant after it has been computed:</p>
<pre class="literal-block">
&gt; using math, system;
&gt; solve p q = -p/2+sqrt d,-p/2-sqrt d if d&gt;=0
&gt; when d = p^2/4-q; printf &quot;The discriminant is: %g\n&quot; d; end;
&gt; solve 4 2;
The discriminant is: 2
-0.585786437626905,-3.41421356237309
&gt; solve 2 4;
The discriminant is: -3
solve 2 4
</pre>
<p>Note that simple rules of the same form <tt class="docutils literal"><span class="pre">lhs</span> <span class="pre">=</span> <span class="pre">rhs</span></tt> are also used in macro
definitions (<tt class="docutils literal"><span class="pre">def</span></tt>), to be discussed in the <a class="reference internal" href="#macros">Macros</a> section. In this case,
however, the rule denotes a real rewriting rule, not a pattern binding, hence
the left-hand side is mandatory in these rules.</p>
</div>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#id25">5&nbsp;&nbsp;&nbsp;Examples</a></h1>
<p>Here are a few examples of simple Pure programs.</p>
<p>The factorial:</p>
<pre class="literal-block">
fact n = n*fact (n-1) if n&gt;0;
       = 1 otherwise;
let facts = map fact (1..10); facts;
</pre>
<p>The Fibonacci numbers:</p>
<pre class="literal-block">
fib n = a when a,b = fibs n end
          with fibs n = 0,1 if n&lt;=0;
                      = case fibs (n-1) of
                          a,b = b,a+b;
                        end;
          end;
let fibs = map fib (1..30); fibs;
</pre>
<p>It is worth noting here that in most cases Pure performs tail call
optimization so that tail-recursive definitions like the following will be
executed in constant stack space (see <a class="reference internal" href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a> in the
<a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section for more details on this):</p>
<pre class="literal-block">
// tail-recursive factorial using an &quot;accumulating parameter&quot;
fact n = loop 1 n with
  loop p n = if n&gt;0 then loop (p*n) (n-1) else p;
end;
</pre>
<p>Here is an example showing how constants are defined and used. Constant
definitions take pretty much the same form as variable definitions with
<tt class="docutils literal"><span class="pre">let</span></tt> (see above), but work more like the definition of a parameterless
function whose value is precomputed at compile time:</p>
<pre class="literal-block">
&gt; extern double atan(double);
&gt; const pi = 4*atan 1.0;
&gt; pi;
3.14159265358979
&gt; foo x = 2*pi*x;
&gt; show foo
foo x = 2*3.14159265358979*x;
&gt; foo 1;
6.28318530717958
</pre>
<div class="section" id="list-comprehensions">
<h2><a class="toc-backref" href="#id26">5.1&nbsp;&nbsp;&nbsp;List Comprehensions</a></h2>
<p>List comprehensions are Pure's main workhorse for generating and processing
all kinds of list values. Here's a well-known example, a variation of
Erathosthenes' classical prime sieve:</p>
<pre class="literal-block">
primes n        = sieve (2..n) with
  sieve []      = [];
  sieve (p:qs)  = p : sieve [q | q = qs; q mod p];
end;
</pre>
<p>(This definition is actually rather inefficient, there are much better albeit
more complicated implementations of this sieve.)</p>
<p>For instance:</p>
<pre class="literal-block">
&gt; primes 100;
[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
</pre>
<p>If you dare, you can actually have a look at the catmap-lambda-if-then-else
expression the comprehension expanded to:</p>
<pre class="literal-block">
&gt; show primes
primes n = sieve (2..n) with sieve [] = []; sieve (p:qs) = p:sieve
(catmap (\q -&gt; if q mod p then [q] else []) qs) end;
</pre>
<p>List comprehensions are also a useful device to organize backtracking
searches. For instance, here's an algorithm for the n queens problem, which
returns the list of all placements of n queens on an n x n board (encoded as
lists of n pairs (i,j) with i = 1..n), so that no two queens hold each other
in check:</p>
<pre class="literal-block">
queens n       = search n 1 [] with
  search n i p = [reverse p] if i&gt;n;
               = cat [search n (i+1) ((i,j):p) | j = 1..n; safe (i,j) p];
  safe (i,j) p = ~any (check (i,j)) p;
  check (i1,j1) (i2,j2)
               = i1==i2 || j1==j2 || i1+j1==i2+j2 || i1-j1==i2-j2;
end;
</pre>
<p>(Again, this algorithm is rather inefficient, see the examples included in the
Pure distribution for a much better algorithm by Libor Spacek.)</p>
</div>
<div class="section" id="lazy-evaluation-and-streams">
<h2><a class="toc-backref" href="#id27">5.2&nbsp;&nbsp;&nbsp;Lazy Evaluation and Streams</a></h2>
<p>As already mentioned, lists can also be evaluated in a &quot;lazy&quot; fashion, by just
turning the tail of a list into a future. This special kind of list is also
called a <strong class="dfn">stream</strong>. Streams enable you to work with infinite lists (or finite
lists which are so huge that you would never want to keep them in memory in
their entirety). E.g., here's one way to define the infinite stream of all
Fibonacci numbers:</p>
<pre class="literal-block">
&gt; let fibs = fibs 0L 1L with fibs a b = a : fibs b (a+b) &amp; end;
&gt; fibs;
0L:#&lt;thunk 0xb5d54320&gt;
</pre>
<p>Note the <tt class="docutils literal"><span class="pre">&amp;</span></tt> on the tail of the list in the definition of the local <tt class="docutils literal"><span class="pre">fibs</span></tt>
function. This turns the result of <tt class="docutils literal"><span class="pre">fibs</span></tt> into a stream, which is required
to prevent the function from recursing into samadhi. Also note that we work
with bigints in this example because the Fibonacci numbers grow quite rapidly,
so with machine integers the values would soon start wrapping around to
negative integers.</p>
<p>Streams like these can be worked with in pretty much the same way as with
lists. Of course, care must be taken not to invoke &quot;eager&quot; operations such as
<tt class="docutils literal"><span class="pre">#</span></tt> (which computes the size of a list) on infinite streams, to prevent
infinite recursion. However, many list operations work with infinite streams
just fine, and return the appropriate stream results. E.g., the <tt class="docutils literal"><span class="pre">take</span></tt>
function (which retrieves a given number of elements from the front of a list)
works with streams just as well as with &quot;eager&quot; lists:</p>
<pre class="literal-block">
&gt; take 10 fibs;
0L:#&lt;thunk 0xb5d54350&gt;
</pre>
<p>Hmm, not much progress there, but that's just how streams work (or rather they
don't, they're lazy bums indeed!). Nevertheless, the stream computed with
<tt class="docutils literal"><span class="pre">take</span></tt> is in fact finite and we can readily convert it to an ordinary list,
forcing its evaluation:</p>
<pre class="literal-block">
&gt; list (take 10 fibs);
[0L,1L,1L,2L,3L,5L,8L,13L,21L,34L]
</pre>
<p>An easier way to achieve this is to cut a &quot;slice&quot; from the stream:</p>
<pre class="literal-block">
&gt; fibs!!(0..10);
[0L,1L,1L,2L,3L,5L,8L,13L,21L,34L,55L]
</pre>
<p>Also note that since we bound the stream to a variable, the already computed
prefix of the stream has been memoized, so that this portion of the stream is
now readily available in case we need to have another look at it later. By
these means, possibly costly reevaluations are avoided, trading memory for
execution speed:</p>
<pre class="literal-block">
&gt; fibs;
0L:1L:1L:2L:3L:5L:8L:13L:21L:34L:55L:#&lt;thunk 0xb5d54590&gt;
</pre>
<p>Let's take a look at some of the other convenience operations for generating
stream values. The prelude defines infinite arithmetic sequences, using
<tt class="docutils literal"><span class="pre">inf</span></tt> or <tt class="docutils literal"><span class="pre">-inf</span></tt> to denote an upper (or lower) infinite bound for the
sequence, e.g.:</p>
<pre class="literal-block">
&gt; let u = 1..inf; let v = -1.0:-1.2..-inf;
&gt; u!!(0..10); v!!(0..10);
[1,2,3,4,5,6,7,8,9,10,11]
[-1.0,-1.2,-1.4,-1.6,-1.8,-2.0,-2.2,-2.4,-2.6,-2.8,-3.0]
</pre>
<p>Other useful stream generator functions are <tt class="docutils literal"><span class="pre">iterate</span></tt>, <tt class="docutils literal"><span class="pre">repeat</span></tt> and
<tt class="docutils literal"><span class="pre">cycle</span></tt>, which have been adopted from Haskell. In fact, infinite arithmetic
progressions are implemented in terms of <tt class="docutils literal"><span class="pre">iterate</span></tt>. The <tt class="docutils literal"><span class="pre">repeat</span></tt> function
just repeats its argument, and <tt class="docutils literal"><span class="pre">cycle</span></tt> cycles through the elements of the
given list:</p>
<pre class="literal-block">
&gt; repeat 1!!(0..10);
[1,1,1,1,1,1,1,1,1,1,1]
&gt; cycle [0,1]!!(0..10);
[0,1,0,1,0,1,0,1,0,1,0]
</pre>
<p>Moreover, list comprehensions can draw values from streams and return the
appropriate stream result:</p>
<pre class="literal-block">
&gt; let rats = [m,n-m | n=2..inf; m=1..n-1; gcd m (n-m) == 1]; rats;
(1,1):#&lt;thunk 0xb5d54950&gt;
&gt; rats!!(0..10);
[(1,1),(1,2),(2,1),(1,3),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(5,1)]
</pre>
<p>Finally, let's rewrite our prime sieve so that it generates the infinite
stream of <em>all</em> prime numbers:</p>
<pre class="literal-block">
all_primes      = sieve (2..inf) with
  sieve (p:qs)  = p : sieve [q | q = qs; q mod p] &amp;;
end;
</pre>
<p>Note that we can omit the empty list case of <tt class="docutils literal"><span class="pre">sieve</span></tt> here, since the sieve
now never becomes empty. Example:</p>
<pre class="literal-block">
&gt; let P = all_primes;
&gt; P!!(0..20);
[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73]
&gt; P!299;
1987
</pre>
<p>You can also just print the entire stream. This will run forever, so hit
<tt class="docutils literal"><span class="pre">Ctrl-C</span></tt> when you get bored:</p>
<pre class="literal-block">
&gt; using system;
&gt; do (printf &quot;%d\n&quot;) all_primes;
2
3
5
  ...
</pre>
<p>(Make sure that you really use the <tt class="docutils literal"><span class="pre">all_primes</span></tt> function instead of the
<tt class="docutils literal"><span class="pre">P</span></tt> variable to print the stream. Otherwise, because of memoization the
stream stored in <tt class="docutils literal"><span class="pre">P</span></tt> will grow with the number of elements printed until
memory is exhausted. Calling <tt class="docutils literal"><span class="pre">do</span></tt> on a fresh instance of the stream of
primes allows <tt class="docutils literal"><span class="pre">do</span></tt> to get rid of each &quot;cons&quot; cell after having printed the
corresponding stream element.)</p>
</div>
<div class="section" id="matrix-computations">
<h2><a class="toc-backref" href="#id28">5.3&nbsp;&nbsp;&nbsp;Matrix Computations</a></h2>
<p>Pure offers a number of basic matrix operations, such as matrix construction,
indexing, slicing, as well as getting the size and dimensions of a matrix
(these are briefly described in the <a class="reference internal" href="#standard-library">Standard Library</a> section
below). However, it does <em>not</em> supply built-in support for matrix arithmetic
and other linear algebra algorithms. The idea is that these can and should be
provided through separate libraries (please check the Pure website for the
pure-gsl module which is an ongoing project to provide a full GSL interface
for the Pure language).</p>
<p>But Pure's facilities for matrix and list processing also make it easy to roll
your own, if desired. First, the prelude provides matrix versions of the
common list operations like <tt class="docutils literal"><span class="pre">map</span></tt>, <tt class="docutils literal"><span class="pre">fold</span></tt>, <tt class="docutils literal"><span class="pre">zip</span></tt> etc., which provide a
way to implement common matrix operations. E.g., multiplying a matrix <tt class="docutils literal"><span class="pre">x</span></tt>
with a scalar <tt class="docutils literal"><span class="pre">a</span></tt> amounts to mapping the function <tt class="docutils literal"><span class="pre">(a*)</span></tt> to x, which
can be done as follows:</p>
<pre class="literal-block">
&gt; a * x::matrix = map (a*) x if ~matrixp a;
&gt; 2*{1,2,3;4,5,6};
{2,4,6;8,10,12}
</pre>
<p>Likewise, matrix addition and other element-wise operations can be realized
using <tt class="docutils literal"><span class="pre">zipwith</span></tt>, which combines corresponding elements of two matrices using
a given binary function:</p>
<pre class="literal-block">
&gt; x::matrix + y::matrix = zipwith (+) x y;
&gt; {1,2,3;4,5,6}+{1,2,1;3,2,3};
{2,4,4;7,7,9}
</pre>
<p>Second, matrix comprehensions make it easy to express a variety of algorithms
which would typically be implemented using <tt class="docutils literal"><span class="pre">for</span></tt> loops in conventional
programming languages. To illustrate the use of matrix comprehensions, here is
how we can define an operation to create a square identity matrix of a given
dimension:</p>
<pre class="literal-block">
&gt; eye n = {i==j | i = 1..n; j = 1..n};
&gt; eye 3;
{1,0,0;0,1,0;0,0,1}
</pre>
<p>Note that the <tt class="docutils literal"><span class="pre">i==j</span></tt> term is just a Pure idiom for the Kronecker
symbol. Another point worth mentioning here is that the generator clauses of
matrix comprehensions alternate between row and column generation
automatically, if values are drawn from lists as in the example above. (More
precisely, the last generator, which varies most quickly, yields a row, the
next-to-last one a column of these row vectors, and so on.) This makes matrix
comprehensions resemble customary mathematical notation very closely.</p>
<p>Of course, matrix comprehensions can also draw values from other matrices
instead of lists. In this case the block layout of the component matrices is
preserved. For instance:</p>
<pre class="literal-block">
&gt; {x,y|x={1,2};y={a,b;c,d}};
{(1,a),(1,b),(2,a),(2,b);(1,c),(1,d),(2,c),(2,d)}
</pre>
<p>Note that a matrix comprehension involving filters may fail because the
filtered result isn't a rectangular matrix any more. E.g.,
<tt class="docutils literal"><span class="pre">{2*x|x={1,2,3,-4};x&gt;0}</span></tt> works, as does <tt class="docutils literal"><span class="pre">{2*x|x={-1,2;3,-4};x&gt;0}</span></tt>, but
<tt class="docutils literal"><span class="pre">{2*x|x={1,2;3,-4};x&gt;0}</span></tt> looses because the rows of the result matrix have
different lengths.</p>
<p>As a slightly more comprehensive example (no pun intended!), here is a
definition of matrix multiplication in Pure. The building block here is the
&quot;dot&quot; product of two vectors which can be defined as follows:</p>
<pre class="literal-block">
&gt; sum = foldl (+) 0;
&gt; dot x::matrix y::matrix = sum $ zipwith (*) (rowvector x) (rowvector y);
&gt; dot {1,2,3} {1,0,1};
4
</pre>
<p>The general matrix product now boils down to a simple matrix comprehension
which just computes the dot product of all rows of <tt class="docutils literal"><span class="pre">x</span></tt> with all columns of
<tt class="docutils literal"><span class="pre">y</span></tt> (the <tt class="docutils literal"><span class="pre">rows</span></tt> and <tt class="docutils literal"><span class="pre">cols</span></tt> functions are prelude operations found in
matrices.pure):</p>
<pre class="literal-block">
&gt; x::matrix * y::matrix = {dot u v | u = rows x; v = cols y};
&gt; {0,1;1,0;1,1}*{1,2,3;4,5,6};
{4,5,6;1,2,3;5,7,9}
</pre>
<p>(For the sake of simplicity, this doesn't do much error checking. In
production code you'd check at least the conformance of matrix dimensions, of
course.)</p>
<p>Well, that was easy. So let's take a look at a more challenging example,
Gaussian elimination, which can be used to solve systems of linear
equations. The algorithm brings a matrix into &quot;row echelon&quot; form, a
generalization of triangular matrices. The resulting system can then be solved
quite easily using back substitution. Here is a Pure implementation of the
algorithm:</p>
<pre class="literal-block">
gauss_elimination x::matrix = p,x
when n,m = dim x; p,_,x = foldl step (0..n-1,0,x) (0..m-1) end;

// One pivoting and elimination step in column j of the matrix:
step (p,i,x) j
= if max_x==0 then p,i,x
  else
    // updated row permutation and index:
    transp i max_i p, i+1,
    {// the top rows of the matrix remain unchanged:
     x!!(0..i-1,0..m-1);
     // the pivot row, divided by the pivot element:
     {x!(i,l)/x!(i,j)                 | l=0..m-1};
     // subtract suitable multiples of the pivot row:
     {x!(k,l)-x!(k,j)*x!(i,l)/x!(i,j) | k=i+1..n-1; l=0..m-1}}
when
  n,m = dim x; max_i, max_x = pivot i (col x j);
  x = if max_x&gt;0 then swap x i max_i else x;
end with
  pivot i x       = foldl max (0,0) [j,abs (x!j)|j=i..#x-1];
  max (i,x) (j,y) = if x&lt;y then j,y else i,x;
end;
</pre>
<p>The real meat is in the pivoting and elimination step (<tt class="docutils literal"><span class="pre">step</span></tt> function)
which is iterated over all columns of the input matrix. In each step, <tt class="docutils literal"><span class="pre">x</span></tt> is
the current matrix, <tt class="docutils literal"><span class="pre">i</span></tt> the current row index, <tt class="docutils literal"><span class="pre">j</span></tt> the current column
index, and <tt class="docutils literal"><span class="pre">p</span></tt> keeps track of the current permutation of the row indices
performed during pivoting. The algorithm returns the updated matrix <tt class="docutils literal"><span class="pre">x</span></tt>, row
index <tt class="docutils literal"><span class="pre">i</span></tt> and row permutation <tt class="docutils literal"><span class="pre">p</span></tt>.</p>
<p>Please refer to any good textbook on numerical mathematics for a closer
description of the algorithm. But here is a brief rundown of what happens in
each elimination step: First we find the pivot element in column <tt class="docutils literal"><span class="pre">j</span></tt> of the
matrix. (We're doing partial pivoting here, i.e., we only look for the element
with the largest absolute value in column <tt class="docutils literal"><span class="pre">j</span></tt>, starting at row <tt class="docutils literal"><span class="pre">i</span></tt>. That's
usually good enough to achieve numerical stability.) If the pivot is zero then
we're done (the rest of the pivot column is already zeroed out). Otherwise, we
bring it into the pivot position (swapping row <tt class="docutils literal"><span class="pre">i</span></tt> and the pivot row),
divide the pivot row by the pivot, and subtract suitable multiples of the
pivot row to eliminate the elements of the pivot column in all subsequent
rows. Finally we update <tt class="docutils literal"><span class="pre">i</span></tt> and <tt class="docutils literal"><span class="pre">p</span></tt> accordingly and return the result.</p>
<p>In order to complete the implementation, we still need the following little
helper functions to swap two rows of a matrix (this is used in the pivoting
step) and to apply a transposition to a permutation (represented as a list):</p>
<pre class="literal-block">
swap x i j = x!!(transp i j (0..n-1),0..m-1) when n,m = dim x end;
transp i j p = [p!tr k | k=0..#p-1]
with tr k = if k==i then j else if k==j then i else k end;
</pre>
<p>Finally, let us define a convenient print representation of double matrices a
la <a class="reference internal" href="#octave">Octave</a> (the meaning of the <tt class="docutils literal"><span class="pre">__show__</span></tt> function is explained in the
<a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section):</p>
<pre class="literal-block">
using system;
 __show__ x::matrix
 = strcat [printd j (x!(i,j))|i=0..n-1; j=0..m-1] + &quot;\n&quot;
 with printd 0 = sprintf &quot;\n%10.5f&quot;; printd _ = sprintf &quot;%10.5f&quot; end
 when n,m = dim x end if dmatrixp x;
</pre>
<p>Example:</p>
<pre class="literal-block">
&gt; let x = dmatrix {2,1,-1,8; -3,-1,2,-11; -2,1,2,-3};
&gt; x; gauss_elimination x;
   2.00000   1.00000  -1.00000   8.00000
  -3.00000  -1.00000   2.00000 -11.00000
  -2.00000   1.00000   2.00000  -3.00000
[1,2,0],
   1.00000   0.33333  -0.66667   3.66667
   0.00000   1.00000   0.40000   2.60000
   0.00000   0.00000   1.00000  -1.00000
</pre>
</div>
</div>
<div class="section" id="macros">
<h1><a class="toc-backref" href="#id29">6&nbsp;&nbsp;&nbsp;Macros</a></h1>
<p>Macros are a special type of functions to be executed as a kind of
&quot;preprocessing stage&quot; at compile time. In Pure these are typically used to
define custom special forms and to perform inlining of function calls and
other simple kinds of source-level optimizations.</p>
<p>Whereas the macro facilities of most programming languages simply provide a
kind of textual substitution mechanism, Pure macros operate on symbolic
expressions and are implemented by the same kind of rewriting rules that are
also used to define ordinary functions in Pure. In difference to these, macro
rules start out with the keyword <tt class="docutils literal"><span class="pre">def</span></tt>, and only simple kinds of rules
without any guards or multiple left-hand and right-hand sides are permitted.</p>
<p>Syntactically, a macro definition looks just like a variable or constant
definition, using <tt class="docutils literal"><span class="pre">def</span></tt> in lieu of <tt class="docutils literal"><span class="pre">let</span></tt> or <tt class="docutils literal"><span class="pre">const</span></tt>, but they are
processed in a different way. Macros are substituted into the right-hand sides
of function, constant and variable definitions. All macro substitution happens
before constant substitutions and the actual compilation step. Macros can be
defined in terms of other macros (also recursively), and are evaluated using
call by value (i.e., macro calls in macro arguments are expanded before the
macro gets applied to its parameters).</p>
<div class="section" id="optimization-rules">
<h2><a class="toc-backref" href="#id30">6.1&nbsp;&nbsp;&nbsp;Optimization Rules</a></h2>
<p>Here is a simple example, showing a rule which expands saturated calls of the
<tt class="docutils literal"><span class="pre">succ</span></tt> function (defined in the prelude) at compile time:</p>
<pre class="literal-block">
&gt; def succ x = x+1;
&gt; foo x::int = succ (succ x);
&gt; show foo
foo x::int = x+1+1;
</pre>
<p>Rules like these can be useful to help the compiler generate better code. Note
that a macro may have the same name as an ordinary Pure function, which is
essential if you want to optimize calls to an existing function, as in the
previous example. (Just like ordinary functions, the number of parameters in
each rule for a given macro must be the same, but a macro may have a different
number of arguments than the corresponding function.)</p>
<p>A somewhat more practical example is the following rule from the prelude,
which eliminates saturated instances of the right-associative function
application operator:</p>
<pre class="literal-block">
def f $ x = f x;
</pre>
<p>Like in Haskell, this low-priority operator is handy to write cascading
function calls. With the above macro rule, these will be &quot;inlined&quot; as ordinary
function applications automagically. Example:</p>
<pre class="literal-block">
&gt; foo x = bar $ bar $ 2*x;
&gt; show foo
foo x = bar (bar (2*x));
</pre>
<p>Here are two slightly more tricky rules from the prelude, which optimize the
case of &quot;throwaway&quot; list comprehensions. This is useful if a list
comprehension is evaluated solely for its side effects:</p>
<pre class="literal-block">
def void (catmap f x) = do f x;
def void (listmap f x) = do f x;
</pre>
<p>Note that the <tt class="docutils literal"><span class="pre">void</span></tt> function simply throws away its argument and returns
<tt class="docutils literal"><span class="pre">()</span></tt> instead. The <tt class="docutils literal"><span class="pre">do</span></tt> function applies a function to every member of a
list (like <tt class="docutils literal"><span class="pre">map</span></tt>), but throws away all intermediate results and just returns
<tt class="docutils literal"><span class="pre">()</span></tt>, which is much more efficient if you don't need those results
anyway. These are both defined in the prelude.</p>
<p>Before we delve into this example, a few remarks are in order about the way
list comprehensions are implemented in Pure. As already mentioned, list
comprehensions are just syntactic sugar; the compiler immediately transforms
them to an equivalent expression involving only lambdas and a few other list
operations. Note that list comprehensions are essentially equivalent to piles
of nested lambdas, filters and maps, but for various reasons they are actually
implemented using two special helper operations, <tt class="docutils literal"><span class="pre">catmap</span></tt> and <tt class="docutils literal"><span class="pre">listmap</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">catmap</span></tt> operation combines <tt class="docutils literal"><span class="pre">map</span></tt> and <tt class="docutils literal"><span class="pre">cat</span></tt>; this is needed, in
particular, to accumulate the results of nested generators, such as <tt class="docutils literal"><span class="pre">[i,j</span> <span class="pre">|</span> <span class="pre">i</span>
<span class="pre">=</span> <span class="pre">1..n;</span> <span class="pre">j</span> <span class="pre">=</span> <span class="pre">1..m]</span></tt>. The same operation is also used to implement filter
clauses, you can see this below in the examples. However, for efficiency
simple generators like <tt class="docutils literal"><span class="pre">[2*i</span> <span class="pre">|</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1..n]</span></tt> are translated to a <tt class="docutils literal"><span class="pre">listmap</span></tt>
instead (which is basically just <tt class="docutils literal"><span class="pre">map</span></tt>, but works with different aggregate
types, so that list comprehensions can draw values from aggregates other than
lists, such as matrices).</p>
<p>Now let's see how the rules above transform a list comprehension if we
&quot;voidify&quot; it:</p>
<pre class="literal-block">
&gt; using system;
&gt; f = [printf &quot;%g\n&quot; (2^x+1) | x=1..5; x mod 2];
&gt; g = void [printf &quot;%g\n&quot; (2^x+1) | x=1..5; x mod 2];
&gt; show f g
f = catmap (\x -&gt; if x mod 2 then [printf &quot;%g\n&quot; (2^x+1)] else []) (1..5);
g = do (\x -&gt; if x mod 2 then [printf &quot;%g\n&quot; (2^x+1)] else []) (1..5);
</pre>
<p>Ok, so the <tt class="docutils literal"><span class="pre">catmap</span></tt> got replaced with a <tt class="docutils literal"><span class="pre">do</span></tt> which is just what we need to
make this code go essentially as fast as a <tt class="docutils literal"><span class="pre">for</span></tt> loop in conventional
programming languages (up to constant factors, of course). Here's how it looks
like when we run the <tt class="docutils literal"><span class="pre">g</span></tt> function:</p>
<pre class="literal-block">
&gt; g;
3
9
33
()
</pre>
<p>It's not all roses, however, since the above macro rules will only get rid of
the outermost <tt class="docutils literal"><span class="pre">catmap</span></tt> if the list comprehension binds multiple variables:</p>
<pre class="literal-block">
&gt; u = void [puts $ str (x,y) | x=1..2; y=1..3];
&gt; show u
u = do (\x -&gt; listmap (\y -&gt; puts (str (x,y))) (1..3)) (1..2);
</pre>
<p>If you're bothered by this, you'll have to apply <tt class="docutils literal"><span class="pre">void</span></tt> recursively,
creating a nested list comprehension which expands to a nested <tt class="docutils literal"><span class="pre">do</span></tt>:</p>
<pre class="literal-block">
&gt; v = void [void [puts $ str (x,y) | y=1..3] | x=1..2];
&gt; show v
v = do (\x -&gt; do (\y -&gt; puts (str (x,y))) (1..3)) (1..2);
</pre>
<p>(It would be nice to have this handled automatically, but the left-hand side
of a macro definition must be a simple expression, and thus it's not possible
to write a macro which descends recursively into the lambda argument of
<tt class="docutils literal"><span class="pre">catmap</span></tt>.)</p>
</div>
<div class="section" id="recursive-macros">
<h2><a class="toc-backref" href="#id31">6.2&nbsp;&nbsp;&nbsp;Recursive Macros</a></h2>
<p>Macros can also be recursive, in which case they usually consist of multiple
rules and make use of pattern-matching like ordinary function definitions. As
a simple example, let's implement a Pure version of Lisp's quasiquote which
allows you to create a quoted expression from a &quot;template&quot; while substituting
variable parts of the template. (For the sake of brevity, our definition is
somewhat simplified and does not cover some corner cases. See the Pure
distribution for a full version of this example.)</p>
<pre class="literal-block">
def quasiquote (unquote x)      = x;
def quasiquote (f&#64;_ (splice x)) = foldl ($) (quasiquote f) x;
def quasiquote (f&#64;_ x)          = quasiquote f (quasiquote x);
def quasiquote x                = quote x;
</pre>
<p>(Note the <tt class="docutils literal"><span class="pre">f&#64;_</span></tt>, which is an anonymous &quot;as&quot; pattern forcing the compiler to
recognize <tt class="docutils literal"><span class="pre">f</span></tt> as a function variable, rather than a literal function
symbol. See <a class="reference internal" href="#head-function">Head = Function</a> in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section for an
explanation of this trick.)</p>
<p>The first rule above takes care of &quot;unquoting&quot; embedded subterms. The second
rule &quot;splices&quot; an argument list into an enclosing function application. The
third rule recurses into subterms of a function application, and the fourth
and last rule takes care of quoting the &quot;atomic&quot; subterms. Note that
<tt class="docutils literal"><span class="pre">unquote</span></tt> and <tt class="docutils literal"><span class="pre">splice</span></tt> themselves are just passive constructor symbols,
the real work is done by <tt class="docutils literal"><span class="pre">quasiquote</span></tt>, using <tt class="docutils literal"><span class="pre">foldl</span></tt> at runtime to
actually perform the splicing. (Putting off the splicing until runtime makes
it possible to splice argument lists computed at runtime.)</p>
<p>If we want, we can also add some syntactic sugar for Lisp weenies. (Note that
we cannot have '<tt class="docutils literal"><span class="pre">,</span></tt>' for unquoting, so we use '<tt class="docutils literal"><span class="pre">,$</span></tt>' instead.)</p>
<pre class="literal-block">
prefix 9 ` ,$ ,&#64; ;
def `x = quasiquote x; def ,$x = unquote x; def ,&#64;x = splice x;
</pre>
<p>Examples:</p>
<pre class="literal-block">
&gt; `(2*42+2^12);
2*42+2^12
&gt; `(2*42+,$(2^12));
2*42+4096.0
&gt; `foo 1 2 (,&#64;'[2/3,3/4]) (5/6);
foo 1 2 (2/3) (3/4) (5/6)
&gt; `foo 1 2 (,&#64;'args) (5/6) when args = '[2/3,3/4] end;
foo 1 2 (2/3) (3/4) (5/6)
</pre>
<p>We mention in passing here that, technically, Pure macros are just as powerful
as (unconditional) term rewriting systems and thus they are
Turing-complete. This implies that a badly written macro may well send the
Pure compiler into an infinite recursion, which results in a stack overflow at
compile time. See the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section for information on how to
deal with these by setting the PURE_STACK environment variable.</p>
</div>
<div class="section" id="user-defined-special-forms">
<h2><a class="toc-backref" href="#id32">6.3&nbsp;&nbsp;&nbsp;User-Defined Special Forms</a></h2>
<p>The <tt class="docutils literal"><span class="pre">quasiquote</span></tt> macro in the preceding subsection also provides an example
of how you can use macros to define your own special forms. This works because
the actual evaluation of macro arguments is put off until runtime, and thus we
can safely pass them to built-in special forms and other constructs which
defer their evaluation at <em>runtime</em>. In fact, the right-hand side of a macro
rule may be an arbitrary Pure expression involving conditional expressions,
lambdas, binding clauses, etc. These are never evaluated during macro
substitution, they just become part of the macro expansion (after substituting
the macro parameters).</p>
<p>Here is another useful example of a user-defined special form, the macro
<tt class="docutils literal"><span class="pre">timex</span></tt> which employs the system function <tt class="docutils literal"><span class="pre">clock</span></tt> to report the cpu time
in seconds needed to evaluate a given expression, along with the computed
result:</p>
<pre class="literal-block">
&gt; using system;
&gt; def timex x = (clock-t0)/CLOCKS_PER_SEC,y when t0 = clock; y = x end;
&gt; sum = foldl (+) 0L;
&gt; timex $ sum (1L..100000L);
0.43,5000050000L
</pre>
<p>Note that the above definition of <tt class="docutils literal"><span class="pre">timex</span></tt> wouldn't work as an ordinary
function definition, since by virtue of Pure's basic eager evaluation strategy
the <tt class="docutils literal"><span class="pre">x</span></tt> parameter would have been evaluated already before it is passed to
<tt class="docutils literal"><span class="pre">timex</span></tt>, making <tt class="docutils literal"><span class="pre">timex</span></tt> always return a zero time value. Try it!</p>
<p>Here's yet another example, which is handy if you need to trace function
calls. (As of Pure 0.22, the interpreter now has its own built-in debugging
facility, see <a class="reference internal" href="#debugging">Debugging</a>. However, the following macro allows you to trace
functions using your own custom output format, and may thus be useful in
situations where the built-in debugger is not appropriate.)</p>
<pre class="literal-block">
using system;
def trace f x y = printf &quot;** exit %s: %s -&gt; %s\n&quot; (str f,str x,str y) $$ y
when y = printf &quot;** call %s: %s\n: &quot; (str f,str x) $$ gets $$ y end;
</pre>
<p>This macro is invoked with the function to be traced, the arguments (or
whatever you want to be printed as additional debugging information) and the
actual function call as parameters. (This is a rather simplistic version,
which just prints a prompt on function entry and the final reduction after the
call. You can easily make this as elaborate as you like. E.g., you might want
to keep track of recursive levels and profiling information, add various
interactive commands to selectively enable and disable tracing during the
evaluation, etc.)</p>
<p>We can still make this a bit more convenient by introducing the following
ordinary function definition:</p>
<pre class="literal-block">
trace f x = trace f x (f x);
</pre>
<p>This lets us patch up a call to trace a given function, as shown below,
without having to change the definition of the function at all. This trick
only works with global functions; for local functions you'll have to add an
explicit call of the <tt class="docutils literal"><span class="pre">trace</span></tt> macro to the local definition yourself. Also
note that the definition above only works with functions taking a single
parameter; see the trace.pure example in the distribution for the full version
which can deal with any number of arguments.</p>
<pre class="literal-block">
// Uncomment this line to trace calls to the 'fact' function.
def fact n = trace fact n;
// Sample function to be traced.
fact n = if n&gt;0 then n*fact(n-1) else 1;
</pre>
<p>Here's a trace of the <tt class="docutils literal"><span class="pre">fact</span></tt> function obtained in this fashion (hit carriage
return after each '<tt class="docutils literal"><span class="pre">:</span></tt>' prompt to proceed with the computation):</p>
<pre class="literal-block">
&gt; fact 2;
** call fact: 2
:
** call fact: 1
:
** call fact: 0
:
** exit fact: 0 -&gt; 1
** exit fact: 1 -&gt; 1
** exit fact: 2 -&gt; 2
2
</pre>
<p>Note that by just removing the macro definition for <tt class="docutils literal"><span class="pre">fact</span></tt> above, you can
make the function run untraced as usual again. This scheme is quite flexible,
the only real drawback is that you have to explicitly add some code for each
function you want to trace.</p>
</div>
<div class="section" id="macro-hygiene">
<h2><a class="toc-backref" href="#id33">6.4&nbsp;&nbsp;&nbsp;Macro Hygiene</a></h2>
<p>Pure macros are lexically scoped, i.e., symbols on the right-hand-side of a
macro definition can never refer to anything outside the macro definition, and
macro parameter substitution also takes into account binding constructs, such
as <tt class="docutils literal"><span class="pre">with</span></tt> and <tt class="docutils literal"><span class="pre">when</span></tt> clauses, in the right-hand side of the
definition. Macro facilities with these pleasant properties are also known as
<strong class="dfn">hygienic macros</strong>. They are not susceptible to so-called &quot;name capture,&quot; which
makes macros in less sophisticated languages bug-ridden and hard to use. (This
is explained in more detail in the <a class="reference internal" href="#hygienic-macros">Hygienic Macros</a> section.)</p>
<p>Pure macros also have their limitations. Specifically, the left-hand side of a
macro rule must be a simple expression, just like in ordinary function
definitions. This restricts the kinds of expressions which can be rewritten by
a macro. But Pure macros are certainly powerful enough for most common
preprocessing purposes, while still being robust and easy to use.</p>
</div>
</div>
<div class="section" id="declarations">
<h1><a class="toc-backref" href="#id34">7&nbsp;&nbsp;&nbsp;Declarations</a></h1>
<p>Pure is a very terse language by design. Usually you don't declare much stuff,
you just define it and be done with it. However, there are a few toplevel
constructs which let you declare symbols with special attributes and manage
programs consisting of several source modules:</p>
<ul class="simple">
<li>symbol declarations determine &quot;scope&quot; and &quot;fixity&quot; of a symbol;</li>
<li><tt class="docutils literal"><span class="pre">extern</span></tt> declarations specify external C functions (described in the
<a class="reference internal" href="#c-interface">C Interface</a> section);</li>
<li><tt class="docutils literal"><span class="pre">using</span></tt> clauses let you include other scripts in a Pure script;</li>
<li><tt class="docutils literal"><span class="pre">namespace</span></tt> declarations let you avoid name clashes and thereby make it
easier to manage large programs consisting of many separate modules.</li>
</ul>
<div class="section" id="symbol-declarations">
<h2><a class="toc-backref" href="#id35">7.1&nbsp;&nbsp;&nbsp;Symbol Declarations</a></h2>
<dl class="docutils">
<dt>Scope declarations: <tt class="docutils literal"><span class="pre">public</span> <span class="pre">symbol</span> <span class="pre">...;</span> <span class="pre">private</span> <span class="pre">symbol</span> <span class="pre">...;</span></tt></dt>
<dd><p class="first">Declares the listed symbols as public or private, respectively. All
identifiers without an explicit prior declaration default to public scope,
which means that they are visible everywhere in a program. An explicit
public declaration of ordinary identifiers is thus rarely needed, unless
you want to declare symbols as members of a specific namespace. Symbols
can also be declared private, meaning that the symbol is visible only in
the namespace it belongs to. This is explained in more detail under
<a class="reference internal" href="#namespaces">Namespaces</a> below.</p>
<p class="last">The <tt class="docutils literal"><span class="pre">public</span></tt> and <tt class="docutils literal"><span class="pre">private</span></tt> keywords can also be used as a prefix in
any of the special symbol declarations discussed below, to specify the
scope of the declared symbols (if the scope prefix is omitted, it defaults
to <tt class="docutils literal"><span class="pre">public</span></tt>). Also note that to declare multiple symbols in a single
declaration, you just list them all with whitespace in between. The same
applies to the other types of symbol declarations discussed below.</p>
</dd>
<dt>Operator declarations: <tt class="docutils literal"><span class="pre">infix</span> <span class="pre">level</span> <span class="pre">op</span> <span class="pre">...;</span></tt></dt>
<dd><p class="first">Ten different precedence levels are available for user-defined infix,
prefix and postfix operators, numbered 0 (lowest) thru 9 (highest). On
each precedence level, you can declare (in order of increasing precedence)
<tt class="docutils literal"><span class="pre">infix</span></tt> (binary non-associative), <tt class="docutils literal"><span class="pre">infixl</span></tt> (binary left-associative),
<tt class="docutils literal"><span class="pre">infixr</span></tt> (binary right-associative), <tt class="docutils literal"><span class="pre">prefix</span></tt> (unary prefix) and
<tt class="docutils literal"><span class="pre">postfix</span></tt> (unary postfix) operators. For instance:</p>
<pre class="literal-block">
infixl 6 + - ;
infixl 7 * / div mod ;
</pre>
<p class="last">One thing worth noting here is that unary minus plays a special role in
the syntax. Like in Haskell, unary minus is the only prefix operator
symbol which is also used as an infix operator, and it always has the same
precedence as binary minus (whose precedence may be chosen freely in the
prelude). Thus, with the standard prelude, <tt class="docutils literal"><span class="pre">-x+y</span></tt> will be parsed as
<tt class="docutils literal"><span class="pre">(-x)+y</span></tt>, whereas <tt class="docutils literal"><span class="pre">-x*y</span></tt> is the same as <tt class="docutils literal"><span class="pre">-(x*y)</span></tt>. Also note that the
notation <tt class="docutils literal"><span class="pre">(-)</span></tt> always denotes the binary minus operator; the unary minus
operation can be denoted using the built-in <tt class="docutils literal"><span class="pre">neg</span></tt> function.</p>
</dd>
<dt>Outfix symbol declarations: <tt class="docutils literal"><span class="pre">outfix</span> <span class="pre">left</span> <span class="pre">right</span> <span class="pre">...;</span></tt></dt>
<dd><p class="first">Pure also provides unary outfix operators, which work like in Wm Leler's
constraint programming language <a class="reference internal" href="#bertrand">Bertrand</a>. Outfix operators let you define
your own bracket structures. The operators must be given as pairs of
matching left and right symbols. For instance:</p>
<pre class="literal-block">
outfix |: :| BEGIN END;
</pre>
<p class="last">After this declaration you can write bracketed expressions like <tt class="docutils literal"><span class="pre">|:x:|</span></tt>
or <tt class="docutils literal"><span class="pre">BEGIN</span> <span class="pre">foo,</span> <span class="pre">bar</span> <span class="pre">END</span></tt>. These are always at the highest precedence
level (i.e., syntactically they work like parenthesized expressions). Just
like other operators, you can turn outfix symbols into ordinary functions
by enclosing them in parentheses, but you have to specify the symbols in
matching pairs, such as <tt class="docutils literal"><span class="pre">(BEGIN</span> <span class="pre">END)</span></tt>.</p>
</dd>
<dt>Constant symbol declarations: <tt class="docutils literal"><span class="pre">nonfix</span> <span class="pre">symbol</span> <span class="pre">...;</span></tt></dt>
<dd><p class="first">Pure also has a notation for &quot;nullary&quot; operators, i.e., &quot;operators without
operands&quot;, which are used to denote special constants. These are
introduced using a <tt class="docutils literal"><span class="pre">nonfix</span></tt> declaration, e.g.:</p>
<pre class="literal-block">
nonfix red green blue;
</pre>
<p>Syntactically, these work just like ordinary identifiers, so they may
stand whereever an identifier is allowed (no parentheses are required to
&quot;escape&quot; them). The difference to ordinary identifiers is that nonfix
symbols are always interpreted as literals, even if they occur in a
variable position on the left-hand side of a rule. So, with the above
declaration, you can write something like:</p>
<pre class="literal-block">
&gt; foo x = case x of red = green; green = blue; blue = red end;
&gt; map foo [red,green,blue];
[green,blue,red]
</pre>
<p>Thus, on the syntactic level, nonfix symbols are pretty much like nullary
constructor symbols in languages like Haskell. However, Pure doesn't
enforce that such values are really &quot;constant&quot;, so you can still write a
&quot;constructor equation&quot; like the following:</p>
<pre class="last literal-block">
&gt; red = blue;
&gt; map foo [red,green,blue];
[blue,blue,blue]
</pre>
</dd>
</dl>
<p>Examples for all types of symbol declarations can be found in the prelude
which declares a bunch of standard (arithmetic, relational, logical) operator
symbols as well as the list and pair constructors '<tt class="docutils literal"><span class="pre">:</span></tt>' and '<tt class="docutils literal"><span class="pre">,</span></tt>', and a
few nonfix symbols (mostly for denoting different kinds of exceptions).</p>
</div>
<div class="section" id="modules-and-imports">
<h2><a class="toc-backref" href="#id36">7.2&nbsp;&nbsp;&nbsp;Modules and Imports</a></h2>
<dl class="docutils">
<dt>Using clause: <tt class="docutils literal"><span class="pre">using</span> <span class="pre">name,</span> <span class="pre">...;</span></tt></dt>
<dd>Causes each given script to be included in the Pure program. Each included
script is loaded only once, when the first <tt class="docutils literal"><span class="pre">using</span></tt> clause for the script
is encountered. Note that the <tt class="docutils literal"><span class="pre">using</span></tt> clause also has an alternative
form which allows dynamic libraries to be loaded, this will be discussed
in the <a class="reference internal" href="#c-interface">C Interface</a> section.</dd>
</dl>
<p>While Pure doesn't offer separate compilation, the <tt class="docutils literal"><span class="pre">using</span></tt> declaration
provides a simple but effective way to assemble a Pure program from several
source modules. A Pure program is basically the concatenation of all the
source modules listed as command line arguments. A <tt class="docutils literal"><span class="pre">using</span></tt> clause instructs
the compiler to include the corresponding source script at this point (if it
wasn't already included before), which makes available all the definitions in
the included script in your program.</p>
<p>For instance, the following declaration causes the math.pure script from the
standard library to be included in your program:</p>
<pre class="literal-block">
using math;
</pre>
<p>You can also import multiple scripts in one go:</p>
<pre class="literal-block">
using array, dict, set;
</pre>
<p>Moreover, Pure provides a notation for qualified module names which can be
used to denote scripts located in specific package directories, e.g.:</p>
<pre class="literal-block">
using examples::libor::bits;
</pre>
<p>In fact this is equivalent to the following <tt class="docutils literal"><span class="pre">using</span></tt> clause which spells out
the real filename of the script:</p>
<pre class="literal-block">
using &quot;examples/libor/bits.pure&quot;;
</pre>
<p>Both notations can be used interchangeably; the former is usually more
convenient, but the latter allows you to denote scripts whose names aren't
valid Pure identifiers.</p>
<p>Script identifiers are translated to the corresponding filenames by replacing
the <tt class="docutils literal"><span class="pre">::</span></tt> symbol with the pathname separator <tt class="docutils literal"><span class="pre">/</span></tt> and tacking on the
<tt class="docutils literal"><span class="pre">.pure</span></tt> suffix. The following table illustrates this with a few examples.</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Script identifier</th>
<th class="head">Filename</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">math</span></tt></td>
<td><tt class="docutils literal"><span class="pre">&quot;math.pure&quot;</span></tt></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">examples::libor::bits</span></tt></td>
<td><tt class="docutils literal"><span class="pre">&quot;examples/libor/bits.pure&quot;</span></tt></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">::pure::examples::hello</span></tt></td>
<td><tt class="docutils literal"><span class="pre">&quot;/pure/examples/hello.pure&quot;</span></tt></td>
</tr>
</tbody>
</table>
<p>Note the last example, which shows how an absolute pathname can be denoted
using a qualifier starting with '<tt class="docutils literal"><span class="pre">::</span></tt>'.</p>
<p>Unless an absolute pathname is given, the interpreter performs a search to
locate the script. It first searches the directory of the script containing
the <tt class="docutils literal"><span class="pre">using</span></tt> clause (or the current working directory if the clause was read
from standard input, as is the case, e.g., in an interactive session), then
the directories named in -I options on the command line (in the given order),
then the colon-separated list of directories in the PURE_INCLUDE environment
variable, and finally the directory named by the PURELIB environment
variable. Note that the current working directory is not searched by default
(unless the <tt class="docutils literal"><span class="pre">using</span></tt> clause is read from standard input), but of course you
can force this by adding the option -I. to the command line, or by including
'.' in the PURE_INCLUDE variable.</p>
<p>For the purpose of comparing script names (to determine whether two scripts
are actually the same), the interpreter always uses the canonicalized full
pathname of the script, following symbolic links to the destination file
(albeit only one level). Thus different scripts with the same basename, such
as foo/utils.pure and bar/utils.pure can both be included in the same program
(unless they link to the same file).</p>
<p>The directory of the canonicalized pathname is also used when searching other
scripts included in a script. This makes it possible to have an executable
script with a shebang line in its own directory, which is then executed via a
symbolic link placed on the system PATH. In this case the script search
performed in <tt class="docutils literal"><span class="pre">using</span></tt> clauses will use the real script directory and thus
other required scripts can be located there. This is the recommended practice
for installing standalone Pure applications in source form which are to be run
directly from the shell.</p>
</div>
<div class="section" id="namespaces">
<h2><a class="toc-backref" href="#id37">7.3&nbsp;&nbsp;&nbsp;Namespaces</a></h2>
<dl class="docutils">
<dt>Namespace declarations: <tt class="docutils literal"><span class="pre">namespace</span> <span class="pre">name;</span> <span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">name,</span> <span class="pre">...;</span></tt></dt>
<dd>These declarations allow you to create new namespaces and then later use
them in your program.</dd>
</dl>
<p>To facilitate modular development, Pure also provides namespaces as a means to
avoid name clashes between symbols, and to keep the global namespace tidy and
clean. Namespaces serve as containers holding logical groups of identifiers
and other symbols. Inside each namespace, symbols must be unique, but the same
symbol may be used to denote different objects (variables, functions, etc.) in
different namespaces.</p>
<p>The global namespace is always available. By default, new symbols are created
in this namespace, which is also called the <strong class="dfn">default namespace</strong>. Additional
namespaces can be created with the <tt class="docutils literal"><span class="pre">namespace</span></tt> declaration, which also
switches to the given namespace (makes it the <em>current</em> namespace), so that
subsequent symbol declarations create symbols in that namespace rather than
the default one. The current namespace applies to all kinds of symbol
declarations, including operator and constant symbol declarations, as well as
<tt class="docutils literal"><span class="pre">extern</span></tt> declarations (the latter are described in the <a class="reference internal" href="#c-interface">C Interface</a>
section).</p>
<p>For instance, in order to create two symbols with the same print name <tt class="docutils literal"><span class="pre">foo</span></tt>
in two different namespaces <tt class="docutils literal"><span class="pre">foo</span></tt> and <tt class="docutils literal"><span class="pre">bar</span></tt>, you can write:</p>
<pre class="literal-block">
namespace foo;
public foo;
foo x = x+1;
namespace bar;
public foo;
foo x = x-1;
namespace;
</pre>
<p>Note that just the <tt class="docutils literal"><span class="pre">namespace</span></tt> keyword by itself in the last line switches
back to the default namespace. We can now refer to the symbols we just defined
using <strong class="dfn">qualified symbols</strong> of the form <tt class="docutils literal"><span class="pre">namespace::symbol</span></tt>:</p>
<pre class="literal-block">
&gt; foo::foo 99;
100
&gt; bar::foo 99;
98
</pre>
<p>This avoids any potential name clashes, since the qualified identifier
notation always makes it clear which namespace the given identifier belongs
to.</p>
<p>Similar to the <tt class="docutils literal"><span class="pre">using</span></tt> declaration, a <tt class="docutils literal"><span class="pre">namespace</span></tt> declaration accepts
either identifiers or double-quoted strings as namespace names. E.g., the
following two declarations are equivalent:</p>
<pre class="literal-block">
namespace foo;
namespace &quot;foo&quot;;
</pre>
<p>The latter form also allows more descriptive labels which aren't identifiers,
e.g.:</p>
<pre class="literal-block">
namespace &quot;Private stuff, keep out!&quot;;
</pre>
<p>(Note that the namespace prefix in a qualified identifier must be a legal
identifier, so it isn't possible to access symbols in namespaces with such
descriptive labels in a direct fashion; the only way to get at the symbols in
this case is to use a <tt class="docutils literal"><span class="pre">namespace</span></tt> or <tt class="docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt> declaration, as
described below.)</p>
</div>
<div class="section" id="using-namespaces">
<h2><a class="toc-backref" href="#id38">7.4&nbsp;&nbsp;&nbsp;Using Namespaces</a></h2>
<p>Since it is rather inconvenient if you always have to write identifiers in
their qualified form, Pure allows you to specify a list of <em>search</em> namespaces
which are used to look up symbols not in the default or the current
namespace. This is done with the <tt class="docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt> declaration, as follows:</p>
<pre class="literal-block">
&gt; using namespace foo;
&gt; foo 99;
100
&gt; using namespace bar;
&gt; foo 99;
98
</pre>
<p>The <tt class="docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt> declaration also lets you search multiple namespaces
simultaneously:</p>
<pre class="literal-block">
using namespace foo, bar;
</pre>
<p>However, this requires that a symbol exists in at most one of the listed
namespaces, otherwise you get an error message:</p>
<pre class="literal-block">
&gt; using namespace foo, bar;
&gt; foo 99;
&lt;stdin&gt;, line 15: symbol 'foo' is ambiguous here
</pre>
<p>In such a case you have to use the appropriate namespace qualifier to resolve
the name clash:</p>
<pre class="literal-block">
&gt; foo::foo 99;
100
</pre>
<p>A <tt class="docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt> declaration without any namespace arguments gets you
back to the default empty list of search namespaces:</p>
<pre class="literal-block">
using namespace;
</pre>
<p>The precise rules for looking up symbols are as follows. The compiler searches
for symbols first in the current namespace (if any), then in the currently
active search namespaces (if any), and finally in the default (i.e., the
global) namespace, in that order. This automatic lookup can be bypassed by
using an <em>absolute</em> namespace qualifier of the form <tt class="docutils literal"><span class="pre">::foo::bar</span></tt>. In
particular, <tt class="docutils literal"><span class="pre">::bar</span></tt> always denotes the symbol <tt class="docutils literal"><span class="pre">bar</span></tt> in the default
namespace, while <tt class="docutils literal"><span class="pre">::foo::bar</span></tt> denotes the symbol <tt class="docutils literal"><span class="pre">bar</span></tt> in the <tt class="docutils literal"><span class="pre">foo</span></tt>
namespace. (Normally, the latter kind of notation is only needed if you have
to deal with nested namespaces, see <a class="reference internal" href="#hierarchical-namespaces">Hierarchical Namespaces</a> below.)</p>
<p>If no existing symbol is found, a new symbol is created, implicitly declaring
the identifier as a public symbol with default attributes. New <em>unqualified</em>
symbols are always created in the default namespace, unless you explicitly
declare them (in which case they become members of the current namespace, as
explained above). New <em>qualified</em> symbols are created in the given namespace,
which <em>must</em> be the current namespace. This makes it possible to avoid
explicit symbol declarations in the most common case of ordinary, public
identifiers. E.g., we could have written the above example simply as follows:</p>
<pre class="literal-block">
namespace foo;
foo::foo x = x+1;
namespace bar;
bar::foo x = x-1;
namespace;
</pre>
<p>Note that, as a little safety measure against silly typos, the compiler
insists that new qualified symbols <em>must</em> be introduced in their &quot;home&quot;
namespace, otherwise it complains about an undeclared symbol:</p>
<pre class="literal-block">
&gt; namespace;
&gt; foo::bar x = 1/x;
&lt;stdin&gt;, line 7: undeclared symbol 'foo::bar'
</pre>
<p>To avoid such errors, you either have to use an explicit declaration or make
sure that the right namespace is current when introducing the symbol.</p>
<p>Explicit declarations <em>must</em> be used if you want to introduce special operator
and constant symbols. This works just like in the default namespace, except
that you add the appropriate <tt class="docutils literal"><span class="pre">namespace</span></tt> declaration before declaring the
symbols. For instance, here is how you can create a new <tt class="docutils literal"><span class="pre">+</span></tt> operation which
multiplies its operands rather than adding them:</p>
<pre class="literal-block">
&gt; namespace my;
&gt; infixl 6 +;
&gt; x+y = x*y;
&gt; 5+7;
35
</pre>
<p>Note that the new <tt class="docutils literal"><span class="pre">+</span></tt> operation really belongs to the namespace we
created. The <tt class="docutils literal"><span class="pre">+</span></tt> operation in the default namespace works as before, and in
fact you can use qualified symbols to pick the version that you need:</p>
<pre class="literal-block">
&gt; namespace;
&gt; 5+7;
12
&gt; 5 ::+ 7;
12
&gt; 5 my::+ 7;
35
</pre>
</div>
<div class="section" id="private-symbols">
<h2><a class="toc-backref" href="#id39">7.5&nbsp;&nbsp;&nbsp;Private Symbols</a></h2>
<p>Pure also allows you to have private symbols, as a means to hide away internal
operations which shouldn't be accessed directly outside the namespace in which
they are declared. The scope of a private symbol is confined to its namespace,
i.e., the symbol is only visible when its &quot;home&quot; namespace is current. Symbols
are declared private by using the <tt class="docutils literal"><span class="pre">private</span></tt> keyword in the symbol
declaration:</p>
<pre class="literal-block">
&gt; namespace secret;
&gt; private baz;
&gt; // 'baz' is a private symbol in namespace 'secret' here
&gt; baz x = 2*x;
&gt; // you can use 'baz' just like any other symbol here
&gt; baz 99;
198
&gt; namespace;
</pre>
<p>Note that, at this point, <tt class="docutils literal"><span class="pre">secret::baz</span></tt> is now invisible, even if you have
<tt class="docutils literal"><span class="pre">secret</span></tt> in the search namespace list:</p>
<pre class="literal-block">
&gt; using namespace secret;
&gt; // this actually creates a 'baz' symbol in the default namespace:
&gt; baz 99;
baz 99
&gt; secret::baz 99;
&lt;stdin&gt;, line 27: symbol 'secret::baz' is private here
</pre>
<p>The only way to bring the symbol back into scope is to make the <tt class="docutils literal"><span class="pre">secret</span></tt>
namespace current again:</p>
<pre class="literal-block">
&gt; namespace secret;
&gt; baz 99;
198
&gt; secret::baz 99;
198
</pre>
</div>
<div class="section" id="hierarchical-namespaces">
<h2><a class="toc-backref" href="#id40">7.6&nbsp;&nbsp;&nbsp;Hierarchical Namespaces</a></h2>
<p>Namespace identifiers can themselves be qualified identifiers in Pure, which
enables you to introduce a hierarchy of namespaces. This is useful, e.g., to
group related namespaces together under a common &quot;umbrella&quot; namespace:</p>
<pre class="literal-block">
namespace my;
namespace my::old;
my::old::foo x = x+1;
namespace my::new;
my::new::foo x = x-1;
</pre>
<p>Note that the namespace <tt class="docutils literal"><span class="pre">my</span></tt>, which serves as the parent namespace, must be
created before the <tt class="docutils literal"><span class="pre">my::old</span></tt> and <tt class="docutils literal"><span class="pre">my::new</span></tt> namespaces, even if it does not
contain any symbols of its own. After these declarations, the <tt class="docutils literal"><span class="pre">my::old</span></tt> and
<tt class="docutils literal"><span class="pre">my::new</span></tt> namespaces are part of the <tt class="docutils literal"><span class="pre">my</span></tt> namespace and will be considered
in name lookup accordingly, so that you can write:</p>
<pre class="literal-block">
&gt; using namespace my;
&gt; old::foo 99;
100
&gt; new::foo 99;
98
</pre>
<p>This works pretty much like a hierarchy of directories and files, where the
namespaces play the role of the directories (with the default namespace as the
root directory), the symbols in each namespace correspond to the files in a
directory, and the <tt class="docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt> declaration functions similar to the
shell's <tt class="docutils literal"><span class="pre">PATH</span></tt> variable.</p>
<p>Sometimes it is necessary to tell the compiler to use a symbol in a specific
namespace, bypassing the usual symbol lookup mechanism. For instance, suppose
that we introduce another <em>global</em> <tt class="docutils literal"><span class="pre">old</span></tt> namespace and define yet another
version of <tt class="docutils literal"><span class="pre">foo</span></tt> in that namespace:</p>
<pre class="literal-block">
namespace old;
public foo;
foo x = 2*x;
namespace;
</pre>
<p>Now, if we want to access that function, with <tt class="docutils literal"><span class="pre">my</span></tt> still active as the
search namespace, we cannot simply refer to the new function as <tt class="docutils literal"><span class="pre">old::foo</span></tt>,
since this name will resolve to <tt class="docutils literal"><span class="pre">my::old::foo</span></tt> instead. As a remedy, the
compiler accepts an <strong class="dfn">absolute</strong> qualified identifier of the form
<tt class="docutils literal"><span class="pre">::old::foo</span></tt>. This bypasses name lookup and thus always yields exactly the
symbol in the given namespace (if it exists; as mentioned previously, the
compiler will complain about an undeclared symbol otherwise):</p>
<pre class="literal-block">
&gt; old::foo 99;
100
&gt; ::old::foo 99;
198
</pre>
<p>Also note that, as a special case of the absolute qualifier notation,
<tt class="docutils literal"><span class="pre">::foo</span></tt> always denotes the symbol <tt class="docutils literal"><span class="pre">foo</span></tt> in the default namespace.</p>
</div>
</div>
<div class="section" id="exception-handling">
<h1><a class="toc-backref" href="#id41">8&nbsp;&nbsp;&nbsp;Exception Handling</a></h1>
<p>Pure also offers a useful exception handling facility. To raise an exception,
you just invoke the built-in function <tt class="docutils literal"><span class="pre">throw</span></tt> with the value to be thrown as
the argument. To catch an exception, you use the built-in special form
<tt class="docutils literal"><span class="pre">catch</span></tt> with the exception handler (a function to be applied to the
exception value) as the first and the expression to be evaluated as the second
(call-by-name) argument. For instance:</p>
<pre class="literal-block">
&gt; catch error (throw hello_world);
error hello_world
</pre>
<p>Exceptions are also generated by the runtime system if the program runs out of
stack space, when a guard does not evaluate to a truth value, and when the
subject term fails to match the pattern in a pattern-matching lambda
abstraction, or a <tt class="docutils literal"><span class="pre">let</span></tt>, <tt class="docutils literal"><span class="pre">case</span></tt> or <tt class="docutils literal"><span class="pre">when</span></tt> construct. These types of
exceptions are reported using the symbols <tt class="docutils literal"><span class="pre">stack_fault</span></tt>, <tt class="docutils literal"><span class="pre">failed_cond</span></tt> and
<tt class="docutils literal"><span class="pre">failed_match</span></tt>, respectively, which are declared as constant symbols in the
standard prelude. You can use <tt class="docutils literal"><span class="pre">catch</span></tt> to handle these kinds of exceptions
just like any other. For instance:</p>
<pre class="literal-block">
&gt; fact n = if n&gt;0 then n*fact(n-1) else 1;
&gt; catch error (fact foo);
error failed_cond
&gt; catch error (fact 100000);
error stack_fault
</pre>
<p>(You'll only get the latter kind of exception if the interpreter does stack
checks, see the discussion of the PURE_STACK environment variable in the
<a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section.)</p>
<p>Note that unhandled exceptions are reported by the interpreter with a
corresponding error message:</p>
<pre class="literal-block">
&gt; fact foo;
&lt;stdin&gt;, line 2: unhandled exception 'failed_cond' while evaluating 'fact foo'
</pre>
<p>Exceptions also provide a way to handle asynchronous signals. Pure's system
module provides symbolic constants for common POSIX signals and also defines
the operation <tt class="docutils literal"><span class="pre">trap</span></tt> which lets you rebind any signal to a signal
exception. For instance, the following lets you handle the <tt class="docutils literal"><span class="pre">SIGQUIT</span></tt>
signal:</p>
<pre class="literal-block">
&gt; using system;
&gt; trap SIG_TRAP SIGQUIT;
</pre>
<p>You can also use <tt class="docutils literal"><span class="pre">trap</span></tt> to just ignore a signal or revert to the system's
default handler (which might take different actions depending on the type of
signal, see signal(7) for details):</p>
<pre class="literal-block">
&gt; trap SIG_IGN SIGQUIT; // signal is ignored
&gt; trap SIG_DFL SIGQUIT; // reinstalls the default signal handler
</pre>
<p>Note that when the interpreter runs interactively, for convenience most
standard termination signals (<tt class="docutils literal"><span class="pre">SIGINT</span></tt>, <tt class="docutils literal"><span class="pre">SIGTERM</span></tt>, etc.) are already set
up to produce corresponding Pure exceptions of the form <tt class="docutils literal"><span class="pre">signal</span> <span class="pre">SIG</span></tt> where
<tt class="docutils literal"><span class="pre">SIG</span></tt> is the signal number.</p>
<p>Last but not least, exceptions can also be used to implement non-local value
returns. For instance, here's a variation of our n queens algorithm which only
returns the first solution. Note the use of <tt class="docutils literal"><span class="pre">throw</span></tt> in the recursive search
routine to bail out with a solution as soon as we found one. The value thrown
there is caught in the main routine. Also note the use of <tt class="docutils literal"><span class="pre">void</span></tt> in the
second equation of <tt class="docutils literal"><span class="pre">search</span></tt>. This effectively turns the list comprehension
into a simple loop which suppresses the normal list result and just returns
<tt class="docutils literal"><span class="pre">()</span></tt> instead. Thus, if no value gets thrown then the function regularly
returns with <tt class="docutils literal"><span class="pre">()</span></tt> to indicate that there is no solution.</p>
<pre class="literal-block">
queens n       = catch reverse (search n 1 []) with
  search n i p = throw p if i&gt;n;
               = void [search n (i+1) ((i,j):p) | j = 1..n; safe (i,j) p];
  safe (i,j) p = ~any (check (i,j)) p;
  check (i1,j1) (i2,j2)
               = i1==i2 || j1==j2 || i1+j1==i2+j2 || i1-j1==i2-j2;
end;
</pre>
<p>E.g., let's compute a solution for a standard 8x8 board:</p>
<pre class="literal-block">
&gt; queens 8;
[(1,1),(2,5),(3,8),(4,6),(5,3),(6,7),(7,2),(8,4)]
</pre>
</div>
<div class="section" id="c-interface">
<h1><a class="toc-backref" href="#id42">9&nbsp;&nbsp;&nbsp;C Interface</a></h1>
<p>Accessing C functions from Pure programs is dead simple. You just need an
<tt class="docutils literal"><span class="pre">extern</span></tt> declaration of the function, which is a simplified kind of C
prototype. The function can then be called in Pure just like any other. For
instance, the following commands, entered interactively in the interpreter,
let you use the <tt class="docutils literal"><span class="pre">sin</span></tt> function from the C library (of course you could just
as well put the <tt class="docutils literal"><span class="pre">extern</span></tt> declaration into a script):</p>
<pre class="literal-block">
&gt; extern double sin(double);
&gt; sin 0.3;
0.29552020666134
</pre>
<p>An <tt class="docutils literal"><span class="pre">extern</span></tt> declaration can also be prefixed with a <tt class="docutils literal"><span class="pre">public</span></tt>/<tt class="docutils literal"><span class="pre">private</span></tt>
scope specifier:</p>
<pre class="literal-block">
private extern double sin(double);
</pre>
<p>Multiple prototypes can be given in one <tt class="docutils literal"><span class="pre">extern</span></tt> declaration, separating
them with commas:</p>
<pre class="literal-block">
extern double sin(double), double cos(double), double tan(double);
</pre>
<p>For clarity, the parameter types can also be annotated with parameter names,
e.g.:</p>
<pre class="literal-block">
extern double sin(double x);
</pre>
<p>Parameter names in prototypes only serve informational purposes and are for
the human reader; they are effectively treated as comments by the compiler.</p>
<p>The interpreter makes sure that the parameters in a call match; if not, the
call is treated as a normal form expression by default, which gives you the
opportunity to extend the external function with your own Pure equations (see
below). The range of supported C types is a bit limited right now (<tt class="docutils literal"><span class="pre">void</span></tt>,
<tt class="docutils literal"><span class="pre">bool</span></tt>, <tt class="docutils literal"><span class="pre">char</span></tt>, <tt class="docutils literal"><span class="pre">short</span></tt>, <tt class="docutils literal"><span class="pre">int</span></tt>, <tt class="docutils literal"><span class="pre">long</span></tt>, <tt class="docutils literal"><span class="pre">float</span></tt>, <tt class="docutils literal"><span class="pre">double</span></tt>, as
well as arbitrary pointer types, i.e.: <tt class="docutils literal"><span class="pre">void*</span></tt>, <tt class="docutils literal"><span class="pre">char*</span></tt>, etc.), but in
practice these should cover most kinds of calls that need to be done when
interfacing to C libraries.</p>
<p>Single precision float arguments and return values are converted from/to
Pure's double precision floating point numbers automatically.</p>
<p>A variety of C integer types (<tt class="docutils literal"><span class="pre">char</span></tt>, <tt class="docutils literal"><span class="pre">short</span></tt>, <tt class="docutils literal"><span class="pre">int</span></tt>, <tt class="docutils literal"><span class="pre">long</span></tt>) are
provided which are converted from/to the available Pure integer types in a
straightforward way. In addition, the synonyms <tt class="docutils literal"><span class="pre">int8</span></tt>, <tt class="docutils literal"><span class="pre">int16</span></tt> and
<tt class="docutils literal"><span class="pre">int32</span></tt> are provided for <tt class="docutils literal"><span class="pre">char</span></tt>, <tt class="docutils literal"><span class="pre">short</span></tt> and <tt class="docutils literal"><span class="pre">int</span></tt>, respectively, and
<tt class="docutils literal"><span class="pre">int64</span></tt> denotes 64 bit integers (a.k.a. ISO C99 <tt class="docutils literal"><span class="pre">long</span> <span class="pre">long</span></tt>). Note that
<tt class="docutils literal"><span class="pre">long</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">int32</span></tt> on 32 bit systems, whereas it is the same
as <tt class="docutils literal"><span class="pre">int64</span></tt> on most 64 bit systems. All integer parameters take both Pure
ints and bigints as actual arguments; truncation or sign extension is
performed as needed, so that the C interface behaves as if the argument was
&quot;cast&quot; to the C target type. Returned integers use the smallest Pure type
capable of holding the result, i.e., int for the C <tt class="docutils literal"><span class="pre">char</span></tt>, <tt class="docutils literal"><span class="pre">short</span></tt> and
<tt class="docutils literal"><span class="pre">int</span></tt> types, bigint for <tt class="docutils literal"><span class="pre">int64</span></tt>.</p>
<p>To make it easier to interface to various system routines, there's also a
special <tt class="docutils literal"><span class="pre">size_t</span></tt> integer type which usually is 4 bytes on 32 bit and 8 bytes
on 64 bit systems.</p>
<p>Pure considers all integers as signed quantities, but it is possible to pass
unsigned integers as well (if necessary, you can use a bigint to pass positive
values which are too big to fit into a machine int). Also note that when an
unsigned integer is returned by a C routine, which is too big to fit into the
corresponding signed integer type, it will &quot;wrap around&quot; and become
negative. In this case, depending on the target type, you can use the
<tt class="docutils literal"><span class="pre">ubyte</span></tt>, <tt class="docutils literal"><span class="pre">ushort</span></tt>, <tt class="docutils literal"><span class="pre">uint</span></tt>, <tt class="docutils literal"><span class="pre">ulong</span></tt> and <tt class="docutils literal"><span class="pre">uint64</span></tt> functions provided
by the prelude to convert the result back to an unsigned quantity.</p>
<p>Concerning the pointer types, <tt class="docutils literal"><span class="pre">char*</span></tt> is for string arguments and return
values which need translation between Pure's internal utf-8 representation and
the system encoding, while <tt class="docutils literal"><span class="pre">void*</span></tt> is for any generic kind of pointer
(including strings, which are not translated when passed/returned as
<tt class="docutils literal"><span class="pre">void*</span></tt>). Any other kind of pointer (except <tt class="docutils literal"><span class="pre">expr*</span></tt> and the GSL matrix
pointer types, which are discussed below) is effectively treated as <tt class="docutils literal"><span class="pre">void*</span></tt>
right now, although in a future version the interpreter may keep track of the
type names for the purpose of checking parameter types.</p>
<p>The <tt class="docutils literal"><span class="pre">expr*</span></tt> pointer type is special; it indicates a Pure expression
parameter or return value which is just passed through unchanged. All other
types of values have to be &quot;unboxed&quot; when they are passed as arguments (i.e.,
from Pure to C) and &quot;boxed&quot; again when they are returned as function results
(from C to Pure). All of this is handled by the runtime system in a
transparent way, of course.</p>
<p>The matrix pointer types <tt class="docutils literal"><span class="pre">dmatrix*</span></tt>, <tt class="docutils literal"><span class="pre">cmatrix*</span></tt> and <tt class="docutils literal"><span class="pre">imatrix*</span></tt> can be
used to pass double, complex double and int matrices to GSL functions taking
pointers to the corresponding GSL types (<tt class="docutils literal"><span class="pre">gsl_matrix</span></tt>,
<tt class="docutils literal"><span class="pre">gsl_matrix_complex</span></tt> and <tt class="docutils literal"><span class="pre">gsl_matrix_int</span></tt>) as arguments or returning them
as results. Note that there is no marshalling of Pure's symbolic matrix type,
as these aren't supported by GSL anyway. Also note that matrices are always
passed by reference. If you need to pass a matrix as an output parameter of a
GSL matrix routine, you can either create a zero matrix or a copy of an
existing matrix. The prelude provides various operations for that purpose (in
particular, see the <tt class="docutils literal"><span class="pre">dmatrix</span></tt>, <tt class="docutils literal"><span class="pre">cmatrix</span></tt>, <tt class="docutils literal"><span class="pre">imatrix</span></tt> and <tt class="docutils literal"><span class="pre">pack</span></tt>
functions in matrices.pure). For instance, here is how you can quickly wrap up
GSL's double matrix addition function in a way that preserves value
semantics:</p>
<pre class="literal-block">
&gt; extern int gsl_matrix_add(dmatrix*, dmatrix*);
&gt; x::matrix + y::matrix = gsl_matrix_add x y $$ x when x = pack x end;
&gt; let x = dmatrix {1,2,3}; let y = dmatrix {2,3,2}; x; y; x+y;
{1.0,2.0,3.0}
{2.0,3.0,2.0}
{3.0,5.0,5.0}
</pre>
<p>Most GSL matrix routines can be wrapped in this fashion quite easily. A
ready-made GSL interface providing access to all of GSL's numeric functions is
in the works; please check the Pure website for details.</p>
<p>For convenience, it is also possible to pass a numeric matrix for a
<tt class="docutils literal"><span class="pre">short*</span></tt>, <tt class="docutils literal"><span class="pre">int*</span></tt>, <tt class="docutils literal"><span class="pre">float*</span></tt> or <tt class="docutils literal"><span class="pre">double*</span></tt> parameter. The required
conversions are done automatically, on the fly, and the matrix data is copied
to temporary storage in order to preserve value sematics.</p>
<p>In addition, any kind of matrix (including symbolic matrices) can also be
passed for a generic <tt class="docutils literal"><span class="pre">void*</span></tt> pointer. In this case no conversions are done
and a pointer to the raw matrix data is passed, which allows the matrix to be
modified in-place. Similarly, <tt class="docutils literal"><span class="pre">void*</span></tt> also allows you to pass a bigint
argument as a raw <tt class="docutils literal"><span class="pre">mpz_t</span></tt> value. This makes it possible to call most GMP
integer routines directly from Pure.</p>
<p>As already mentioned, it is possible to augment an external C function with
ordinary Pure equations, but in this case you have to make sure that the
<tt class="docutils literal"><span class="pre">extern</span></tt> declaration of the function comes first. For instance, we might
want to extend our imported <tt class="docutils literal"><span class="pre">sin</span></tt> function with a rule to handle integers:</p>
<pre class="literal-block">
&gt; extern double sin(double);
&gt; sin 0.3;
0.29552020666134
&gt; sin 0;
sin 0
&gt; sin x::int = sin (double x);
&gt; sin 0;
0.0
</pre>
<p>Sometimes it is preferable to replace a C function with a wrapper function
written in Pure. In such a case you can specify an <strong class="dfn">alias</strong> under which the
original C function is known to the Pure program, so that you can still call
the C function from the wrapper. An alias is introduced by terminating the
extern declaration with a clause of the form <tt class="docutils literal"><span class="pre">=</span> <span class="pre">alias</span></tt>. For instance:</p>
<pre class="literal-block">
&gt; extern double sin(double) = c_sin;
&gt; sin x::double = c_sin x;
&gt; sin x::int = c_sin (double x);
&gt; sin 0.3; sin 0;
0.29552020666134
0.0
</pre>
<p>As an alternative, you can also declare the C function in a special namespace
(cf. <a class="reference internal" href="#namespaces">Namespaces</a> in the <a class="reference internal" href="#declarations">Declarations</a> section):</p>
<pre class="literal-block">
&gt; namespace c;
&gt; extern double sin(double);
&gt; c::sin 0.3;
0.29552020666134
</pre>
<p>Note that the namespace qualification only affects the Pure side; the
underlying C function is still called under the unqualified name as usual. The
way in which such qualified externs are accessed is the same as for ordinary
qualified symbols. In particular, the <tt class="docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt> declaration applies
as usual, and you can declare such symbols as <tt class="docutils literal"><span class="pre">private</span></tt> if needed. It is
also possible to combine a namespace qualifier with an alias:</p>
<pre class="literal-block">
&gt; namespace c;
&gt; extern double sin(double) = mysin;
&gt; c::mysin 0.3;
0.29552020666134
</pre>
<p>External C functions are resolved by the LLVM runtime, which first looks for
the symbol in the C library and Pure's runtime library (or the interpreter
executable, if the interpreter was linked statically). Thus all C library and
Pure runtime functions are readily available in Pure programs. Other functions
can be provided by adding them to the runtime, or by linking them into the
runtime or the interpreter executable. Better yet, you can just &quot;dlopen&quot;
shared libraries at runtime with a special form of the <tt class="docutils literal"><span class="pre">using</span></tt> clause:</p>
<pre class="literal-block">
using &quot;lib:libname[.ext]&quot;;
</pre>
<p>For instance, if you want to call the functions from library libxyz directly
from Pure:</p>
<pre class="literal-block">
using &quot;lib:libxyz&quot;;
</pre>
<p>After this declaration the functions from the given library will be ready to
be imported into your Pure program by means of corresponding <tt class="docutils literal"><span class="pre">extern</span></tt>
declarations.</p>
<p>Shared libraries opened with using clauses are searched for in the same way as
source scripts (see section <a class="reference internal" href="#modules-and-imports">Modules and Imports</a> above), using the -L option
and the PURE_LIBRARY environment variable in place of -I and PURE_INCLUDE. If
the library isn't found by these means, the interpreter will also consider
other platform-specific locations searched by the dynamic linker, such as the
system library directories and LD_LIBRARY_PATH on Linux. The necessary
filename suffix (e.g., .so on Linux or .dll on Windows) will be supplied
automatically when needed. Of course you can also specify a full pathname for
the library if you prefer that. If a library file cannot be found, or if an
<tt class="docutils literal"><span class="pre">extern</span></tt> declaration names a function symbol which cannot be resolved, an
appropriate error message is printed.</p>
</div>
<div class="section" id="standard-library">
<h1><a class="toc-backref" href="#id43">10&nbsp;&nbsp;&nbsp;Standard Library</a></h1>
<p>Pure comes with a collection of Pure library modules, which includes the
standard prelude (loaded automatically at startup time) and some other modules
which can be loaded explicitly with a <tt class="docutils literal"><span class="pre">using</span></tt> clause. The prelude offers the
necessary functions to work with the built-in types (including arithmetic and
logical operations) and to do most kind of list processing you can find in ML-
and Haskell-like languages. It also provides a collection of basic string and
matrix operations. Please refer to the <a class="reference external" href="purelib.html">Pure Library Manual</a> for details on
the provided operations. Here is a very brief summary of some of the prelude
operations which, besides the usual arithmetic and logical operators, are
probably used most frequently:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">x+y</span></tt></dt>
<dd>This is also used to denote list and string concatenation.</dd>
<dt><tt class="docutils literal"><span class="pre">x:y</span></tt></dt>
<dd>This is the list-consing operation. <tt class="docutils literal"><span class="pre">x</span></tt> becomes the head of the list,
<tt class="docutils literal"><span class="pre">y</span></tt> its tail. As '<tt class="docutils literal"><span class="pre">:</span></tt>' is a constructor symbol, you can use it in
patterns on the left hand side of rewriting rules.</dd>
<dt><tt class="docutils literal"><span class="pre">x..y</span></tt></dt>
<dd>Constructs arithmetic sequences. <tt class="docutils literal"><span class="pre">x:y..z</span></tt> can be used to denote
sequences with arbitrary stepsize <tt class="docutils literal"><span class="pre">y-x</span></tt>. Infinite sequences can be
constructed using an infinite bound (i.e., <tt class="docutils literal"><span class="pre">inf</span></tt> or <tt class="docutils literal"><span class="pre">-inf</span></tt>). E.g.,
<tt class="docutils literal"><span class="pre">1:3..inf</span></tt> denotes the stream of all positive odd (machine) integers.</dd>
<dt><tt class="docutils literal"><span class="pre">x,y</span></tt></dt>
<dd>This is the pair constructor, used to create tuples of arbitrary
sizes. Tuples provide an alternative way to represent aggregate values in
Pure. In difference to lists, tuples are always &quot;flat&quot;, so that
<tt class="docutils literal"><span class="pre">(x,y),z</span></tt> and <tt class="docutils literal"><span class="pre">x,(y,z)</span></tt> denote the same triple <tt class="docutils literal"><span class="pre">x,y,z</span></tt>. (This is
explained in more detail in the <a class="reference internal" href="#pure-overview">Pure Overview</a> section.)</dd>
<dt><tt class="docutils literal"><span class="pre">#x</span></tt></dt>
<dd>The size (number of elements) of the list, tuple, matrix or string
<tt class="docutils literal"><span class="pre">x</span></tt>. In addition, <tt class="docutils literal"><span class="pre">dim</span> <span class="pre">x</span></tt> yields the dimensions (number of rows and
columns) of a matrix.</dd>
<dt><tt class="docutils literal"><span class="pre">x!y</span></tt></dt>
<dd>This is Pure's indexing operation, which applies to lists, tuples,
matrices and strings. Note that all indices in Pure are zero-based, thus
<tt class="docutils literal"><span class="pre">x!0</span></tt> and <tt class="docutils literal"><span class="pre">x!(#x-1)</span></tt> are the first and last element of <tt class="docutils literal"><span class="pre">x</span></tt>. In the
case of matrices, the subscript may also be a pair of row and column
indices, such as <tt class="docutils literal"><span class="pre">x!(1,2)</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">x!!ys</span></tt></dt>
<dd>This is the &quot;slicing&quot; operation, which returns the list, tuple, matrix or
string of all <tt class="docutils literal"><span class="pre">x!y</span></tt> while <tt class="docutils literal"><span class="pre">y</span></tt> runs through the (list or matrix)
<tt class="docutils literal"><span class="pre">ys</span></tt>. Thus, e.g., <tt class="docutils literal"><span class="pre">x!!(i..j)</span></tt> returns all the elements between <tt class="docutils literal"><span class="pre">i</span></tt>
and <tt class="docutils literal"><span class="pre">j</span></tt> (inclusive). Indices which fall outside the valid index range
are quietly discarded. The index range <tt class="docutils literal"><span class="pre">ys</span></tt> may contain any number of
indices (also duplicates), in any order. Thus <tt class="docutils literal"><span class="pre">x!![0|i=1..n]</span></tt> returns the
first element of <tt class="docutils literal"><span class="pre">x</span></tt> <tt class="docutils literal"><span class="pre">n</span></tt> times, and, if <tt class="docutils literal"><span class="pre">ys</span></tt> is a permutation of the
range <tt class="docutils literal"><span class="pre">0..#x-1</span></tt>, then <tt class="docutils literal"><span class="pre">x!!ys</span></tt> yields the corresponding permutation of
the elements of <tt class="docutils literal"><span class="pre">x</span></tt>. In the case of matrices the index range may also
contain two-dimensional subscripts, or the index range itself may be
specified as a pair of row/column index lists such as <tt class="docutils literal"><span class="pre">x!!(i..j,k..l)</span></tt>.</dd>
</dl>
<p>The prelude also offers support operations for the implementation of list and
matrix comprehensions, as well as the customary list operations like <tt class="docutils literal"><span class="pre">head</span></tt>,
<tt class="docutils literal"><span class="pre">tail</span></tt>, <tt class="docutils literal"><span class="pre">drop</span></tt>, <tt class="docutils literal"><span class="pre">take</span></tt>, <tt class="docutils literal"><span class="pre">filter</span></tt>, <tt class="docutils literal"><span class="pre">map</span></tt>, <tt class="docutils literal"><span class="pre">foldl</span></tt>, <tt class="docutils literal"><span class="pre">foldr</span></tt>,
<tt class="docutils literal"><span class="pre">scanl</span></tt>, <tt class="docutils literal"><span class="pre">scanr</span></tt>, <tt class="docutils literal"><span class="pre">zip</span></tt>, <tt class="docutils literal"><span class="pre">unzip</span></tt>, etc., which make list programming so
much fun in modern FPLs. In Pure, these also work on strings as well as
matrices, although, for reasons of efficiency, these data structures are
internally represented as different kinds of array data structures.</p>
<p>Besides the prelude, Pure's standard library also comprises a growing number
of additional library modules which we can only mention in passing here. In
particular, the math.pure module provides additional mathematical functions as
well as Pure's complex and rational number data types. Common container data
structures like sets and dictionaries are implemented in the set.pure and
dict.pure modules, among others. Moreover, the (beginnings of a) system
interface can be found in the system.pure module. In particular, this module
also provides operations to do basic C-style I/O, including <tt class="docutils literal"><span class="pre">printf</span></tt> and
<tt class="docutils literal"><span class="pre">scanf</span></tt>. These are all described in much more detail in the <a class="reference external" href="purelib.html">Pure Library
Manual</a>.</p>
</div>
<div class="section" id="interactive-usage">
<h1><a class="toc-backref" href="#id44">11&nbsp;&nbsp;&nbsp;Interactive Usage</a></h1>
<p>In interactive mode, the interpreter reads definitions and expressions and
processes them as usual. You can use the -i option to force interactive mode
when invoking the interpreter with some script files. Additional scripts can
be loaded interactively using either a using declaration or the interactive
run command (see the description of the run command below for the differences
between these). Or you can just start typing away, entering your own
definitions and expressions to be evaluated.</p>
<p>The input language is just the same as for source scripts, and hence
individual definitions and expressions must be terminated with a semicolon
before they are processed. For instance, here is a simple interaction which
defines the factorial and then uses that definition in some evaluations. Input
lines begin with '<tt class="docutils literal"><span class="pre">&gt;</span></tt>', which is the interpreter's default command prompt:</p>
<pre class="literal-block">
&gt; fact 1 = 1;
&gt; fact n = n*fact (n-1) if n&gt;1;
&gt; let x = fact 10; x;
3628800
&gt; map fact (1..10);
[1,2,6,24,120,720,5040,40320,362880,3628800]
</pre>
<p>As indicated, in interactive mode the normal forms of toplevel expressions are
printed after each expression is entered. We also call this the
<strong class="dfn">read-eval-print loop</strong>. Normal form expressions are usually printed in the
same form as you'd enter them. However, there are a few special kinds of
objects like anonymous closures, thunks (&quot;lazy&quot; values to be evaluated when
needed) and pointers which don't have a textual representation in the Pure
syntax and will be printed in the format <tt class="docutils literal"><span class="pre">#&lt;</span></tt>object description<tt class="docutils literal"><span class="pre">&gt;</span></tt>
by default. It is also possible to override the print representation of any
kind of expression by means of the <tt class="docutils literal"><span class="pre">__show__</span></tt> function, see the <a class="reference internal" href="#caveats-and-notes">Caveats and
Notes</a> section for details.</p>
<div class="section" id="online-help">
<h2><a class="toc-backref" href="#id45">11.1&nbsp;&nbsp;&nbsp;Online Help</a></h2>
<p>Online help is available in the interpreter with the interactive <tt class="docutils literal"><span class="pre">help</span></tt>
command, see <a class="reference internal" href="#interactive-commands">Interactive Commands</a> below. You need to have a html browser
installed for that. By default, the <tt class="docutils literal"><span class="pre">help</span></tt> command uses w3m(1), but you can
change this by setting either the PURE_HELP or the BROWSER environment
variable accordingly.</p>
<p>When invoked without arguments, the <tt class="docutils literal"><span class="pre">help</span></tt> command displays this manual:</p>
<pre class="literal-block">
&gt; help
</pre>
<p>The <tt class="docutils literal"><span class="pre">help</span></tt> command also accepts a parameter which lets you specify a topic
to show in the accompanying Pure Library manual, e.g.:</p>
<pre class="literal-block">
&gt; help foldl
</pre>
<p>The help files distributed with the Pure interpreter are located in the Pure
library directory (/usr/local/lib/pure by default). You can install additional
documentation in html format in this directory, and look up topics in those
help files with a command like the following:</p>
<pre class="literal-block">
&gt; help mydoc#foo
</pre>
<p>Here <tt class="docutils literal"><span class="pre">mydoc</span></tt> is the basename of your help file (library path and .html
suffix are supplied automatically), and <tt class="docutils literal"><span class="pre">foo</span></tt> can be any link target in the
document (as specified with a <tt class="docutils literal"><span class="pre">&lt;a</span> <span class="pre">name=...&gt;</span></tt> tag or an <tt class="docutils literal"><span class="pre">id</span></tt> attribute in
the html source). To just read the mydoc.html file without specifying a
target, type the following:</p>
<pre class="literal-block">
&gt; help mydoc#
</pre>
<p>Note that just <tt class="docutils literal"><span class="pre">help</span> <span class="pre">mydoc</span></tt> wouldn't work, since it would look for an entry
<tt class="docutils literal"><span class="pre">mydoc</span></tt> in the standard library documentation.</p>
<p>If the basename of the help file is missing, it defaults to the library
manual, so <tt class="docutils literal"><span class="pre">help</span> <span class="pre">#foldl</span></tt> does the same as <tt class="docutils literal"><span class="pre">help</span> <span class="pre">foldl</span></tt>, and just <tt class="docutils literal"><span class="pre">help</span>
<span class="pre">#</span></tt> is a convenient shorthand to bring up the library manual without a
specific topic. Of course, this syntax also works for looking up sections in
the Pure manual:</p>
<pre class="literal-block">
&gt; help pure#declarations
</pre>
<p>Note that the <a class="reference external" href="http://docutils.sourceforge.net/">docutils</a> tools used to generate the html source of the Pure
manual mangle the section titles so that they are in lowercase and blanks are
replaced with hyphens. So to look up the present section in this manual you'd
have to type:</p>
<pre class="literal-block">
&gt; help pure#online-help
</pre>
<p>You can also point the help browser to a proper URL, either a local file or
some website (provided that your browser program can handle these). For
instance:</p>
<pre class="literal-block">
&gt; help file:mydoc.html#foo
&gt; help http://pure-lang.googlecode.com
</pre>
</div>
<div class="section" id="interactive-commands">
<h2><a class="toc-backref" href="#id46">11.2&nbsp;&nbsp;&nbsp;Interactive Commands</a></h2>
<p>When running interactively, the interpreter accepts a number of special
commands useful for interactive purposes. Here is a quick rundown of the
currently supported operations:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">!</span> <span class="pre">command</span></tt></dt>
<dd>Shell escape.</dd>
<dt><tt class="docutils literal"><span class="pre">break</span> <span class="pre">[symbol</span> <span class="pre">...]</span></tt></dt>
<dd>Sets breakpoints on the given function or operator symbols. If invoked
without arguments, prints all currently defined breakpoints. This requires
that the interpreter was invoked with the -g option to enable debugging
support. See <a class="reference internal" href="#debugging">Debugging</a> below for details.</dd>
<dt><tt class="docutils literal"><span class="pre">cd</span> <span class="pre">dir</span></tt></dt>
<dd>Change the current working dir.</dd>
<dt><tt class="docutils literal"><span class="pre">clear</span> <span class="pre">[option</span> <span class="pre">...]</span> <span class="pre">[symbol</span> <span class="pre">...]</span></tt></dt>
<dd>Purge the definitions of the given symbols (functions, macros, constants
or global variables). If invoked as <tt class="docutils literal"><span class="pre">clear</span> <span class="pre">ans</span></tt>, clears the <tt class="docutils literal"><span class="pre">ans</span></tt>
value (see <a class="reference internal" href="#last-result">Last Result</a> below). When invoked without any arguments,
<tt class="docutils literal"><span class="pre">clear</span></tt> purges all definitions at the current interactive &quot;level&quot; (after
confirmation) and returns you to the previous level, if any. (It might be
a good idea to first check your current definitions with <tt class="docutils literal"><span class="pre">show</span></tt> or back
them up with <tt class="docutils literal"><span class="pre">dump</span></tt> before you do that.) The desired level can be
specified with the -t option. See the description of the <tt class="docutils literal"><span class="pre">save</span></tt> command
and <a class="reference internal" href="#definition-levels">Definition Levels</a> below for further details. A description of the
common options accepted by the <tt class="docutils literal"><span class="pre">clear</span></tt>, <tt class="docutils literal"><span class="pre">dump</span></tt> and <tt class="docutils literal"><span class="pre">show</span></tt> commands
can be found in <a class="reference internal" href="#specifying-symbol-selections">Specifying Symbol Selections</a> below.</dd>
<dt><tt class="docutils literal"><span class="pre">del</span> <span class="pre">[symbol</span> <span class="pre">...]</span></tt></dt>
<dd>Deletes breakpoints on the given function or operator symbols. If invoked
without arguments, clears all currently defined breakpoints (after
confirmation). See <a class="reference internal" href="#debugging">Debugging</a> below for details.</dd>
<dt><tt class="docutils literal"><span class="pre">dump</span> <span class="pre">[-n</span> <span class="pre">filename]</span> <span class="pre">[option</span> <span class="pre">...]</span> <span class="pre">[symbol</span> <span class="pre">...]</span></tt></dt>
<dd><p class="first">Dump a snapshot of the current function, macro, constant and variable
definitions in Pure syntax to a text file. This works similar to the
<tt class="docutils literal"><span class="pre">show</span></tt> command (see below), but writes the definitions to a file. The
default output file is .pure in the current directory, which is then
reloaded automatically the next time the interpreter starts up in
interactive mode in the same directory. This provides a quick-and-dirty
way to save an interactive session and have it restored later, but note
that this isn't perfect yet. In particular, declarations of <tt class="docutils literal"><span class="pre">extern</span></tt>
symbols won't be saved unless they're specified explicitly, and some
objects like closures, thunks and pointers don't have a textual
representation from which they could be reconstructed. To handle these,
you'll probably have to prepare a corresponding .purerc file yourself, see
<a class="reference internal" href="#interactive-startup">Interactive Startup</a> below.</p>
<p class="last">A different filename can be specified with the -n option, which expects
the name of the script to be written in the next argument, e.g: <tt class="docutils literal"><span class="pre">dump</span> <span class="pre">-n</span>
<span class="pre">myscript.pure</span></tt>. You can then edit that file and use it as a starting
point for an ordinary script or a .purerc file, or you can just run the
file with the <tt class="docutils literal"><span class="pre">run</span></tt> command (see below) to restore the definitions in a
subsequent interpreter session.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">help</span> <span class="pre">[target]</span></tt></dt>
<dd>Display the Pure manual or some other bit of documentation. In particular,
<tt class="docutils literal"><span class="pre">help</span> <span class="pre">foo</span></tt> looks up the symbol <tt class="docutils literal"><span class="pre">foo</span></tt> in the Pure Library manual. See
<a class="reference internal" href="#online-help">Online Help</a> above for details.</dd>
<dt><tt class="docutils literal"><span class="pre">ls</span> <span class="pre">[args]</span></tt></dt>
<dd>List files (shell ls(1) command).</dd>
<dt><tt class="docutils literal"><span class="pre">override</span></tt></dt>
<dd>Enter &quot;override&quot; mode. This allows you to add equations &quot;above&quot; existing
definitions in the source script, possibly overriding existing
equations. See <a class="reference internal" href="#definition-levels">Definition Levels</a> below for details.</dd>
<dt><tt class="docutils literal"><span class="pre">pwd</span></tt></dt>
<dd>Print the current working dir (shell pwd(1) command).</dd>
<dt><tt class="docutils literal"><span class="pre">quit</span></tt></dt>
<dd>Exits the interpreter.</dd>
<dt><tt class="docutils literal"><span class="pre">run</span> <span class="pre">script</span></tt></dt>
<dd>Loads the given script file and adds its definitions to the current
environment. This works more or less like a <tt class="docutils literal"><span class="pre">using</span></tt> clause, but only
searches for the script in the current directory and places the
definitions in the script at the current temporary level, so that
<tt class="docutils literal"><span class="pre">clear</span></tt> can be used to remove them again. In particular, this makes it
possible to quickly reload a script without exiting the interpreter, by
issuing the <tt class="docutils literal"><span class="pre">clear</span></tt> command followed by <tt class="docutils literal"><span class="pre">run</span></tt>. (This works best if you
start out from a clean environment, with no scripts loaded on the command
line.)</dd>
<dt><tt class="docutils literal"><span class="pre">save</span></tt></dt>
<dd>Begin a new level of temporary definitions. A subsequent <tt class="docutils literal"><span class="pre">clear</span></tt> command
(see above) will purge the definitions made since the most recent <tt class="docutils literal"><span class="pre">save</span></tt>
command. See <a class="reference internal" href="#definition-levels">Definition Levels</a> below for details.</dd>
<dt><tt class="docutils literal"><span class="pre">show</span> <span class="pre">[option</span> <span class="pre">...]</span> <span class="pre">[symbol</span> <span class="pre">...]</span></tt></dt>
<dd>Show the definitions of symbols in various formats. See <a class="reference internal" href="#the-show-command">The show
Command</a> below for details. A description of the common options accepted
by the <tt class="docutils literal"><span class="pre">clear</span></tt>, <tt class="docutils literal"><span class="pre">dump</span></tt> and <tt class="docutils literal"><span class="pre">show</span></tt> commands can be found in
<a class="reference internal" href="#specifying-symbol-selections">Specifying Symbol Selections</a> below.</dd>
<dt><tt class="docutils literal"><span class="pre">stats</span> <span class="pre">[on|off]</span></tt></dt>
<dd>Enables (default) or disables &quot;stats&quot; mode, in which various statistics
are printed after an expression has been evaluated. Currently, this just
prints the cpu time in seconds for each evaluation, but in the future
additional profiling information may be provided.</dd>
<dt>underride</dt>
<dd>Exits &quot;override&quot; mode. This returns you to the normal mode of operation,
where new equations are added &quot;below&quot; previous rules of an existing
function. See <a class="reference internal" href="#definition-levels">Definition Levels</a> below for details.</dd>
</dl>
<p>Note that these special commands are only recognized at the beginning of the
interactive command line (they are not reserved keywords of the Pure
language). Thus it's possible to &quot;escape&quot; identifiers looking like commands by
entering a space at the beginning of the line.</p>
</div>
<div class="section" id="last-result">
<h2><a class="toc-backref" href="#id47">11.3&nbsp;&nbsp;&nbsp;Last Result</a></h2>
<p>Another convenience for interactive usage is the <tt class="docutils literal"><span class="pre">ans</span></tt> function, which
retrieves the most recent result printed in interactive mode. For instance:</p>
<pre class="literal-block">
&gt; fact n = if n&lt;=1 then 1 else n*fact (n-1);
&gt; map fact (1..10);
[1,2,6,24,120,720,5040,40320,362880,3628800]
&gt; scanl (+) 0 ans;
[0,1,3,9,33,153,873,5913,46233,409113,4037913]
</pre>
<p>Note that <tt class="docutils literal"><span class="pre">ans</span></tt> is just an ordinary function, defined in the prelude, not
a special command. However, there is a special <tt class="docutils literal"><span class="pre">clear</span> <span class="pre">ans</span></tt> command which
purges the <tt class="docutils literal"><span class="pre">ans</span></tt> value. This is useful, e.g., if you got a huge result
which you want to erase from memory before starting the next computation.</p>
<pre class="literal-block">
&gt; clear ans
&gt; ans;
ans
</pre>
</div>
<div class="section" id="specifying-symbol-selections">
<h2><a class="toc-backref" href="#id48">11.4&nbsp;&nbsp;&nbsp;Specifying Symbol Selections</a></h2>
<p>The <tt class="docutils literal"><span class="pre">clear</span></tt>, <tt class="docutils literal"><span class="pre">dump</span></tt> and <tt class="docutils literal"><span class="pre">show</span></tt> commands all accept the following options
for specifying a subset of symbols and definitions on which to
operate. Options may be combined, thus, e.g., <tt class="docutils literal"><span class="pre">show</span> <span class="pre">-mft</span></tt> is the same as
<tt class="docutils literal"><span class="pre">show</span> <span class="pre">-m</span> <span class="pre">-f</span> <span class="pre">-t</span></tt>. Some options specify optional numeric parameters; these
must follow immediately behind the option character if present, as in <tt class="docutils literal"><span class="pre">-t0</span></tt>.</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-c</span></kbd></td>
<td>Selects defined constants.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-f</span></kbd></td>
<td>Selects defined functions.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-g</span></kbd></td>
<td>Indicates that the following symbols are actually shell glob patterns and
that all matching symbols should be selected.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-m</span></kbd></td>
<td>Select defined macros.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-p<var>flag</var></span></kbd></td>
<td>Select only private symbols if <em>flag</em> is nonzero (the default), otherwise
(<em>flag</em> is zero) select only public symbols. If this option is omitted
then both private and public symbols are selected.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-t<var>level</var></span></kbd></td>
<td>Select symbols and definitions at the given &quot;level&quot; of definitions and
above. This is described in more detail below. Briefly, the executing
program and all imported modules (including the prelude) are at level 0,
while &quot;temporary&quot; definitions made interactively in the interpreter are at
level 1 and above. Thus a level of 1 restricts the selection to all
temporary definitions, whereas 0 indicates all definitions (i.e.,
everything, including the prelude). If <em>level</em> is omitted, it defaults to
the current definitions level.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-v</span></kbd></td>
<td>Select defined variables.</td></tr>
</tbody>
</table>
<p>In addition, the -h option prints a short help message describing all
available options of the command at hand.</p>
<p>If none of the -c, -f, -m and -v options are specified, then all kinds of
symbols (constants, functions, macros and variables) are selected, otherwise
only the specified categories will be considered.</p>
<p>A reasonable default is used if the -t option is omitted. By default, if no
symbols are specified, only temporary definitions are considered, which
corresponds to -t1. Otherwise the command applies to all corresponding
definitions, no matter whether they belong to the executing program, the
prelude, or some temporary level, which has the same effect as -t0. This
default choice can be overridden by specifying the desired level explicitly.</p>
<p>As a special case, just <tt class="docutils literal"><span class="pre">clear</span></tt> (without any other options or symbol
arguments) always backs out to the previous definitions level (instead of
level #1). This is inconsistent with the rules set out above, but is
implemented this way for convenience and backward compatibility. Thus, if you
really want to delete all your temporary definitions, use <tt class="docutils literal"><span class="pre">clear</span> <span class="pre">-t1</span></tt>
instead. When used in this way, the <tt class="docutils literal"><span class="pre">clear</span></tt> command will only remove
temporary definitions; if you need to remove definitions at level #0, you must
specify those symbols explicitly.</p>
<p>Note that <tt class="docutils literal"><span class="pre">clear</span> <span class="pre">-g</span> <span class="pre">*</span></tt> will have pretty much the same disastrous
consequences as the Unix command <tt class="docutils literal"><span class="pre">rm</span> <span class="pre">-rf</span> <span class="pre">*</span></tt>, so don't do that. Also note
that a macro or function symbol may well have defining equations at different
levels, in which case a command like <tt class="docutils literal"><span class="pre">clear</span> <span class="pre">-tn</span> <span class="pre">foo</span></tt> might only affect some
part of <tt class="docutils literal"><span class="pre">foo</span></tt>'s definition. The <tt class="docutils literal"><span class="pre">dump</span></tt> and <tt class="docutils literal"><span class="pre">show</span></tt> commands work
analogously (albeit less destructively). See <a class="reference internal" href="#definition-levels">Definition Levels</a> below for
some examples.</p>
</div>
<div class="section" id="the-show-command">
<h2><a class="toc-backref" href="#id49">11.5&nbsp;&nbsp;&nbsp;The show Command</a></h2>
<p>The <tt class="docutils literal"><span class="pre">show</span></tt> command can be used to obtain information about defined symbols
in various formats. Besides the common selection options discussed above, this
command recognizes the following additional options for specifying the content
to be listed and the format to use.</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-a</span></kbd></td>
<td>Disassembles pattern matching automata. Works like the -v4 option of the
interpreter.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-d</span></kbd></td>
<td>Disassembles LLVM IR, showing the generated LLVM assembler code of a
function. Works like the -v8 option of the interpreter.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-e</span></kbd></td>
<td>Annotate printed definitions with lexical environment information (de
Bruijn indices, subterm paths). Works like the -v2 option of the
interpreter.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-l</span></kbd></td>
<td>Long format, prints definitions along with the summary symbol
information. This implies -s.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-s</span></kbd></td>
<td>Summary format, print just summary information about listed symbols.</td></tr>
</tbody>
</table>
<p>Symbols are always listed in lexicographic order. Note that some of the
options (in particular, -a and -d) may produce excessive amounts of
information. By setting the PURE_MORE environment variable accordingly, you
can specify a shell command to be used for paging, usually more(1) or less(1).</p>
<p>For instance, to list all temporary definitions made in an interactive
session, simply say:</p>
<pre class="literal-block">
&gt; show
</pre>
<p>You can also list a specific symbol, no matter whether it comes from the
interactive command line, the executing script or the prelude:</p>
<pre class="literal-block">
&gt; show foldl
foldl f a x::matrix = foldl f a (list x);
foldl f a s::string = foldl f a (chars s);
foldl f a [] = a;
foldl f a (x:xs) = foldl f (f a x) xs;
</pre>
<p>Wildcards can be used with the -g option, which is useful if you want to print
an entire family of related functions, e.g.:</p>
<pre class="literal-block">
&gt; show -g foldl*
foldl f a x::matrix = foldl f a (list x);
foldl f a s::string = foldl f a (chars s);
foldl f a [] = a;
foldl f a (x:xs) = foldl f (f a x) xs;
foldl1 f x::matrix = foldl1 f (list x);
foldl1 f s::string = foldl1 f (chars s);
foldl1 f (x:xs) = foldl f x xs;
</pre>
<p>Or you can just specify multiple symbols as follows (this also works with
multiple glob patterns when you add the -g option):</p>
<pre class="literal-block">
&gt; show min max
max x y = if x&gt;=y then x else y;
min x y = if x&lt;=y then x else y;
</pre>
<p>You can also select symbols by category. E.g., the following command shows
summary information about all the variable symbols along with their current
values (using the &quot;long&quot; format):</p>
<pre class="literal-block">
&gt; show -lvg *
argc         var  argc = 0;
argv         var  argv = [];
gsl_version  var  gsl_version = &quot;1.9&quot;;
sysinfo      var  sysinfo = &quot;i686-pc-linux-gnu&quot;;
version      var  version = &quot;0.17&quot;;
5 variables
</pre>
<p>Or you can list just private symbols of the namespace <tt class="docutils literal"><span class="pre">foo</span></tt>, as follows:</p>
<pre class="literal-block">
&gt; show -pg foo::*
</pre>
<p>The following command will list each and every symbol that's currently defined
(instead of <tt class="docutils literal"><span class="pre">-g</span> <span class="pre">*</span></tt> you can also use the <tt class="docutils literal"><span class="pre">-t0</span></tt> option):</p>
<pre class="literal-block">
&gt; show -g *
</pre>
<p>This usually produces a lot of output and is rarely needed, unless you'd like
to browse through an entire program including all library imports. (In that
case you might consider to use the <tt class="docutils literal"><span class="pre">dump</span></tt> command instead, which writes the
definitions to a file which can then be loaded into a text editor for easier
viewing. This may occasionally be useful for debugging purposes.)</p>
<p>Finally, there are two alternate forms of the <tt class="docutils literal"><span class="pre">show</span></tt> command: <tt class="docutils literal"><span class="pre">show</span>
<span class="pre">namespace</span></tt> which lists the current and search namespaces, and <tt class="docutils literal"><span class="pre">show</span>
<span class="pre">namespaces</span></tt> which lists all declared namespaces. These come in handy if you
have forgotten what namespaces are currently active and which other namespaces
are available in your program. For instance:</p>
<pre class="literal-block">
&gt; show namespace
&gt; show namespaces
namespace C;
namespace matrix;
&gt; using namespace C;
&gt; namespace my;
&gt; show namespace
namespace my;
using namespace C;
</pre>
</div>
<div class="section" id="definition-levels">
<h2><a class="toc-backref" href="#id50">11.6&nbsp;&nbsp;&nbsp;Definition Levels</a></h2>
<p>To help with incremental development, the interpreter offers some facilities
to manipulate the current set of definitions interactively. To these ends,
definitions are organized into different subsets called <strong class="dfn">levels</strong>. As already
mentioned, the prelude, as well as other source programs specified when
invoking the interpreter, are always at level 0, while the interactive
environment starts at level 1.</p>
<p>Each <tt class="docutils literal"><span class="pre">save</span></tt> command introduces a new temporary level, and each subsequent
<tt class="docutils literal"><span class="pre">clear</span></tt> command (without any arguments) &quot;pops&quot; the definitions on the
current level and returns you to the previous one (if any). This gives you a
&quot;stack&quot; of temporary environments which enables you to &quot;plug and play&quot; in a
(more or less) safe fashion, without affecting the rest of your program. For
all practical purposes, this stack is unlimited, so that you can create as
many levels as you like. Example:</p>
<pre class="literal-block">
&gt; foo (x:xs) = x+foo xs;
&gt; foo [] = 0;
&gt; show
foo (x:xs) = x+foo xs;
foo [] = 0;
&gt; foo (1..10);
55
&gt; clear
This will clear all temporary definitions at level #1.
Continue (y/n)? y
&gt; show
&gt; foo (1..10);
foo [1,2,3,4,5,6,7,8,9,10]
</pre>
<p>We've seen already that normally, if you enter a sequence of equations, they
will be recorded in the order in which they were written. However, it is also
possible to override definitions in lower levels with the <tt class="docutils literal"><span class="pre">override</span></tt>
command:</p>
<pre class="literal-block">
&gt; foo (x:xs) = x+foo xs;
&gt; foo [] = 0;
&gt; show
foo (x:xs) = x+foo xs;
foo [] = 0;
&gt; foo (1..10);
55
&gt; save
save: now at temporary definitions level #2
&gt; override
&gt; foo (x:xs) = x*foo xs;
&gt; show
foo (x:xs) = x*foo xs;
foo (x:xs) = x+foo xs;
foo [] = 0;
&gt; foo (1..10);
warning: rule never reduced: foo (x:xs) = x+foo xs;
0
</pre>
<p>Note that the equation <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">(x:xs)</span> <span class="pre">=</span> <span class="pre">x*foo</span> <span class="pre">xs;</span></tt> was inserted before the
previous <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">(x:xs)</span> <span class="pre">=</span> <span class="pre">x+foo</span> <span class="pre">xs;</span></tt> rule, which is at level #1. (The latter
equation is now &quot;shadowed&quot; by the rule we just entered, hence the compiler
warns us that this rule can't be reduced any more.)</p>
<p>Even in override mode, new definitions will be added after other definitions
at the <em>current</em> level. This allows us to just continue adding more
high-priority definitions overriding lower-priority ones:</p>
<pre class="literal-block">
&gt; foo [] = 1;
&gt; show
foo (x:xs) = x*foo xs;
foo [] = 1;
foo (x:xs) = x+foo xs;
foo [] = 0;
&gt; foo (1..10);
warning: rule never reduced: foo (x:xs) = x+foo xs;
warning: rule never reduced: foo [] = 0;
3628800
</pre>
<p>Again, the new equation was inserted above the existing lower-priority rules,
but below our previous <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">(x:xs)</span> <span class="pre">=</span> <span class="pre">x*foo</span> <span class="pre">xs;</span></tt> equation entered at the same
level. As you can see, we have now effectively replaced our original
definition of <tt class="docutils literal"><span class="pre">foo</span></tt> with a version that calculates list products instead of
sums, but of course we can easily go back one level to restore the previous
definition:</p>
<pre class="literal-block">
&gt; clear
This will clear all temporary definitions at level #2.
Continue (y/n)? y
clear: now at temporary definitions level #1
clear: override mode is on
&gt; show
foo (x:xs) = x+foo xs;
foo [] = 0;
&gt; foo (1..10);
55
</pre>
<p>Note that <tt class="docutils literal"><span class="pre">clear</span></tt> reminded us that override mode is still enabled (<tt class="docutils literal"><span class="pre">save</span></tt>
will do the same if override mode is on while pushing a new definitions
level). To turn it off again, use the <tt class="docutils literal"><span class="pre">underride</span></tt> command. This will revert
to the normal behaviour of adding new equations below existing ones:</p>
<pre class="literal-block">
&gt; underride
</pre>
<p>Finally, it's also possible to use <tt class="docutils literal"><span class="pre">clear</span></tt> to back out multiple levels at
once, if you specify the target level to be cleared with the -t option. For
instance:</p>
<pre class="literal-block">
&gt; save
save: now at temporary definitions level #2
&gt; let bar = 99;
&gt; show
let bar = 99;
foo (x:xs) = x+foo xs;
foo [] = 0;
&gt; clear -t1 // this scraps all our scribblings!
This will clear all temporary definitions at level #1 and above.
Continue (y/n)? y
clear: now at temporary definitions level #1
&gt; show
&gt;
</pre>
</div>
<div class="section" id="debugging">
<h2><a class="toc-backref" href="#id51">11.7&nbsp;&nbsp;&nbsp;Debugging</a></h2>
<p>The interpreter provides a simple but reasonably convenient symbolic debugging
facility when running interactively. To make this work, you have to specify
the -g option when invoking the interpreter:</p>
<pre class="literal-block">
$ pure -g
</pre>
<p>This option disables tail call optimization (see <a class="reference internal" href="#stack-size-and-tail-recursion">Stack Size and Tail
Recursion</a>) to make it easier to debug programs. It also causes special
debugging code to be generated which will make your program run <em>much</em>
slower. Therefore the -g option should only be used if you actually need the
debugger.</p>
<p>To debug a given function, just set a breakpoint with the <tt class="docutils literal"><span class="pre">break</span></tt> command.
For instance:</p>
<pre class="literal-block">
&gt; fact n::int = if n&gt;0 then n*fact (n-1) else 1;
&gt; break fact
&gt; fact 1;
** [1] fact: fact n::int = if n&gt;0 then n*fact (n-1) else 1;
     n = 1
(Type 'h' for help.)
:
** [2] fact: fact n::int = if n&gt;0 then n*fact (n-1) else 1;
     n = 0
:
++ [2] fact: fact n::int = if n&gt;0 then n*fact (n-1) else 1;
     n = 0
     --&gt; 1
** [2] (*): x::int*y::int = x*y;
     x = 1; y = 1
:
++ [2] (*): x::int*y::int = x*y;
     x = 1; y = 1
     --&gt; 1
++ [1] fact: fact n::int = if n&gt;0 then n*fact (n-1) else 1;
     n = 1
     --&gt; 1
1
</pre>
<p>Lines beginning with <tt class="docutils literal"><span class="pre">**</span></tt> indicate that the evaluation was interrupted to
show the rule (or external) which is currently being considered, along with
the current depth of the call stack, the invoked function and the values of
parameters and other local variables in the current lexical environment. In
contrast, the prefix <tt class="docutils literal"><span class="pre">++</span></tt> denotes reductions which were actually performed
during the evaluation and the results that were returned by the function call
(printed as <tt class="docutils literal"><span class="pre">--&gt;</span> <span class="pre">return</span> <span class="pre">value</span></tt>).</p>
<p>Sometimes you might also see funny symbols like <tt class="docutils literal"><span class="pre">#&lt;case&gt;</span></tt>, <tt class="docutils literal"><span class="pre">#&lt;when&gt;</span></tt> or
<tt class="docutils literal"><span class="pre">#&lt;closure&gt;</span></tt> instead of the function name. These indicate lambdas and the
special variable-binding environments, which are all implemented as anonymous
closures in Pure. Also note that the debugger doesn't know about the argument
names of external functions (which are optional in Pure and not recorded
anywhere), so it will display the generic names <tt class="docutils literal"><span class="pre">x1</span></tt>, <tt class="docutils literal"><span class="pre">x2</span></tt> etc. instead.</p>
<p>At the debugger prompt '<tt class="docutils literal"><span class="pre">:</span></tt>' you can enter various special debugger
commands, or just keep on hitting the carriage return key to walk through an
evaluation step by step, as we did in the example above. (Command line editing
using readline works as usual at the debugger prompt, if it is enabled.) The
usual commands are provided to walk through an evaluation, print and navigate
the call stack, step over the current call, or continue the evaluation
unattended until you hit another breakpoint. If you know other source level
debuggers like gdb then you should feel right at home. You can type <tt class="docutils literal"><span class="pre">h</span></tt> at
the debugger prompt to print the following list:</p>
<pre class="literal-block">
: h
Debugger commands:
a       auto: step through the entire program, run unattended
c [f]   continue until next breakpoint, or given function f
h       help: print this list
n       next step: step over reduction
p [n]   print rule stack (n = number of frames)
r       run: finish evaluation without debugger
s       single step: step into reduction
t, b    move to the top or bottom of the rule stack
u, d    move up or down one level in the rule stack
x       exit the interpreter (after confirmation)
.       reprint current rule
! cmd   shell escape
? expr  evaluate expression
&lt;cr&gt;    single step (same as 's')
&lt;eof&gt;   step through program, run unattended (same as 'a')
</pre>
<p>The command syntax is very simple. Besides the commands listed above you can
also enter comment lines (<tt class="docutils literal"><span class="pre">//</span> <span class="pre">comment</span> <span class="pre">text</span></tt>) which will just be
ignored. Extra arguments on commands which don't expect any will generally be
ignored as well. The single letter commands all have to be separated from any
additional parameters with whitespace, whereas the '<tt class="docutils literal"><span class="pre">!</span></tt>', '<tt class="docutils literal"><span class="pre">?</span></tt>' and
'<tt class="docutils literal"><span class="pre">.</span></tt>' commands count as word delimiters and can thus be followed immediately
by an argument. For convenience, the '<tt class="docutils literal"><span class="pre">?</span></tt>' command can also be omitted if
the expression to be evaluated doesn't start with a single letter or one of
the special punctuation commands.</p>
<p>The debugger can be exited or suspended in the following ways:</p>
<ul class="simple">
<li>You can type <tt class="docutils literal"><span class="pre">c</span></tt> to continue the evaluation until the next breakpoint, or
<tt class="docutils literal"><span class="pre">c</span> <span class="pre">foo</span></tt> in order to proceed until the debugger hits an invokation of the
function <tt class="docutils literal"><span class="pre">foo</span></tt>.</li>
<li>You can type <tt class="docutils literal"><span class="pre">r</span></tt> to run the rest of the evaluation without the debugger.</li>
<li>The <tt class="docutils literal"><span class="pre">a</span></tt> (&quot;auto&quot;) command single-steps through the rest of the evaluation,
running unattended. This command can also be entered by just hitting the
end-of-file key (<tt class="docutils literal"><span class="pre">Ctrl-D</span></tt> on Unix systems) at the debugger prompt.</li>
<li>You can also type <tt class="docutils literal"><span class="pre">x</span></tt> to exit from the debugger <em>and</em> the interpreter
immediately (after confirmation).</li>
</ul>
<p>At the debugger prompt, you can use the <tt class="docutils literal"><span class="pre">u</span></tt> (&quot;up&quot;), <tt class="docutils literal"><span class="pre">d</span></tt> (&quot;down&quot;), <tt class="docutils literal"><span class="pre">t</span></tt>
(&quot;top&quot;) and <tt class="docutils literal"><span class="pre">b</span></tt> (&quot;bottom&quot;) commands to move around on the current call
stack. The <tt class="docutils literal"><span class="pre">p</span></tt> command prints a range of the call stack centered around the
currently selected stack frame, which is indicated with the <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> tag,
whereas <tt class="docutils literal"><span class="pre">**</span></tt> denotes the current bottom of the stack (which is the rule to
be executed with the single step command). The <tt class="docutils literal"><span class="pre">p</span></tt> command can also be
followed by a numeric argument which indicates the number of stack frames to
be printed (this will then become the default for subsequent invocations of
<tt class="docutils literal"><span class="pre">p</span></tt>). The <tt class="docutils literal"><span class="pre">n</span></tt> command steps over the call selected with the stack
navigation commands. For instance:</p>
<pre class="literal-block">
&gt; fact 3;
** [1] fact: fact n::int = if n&gt;0 then n*fact (n-1) else 1;
     n = 3
: c *
** [4] (*): x::int*y::int = x*y;
     x = 1; y = 1
: p
   [1] fact: fact n::int = if n&gt;0 then n*fact (n-1) else 1;
     n = 3
   [2] fact: fact n::int = if n&gt;0 then n*fact (n-1) else 1;
     n = 2
   [3] fact: fact n::int = if n&gt;0 then n*fact (n-1) else 1;
     n = 1
** [4] (*): x::int*y::int = x*y;
     x = 1; y = 1
: u
&gt;&gt; [3] fact: fact n::int = if n&gt;0 then n*fact (n-1) else 1;
     n = 1
: u
&gt;&gt; [2] fact: fact n::int = if n&gt;0 then n*fact (n-1) else 1;
     n = 2
: p
   [1] fact: fact n::int = if n&gt;0 then n*fact (n-1) else 1;
     n = 3
&gt;&gt; [2] fact: fact n::int = if n&gt;0 then n*fact (n-1) else 1;
     n = 2
   [3] fact: fact n::int = if n&gt;0 then n*fact (n-1) else 1;
     n = 1
** [4] (*): x::int*y::int = x*y;
     x = 1; y = 1
: n
++ [2] fact: fact n::int = if n&gt;0 then n*fact (n-1) else 1;
     n = 2
     --&gt; 2
** [2] (*): x::int*y::int = x*y;
     x = 3; y = 2
:
</pre>
<p>If you ever get lost, you can reprint the current rule with the '<tt class="docutils literal"><span class="pre">.</span></tt>'
command:</p>
<pre class="literal-block">
: .
** [2] (*): x::int*y::int = x*y;
     x = 3; y = 2
</pre>
<p>Another useful feature is the <tt class="docutils literal"><span class="pre">?</span></tt> command which lets you evaluate any Pure
expression, with the local variables of the current rule bound to their
corresponding values. Like the <tt class="docutils literal"><span class="pre">n</span></tt> command, <tt class="docutils literal"><span class="pre">?</span></tt> applies to the current
stack frame as selected with the stack navigation commands. The expression
must be entered on a single line, and the trailing semicolon is optional. For
instance:</p>
<pre class="literal-block">
&gt; fact 3;
** [1] fact: fact n::int = if n&gt;0 then n*fact (n-1) else 1;
     n = 3
: c *
** [4] (*): x::int*y::int = x*y;
     x = 1; y = 1
: ?x+y
2
: u
&gt;&gt; [3] fact: fact n::int = if n&gt;0 then n*fact (n-1) else 1;
     n = 1
: n&gt;0, fact n
1,1
</pre>
<p>Note that the current set of breakpoints can only be changed with the
<tt class="docutils literal"><span class="pre">break</span></tt> and <tt class="docutils literal"><span class="pre">del</span></tt> commands of the interpreter, see <a class="reference internal" href="#interactive-commands">Interactive Commands</a>
above. Use <tt class="docutils literal"><span class="pre">break</span></tt> without arguments to list the currently defined
breakpoints. Breakpoints can be deleted with the <tt class="docutils literal"><span class="pre">del</span></tt> command, which is
followed by the function and operator symbols to be removed from the
breakpoint list. If <tt class="docutils literal"><span class="pre">del</span></tt> is invoked without arguments, it clears all
breakpoints (after confirmation).</p>
</div>
<div class="section" id="interactive-startup">
<h2><a class="toc-backref" href="#id52">11.8&nbsp;&nbsp;&nbsp;Interactive Startup</a></h2>
<p>In interactive mode, the interpreter also runs some additional scripts at
startup, after loading the prelude and the scripts specified on the command
line. This lets you tailor the interactive environment to your liking.</p>
<p>The interpreter first looks for a .purerc file in the user's home directory
(as given by the HOME environment variable) and then for a .purerc file in the
current working directory. These are just ordinary Pure scripts which may
contain any additional definitions that you need. The .purerc file in the home
directory is for global definitions which should always be available when
running interactively, while the .purerc file in the current directory can be
used for project-specific definitions.</p>
<p>Finally, you can also have a .pure initialization file in the current
directory, which is created by the <tt class="docutils literal"><span class="pre">dump</span></tt> command (see above) and is loaded
after the .purerc files if it is present.</p>
<p>The interpreter processes all these files in the same way as with the <tt class="docutils literal"><span class="pre">run</span></tt>
command (see above). When invoking the interpreter, you can specify the --norc
option on the command line if you wish to skip these initializations.</p>
</div>
</div>
<div class="section" id="caveats-and-notes">
<h1><a class="toc-backref" href="#id53">12&nbsp;&nbsp;&nbsp;Caveats and Notes</a></h1>
<p>This section is a grab bag of casual remarks, useful tips and tricks, and
information on common pitfalls, quirks and limitations of the current
implementation and how to deal with them.</p>
<div class="section" id="purity">
<h2><a class="toc-backref" href="#id54">12.1&nbsp;&nbsp;&nbsp;Purity</a></h2>
<p>People keep asking me what's so &quot;pure&quot; about Pure. The long and apologetic
answer is that at its core, Pure is in fact purely algebraic and purely
functional. Pure doesn't get in your way if you want to call external
operations with side effects (it does allow you to call any C function after
all), but with a few exceptions the standard library operations are free of
those. Just stay away from operations marked &quot;IMPURE&quot; in the library sources
(most notably, <tt class="docutils literal"><span class="pre">eval</span></tt>, <tt class="docutils literal"><span class="pre">catch</span></tt>/<tt class="docutils literal"><span class="pre">throw</span></tt>, references, sentries and direct
pointer manipulations) and avoid the system module, then your program will
behave according to the semantics of term rewriting.</p>
<p>The short answer is that I simply liked the name, and there wasn't any
programming language named &quot;Pure&quot; yet (quite a feat nowadays), so there's one
now. :)</p>
</div>
<div class="section" id="backward-compatibility">
<h2><a class="toc-backref" href="#id55">12.2&nbsp;&nbsp;&nbsp;Backward Compatibility</a></h2>
<p>Pure 0.7 introduced built-in matrix structures, which called for some minor
changes in the syntax of comprehensions and arithmetic
sequences. Specifically, the template expression and generator/filter clauses
of a comprehension are now separated with <tt class="docutils literal"><span class="pre">|</span></tt> instead of <tt class="docutils literal"><span class="pre">;</span></tt>. Moreover,
arithmetic sequences with arbitrary stepsize are now written <tt class="docutils literal"><span class="pre">x:y..z</span></tt>
instead of <tt class="docutils literal"><span class="pre">x,y..z</span></tt>, and the '<tt class="docutils literal"><span class="pre">..</span></tt>' operator now has a higher precedence
than the '<tt class="docutils literal"><span class="pre">,</span></tt>' operator. This makes writing matrix slices like
<tt class="docutils literal"><span class="pre">x!!(i..j,k..l)</span></tt> much more convenient.</p>
<p>In Pure 0.13 the naming of the logical and bitwise operations was changed, so
that these are now called <tt class="docutils literal"><span class="pre">~</span></tt>, <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt>, <tt class="docutils literal"><span class="pre">||</span></tt> and <tt class="docutils literal"><span class="pre">not</span></tt>/<tt class="docutils literal"><span class="pre">and</span></tt>/<tt class="docutils literal"><span class="pre">or</span></tt>,
respectively. (Previously, <tt class="docutils literal"><span class="pre">~</span></tt> was used for bitwise, <tt class="docutils literal"><span class="pre">not</span></tt> for logical
negation, which was rather inconsistent, albeit compatible with the naming of
the <tt class="docutils literal"><span class="pre">not</span></tt> operation in Haskell and ML.) Also, to stay in line with this
naming scheme, inequality was renamed to <tt class="docutils literal"><span class="pre">~=</span></tt> (previously <tt class="docutils literal"><span class="pre">!=</span></tt>).</p>
<p>Pure 0.14 introduced the namespaces feature. Consequently, the scope of
private symbols is now confined to a namespace rather than a source module;
scripts making use of private symbols need to be adapted accordingly. Also
note that syntax like <tt class="docutils literal"><span class="pre">foo::int</span></tt> may now also denote a qualified symbol
rather than a tagged variable, if <tt class="docutils literal"><span class="pre">foo</span></tt> has been declared as a
namespace. You can work around such ambiguities by renaming the variable, or
by placing spaces around the <tt class="docutils literal"><span class="pre">::</span></tt> delimiter (these aren't permitted in a
qualified symbol, so the construct <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">::</span> <span class="pre">int</span></tt> is always interpreted as a
tagged variable, no matter whether <tt class="docutils literal"><span class="pre">foo</span></tt> is also a valid namespace).</p>
<p>Pure 0.26 extended the namespaces feature to add support for hierarchical
namespaces. This means that name lookup works in a slightly different fashion
now (see <a class="reference internal" href="#hierarchical-namespaces">Hierarchical Namespaces</a> for details), but old code which doesn't
use the new feature should continue to work unchanged.</p>
</div>
<div class="section" id="error-recovery">
<h2><a class="toc-backref" href="#id56">12.3&nbsp;&nbsp;&nbsp;Error Recovery</a></h2>
<p>The parser uses a fairly simplistic panic mode error recovery which tries to
catch syntax errors at the toplevel only. This seems to work reasonably well,
but might catch some errors much too late. Unfortunately, Pure's terseness
makes it rather difficult to design a better scheme. As a remedy, the parser
accepts an empty definition (just <tt class="docutils literal"><span class="pre">;</span></tt> by itself) at the toplevel only. Thus,
in interactive usage, if the parser seems to eat away your input without doing
anything, entering an extra semicolon or two should break the spell, putting
you back at the toplevel where you can start typing the definition again.</p>
</div>
<div class="section" id="batch-compilation">
<h2><a class="toc-backref" href="#id57">12.4&nbsp;&nbsp;&nbsp;Batch Compilation</a></h2>
<p>As of Pure 0.21, the interpreter has a new -c option which provides a
convenient means to turn Pure scripts into standalone executables. This
feature is still a bit experimental right now. In particular, note that the
compiled executable is essentially a <em>static snapshot</em> of your program which
is executed on the &quot;bare metal&quot;, without a hosting interpreter. Only a minimal
runtime system is provided. This considerably reduces startup times, but also
implies the following quirks and limitations:</p>
<ul class="simple">
<li>All toplevel expressions and <tt class="docutils literal"><span class="pre">let</span></tt> bindings are evaluated <em>after</em> all
functions have been defined. This might cause inconsistent behaviour with an
interpreted run of the same program, which executes expressions and variable
definitions immediately, as the program is being processed. To avoid these
semantic differences, you'll have to make sure that expressions are
evaluated <em>after</em> all functions used in the evaluation have been defined
completely.</li>
<li>Toplevel expressions won't be of much use in a batch-compiled program,
unless, of course, they are evaluated for their side-effects. Usually your
program will have to include at least one of these to play the role of the
&quot;main program&quot; in your script. In most cases these expressions are best
placed after all the function and variable definitions, at the end of your
program.</li>
<li>The <a class="reference external" href="purelib.html#eval">eval</a> function can only be used to evaluate plain toplevel expressions.
You can define local functions and variables in <tt class="docutils literal"><span class="pre">with</span></tt> and <tt class="docutils literal"><span class="pre">when</span></tt>
clauses inside an expression, but you can't use <a class="reference external" href="purelib.html#eval">eval</a> to define new global
variables and functions. In other words, anything which changes the
executing program is &quot;verboten&quot;.</li>
<li>The introspective capabilities provided by <a class="reference external" href="purelib.html#evalcmd">evalcmd</a> (discussed under
<a class="reference internal" href="#reflection">Reflection</a> below) won't work either because the interactive commands are
all disabled.</li>
<li>Constant and macro definitions, being compile time features, aren't
available in the compiled program. If you need to use these with <a class="reference external" href="purelib.html#eval">eval</a> at
run time, you have to provide them through variable and function definitions
instead.</li>
<li>Code which gets executed to compute constant values at compile time will
<em>not</em> be executed in the compiled executable, so your program shouldn't rely
on side-effects of such computations (this would be bad practice anyway).</li>
<li>Constant values in a batch-compiled script must be real constants, run time
data such as pointers (other than the null pointer) and local functions are
not permitted. (If necessary, you can bind such values to variables instead,
then they will work fine even in a batch-compiled program.)</li>
</ul>
<p>What all this boils down to is that anything which requires the compile time
or interactive facilities of the interpreter, is unavailable. These
restrictions only apply at run time, of course. At compile time the program
<em>is</em> being executed by the interpreter so you can use <a class="reference external" href="purelib.html#eval">eval</a> and <a class="reference external" href="purelib.html#evalcmd">evalcmd</a> in
any desired way. See the description of the <tt class="docutils literal"><span class="pre">compiling</span></tt> variable below for
how to distinguish these cases in your script.</p>
<p>For most kinds of scripts, the above restrictions aren't really that much of
an obstacle, or can easily be worked around. For the few scripts which
actually need the full dynamic capabilities of Pure you'll just have to run
the script with the interpreter. This isn't a big deal either, only the
startup will be somewhat slower because the script is compiled on the
fly. Once the JIT has done its thing the &quot;interpreted&quot; script will run every
bit as fast as the &quot;compiled&quot; one, since in fact <em>both</em> are compiled (only at
different times) to exactly the same code!</p>
<p>Also note that during a batch compilation, the compiled program is actually
executed as usual, i.e., the script is also run <em>at compile time</em>. This might
first seem to be a big annoyance, but it actually opens the door for some
powerful programming techniques like <a class="reference external" href="http://en.wikipedia.org/wiki/Partial_evaluation">partial evaluation</a>. It is also a
necessity because of Pure's highly dynamic nature. For instance, Pure allows
you to define constants by evaluating an arbitrary expression (see <a class="reference internal" href="#constant-definitions">Constant
Definitions</a> below), and using <a class="reference external" href="purelib.html#eval">eval</a> a program can easily modify itself in
even more unforeseeable ways. Therefore pretty much anything in your program
can actually depend on previous computations performed while the program is
being executed.</p>
<p>For the sake of a concrete example, consider the following little script:</p>
<pre class="literal-block">
using system;

fact n = if n&gt;0 then n*fact (n-1) else 1;

main n = do puts [&quot;Hello, world!&quot;, str (map fact (1..n))];

if argc&lt;=1 then () else main (sscanf (argv!1) &quot;%d&quot;);
</pre>
<p>When invoked from the command line, with the number <tt class="docutils literal"><span class="pre">n</span></tt> as the first
parameter, this program will print the string <tt class="docutils literal"><span class="pre">&quot;Hello,</span> <span class="pre">world!&quot;</span></tt> and the list
of the first <tt class="docutils literal"><span class="pre">n</span></tt> factorials:</p>
<pre class="literal-block">
$ pure -x hello.pure 10
Hello, world!
[1,2,6,24,120,720,5040,40320,362880,3628800]
</pre>
<p>Note the condition on <tt class="docutils literal"><span class="pre">argc</span></tt> in the last line of the script. This prevents
the program from producing an exception if no command line parameters are
specified, so that the program can also be run interactively:</p>
<pre class="literal-block">
$ pure -i -q hello.pure
&gt; main 10;
Hello, world!
[1,2,6,24,120,720,5040,40320,362880,3628800]
()
&gt; quit
</pre>
<p>Turning the script into an executable works as follows:</p>
<pre class="literal-block">
$ pure -c hello.pure -o hello
$ ./hello 10
Hello, world!
[1,2,6,24,120,720,5040,40320,362880,3628800]
</pre>
<p>Next suppose that we'd like to supply the value <tt class="docutils literal"><span class="pre">n</span></tt> at <em>compile</em> rather than
run time. To these ends we want to turn the value passed to the <tt class="docutils literal"><span class="pre">main</span></tt>
function into a compile time constant, which can be done as follows:</p>
<pre class="literal-block">
const n = if argc&gt;1 then sscanf (argv!1) &quot;%d&quot; else 10;
</pre>
<p>(Note that we provide <tt class="docutils literal"><span class="pre">10</span></tt> as a default if <tt class="docutils literal"><span class="pre">n</span></tt> isn't specified on the
command line.)</p>
<p>Moreover, we want to skip the execution of <tt class="docutils literal"><span class="pre">main</span></tt> at compile time. The Pure
runtime provides a special system variable <tt class="docutils literal"><span class="pre">compiling</span></tt> which holds a truth
value indicating whether the program is actually running under the auspices of
the batch compiler, so that it can adjust accordingly. In our example, the
evaluation of <tt class="docutils literal"><span class="pre">main</span></tt> becomes:</p>
<pre class="literal-block">
if compiling then () else main n;
</pre>
<p>Our program now looks as follows:</p>
<pre class="literal-block">
using system;

fact n = if n&gt;0 then n*fact (n-1) else 1;

main n = do puts [&quot;Hello, world!&quot;, str (map fact (1..n))];

const n = if argc&gt;1 then sscanf (argv!1) &quot;%d&quot; else 10;
if compiling then () else main n;
</pre>
<p>This script &quot;specializes&quot; <tt class="docutils literal"><span class="pre">n</span></tt> to the first (compile time) parameter when
being batch-compiled, and it still works as before when we run it through the
interpreter in both batch and interactive mode, too:</p>
<pre class="literal-block">
$ pure -i -q hello.pure
Hello, world!
[1,2,6,24,120,720,5040,40320,362880,3628800]
&gt; main 5;
Hello, world!
[1,2,6,24,120]
()
&gt; quit

$ pure -x hello.pure 7
Hello, world!
[1,2,6,24,120,720,5040]

$ pure -o hello -c -x hello.pure 7
$ ./hello
Hello, world!
[1,2,6,24,120,720,5040]
</pre>
<p>You'll rarely need an elaborate setup like this, most of the time something
like our simple first example will do the trick. But, as you've seen, Pure can
easily do it.</p>
<p>Note that while the batch compiler generates native executables by default, it
can just as well create object files which can be linked into other C/C++
programs and libraries:</p>
<pre class="literal-block">
$ pure -o hello.o -c -x hello.pure 7
</pre>
<p>The .o extension tells the compiler that you want an object file. When linking
the object module, you also need to supply an initialization routine which
calls the <tt class="docutils literal"><span class="pre">__pure_main__</span></tt> function in hello.o to initialize the compiled
module. This routine is declared in C/C++ code as follows:</p>
<pre class="literal-block">
extern &quot;C&quot; void __pure_main__(int argc, char** argv);
</pre>
<p>As indicated, <tt class="docutils literal"><span class="pre">__pure_main__</span></tt> is to be invoked with two parameters, the
argument count and NULL-terminated argument vector which become the <tt class="docutils literal"><span class="pre">argc</span></tt>
and the <tt class="docutils literal"><span class="pre">argv</span></tt> of the Pure program, respectively. (You can also just pass 0
for both arguments if you don't need to supply command line parameters.) The
purpose of <tt class="docutils literal"><span class="pre">__pure_main__</span></tt> is to initialize a shell instance of the Pure
interpreter which provides the minimal runtime support necessary to execute
the Pure program, and to invoke all &quot;initialization code&quot; (variable
definitions and toplevel expressions) of the program itself.</p>
<p>A minimal C <tt class="docutils literal"><span class="pre">main</span></tt> function which does the job of initializing the Pure
module looks as follows:</p>
<pre class="literal-block">
extern void __pure_main__(int argc, char** argv);

int main(int argc, char** argv)
{
  __pure_main__(argc, argv);
  return 0;
}
</pre>
<p>If you link the <tt class="docutils literal"><span class="pre">main</span></tt> routine with the Pure module, don't forget to also
pull in the Pure runtime library. Assuming that the above C code is in
pure_main.c:</p>
<pre class="literal-block">
$ gcc -c pure_main.c -o pure_main.o
$ g++ -o hello hello.o pure_main.o -lpure
$ ./hello
Hello, world!
[1,2,6,24,120,720,5040]
</pre>
<p>(The C++ compiler is used as the linker here so that the standard C++ library
gets linked in, too. This is necessary because Pure's runtime library is
actually written in C++.)</p>
<p>In fact, this is pretty much what <tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-c</span></tt> actually does for you when
creating an executable, except that it uses llvm-g++ to do the linking.</p>
<p>If your script loads dynamic libraries (<tt class="docutils literal"><span class="pre">using</span> <span class="pre">&quot;lib:...&quot;;</span></tt>) then you'll also
have to link with those; <em>all</em> external references have to be resolved at
compile time. This is taken care of automagically when creating
executables. Otherwise it is a good idea to run <tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-c</span></tt> with the
<tt class="docutils literal"><span class="pre">-v0100</span></tt> verbosity option so that it prints the libraries to be linked (in
addition to the command used to invoke llvmc):</p>
<pre class="literal-block">
$ pure -v0100 -c hello.pure -o hello.o
llvmc -c -x llvm-assembler hello.o.ll -o hello.o
Link with: llvm-g++ hello.o -lpure
</pre>
<p>Well, we already knew that, so let's consider a slightly more interesting
example from Pure's ODBC module:</p>
<pre class="literal-block">
$ pure -v0100 -c pure-odbc/examples/menagerie.pure -o menagerie.o
llvmc -c -x llvm-assembler menagerie.o.ll -o menagerie.o
Link with: llvm-g++ menagerie.o /usr/local/lib/pure/odbc.so -lpure
$ llvm-g++ -shared -o menagerie.so menagerie.o /usr/local/lib/pure/odbc.so -lpure
</pre>
<p>Note that the listed link options are necessary but might not be sufficient;
<tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-c</span></tt> just makes a best guess based on the Pure source. On most systems
this will be good enough, but if it isn't, you can just add options to the
linker command as needed to pull in additional required libraries.</p>
<p>As this last example shows, you can also create shared libraries from Pure
modules. (Even then you'll have to supply an initialization routine which
calls <tt class="docutils literal"><span class="pre">__pure_main__</span></tt> somewhere. Once the Pure module is initialized, you
can employ the Pure runtime API to call Pure functions in the module. See the
runtime.h header file for details.)</p>
<p>Last but not least, <tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-c</span></tt> can also generate just plain LLVM assembler
code:</p>
<pre class="literal-block">
pure -c hello.pure -o hello.ll
</pre>
<p>Note the .ll extension; this tells the compiler that you want an LLVM
assembler file. In this case you'll have to have to handle the rest of the
compilation yourself. This gives you the opportunity, e.g., to employ the LLVM
toolchain to apply special source code optimizations. Please refer to the
<a class="reference external" href="http://llvm.org/docs/">LLVM documentation</a> for details.</p>
</div>
<div class="section" id="the-show-function">
<h2><a class="toc-backref" href="#id58">12.5&nbsp;&nbsp;&nbsp;The __show__ Function</a></h2>
<p>As of Pure 0.6, the interpreter provides a &quot;hook&quot; to override the print
representations of expressions at runtime by means of the <tt class="docutils literal"><span class="pre">__show__</span></tt>
function, which works in a fashion similar to Haskell's <tt class="docutils literal"><span class="pre">show</span></tt>
function. This feature is still a bit experimental, but seems to work
reasonably well for the purposes for which it is intended.</p>
<p><tt class="docutils literal"><span class="pre">__show__</span></tt> is just an ordinary Pure function expected to return a string
with the desired custom representation of a normal form value given as the
function's single argument. This function is not defined by default, so you
are free to add any rules that you want. The interpreter prints the strings
returned by <tt class="docutils literal"><span class="pre">__show__</span></tt> just as they are. It will not check whether they
conform to Pure syntax and/or semantics, or modify them in any way.</p>
<p>Custom print representations are most useful for interactive purposes, if
you're not happy with the default print syntax of some kinds of objects. One
particularly useful application of <tt class="docutils literal"><span class="pre">__show__</span></tt> is to change the format of
numeric values. Here are some examples:</p>
<pre class="literal-block">
&gt; using system;
&gt; __show__ x::double = sprintf &quot;%0.6f&quot; x;
&gt; 1/7;
0.142857
&gt; __show__ x::int = sprintf &quot;0x%0x&quot; x;
&gt; 1786;
0x6fa
&gt; using math;
&gt; __show__ (x::double+:y::double) = sprintf &quot;%0.6f+%0.6fi&quot; (x,y);
&gt; cis (-pi/2);
0.000000+-1.000000i
</pre>
<p>The prelude function <tt class="docutils literal"><span class="pre">str</span></tt>, which returns the print representation of any
Pure expression, calls <tt class="docutils literal"><span class="pre">__show__</span></tt> as well:</p>
<pre class="literal-block">
&gt; str (1/7);
&quot;0.142857&quot;
</pre>
<p>Conversely, you can call the <tt class="docutils literal"><span class="pre">str</span></tt> function from <tt class="docutils literal"><span class="pre">__show__</span></tt>, but in this
case it always returns the default representation of an expression. This
prevents the expression printer from going recursive, and allows you to define
your custom representation in terms of the default one. E.g., the following
rule removes the <tt class="docutils literal"><span class="pre">L</span></tt> suffixes from bigint values:</p>
<pre class="literal-block">
&gt; __show__ x::bigint = init (str x);
&gt; fact n = foldl (*) 1L (1..n);
&gt; fact 30;
265252859812191058636308480000000
</pre>
<p>Of course, your definition of <tt class="docutils literal"><span class="pre">__show__</span></tt> can also call <tt class="docutils literal"><span class="pre">__show__</span></tt> itself
recursively to determine the custom representation of an object.</p>
<p>One case which needs special consideration are thunks (futures). The printer
will <em>never</em> use <tt class="docutils literal"><span class="pre">__show__</span></tt> for those, to prevent them from being forced
inadvertently. In fact, you <em>can</em> use <tt class="docutils literal"><span class="pre">__show__</span></tt> to define custom
representations for thunks, but only in the context of a rule for other kinds
of objects, such as lists. For instance:</p>
<pre class="literal-block">
&gt; nonfix ...;
&gt; __show__ (x:xs) = str (x:...) if thunkp xs;
&gt; 1:2:(3..inf);
1:2:3:...
</pre>
<p>Another case which needs special consideration are numeric matrices. For
efficiency, the expression printer will always use the default representation
for these, unless you override the representation of the matrix as a
whole. E.g., the following rule for double matrices mimics Octave's default
output format (for the sake of simplicity, this isn't perfect, but you get the
idea):</p>
<pre class="literal-block">
&gt; __show__ x::matrix =
&gt;   strcat [printd j (x!(i,j))|i=0..n-1; j=0..m-1] + &quot;\n&quot;
&gt; with printd 0 = sprintf &quot;\n%10.5f&quot;; printd _ = sprintf &quot;%10.5f&quot; end
&gt; when n,m = dim x end if dmatrixp x;
&gt; {1.0,1/2;1/3,4.0};
   1.00000   0.50000
   0.33333   4.00000
</pre>
<p>Finally, by just purging the definition of the <tt class="docutils literal"><span class="pre">__show__</span></tt> function you can
easily go back to the standard print syntax:</p>
<pre class="literal-block">
&gt; clear __show__
&gt; 1/7; 1786; cis (-pi/2);
0.142857142857143
1786
6.12303176911189e-17+:-1.0
</pre>
<p>Note that if you have a set of definitions for the <tt class="docutils literal"><span class="pre">__show__</span></tt> function which
should always be loaded at startup, you can put them into the interpreter's
interactive startup files, see <a class="reference internal" href="#interactive-usage">Interactive Usage</a>.</p>
</div>
<div class="section" id="as-patterns">
<h2><a class="toc-backref" href="#id59">12.6&nbsp;&nbsp;&nbsp;&quot;As&quot; Patterns</a></h2>
<p>In the current implementation, &quot;as&quot; patterns cannot be placed on the &quot;spine&quot;
of a function definition. Thus rules like the following, which have the
pattern somewhere in the head of the left-hand side, will all provoke an error
message from the compiler:</p>
<pre class="literal-block">
a&#64;foo x y   = a,x,y;
a&#64;(foo x) y = a,x,y;
a&#64;(foo x y) = a,x,y;
</pre>
<p>This is because the spine of a function application is not available when the
function is called at runtime. &quot;As&quot; patterns in pattern bindings (<tt class="docutils literal"><span class="pre">case</span></tt>,
<tt class="docutils literal"><span class="pre">when</span></tt>) are not affected by this restriction since the entire value to be
matched is available at runtime. For instance:</p>
<pre class="literal-block">
&gt; case bar 99 of y&#64;(bar x) = y,x+1; end;
bar 99,100
</pre>
</div>
<div class="section" id="head-function">
<h2><a class="toc-backref" href="#id60">12.7&nbsp;&nbsp;&nbsp;Head = Function</a></h2>
<p>&quot;As&quot; patterns are also a useful device if you need to manipulate function
applications in a generic way. Note that the &quot;head = function&quot; rule means that
the head symbol <tt class="docutils literal"><span class="pre">f</span></tt> of an application <tt class="docutils literal"><span class="pre">f</span> <span class="pre">x1</span> <span class="pre">...</span> <span class="pre">xn</span></tt> occurring on (or
inside) the left-hand side of an equation, variable binding, or
pattern-matching lambda expression, is always interpreted as a literal
function symbol (not a variable). This implies that you cannot match the
&quot;function&quot; component of an application against a variable, at least not
directly. An anonymous &quot;as&quot; pattern like <tt class="docutils literal"><span class="pre">f&#64;_</span></tt> does the trick, however,
since the anonymous variable is always recognized, even if it occurs as the
head symbol of a function application. Here's a little example which
demonstrates how you can convert a function application to a list containing
the function and all arguments:</p>
<pre class="literal-block">
&gt; foo x = a [] x with a xs (x&#64;_ y) = a (y:xs) x; a xs x = x:xs end;
&gt; foo (a b c d);
[a,b,c,d]
</pre>
<p>This may seem a little awkward, but as a matter of fact the &quot;head = function&quot;
rule is quite useful since it covers the common cases without forcing the
programmer to declare &quot;constructor&quot; symbols (except nonfix symbols). On the
other hand, generic rules operating on arbitrary function applications are not
all that common, so having to &quot;escape&quot; a variable using the anonymous &quot;as&quot;
pattern trick is a small price to pay for that convenience.</p>
<p>Sometimes you may also run into the complementary problem, i.e., to match a
function argument against a given function. Consider this code fragment:</p>
<pre class="literal-block">
foo x = x+1;
foop f = case f of foo = 1; _ = 0 end;
</pre>
<p>You might expect <tt class="docutils literal"><span class="pre">foop</span></tt> to return true for <tt class="docutils literal"><span class="pre">foo</span></tt>, and false on all other
values. Better think again, because in reality <tt class="docutils literal"><span class="pre">foop</span></tt> will always return
true! In fact, the Pure compiler will warn you about the second rule of the
<tt class="docutils literal"><span class="pre">case</span></tt> expression not being used at all:</p>
<pre class="literal-block">
&gt; foop 99;
warning: rule never reduced: _ = 0;
1
</pre>
<p>This happens because an identifier on the left-hand side of a rule, which is
neither the head symbol of a function application nor a <tt class="docutils literal"><span class="pre">nonfix</span></tt> symbol, is
always considered to be a variable (cf. <a class="reference internal" href="#parameters-in-equations">Parameters in Equations</a>), even if
that symbol is defined as a global function elsewhere. So <tt class="docutils literal"><span class="pre">foo</span></tt> isn't a
literal name in the above <tt class="docutils literal"><span class="pre">case</span></tt> expression, it's a variable! (As a matter
of fact, this is rather useful, since otherwise a rule like <tt class="docutils literal"><span class="pre">f</span> <span class="pre">g</span> <span class="pre">=</span> <span class="pre">g+1</span></tt>
would suddenly change meaning if you happen to add a definition like <tt class="docutils literal"><span class="pre">g</span> <span class="pre">x</span> <span class="pre">=</span>
<span class="pre">x-1</span></tt> somewhere else in your program, which certainly isn't desirable.)</p>
<p>A possible workaround is to &quot;escape&quot; the function symbol using an empty
namespace qualifier:</p>
<pre class="literal-block">
foop f = case f of ::foo = 1; _ = 0 end;
</pre>
<p>This trick works in <tt class="docutils literal"><span class="pre">case</span></tt> expressions and function definitions, but fails
in circumstances in which qualified variable symbols are permitted (i.e., in
variable and constant definitions). A better solution is to employ the
syntactic equality operator <tt class="docutils literal"><span class="pre">===</span></tt> defined in the prelude to match the target
value against the function symbol. This allows you to define the <tt class="docutils literal"><span class="pre">foop</span></tt>
predicate as follows:</p>
<pre class="literal-block">
&gt; foop f = f===foo;
&gt; foop foo, foop 99;
1,0
</pre>
<p>Another way to deal with the situation would be to just declare <tt class="docutils literal"><span class="pre">foo</span></tt> as a
nonfix symbol. However, this makes the <tt class="docutils literal"><span class="pre">foo</span></tt> symbol &quot;precious&quot;, i.e., after
such a declaration it cannot be used as a local variable anymore. It's usually
a good idea to avoid that kind of thing, at least for generic symbols, so the
above solution is preferred in this case.</p>
</div>
<div class="section" id="namespaces-and-implicit-declarations">
<h2><a class="toc-backref" href="#id61">12.8&nbsp;&nbsp;&nbsp;Namespaces and Implicit Declarations</a></h2>
<p>A common pitfall is the implicit declaration of unqualified symbols in
conjunction with the <tt class="docutils literal"><span class="pre">namespace</span></tt> declaration. For instance, it is tempting
to write the following, and expect <tt class="docutils literal"><span class="pre">foo</span></tt> to become a member of the <tt class="docutils literal"><span class="pre">bar</span></tt>
namespace:</p>
<pre class="literal-block">
namespace bar;
foo x = x+1;
</pre>
<p>But, assuming that <tt class="docutils literal"><span class="pre">foo</span></tt> is not already declared or defined elsewhere, it
will actually become a member of the default namespace instead. This is
necessary because in Pure it is impossible to distinguish local variables from
unqualified function symbols at the lexical level, and thus all undeclared and
unqualified identifiers are implicitly declared in the default
namespace. Thus, if you really want the <tt class="docutils literal"><span class="pre">foo</span></tt> symbol to become a member of
the <tt class="docutils literal"><span class="pre">bar</span></tt> namespace, you must either declare it explicitly or use a
qualified identifier. That is, you have to write either:</p>
<pre class="literal-block">
namespace bar;
bar::foo x = x+1;
</pre>
<p>Or:</p>
<pre class="literal-block">
namespace bar;
public foo;
foo x = x+1;
</pre>
<p>This will tell the compiler about the desired namespace of the symbol.</p>
</div>
<div class="section" id="with-or-when">
<h2><a class="toc-backref" href="#id62">12.9&nbsp;&nbsp;&nbsp;With or when?</a></h2>
<p>Another common source of confusion is that Pure provides two different
constructs to bind local function and variable symbols, respectively. This
distinction is necessary because Pure does not segregate defined functions and
constructors, and thus there is no magic to figure out whether an equation
like <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></tt> by itself is meant as a definition of a function <tt class="docutils literal"><span class="pre">foo</span></tt>
with formal parameter <tt class="docutils literal"><span class="pre">x</span></tt> and return value <tt class="docutils literal"><span class="pre">y</span></tt>, or a definition binding
the local variable <tt class="docutils literal"><span class="pre">x</span></tt> by matching the constructor pattern <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">x</span></tt> against
the value <tt class="docutils literal"><span class="pre">y</span></tt>. The <tt class="docutils literal"><span class="pre">with</span></tt> construct does the former, <tt class="docutils literal"><span class="pre">when</span></tt> the latter.</p>
<p>Another speciality is that <tt class="docutils literal"><span class="pre">with</span></tt> and <tt class="docutils literal"><span class="pre">when</span></tt> clauses are tacked on to the
end of the expression they belong to, which mimics mathematical language but
may be unfamilar if you're more accustomed to programming languages from the
Algol/Pascal/C family. If you want to figure out what is actually going on
there, it is helpful to read nested scopes &quot;in reverse&quot; (proceeding from the
rightmost/outermost to the leftmost/innermost clause).</p>
</div>
<div class="section" id="numeric-calculations">
<h2><a class="toc-backref" href="#id63">12.10&nbsp;&nbsp;&nbsp;Numeric Calculations</a></h2>
<p>If possible, you should decorate numeric variables on the left-hand sides of
function definitions with the appropriate type tags, like <tt class="docutils literal"><span class="pre">::int</span></tt> or
<tt class="docutils literal"><span class="pre">::double</span></tt>. This often helps the compiler to generate better code and makes
your programs run faster. The <tt class="docutils literal"><span class="pre">|</span></tt> syntax makes it easy to add the necessary
specializations of existing rules to your program. E.g., taking the
polymorphic implementation of the factorial as an example, you only have to
add a left-hand side with the appropriate type tag to make that definition go
as fast as possible for the special case of machine integers:</p>
<pre class="literal-block">
fact n::int    |
fact n         = n*fact(n-1) if n&gt;0;
               = 1 otherwise;
</pre>
<p>(This obviously becomes unwieldy if you have to deal with several numeric
arguments of different types, however, so in this case it is usually better to
just use a polymorphic rule.)</p>
<p>Also note that int (the machine integers), bigint (the GMP &quot;big&quot; integers) and
double (floating point numbers) are all different kinds of objects. While they
can be used in mixed operations (such as multiplying an int with a bigint
which produces a bigint, or a bigint with a double which produces a double),
the <tt class="docutils literal"><span class="pre">::int</span></tt> tag will only ever match a machine int, <em>not</em> a bigint or a
double. Likewise, <tt class="docutils literal"><span class="pre">::bigint</span></tt> only matches bigints (never int or double
values), and <tt class="docutils literal"><span class="pre">::double</span></tt> only doubles. Thus, if you want to define a function
operating on different kinds of numbers, you'll also have to provide equations
for all the types that you need (or a polymorphic rule which catches them
all). This also applies to equations matching against constant values of these
types. In particular, a small integer constant like <tt class="docutils literal"><span class="pre">0</span></tt> only matches machine
integers, not bigints; for the latter you'll have to use the &quot;big L&quot; notation
<tt class="docutils literal"><span class="pre">0L</span></tt>. Similarly, the constant <tt class="docutils literal"><span class="pre">0.0</span></tt> only matches doubles, but not ints or
bigints.</p>
</div>
<div class="section" id="constant-definitions">
<h2><a class="toc-backref" href="#id64">12.11&nbsp;&nbsp;&nbsp;Constant Definitions</a></h2>
<p>When definining a function in terms of constant values which have to be
computed beforehand, it's usually better to use a <tt class="docutils literal"><span class="pre">const</span></tt> definition (rather
than defining a variable or a parameterless function or macro) for that
purpose, since this will often allow the compiler to generate better code
using constant folding and similar techniques. Example:</p>
<pre class="literal-block">
&gt; extern double atan(double);
&gt; const pi = 4*atan 1.0;
&gt; foo x = 2*pi*x;
&gt; show foo
foo x = 2*3.14159265358979*x;
</pre>
<p>(If you take a look at the disassembled code for this function, you will find
that the value 2*3.14159265358979 = 6.28318530717959 has actually been
computed at compile time.)</p>
<p>Note that constant definitions differ from parameterless macros in that the
right-hand side of the definition is in fact evaluated at definition
time. E.g., compare the above with the following macro definition:</p>
<pre class="literal-block">
&gt; clear pi foo
&gt; def pi = 4*atan 1.0;
&gt; foo x = 2*pi*x;
&gt; show foo
foo x = 2*(4*atan 1.0)*x;
</pre>
<p>The LLVM backend also eliminates dead code automagically, which enables you to
employ a constant computed at runtime to configure your code for different
environments, without any runtime penalties:</p>
<pre class="literal-block">
const win = index sysinfo &quot;mingw32&quot; &gt;= 0;
check boy = bad boy if win;
          = good boy otherwise;
</pre>
<p>In this case the code for one of the branches of <tt class="docutils literal"><span class="pre">check</span></tt> will be completely
eliminated, depending on the outcome of the configuration check.</p>
<p>Constants also differ from variables in that they cannot be redefined (that's
their purpose after all) and will only take effect on subsequent
definitions. E.g.:</p>
<pre class="literal-block">
&gt; const c = 2;
&gt; foo x = c*x;
&gt; show foo
foo x = 2*x;
&gt; foo 99;
198
&gt; const c = 3;
&lt;stdin&gt;, line 5: symbol 'c' is already defined as a constant
</pre>
<p>Well, in fact this not the full truth because in interactive mode it <em>is</em>
possible to redefine constants after all, if the old definition is first
purged with the <tt class="docutils literal"><span class="pre">clear</span></tt> command. However, this won't affect any other
existing definitions:</p>
<pre class="literal-block">
&gt; clear c
&gt; const c = 3;
&gt; bar x = c*x;
&gt; show foo bar
foo x = 2*x;
bar x = 3*x;
</pre>
<p>(You'll also have to purge any existing definition of a variable if you want
to redefine it as a constant, or vice versa, since Pure won't let you redefine
an existing constant or variable as a different kind of symbol. The same also
holds if a symbol is currently defined as a function or a macro.)</p>
<p>Finally, note that in difference to <tt class="docutils literal"><span class="pre">nonfix</span></tt> symbols, by default <tt class="docutils literal"><span class="pre">const</span></tt>
symbols cannot be used on the left-hand side of a rule. E.g., the following
will not work as expected:</p>
<pre class="literal-block">
&gt; const zero = 0; const one = 1;
&gt; foo x = case x of one = &quot;one&quot;; zero = &quot;zero&quot;; _ = &quot;???&quot; end;
&gt; show foo
foo x = case x of one = &quot;one&quot;; zero = &quot;zero&quot;; _ = &quot;???&quot; end;
&gt; foo zero, foo one, foo 99;
warning: rule never reduced: zero = &quot;zero&quot;;
warning: rule never reduced: _ = &quot;???&quot;;
&quot;one&quot;,&quot;one&quot;,&quot;one&quot;
</pre>
<p>This is the same kind of pitfall as discussed in the context of the <tt class="docutils literal"><span class="pre">foop</span></tt>
predicate in <a class="reference internal" href="#head-function">Head = Function</a> above. As a remedy, Pure allows you to declare
a <tt class="docutils literal"><span class="pre">const</span></tt> symbol as <tt class="docutils literal"><span class="pre">nonfix</span></tt> and have it behave as a nonfix symbol also on
the <em>left-hand side</em> of a rule. To these ends, the value of the symbol will
then be substituted for its occurrences in a pattern:</p>
<pre class="literal-block">
&gt; nonfix zero one;
&gt; bar x = case x of one = &quot;one&quot;; zero = &quot;zero&quot;; _ = &quot;???&quot; end;
&gt; show bar
bar x = case x of 1 = &quot;one&quot;; 0 = &quot;zero&quot;; _ = &quot;???&quot; end;
&gt; bar zero, bar one, bar 99;
&quot;zero&quot;,&quot;one&quot;,&quot;???&quot;
</pre>
</div>
<div class="section" id="external-c-functions">
<h2><a class="toc-backref" href="#id65">12.12&nbsp;&nbsp;&nbsp;External C Functions</a></h2>
<p>The interpreter always takes your <tt class="docutils literal"><span class="pre">extern</span></tt> declarations of C routines at
face value. It will not go and read any C header files to determine whether
you actually declared the function correctly! So you have to be careful to
give the proper declarations, otherwise your program will probably segfault
calling the function.</p>
<p>You also have to be careful when passing generic pointer values to external C
routines, since currently there is no type checking for these; any pointer
type other than <tt class="docutils literal"><span class="pre">char*</span></tt>, <tt class="docutils literal"><span class="pre">expr*</span></tt> and the matrix pointer types is
effectively treated as <tt class="docutils literal"><span class="pre">void*</span></tt>. This considerably simplifies lowlevel
programming and interfacing to C libraries, but also makes it very easy to
have your program segfault all over the place. Therefore it is highly
recommended that you wrap your lowlevel code in Pure routines and data
structures which do all the checks necessary to ensure that only the right
kind of data is passed to C routines.</p>
<p>Another limitation of the C interface is that it does not offer any special
support for C structs and C function parameters. However, an optional addon
module is available which interfaces to the <a class="reference external" href="http://sourceware.org/libffi/">libffi</a> library to provide that
kind of functionality, please see the description of the <a class="reference external" href="http://code.google.com/p/pure-lang/wiki/Addons#pure-ffi">pure-ffi</a> module on
the Pure website for details.</p>
<p>Last but not least, to make it easier to create Pure interfaces to large C
libraries, there's a separate <a class="reference external" href="http://code.google.com/p/pure-lang/wiki/Addons#pure-gen">pure-gen</a> program available at the Pure
website. This program takes a C header (.h) file and creates a corresponding
Pure module with definitions and <tt class="docutils literal"><span class="pre">extern</span></tt> declarations for the constants and
functions declared in the header. Please refer to the pure-gen(1) manual page
for details.</p>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id66">12.13&nbsp;&nbsp;&nbsp;Special Forms</a></h2>
<p>Special forms are recognized at compile time only. Thus the <tt class="docutils literal"><span class="pre">catch</span></tt>
function, as well as <tt class="docutils literal"><span class="pre">quote</span></tt> and the operators <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt>, <tt class="docutils literal"><span class="pre">||</span></tt>, <tt class="docutils literal"><span class="pre">$$</span></tt> and
<tt class="docutils literal"><span class="pre">&amp;</span></tt>, are only treated as special forms in direct (saturated) calls. They can
still be used if you pass them around as function values or in partial
applications, but in this case they lose all their special call-by-name
argument processing.</p>
</div>
<div class="section" id="the-quote">
<h2><a class="toc-backref" href="#id67">12.14&nbsp;&nbsp;&nbsp;The Quote</a></h2>
<p>Like in Lisp, the <tt class="docutils literal"><span class="pre">quote</span></tt> special form can be used to construct literal
expressions which can then be manipulated before actually evaluating them
using the built-in <tt class="docutils literal"><span class="pre">eval</span></tt> function. However, there are some notable
differences to the Lisp version of <tt class="docutils literal"><span class="pre">quote</span></tt>:</p>
<ul class="simple">
<li>Local variables (i.e., variables bound by the left-hand side of an equation,
a lambda expression or the <tt class="docutils literal"><span class="pre">when</span></tt> construct) can never be quoted, so the
corresponding value gets substituted even into quoted expressions. Thus,
e.g., <tt class="docutils literal"><span class="pre">'(2*42+2^n)</span> <span class="pre">when</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">12</span> <span class="pre">end</span></tt> evaluates to <tt class="docutils literal"><span class="pre">2*42+2^12</span></tt> rather than
<tt class="docutils literal"><span class="pre">2*42+2^n</span></tt>.</li>
<li>Only simple expressions can be quoted in Pure. Special constructs embedded
in a quoted expression, such as conditionals and local bindings, are
evaluated as usual. For instance, <tt class="docutils literal"><span class="pre">'(2*42+(2^n</span> <span class="pre">when</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">2*6</span> <span class="pre">end))</span></tt>
evaluates to <tt class="docutils literal"><span class="pre">2*42+4096.0</span></tt> rather than quoting the embedded <tt class="docutils literal"><span class="pre">when</span></tt>
expression.</li>
</ul>
<p>While it's possible to define a Lisp-like <tt class="docutils literal"><span class="pre">quasiquote</span></tt> in Pure (see the
<a class="reference internal" href="#recursive-macros">Recursive Macros</a> section for a simplified version, a full implementation
can be found in the Pure library sources), it's usually not needed. As
discussed above, substitution of local variables is performed even in quoted
expressions, so that it is quite easy to fill in variable parts in a quoted
&quot;template&quot; expression. For instance:</p>
<pre class="literal-block">
&gt; (\x -&gt; '(2*x+1)) 99;
2*99+1
&gt; foo x = '(2*x+1);
&gt; foo 99; foo $ '(7/y);
2*99+1
2*(7/y)+1
</pre>
<p>In fact, it is possible to perform arbitrary computations right in the middle
of a quoted expression, using one of the special <tt class="docutils literal"><span class="pre">if</span></tt>-<tt class="docutils literal"><span class="pre">then</span></tt>-<tt class="docutils literal"><span class="pre">else</span></tt>,
<tt class="docutils literal"><span class="pre">case</span></tt>, <tt class="docutils literal"><span class="pre">when</span></tt> and <tt class="docutils literal"><span class="pre">with</span></tt> expressions, since these are never quoted
either. Example:</p>
<pre class="literal-block">
&gt; '(x+1 when x = '(2*3) end);
2*3+1
</pre>
<p>Another useful feature of Lisp's <tt class="docutils literal"><span class="pre">quasiquote</span></tt> is the capability to splice
arguments into a function application. It is possible to achieve pretty much
the same in Pure with the following variation of the <tt class="docutils literal"><span class="pre">$</span></tt> operator which
&quot;curries&quot; its second (tuple) operand:</p>
<pre class="literal-block">
infixr 0 $&#64; ;
f $&#64; ()     = f;
f $&#64; (x,xs) = f x $&#64; xs;
f $&#64; x      = f x;
</pre>
<p>Now you can write, e.g.:</p>
<pre class="literal-block">
&gt; '(foo 1 2) $&#64; '(2/3,3/4);
foo 1 2 (2/3) (3/4)
</pre>
<p>One shortcoming of Pure's <tt class="docutils literal"><span class="pre">quote</span></tt> is that there is no way to quote special
constructs such as lambdas. Macro expansion <em>is</em> inhibited in quoted
expressions, however, so it is possible to work around this limitation by
defining a custom special form to be used as a symbolic representation for,
say, a lambda expression, which reduces to a real lambda when evaluated. To
these ends, the <tt class="docutils literal"><span class="pre">eval</span></tt> function can be invoked with a string argument as
follows:</p>
<pre class="literal-block">
def lambda x y = eval $ &quot;\\ &quot;+str ('x)+&quot; -&gt; &quot;+str ('y);
</pre>
<p>Example:</p>
<pre class="literal-block">
&gt; let l = 'lambda x (x+1); l;
lambda x (x+1)
&gt; let f = eval l; f; f 9;
#&lt;closure 0x7fdc3ca45be8&gt;
10
</pre>
<p>Other special constructs, such as <tt class="docutils literal"><span class="pre">case</span></tt>, <tt class="docutils literal"><span class="pre">when</span></tt> and <tt class="docutils literal"><span class="pre">with</span></tt> can be
handled in a similar fashion.</p>
</div>
<div class="section" id="laziness">
<h2><a class="toc-backref" href="#id68">12.15&nbsp;&nbsp;&nbsp;Laziness</a></h2>
<p>Pure does lazy evaluation in the same way as <a class="reference internal" href="#alice-ml">Alice ML</a>, providing an
explicit operation (<tt class="docutils literal"><span class="pre">&amp;</span></tt>) to defer evaluation and create a &quot;future&quot; which is
called by need. However, note that like any language with a basically eager
evaluation strategy, Pure cannot really support lazy evaluation in a fully
automatic way. That is, coding an operation so that it works with infinite
data structures usually requires additional thought, and sometimes special
code will be needed to recognize futures in the input and handle them
accordingly. This can be hard, but of course in the case of the prelude
operations this work has already been done for you, so as long as you stick to
these, you'll never have to think about these issues. (It should be noted here
that lazy evaluation has its pitfalls even in fully lazy FPLs, such as hidden
memory leaks and other kinds of subtle inefficiencies or non-termination
issues resulting from definitions being too lazy or not lazy enough. You can
read about that in any good textbook on Haskell.)</p>
<p>The prelude goes to great lengths to implement all standard list operations in
a way that properly deals with streams (a.k.a. lazy lists). What this all
boils down to is that all list operations which can reasonably be expected to
operate in a lazy way on streams, will do so. (Exceptions are inherently eager
operations such as <tt class="docutils literal"><span class="pre">#</span></tt>, <tt class="docutils literal"><span class="pre">reverse</span></tt> and <tt class="docutils literal"><span class="pre">foldl</span></tt>.) Only those portions of
an input stream will be traversed which are strictly required to produce the
result. For most purposes, this works just like in fully lazy FPLs such as
Haskell. However, there are some notable differences:</p>
<ul class="simple">
<li>Since Pure uses dynamic typing, some of the list functions may have to peek
ahead one element in input streams to check their arguments for validity,
meaning that these functions will be slightly more eager than their Haskell
counterparts.</li>
<li>Pure's list functions never produce truly cyclic list structures such as the
ones you get, e.g., with Haskell's <tt class="docutils literal"><span class="pre">cycle</span></tt> operation. (This is actually a
good thing, because the current implementation of the interpreter cannot
garbage-collect cyclic expression data.) Cyclic streams such as <tt class="docutils literal"><span class="pre">cycle</span>
<span class="pre">[1]</span></tt> or <tt class="docutils literal"><span class="pre">fix</span> <span class="pre">(1:)</span></tt> will of course work as expected, but, depending
on the algorithm, memory usage may increase linearly as they are traversed.</li>
<li>Pattern matching is always refutable (and therefore eager) in Pure. If you
need something like Haskell's irrefutable matches, you'll have to code them
explicitly using futures. See the definition of the <tt class="docutils literal"><span class="pre">unzip</span></tt> function in
the prelude for an example showing how to do this.</li>
</ul>
</div>
<div class="section" id="reflection">
<h2><a class="toc-backref" href="#id69">12.16&nbsp;&nbsp;&nbsp;Reflection</a></h2>
<p>Pure versions since 0.12 offer some basic reflection capabilities via the
<tt class="docutils literal"><span class="pre">evalcmd</span></tt> primitive. This function provides access to interactive commands
like <tt class="docutils literal"><span class="pre">clear</span></tt>, <tt class="docutils literal"><span class="pre">save</span></tt> and <tt class="docutils literal"><span class="pre">show</span></tt>, which enable you to inspect and modify
the running program. The only &quot;canonical&quot; way to represent an entire Pure
program in Pure itself is the program text, hence <tt class="docutils literal"><span class="pre">evalcmd</span></tt> only provides a
textual interface at this time. But of course custom higher-level
representations can be built on top of that, similar to those discussed in
section <a class="reference internal" href="#the-quote">The Quote</a>.</p>
<p>Here's an example showing what can be done using the <tt class="docutils literal"><span class="pre">show</span></tt> command and a
little bit of trivial text processing. The following <tt class="docutils literal"><span class="pre">sym_info</span></tt> function
retrieves information about a given collection of global symbols in a way
which can be processed in a Pure program. The <tt class="docutils literal"><span class="pre">cat</span></tt> argument can be any
combination of the letters &quot;c&quot;, &quot;v&quot;, &quot;f&quot; and &quot;m&quot; denoting the categories of
constants, variables, functions and macros, respectively. (You can also just
leave this empty if you don't care about the type of symbol.) The <tt class="docutils literal"><span class="pre">pat</span></tt>
argument is a shell-like glob pattern for the name of symbols which should be
listed (just &quot;*&quot; matches all symbols). The result is a list of tuples <tt class="docutils literal"><span class="pre">(name,</span>
<span class="pre">value,</span> <span class="pre">cat,</span> <span class="pre">descr)</span></tt> with the name of the symbol and its value, as well as the
category and description of the symbol, as provided by <tt class="docutils literal"><span class="pre">show</span> <span class="pre">-s</span></tt>.</p>
<pre class="literal-block">
using system;
sym_info cat::string pat::string
= [name,eval (&quot;(&quot;+name+&quot;)&quot;),descr | name,descr = info]
when
  // Get the info about matching symbols from the 'show' command.
  info = evalcmd $ sprintf &quot;show -sg%s %s&quot; (cat,pat);
  // Split into lines.
  info = if null info then [&quot;&quot;] else split &quot;\n&quot; $ init info;
  // Get rid of the last line with the summary information.
  info = init info;
  // Retrieve the information that we need.
  info = [x | x&#64;(s,_) = map fields info;
  // Get rid of extra lines containing extern and fixity declarations.
          s ~= &quot;extern&quot; &amp;&amp; s ~= &quot;nonfix&quot; &amp;&amp; s ~= &quot;outfix&quot; &amp;&amp;
          s ~= &quot;prefix&quot; &amp;&amp; s ~= &quot;postfix&quot; &amp;&amp; ~fnmatch &quot;infix*&quot; s 0];
end with
  // Regex call to split the summary information about one symbol, as
  // returned by 'show -s', into the name and description parts.
  fields s::string = tuple $
          [info!2 | info = tail $ regs $ reg_info $
           regex &quot;([^ ]+)[ ]+([a-z]*)[ ]*(.*)&quot; REG_EXTENDED s 0];
end;
</pre>
<p>E.g., this call retrieves information about all defined macros:</p>
<pre class="literal-block">
&gt; sym_info &quot;m&quot; &quot;*&quot;;
[(&quot;$&quot;,($),&quot;mac&quot;,&quot;2 args, 1 rules&quot;),(&quot;.&quot;,(.),&quot;mac&quot;,&quot;3 args, 1 rules&quot;),
(&quot;void&quot;,void,&quot;mac&quot;,&quot;1 args, 6 rules&quot;)]
</pre>
</div>
<div class="section" id="hygienic-macros">
<h2><a class="toc-backref" href="#id70">12.17&nbsp;&nbsp;&nbsp;Hygienic Macros</a></h2>
<p>Macro hygiene is a somewhat esoteric topic for most programmers, so let us
take a brief look at what it's all about. The problem avoided by hygienic
macros is that of <em>name capture</em>. There are actually two kinds of name capture
which may occur in unhygienic macro systems:</p>
<ul class="simple">
<li>A free symbol in the macro <em>body</em> inadvertently becomes bound to the value
of a local symbol in the context in which the macro is called.</li>
<li>A free symbol in the macro <em>call</em> inadvertently becomes bound to the value
of a local symbol in the macro body.</li>
</ul>
<p>Pure's hygienic macros avoid both pitfalls. Here is an example for the first
form of name capture:</p>
<pre class="literal-block">
&gt; def G x = x+y;
&gt; G 10 when y = 99 end;
10+y
</pre>
<p>Note that the expansion of the <tt class="docutils literal"><span class="pre">G</span></tt> macro correctly uses the global instance
of <tt class="docutils literal"><span class="pre">y</span></tt>, even though <tt class="docutils literal"><span class="pre">y</span></tt> is locally defined in the context of the macro
call. (Sometimes this form of name capture is actually used deliberately in
order to make the macro use the binding of the symbol which is active at the
point of the macro call. This never works in Pure, hence in such cases you
will have to explicitly pass such symbols to the macro.)</p>
<p>In contrast, the second form of name capture is usually not intended, and is
therefore more dangerous. Consider the following example:</p>
<pre class="literal-block">
&gt; def F x = x+y when y = x+1 end;
&gt; F y;
y+(y+1)
</pre>
<p>Pure again gives the correct result here. You'd have to be worried if you got
<tt class="docutils literal"><span class="pre">(y+1)+(y+1)</span></tt> instead, which would result from the literal expansion <tt class="docutils literal"><span class="pre">y+y</span>
<span class="pre">when</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">y+1</span> <span class="pre">end</span></tt>, where the (free) variable <tt class="docutils literal"><span class="pre">y</span></tt> passed to <tt class="docutils literal"><span class="pre">F</span></tt> gets
captured by the local binding of <tt class="docutils literal"><span class="pre">y</span></tt>. In fact, that's exactly what you get
with C macros:</p>
<pre class="literal-block">
#define F(x) { int y = x+1; return x+y; }
</pre>
<p>Here <tt class="docutils literal"><span class="pre">F(y)</span></tt> expands to <tt class="docutils literal"><span class="pre">{</span> <span class="pre">int</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">y+1;</span> <span class="pre">return</span> <span class="pre">y+y;</span> <span class="pre">}</span></tt> which is usually
<em>not</em> what you want.</p>
<p>There is also one Pure-related caveat here. The expression printer currently
doesn't check for different bindings of the same variable identifier when it
prints a (compile time) expression. E.g.:</p>
<pre class="literal-block">
&gt; foo y = F y;
&gt; show foo
foo y = y+y when y = y+1 end;
</pre>
<p>This <em>looks</em> as if <tt class="docutils literal"><span class="pre">y</span></tt> got captured, but in fact it's not, it's just the
<tt class="docutils literal"><span class="pre">show</span></tt> command which displays the definition in an incorrect way. You can
add the <tt class="docutils literal"><span class="pre">-e</span></tt> option to <tt class="docutils literal"><span class="pre">show</span></tt> which prints the deBruijn indices of locally
bound symbols, then you see that the actual bindings are all right anyway
(note that the number before the colon is the actual deBruijn index, the
sequence of bits behind it is the subterm path):</p>
<pre class="literal-block">
&gt; show -e foo
foo y/*0:1*/ = y/*1:1*/+y/*0:*/ when y/*0:*/ = y/*0:1*/+1 end;
</pre>
<p>Alas, this means that if you use <tt class="docutils literal"><span class="pre">dump</span></tt> to write such a definition to a text
file and read it back with <tt class="docutils literal"><span class="pre">run</span></tt> later, then you'll get the wrong
definition. Currently you will have to correct this manually.</p>
</div>
<div class="section" id="stack-size-and-tail-recursion">
<h2><a class="toc-backref" href="#id71">12.18&nbsp;&nbsp;&nbsp;Stack Size and Tail Recursion</a></h2>
<p>Pure programs may need a considerable amount of stack space to handle
recursive function and macro calls, and the interpreter itself also takes its
toll. So you should configure your system accordingly (8 MB of stack space is
recommended for 32 bit systems, systems with 64 bit pointers probably need
more). If the PURE_STACK environment variable is defined, the interpreter
performs advisory stack checks and raises a Pure exception if the current
stack size exceeds the given limit. The value of PURE_STACK should be the
maximum stack size in kilobytes. Please note that this is only an advisory
limit which does not change the program's physical stack size. Your operating
system should supply you with a command such as ulimit(1) to set the real
process stack size. Also note that this feature isn't 100% foolproof yet,
since for performance reasons the stack will be checked only on certain
occasions, such as entry into a global function.</p>
<p>Fortunately, Pure normally does proper tail calls (if LLVM provides that
feature on the platform at hand), so most tail-recursive definitions should
work fine in limited stack space. For instance, the following little program
will loop forever if your platform supports the required optimizations:</p>
<pre class="literal-block">
loop = loop;
loop;
</pre>
<p>This also works if your definition involves function parameters, guards and
multiple equations, of course. Moreover, conditional expressions
(<tt class="docutils literal"><span class="pre">if</span></tt>-<tt class="docutils literal"><span class="pre">then</span></tt>-<tt class="docutils literal"><span class="pre">else</span></tt>) are tail-recursive in both branches, and the
sequence operator <tt class="docutils literal"><span class="pre">$$</span></tt> is tail-recursive in its second operand. Note,
however, that the logical operators <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt> and <tt class="docutils literal"><span class="pre">||</span></tt> are <em>not</em> tail-recursive
in Pure, because they are required to always yield a proper truth value (0 or
1), which wouldn't be possible with tail call semantics. (The rationale behind
this design decision is that it allows the compiler to generate much better
code for logical expressions.)</p>
<p>There is one additional restriction in the current implementation, namely that
a tail call will be eliminated only if the call is done directly, i.e.,
through an explicit call, not through a (global or local) function
variable. Otherwise the call will be handled by the runtime system which is
written in C and can't do proper tail calls because C can't (at least not in a
portable way). This also affects mutually recursive global function calls,
since there the calls are handled in an indirect way, too, through an
anonymous global variable. (This is done so that a global function definition
can be changed at any time during an interactive session, without having to
recompile the entire program.) However, mutual tail recursion <em>does</em> work with
local functions, so it's easy to work around this limitation.</p>
<p>Also note that tail call optimization is <em>always</em> disabled if the debugger is
enabled (-g). This makes it much easier to debug programs, but of course this
means that you should always run your program without -g when the debugger is
not needed.</p>
</div>
<div class="section" id="handling-of-asynchronous-signals">
<h2><a class="toc-backref" href="#id72">12.19&nbsp;&nbsp;&nbsp;Handling of Asynchronous Signals</a></h2>
<p>As described in section <a class="reference internal" href="#exception-handling">Exception Handling</a>, signals delivered to the
process can be caught and handled with Pure's exception handling
facilities. Like stack checks, checks for pending signals are only performed
at certain places, such as entry into a global function. This doesn't include
tail calls, however, so a busy loop like <tt class="docutils literal"><span class="pre">loop</span> <span class="pre">=</span> <span class="pre">loop;</span></tt> will <em>never</em> be
interrupted. To work around this, just add a call to another global function
to your loop to make it interruptible. For instance:</p>
<pre class="literal-block">
loop = check $$ loop;
check = ();
</pre>
<p>To handle signals while the above loop is executing, you can add an exception
handler like the following:</p>
<pre class="literal-block">
loop = catch handle check $$ loop
with handle (signal k) = catch handle (...) end;
</pre>
<p>(Note the <tt class="docutils literal"><span class="pre">catch</span> <span class="pre">handle</span></tt> around the signal processing code which is needed
for safety because another signal may arrive while the signal handler is being
executed.)</p>
<p>Of course, in a real application the <tt class="docutils literal"><span class="pre">check</span></tt> function would most likely have
to do some actual processing, too. In that case you'd probably want the
<tt class="docutils literal"><span class="pre">loop</span></tt> function to carry around some &quot;state&quot; argument to be processed by the
<tt class="docutils literal"><span class="pre">check</span></tt> routine, which then returns an updated state value for the next
iteration. This can be implemented as follows:</p>
<pre class="literal-block">
loop x = loop (catch handle (check x))
with handle (signal k) = catch handle (...) end;
check x = ...;
</pre>
</div>
</div>
<div class="section" id="copying">
<h1><a class="toc-backref" href="#id73">13&nbsp;&nbsp;&nbsp;Copying</a></h1>
<p>Pure is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.</p>
<p>Pure is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the <a class="reference external" href="http://www.gnu.org/copyleft/gpl.html">GNU General Public License</a> V3 for details. (You can also find the
GPL in the COPYING file accompanying the software.)</p>
</div>
<div class="section" id="author">
<h1><a class="toc-backref" href="#id74">14&nbsp;&nbsp;&nbsp;Author</a></h1>
<p>Albert Gräf &lt;<a class="reference external" href="mailto:Dr.Graef&#64;t-online.de">Dr.Graef&#64;t-online.de</a>&gt;, Dept. of Computer Music, Johannes
Gutenberg University of Mainz, Germany.</p>
<p>The author gratefully acknowledges the contributions by Scott E. Dillard,
Rooslan S. Khayrov, Eddie Rucker, Libor Spacek and Jiri Spitz, as well as Toni
Graffy and Ryan Schmidt who maintain the SUSE Linux and OSX packages. Thanks
are also due to Vili Aapro, Alvaro Castro Castilla, John Cowan, Chris Double,
Tim Haynes, John Lunney and Max Wolf.</p>
</div>
<div class="section" id="see-also">
<h1><a class="toc-backref" href="#id75">15&nbsp;&nbsp;&nbsp;See Also</a></h1>
<dl class="docutils" id="aardappel">
<dt>Aardappel</dt>
<dd>Wouter van Oortmerssen's functional programming language based on term
rewriting, <a class="reference external" href="http://wouter.fov120.com/aardappel">http://wouter.fov120.com/aardappel</a>.</dd>
</dl>
<dl class="docutils" id="alice-ml">
<dt>Alice ML</dt>
<dd>A version of ML (see below) from which Pure borrows its model of lazy
evaluation, <a class="reference external" href="http://www.ps.uni-sb.de/alice">http://www.ps.uni-sb.de/alice</a>.</dd>
</dl>
<dl class="docutils" id="bertrand">
<dt>Bertrand</dt>
<dd>Wm Leler's constraint programming language based on term rewriting,
<a class="reference external" href="http://groups.google.com/group/bertrand-constraint">http://groups.google.com/group/bertrand-constraint</a>.</dd>
</dl>
<dl class="docutils" id="gmp">
<span id="gnu-multiprecision-library"></span><dt>GNU Multiprecision Library</dt>
<dd>Free library for arbitrary precision arithmetic, <a class="reference external" href="http://gmplib.org">http://gmplib.org</a>.</dd>
</dl>
<dl class="docutils" id="octave">
<span id="gnu-octave"></span><dt>GNU Octave</dt>
<dd>A popular high-level language for numeric applications and free MATLAB
replacement, <a class="reference external" href="http://www.gnu.org/software/octave">http://www.gnu.org/software/octave</a>.</dd>
</dl>
<dl class="docutils" id="gsl">
<span id="gnu-scientific-library"></span><dt>GNU Scientific Library</dt>
<dd>A free software library for numeric applications, required for Pure's
numeric matrix support, <a class="reference external" href="http://www.gnu.org/software/gsl">http://www.gnu.org/software/gsl</a>.</dd>
</dl>
<dl class="docutils" id="haskell">
<dt>Haskell</dt>
<dd>A popular non-strict FPL, <a class="reference external" href="http://www.haskell.org">http://www.haskell.org</a>.</dd>
</dl>
<dl class="docutils" id="llvm">
<dt>LLVM</dt>
<dd>The LLVM code generator framework, <a class="reference external" href="http://llvm.org">http://llvm.org</a>.</dd>
</dl>
<dl class="docutils" id="ml">
<dt>ML</dt>
<dd>A popular strict FPL. See Robin Milner, Mads Tofte, Robert Harper,
D. MacQueen: The Definition of Standard ML (Revised). MIT Press, 1997.</dd>
</dl>
<dl class="docutils" id="pure">
<dt>Pure</dt>
<dd>Find the latest releases and the mailing list at the Pure website,
<a class="reference external" href="http://pure-lang.googlecode.com">http://pure-lang.googlecode.com</a>.</dd>
</dl>
<dl class="docutils" id="q">
<dt>Q</dt>
<dd>Another term rewriting language by yours truly, <a class="reference external" href="http://q-lang.sf.net">http://q-lang.sf.net</a>.</dd>
</dl>
</div>
</div>
</body>
</html>
