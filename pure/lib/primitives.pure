
/* Pure primitives. These operations are implemented either directly by
   machine instructions or by C functions provided in the runtime. */

/* Copyright (c) 2008 by Albert Graef <Dr.Graef@t-online.de>.

   This file is part of the Pure programming language and system.

   Pure is free software: you can redistribute it and/or modify it under the
   terms of the GNU General Public License as published by the Free Software
   Foundation, either version 3 of the License, or (at your option) any later
   version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
   details.

   You should have received a copy of the GNU General Public License along
   with this program.  If not, see <http://www.gnu.org/licenses/>. */

using namespace __C;

/* ..

   Primitives
   ----------

   This prelude module is a collection of various lowlevel operations, which
   are implemented either directly by machine instructions or by C functions
   provided in the runtime. In particular, this module defines the basic
   arithmetic and logic operations on machine integers, bigints and floating
   point numbers, as well as various type checking predicates and conversions
   between different types. Some low-level pointer operations are also
   provided, as well as "sentries" (Pure's flavour of object finalizers) and
   "references" (mutable expression pointers).

   Arithmetic
   ~~~~~~~~~~

   The basic arithmetic and logic operations provided by this module are
   summarized in the following table:

   .. _+:
   .. _-:
   .. _*:
   .. _/:
   .. _div:
   .. _mod:
   .. _^:
   .. _==:
   .. _~=:
   .. _<:
   .. _>:
   .. _<=:
   .. _>=:
   .. _~:
   .. _&&:
   .. _||:
   .. _not:
   .. _and:
   .. _or:
   .. _<<:
   .. _>>:

   ===========  ===============  =========================================
   Kind         Operator         Meaning
   ===========  ===============  =========================================
   Arithmetic   ``+`` ``-``      addition, subtraction (also unary minus),
                ``*`` ``/``      multiplication, division (inexact),
                ``div`` ``mod``  exact int/bigint division/modulus,
                ``^``            exponentiation (inexact)
   Comparisons  ``==`` ``~=``    equality, inequality,
                ``<`` ``>``      less than, greater than,
                ``<=`` ``>=``    less than or equal, greater than or equal
   Logic        ``~``            logical not,
                ``&&`` ``||``    and, or (short-circuit)
   Bitwise      ``not``          bitwise not,
                ``and`` ``or``   and, or,
                ``<<`` ``>>``    bit shifts
   ===========  ===============  =========================================

   Precedence and and associativity of the operators can be found in the
   operators_ table at the beginning of this section.

   The names of some operations are at odds with C. Note, in particular, that
   logical negation is denoted ``~`` instead of ``!`` (and, consequently,
   ``~=`` denotes inequality, rather than ``!=``), and the bitwise operations
   are named differently. This is necessary because Pure uses ``!``, ``&`` and
   ``|`` for other purposes. Also, ``/`` always denotes inexact (double)
   division in Pure, whereas the integer division operators are called ``div``
   and ``mod``. (``%``, which is not defined by this module, also has a
   different meaning in Pure; it's the exact division operator, see `Rational
   Numbers`_.)

   The above operations are implemented for int, bigint and, where
   appropriate, double and pointer operands. (Pointer arithmetic comprises
   ``+`` and ``-`` and works in the usual way, i.e., ``p-q`` returns the byte
   offset between two pointers ``p`` and ``q``, and ``p+n`` or ``p-n`` offsets
   a pointer ``p`` by the given integer ``n`` denoting the amount of bytes.) 
   The math module (see `Mathematical Functions`_) also provides
   implementations of the arithmetic and comparison operators for rational,
   complex and complex rational numbers.

   Note that the logical operations are actually implemented as special forms
   in order to provide for short-circuit evaluation. This needs special
   support from the compiler to work. The primitives module still provides
   definitions for these, as well as other special forms like ``quote`` and
   the thunking operator ``&`` so that they may be used as function values and
   in partial applications, but when used in this manner they lose all their
   special call-by-name properties; see `Special Forms`_ in the Pure Manual
   for details.

   The constants ``inf`` and ``nan`` are defined as the usual IEEE floating
   point infinities and NaNs, and the predicates ``infp`` and ``nanp`` are
   provided to check for these kinds of values.

   In addition, the following arithmetic and numeric functions are provided:

   .. _abs:
   .. _sgn:

   ``abs x``, ``sgn x``
     Absolute value and sign of a number.

   .. _min:
   .. _max:

   ``min x y``, ``max x y``
     Minimum and maximum of two values. This works with any kind of values
     which have the ordering relations defined on them.

   .. _succ:
   .. _pred:

   ``succ x``, ``pred x``
     Successor (``+1``) and predecessor (``-1``) functions.

   .. _gcd:
   .. _lcd:

   ``gcd x y``, ``lcd x y``
     The greatest common divisor and least common multiple functions from the
     GMP library. These return a bigint if at least one of the arguments is a
     bigint, a machine int otherwise.

   .. _pow:

   ``pow x y``
     Computes exact powers of ints and bigints. The result is always a
     bigint. Note that ``y`` must always be nonnegative here, but see the math
     module (`Mathematical Functions`_) which deals with the case ``y<0``
     using rational numbers.

   Conversions
   ~~~~~~~~~~~

   These operations convert between various types of Pure values.

   .. _hash:

   ``hash x``
     Compute a 32 bit hash code of a Pure expression.

   .. _int:
   .. _bigint:
   .. _double:
   .. _pointer:

   ``int x``, ``bigint x``, ``double x``, ``pointer x``
     Conversions between the different numeric and pointer types.

   .. _ubyte:
   .. _ushort:
   .. _uint:
   .. _uint64:
   .. _ulong:

   ``ubyte x``, ``ushort x``, ``uint x``, ``uint64 x``, ``ulong x``
     Convert signed (8/16/32/64) bit integers to the corresponding unsigned
     quantities. These functions behave as if the value was "cast" to the
     corresponding unsigned C type, and are most useful for dealing with
     unsigned integers returned by external C routines. The routines always
     use the smallest Pure int type capable of holding the result: ``int`` for
     ``ubyte`` and ``ushort``, ``bigint`` for ``uint``, ``uint64`` and
     ``ulong``. All routines take int parameters. In the case of ``uint64``, a
     bigint parameter is also permitted (which is what the C interface returns
     for 64 bit values). Also note that ``ulong`` reduces to either ``uint``
     or ``uint64``, depending on the size of ``long`` for the host
     architecture.

   The following _`rounding functions` work with all kinds of numbers:

   .. _floor:
   .. _ceil:

   ``floor x``, ``ceil x``
     Floor and ceil.

   .. _round:
   .. _trunc:

   ``round x``, ``trunc x``
     Round or truncate to an integer.

   .. _frac:

   ``frac x``
     Fractional part (``x-trunc x``).

   Predicates
   ~~~~~~~~~~

   A syntactic equality test is provided, as well as various type checking
   predicates.

   .. _same:
   .. _===:
   .. _~==:

   ``x===y``, ``x~==y``, ``same x y``
     Syntactic equality. In difference to ``==`` and ``~=`` this is defined on
     all Pure expressions. Basically, two expressions are syntactically equal
     if they print out the same in the interpreter. In the special case of
     pointer objects and closures, which do not have a syntactic
     representation in Pure, ``x`` and ``y`` must be the same object (same
     pointer value or function).

   .. _intp:
   .. _bigintp:
   .. _doublep:
   .. _stringp:
   .. _pointerp:
   .. _matrixp:

   ``intp x``, ``bigintp x``, ``doublep x``, ``stringp x``, ``pointerp x``, ``matrixp x``
     Predicates to check for the built-in types.

   .. _charp:

   ``charp x``
     Single character string predicate.

   .. _numberp:
   .. _complexp:
   .. _realp:
   .. _rationalp:
   .. _integerp:

   ``numberp x``, ``complexp x``, ``realp x``, ``rationalp x``, ``integerp x``
     Additional number predicates.

   .. _exactp:
   .. _inexactp:

   ``exactp x``, ``inexactp x``
     Check whether a number is exact (i.e., doesn't contain any double
     components).

   .. _applp:
   .. _listp:
   .. _listnp:
   .. _tuplep:

   ``applp x``, ``listp x``, ``listnp x``, ``tuplep x``
     Predicates to check for function applications, proper lists, list nodes
     and proper tuples.

   .. _funp:
   .. _lambdap:
   .. _thunkp:
   .. _varp:

   ``funp x``, ``lambdap x``, ``thunkp x``, ``varp x``
     Predicates to check for function objects (named, anonymous or thunk) and
     global (unbound) variables.

   Inspection
   ~~~~~~~~~~

   The following operations let you peek at various internal information that
   the interpreter provides to Pure programs either for convenience or for
   metaprogramming purposes. They are complemented by the evaluation
   primitives discussed below, see `Eval and Friends`_.

   .. _ans:

   ``ans``
     Retrieve the most recently printed result of a toplevel expression
     evaluated in the read-eval-print loop. This is just a convenience for
     interactive usage. Note that the ``ans`` value will stick around until a
     new expression is computed. (It is possible to clear the ``ans`` value
     with the interactive command ``clear ans``, however.) Example::

       > 1/3;
       0.333333333333333
       > ans/2;
       0.166666666666667

   .. _\__locals__:

   ``__locals__``
     Return a list with the local function bindings (``with`` clauses) visible
     at this point in the program. This is actually implemented as a
     built-in. The return value is a list of "hash" pairs ``x=>f`` where ``x``
     is the (quoted) symbol denoting the function and ``f`` is the function
     itself (or its value, if ``f`` is a parameterless function). The
     ``__locals__`` function is useful for debugging purposes, as well as to
     implement dynamic environments. It is also used internally to implement
     the |reduce|_ macro, see `Eval and Friends`_. Example::

       > __locals__ with foo x = x+1; x = a+b end;
       [x=>a+b,foo=>foo]
       > f 99 when _=>f = ans!1 end;
       100

   .. |reduce| replace:: ``reduce``

   The prelude also provides some functions to retrieve various attributes of
   a function symbol which determine how the operation is applied to its
   operands or arguments. These functions all take a single argument, the
   symbol or function object to be inspected, and return an integer value.

   .. _nargs:

   ``nargs x``
     Get the argument count of a function object, i.e., the number of
     arguments it expects. Returns 0 for thunks and saturated applications, -1
     for over-saturated applications and non-functions.

   .. _arity:

   ``arity x``
     Determine the arity of an operator symbol. The returned value is 0, 1 or
     2 for nullary, unary and binary symbols, respectively, -1 for symbols
     without a fixity declaration or other kinds of objects.

   .. _fixity:

   ``fixity f``
     Determine the fixity of an operator symbol. The fixity is encoded as a
     2-digit number ``10*n+m`` where ``n`` is the precedence level (ranging
     from ``0`` to ``PREC_MAX``, where ``PREC_MAX`` denotes the precedence of
     primary expressions, 16777216 in the current implementation) and ``m``
     indicates the actual fixity at each level, in the order of increasing
     precedence (0 = infix, 1 = infixl, 2 = infixr, 3 = prefix, 4 =
     postfix). The fixity value of nonfix and outfix symbols, as well as
     symbols without a fixity declaration, is always given as ``10*PREC_MAX``,
     and the same value is also reported for non-symbol objects. (``PREC_MAX``
     isn't actually defined as a constant anywhere, but you can easily do that
     yourself by setting ``PREC_MAX`` to the fixity value of any nonfix symbol
     or non-symbol value, e.g.: ``const PREC_MAX = fixity [];``)

   Note that only closures (i.e., named and anonymous functions and thunks)
   have a defined argument count in Pure, otherwise ``nargs`` returns -1
   indicating an unknown argument count. Partial applications of closures
   return the number of remaining arguments, which may be zero to indicate a
   `saturated` (but unevaluated) application, or -1 for `over-saturated` and
   constructor applications. (Note that in Pure a saturated application may
   also remain unevaluated because there is no definition for the given
   combination of arguments and thus the expression is in normal form, or
   because the application was quoted. If such a normal form application is
   then applied to some "extra" arguments it becomes over-saturated.)

   The value returned by ``nargs`` always denotes the actual argument count of
   the given function, regardless of the declared arity if the function also
   happens to be an operator symbol. Often these will coincide (as, e.g., in
   the case of ``+`` which is a binary operator and also expects two
   arguments). But this is not necessarily the case, as shown in the following
   example of a binary operator which actually takes *three* arguments::

     > infix 0 oops;
     > (oops) x y z = x*z+y;
     > arity (oops);
     2
     > nargs (oops);
     3
     > nargs (5 oops 8);
     1
     > map (5 oops 8) (1..5);
     [13,18,23,28,33]

   Also note that the argument count of a *named* function will be the actual
   number of arguments, as given in the function definition::

     > foo x y = x*y;
     > nargs foo;
     2
     > nargs (foo x);
     1

   In contrast, *anonymous* functions (lambdas) always yield an argument count
   of 1, because a multi-argument lambda like ``\x y -> x*y`` is in fact just
   a shorthand for several nested 1-argument lambdas, ``\x -> \y -> x*y`` in
   this example. Hence::

     > bar = \x y -> x*y;
     > nargs bar;
     1
     > nargs (bar x);
     1

   Eval and Friends
   ~~~~~~~~~~~~~~~~

   Pure provides some rather powerful operations to convert between Pure
   expressions and their string representation, and to evaluate quoted
   expressions (``'x``). The string conversions ``str`` and ``eval`` also
   provide a convenient means to serialize Pure expressions, e.g., when terms
   are to be transferred to/from persistent storage. (Note, however, that
   this has its limitations. Specifically, some objects like pointers and
   anonymous functions do not have a parsable string representation. Also see
   the `Expression Serialization`_ section for some dedicated serialization
   operations which provide a more compact binary serialization format.)

   .. _str:

   ``str x``
     Yields the print representation of an expression in Pure syntax, as a
     string.

   .. _eval:

   ``eval x``
     Parses an expression, specified as a string in Pure syntax, and returns
     its value. In fact, ``eval`` can also parse and execute arbitrary Pure
     code. In that case it will return the last computed expression, if any.
     Alternatively, ``eval`` can also be invoked on a (quoted) Pure
     expression, which is recompiled and then evaluated. Exceptions during
     evaluation are reported back to the caller.

   .. _evalcmd:

   ``evalcmd x``
     Like ``eval``, but allows execution of interactive commands and returns
     their captured output as a string. No other results are returned, so this
     operation is most useful for executing Pure definitions and interactive
     commands for their side-effects. (At this time, only the regular output
     of a few commands can be captured, most notably ``clear``, ``save`` and
     ``show``; otherwise the result string will be empty.)

   .. _lasterr:

   ``lasterr``
     Reports errors in ``eval`` and ``evalcmd``. This string value will be
     nonempty iff a compilation or execution error was encountered during the
     most recent invokation of ``eval`` and ``evalcmd``. In that case each
     reported error message is terminated with a newline character.

   .. _reduce:

   ``reduce x``
     Reevaluates an expression in a local environment. This dynamically
     rebinds function symbols in the given expression to whatever local
     definitions are in effect at the point of the ``reduce`` call. Note that
     ``reduce`` is actually implemented as a macro which uses the
     |__locals__|_ builtin to enumerate the bindings which are in effect at
     the call site.

   .. |__locals__| replace:: ``__locals__``

   Examples::

     > str (1/3);
     "0.333333333333333"
     > eval "1/3";
     0.333333333333333
     > eval ('(1/3));
     0.333333333333333
     > evalcmd "show evalcmd";
     "extern expr* evalcmd(expr*);\n"

     > eval "1/3)";
     eval "1/3)"
     > lasterr;
     "<stdin>, line 1: syntax error, unexpected ')', expecting '=' or '|'\n"

   The ``reduce`` macro provides a restricted form of dynamic binding which is
   useful to implement local rewriting rules. It is invoked without parameters
   and expands to a curried primitive which takes one additional argument, the
   expression to be rewritten. The following example shows how to expand or
   factorize an expression using local rules for the corresponding laws of
   distributivity::

     expand = reduce with
       (a+b)*c = a*c+b*c;
       a*(b+c) = a*b+a*c;
     end;

     factor = reduce with
       a*c+b*c1 = (a+b)*c if c===c1;
       a*b+a1*c = a*(b+c) if a===a1;
     end;

     expand ((a+b)*2); // yields a*2+b*2
     factor (a*2+b*2); // yields (a+b)*2

   Note that instances of locally bound functions are substituted back in the
   computed result, thus the instances of ``*`` and ``+`` in the results
   ``a*2+b*2`` and ``(a+b)*2`` shown above denote the corresponding globals,
   not the local incarnations of ``*`` and ``+`` defined in ``expand`` and
   ``factor``, respectively.

   ``reduce`` also adjusts to quoted arguments. In this case, the local rules
   are applied as usual, but back-substituted globals are *not* evaluated in
   the result::

     > expand ((a+1)*2);
     a*2+2
     > expand ('((a+1)*2));
     a*2+1*2

   Note that ``reduce`` only takes into account local *function* bindings from
   ``with`` clauses, local *variable* bindings do not affect its operation in
   any way::

     > let y = [x,x^2,x^3];
     > reduce y when x = u+v end;
     [x,x^2,x^3]

   However, in such cases you can perform the desired substitution by just
   turning the ``when`` into a ``with`` clause::

     > reduce y with x = u+v end;
     [u+v,(u+v)^2,(u+v)^3]

   Expression Serialization
   ~~~~~~~~~~~~~~~~~~~~~~~~

   Like ``str`` and ``eval``, the following ``blob`` and ``val`` operations
   can be used to safely transfer expression data to/from persistent storage
   and between different processes (using, e.g., POSIX shared memory, pipes or
   sockets). However, ``blob`` and ``val`` use a binary format which is
   usually much more compact and gets processed much faster than the string
   representations used by ``str`` and ``eval``. Also, ``val`` offers some
   additional protection against transmission errors through a crc check. (The
   advantage of the textual representation, however, is that it's readable and
   completely portable across architectures.)

   ``blob x``
     Stores the contents of the given expression as a binary object. The
     return value is a cooked pointer which frees itself when
     garbage-collected.

   ``val p``
     Reconstructs a serialized expression from the result of a previous
     invocation of the ``blob`` function.

   ``blobp p``
     Does a quick check for a valid ``blob`` object. (Note that ``val`` may
     fail even if ``blobp`` returns ``true``, because for performance reasons
     ``blobp`` only does a quick plausibility check on the header information
     of the blob, whereas ``val`` also performs a crc check and verifies data
     integrity.)

   ``blob_size p``, ``blob_crc p``
     Determines the size (in bytes) and crc checksum of a blob, respectively.
     For convenience, ``#p`` is defined as an alias for ``blob_size p`` on
     ``blob`` pointers.

   Example::

     > let b = blob {"Hello, world!", 1/3, 4711, NULL};
     > b; #b; blob_crc b;
     #<pointer 0x143ce80>
     136
     892738801
     > val b;
     {"Hello, world!",0.333333333333333,4711,#<pointer 0>}

   Please note that the current implementation has some limitations:

   * Just as with ``str`` and ``eval``, runtime data (local closures and
     pointers other than the ``NULL`` pointer) can't be serialized, causing
     ``blob`` to fail. However, it *is* possible to transfer a global
     function, provided that the function exists (and is the same) in both the
     sending and the receiving process. (This condition can't be verified
     by ``val`` and thus is at the programmer's responsibilty.)

   * Sharing of subexpressions will in general be preserved, but shared tails
     of lists and tuples can't be reconstructed (unless the entire list or
     tuple is shared).

   * The ``val`` function may fail to reconstruct the serialized expression
     even for valid blobs, if there is a conflict in symbol fixities between
     the symbol tables of the sending and the receiving process. To avoid
     this, make sure that symbol declarations in the sending and the receiving
     script match up.

   Other Special Primitives
   ~~~~~~~~~~~~~~~~~~~~~~~~

   .. _throw:

   ``throw x``
     Throw an exception, cf. `Exception Handling`_.

   .. _Exception Handling: pure.html#exception-handling

   ``force x``
     Force a thunk (``x&``), cf. `Special Forms`_. This usually happens
     automagically when the value of a thunk is needed.

   .. _Special Forms: pure.html#special-forms

*/

/* eval and friends. */

extern expr* lastres() = ans;
extern expr* eval(expr*); // IMPURE!
extern expr* evalcmd(expr*); // IMPURE!
extern char* lasterr();

namespace __C;
extern expr *reduce(expr *locals, expr *x);
extern void* str(expr*) = pure_str;
namespace;

def ::reduce = reduce __locals__;

str x = cstring (pure_str x);

/* Expression serialization. */

extern expr* blob(expr*);
extern expr* val(void*);
extern bool blobp(expr*);
extern expr* blob_size(expr*);
extern expr* blob_crc(expr*);

blobp _ = false;
#p::pointer = blob_size p if blobp p;

/* Other specials. */

extern void pure_throw(expr*) = throw; // IMPURE!
extern expr* pure_force(expr*) = force;

/* Syntactic equality. */

extern bool same(expr* x, expr* y);
x === y		= same x y;
x ~== y		= ~same x y;

/* Predicates to check for the built-in types. */

intp x		= case x of _::int     = 1; _ = 0 end;
bigintp x	= case x of _::bigint  = 1; _ = 0 end;
doublep x	= case x of _::double  = 1; _ = 0 end;
stringp x	= case x of _::string  = 1; _ = 0 end;
pointerp x	= case x of _::pointer = 1; _ = 0 end;
matrixp x	= case x of _::matrix  = 1; _ = 0 end;

/* Additional single character predicate. Note that this implementation is in
   general *much* faster than the naive solution 'stringp x && #x==1', because
   it's guaranteed to run in constant time. */

charp x		= case x of _::string  = intp (ord x); _ = 0 end;

/* Additional number predicates. */

numberp x	= realp x || complexp x;
complexp x	= case x of x+:y | x<:y = realp x && realp y; _ = 0 end;
realp x		= case x of _::int | _::bigint | _::double = 1;
		            x%y = realp x && realp y; _ = 0 end;
rationalp x	= case x of x%y = integerp x && integerp y; _ = 0 end;
integerp x	= case x of _::int | _::bigint = 1; _ = 0 end;

/* Check whether a number is exact (i.e., doesn't contain any double
   components. */

exactp x	= numberp x &&
		  (case x of
		     x+:y = ~doublep x && ~doublep y;
		     x<:y = ~doublep x && ~doublep y;
		     x%y  = ~doublep x && ~doublep y;
		     _ = ~doublep x;
		   end);
inexactp x      = numberp x &&
		  (case x of
		     x+:y = doublep x || doublep y;
		     x<:y = doublep x || doublep y;
		     x%y  = doublep x || doublep y;
		     _ = doublep x;
		   end);

/* Predicates to check for function objects (named, anonymous or thunk) and
   global (unbound) variables. */

extern bool funp(expr*), bool lambdap(expr*), bool thunkp(expr*);
extern bool varp(expr*);

/* Get the argument count of a function object, i.e., the number of arguments
   it expects. Returns 0 for thunks and saturated applications, -1 for
   over-saturated applications and non-functions. */

extern int nargs(expr *x);

/* Determine the arity and fixity of an operator symbol. arity is 0, 1 or 2
   for nullary, unary and binary symbols, respectively, -1 for symbols without
   a fixity declaration or other kinds of objects. fixity is encoded as a
   2-digit number 10n+m where n is the precedence level (ranging from 0 to 10,
   10 denotes the precedence of primary expressions) and m indicates the
   actual fixity in order of increasing precedence (0 = infix, 1 = infixl, 2 =
   infixr, 3 = prefix, 4 = postfix). For non-symbol objects, fixity is always
   100. */

extern int arity(expr *x);
extern int fixity(expr *x);

/* Predicates to check for function applications, proper lists, list nodes and
   proper tuples. */

applp (_ _)	= 1;
applp _		= 0 otherwise;

listp []	= 1;
listp (x:xs)	= listp xs;
listp _		= 0 otherwise;

listnp []	= 1;
listnp (x:xs)	= 1;
listnp _	= 0 otherwise;

tuplep ()	= 1;
tuplep (x,xs)	= 1;
tuplep _	= 0 otherwise;

/* Compute a 32 bit hash code of a Pure expression. */

extern int hash(expr*);

/* Conversions between the different numeric and pointer types. */

namespace __C;
extern expr* pure_intval(expr*), expr* pure_dblval(expr*),
  expr* pure_bigintval(expr*), expr* pure_pointerval(expr*);
namespace;

int x::int		= x;
int x::bigint		|
int x::double		|
int x::pointer		= pure_intval x;

bigint x::bigint	= x;
bigint x::int		|
bigint x::double	|
bigint x::pointer	= pure_bigintval x;

double x::double	= x;
double x::int		|
double x::bigint	= pure_dblval x;

pointer x::pointer	= x;
pointer x::int		|
pointer x::bigint	|
pointer x::double	|
pointer x::string	= pure_pointerval x;

/* Convert signed (8/16/32/64) bit integers to the corresponding unsigned
   quantities. */

ubyte x::int		= if x>=0 then x else x+0x100;
ushort x::int		= if x>=0 then x else x+0x10000;
uint x::int		= if x>=0 then bigint x else x+0x100000000L;
uint64 x::int		|
uint64 x::bigint	= if x>=0 then bigint x else x+0x10000000000000000L;
ulong			= if SIZEOF_LONG==4 then uint else uint64;

/* Rounding functions. */

extern double floor(double), double ceil(double);
extern double __round(double) = round, double __trunc(double) = trunc;

floor x::int | floor x::bigint = x;
ceil x::int | ceil x::bigint = x;
round x::int | round x::bigint = x;
trunc x::int | trunc x::bigint = x;

// Fractional part of x.
frac x::int | frac x::bigint | frac x::double = x-trunc x;

/* Absolute value and sign of a number. Note that these don't distinguish
   between IEEE 754 positive and negative zeros; abs always returns 0.0, sgn 0
   for these. The real sign bit of a floating point zero can be obtained with
   sgn (1/x). */

abs x::int | abs x::bigint | abs x::double
			= if x>0 then x else -x;
sgn x::int | sgn x::bigint | sgn x::double
			= if x>0 then 1 else if x<0 then -1 else 0;

/* Generic min and max functions. */

min x y			= if x<=y then x else y;
max x y			= if x>=y then x else y;

/* Generic succ and pred functions. */

succ x			= x+1;
pred x			= x-1;

/* Basic int and double arithmetic. The Pure compiler already knows how to
   handle these, we just need to supply rules with the right type tags. */

-x::int			= -x;
~x::int			= ~x;
not x::int		= not x;

x::int<<y::int		= x<<y;
x::int>>y::int		= x>>y;

x::int+y::int		= x+y;
x::int-y::int		= x-y;
x::int*y::int		= x*y;
x::int/y::int		= x/y;
x::int div y::int	= x div y;
x::int mod y::int	= x mod y;
x::int or y::int	= x or y;
x::int and y::int	= x and y;

x::int<y::int		= x<y;
x::int>y::int		= x>y;
x::int<=y::int		= x<=y;
x::int>=y::int		= x>=y;
x::int==y::int		= x==y;
x::int~=y::int		= x~=y;

-x::double		= -x;

x::double+y::double	= x+y;
x::double-y::double	= x-y;
x::double*y::double	= x*y;
x::double/y::double	= x/y;

x::double<y::double	= x<y;
x::double>y::double	= x>y;
x::double<=y::double	= x<=y;
x::double>=y::double	= x>=y;
x::double==y::double	= x==y;
x::double~=y::double	= x~=y;

// mixed operands

x::int+y::double	= x+y;
x::int-y::double	= x-y;
x::int*y::double	= x*y;
x::int/y::double	= x/y;

x::int<y::double	= x<y;
x::int>y::double	= x>y;
x::int<=y::double	= x<=y;
x::int>=y::double	= x>=y;
x::int==y::double	= x==y;
x::int~=y::double	= x~=y;

x::double+y::int	= x+y;
x::double-y::int	= x-y;
x::double*y::int	= x*y;
x::double/y::int	= x/y;

x::double<y::int	= x<y;
x::double>y::int	= x>y;
x::double<=y::int	= x<=y;
x::double>=y::int	= x>=y;
x::double==y::int	= x==y;
x::double~=y::int	= x~=y;

/* Built-in special forms. Please note that these enjoy call-by-name and
   short-circuit evaluation only as explicit calls! But we still want them to
   work if they are applied partially, so we add these rules here. */

x::int&&y::int		= x&&y;
x::int||y::int		= x||y;
x$$y			= y;
x&			= x;
'x			= x;
quote x			= x;

/* Bigint arithmetic. */

namespace __C;
extern expr* bigint_neg(void*);
extern expr* bigint_not(void*);
extern expr* bigint_add(void*, void*);
extern expr* bigint_sub(void*, void*);
extern expr* bigint_mul(void*, void*);
extern expr* bigint_div(void*, void*);
extern expr* bigint_mod(void*, void*);
extern expr* bigint_shl(void*, int);
extern expr* bigint_shr(void*, int);
extern expr* bigint_and(void*, void*);
extern expr* bigint_or(void*, void*);
extern int bigint_cmp(void*, void*);
namespace;

-x::bigint		= bigint_neg x;
not x::bigint		= bigint_not x;

x::bigint<<y::int	= bigint_shl x y if y>=0;
			= bigint_shr x (-y);
x::bigint>>y::int	= bigint_shr x y if y>=0;
			= bigint_shl x (-y);

x::bigint+y::bigint	= bigint_add x y;
x::bigint-y::bigint	= bigint_sub x y;
x::bigint*y::bigint	= bigint_mul x y;
x::bigint/y::bigint	= double x / double y;
x::bigint div y::bigint	= bigint_div x y;
x::bigint mod y::bigint	= bigint_mod x y;
x::bigint or y::bigint	= bigint_or x y;
x::bigint and y::bigint	= bigint_and x y;

x::bigint<y::bigint	= bigint_cmp x y < 0;
x::bigint>y::bigint	= bigint_cmp x y > 0;
x::bigint<=y::bigint	= bigint_cmp x y <= 0;
x::bigint>=y::bigint	= bigint_cmp x y >= 0;
x::bigint==y::bigint	= bigint_cmp x y == 0;
x::bigint~=y::bigint	= bigint_cmp x y ~= 0;

// mixed int/bigint (promote int to bigint)

x::int+y::bigint	= bigint x+y;
x::int-y::bigint	= bigint x-y;
x::int*y::bigint	= bigint x*y;
x::int/y::bigint	= double x/y;
x::int div y::bigint	= bigint x div y;
x::int mod y::bigint	= bigint x mod y;
x::int or y::bigint	= bigint x or y;
x::int and y::bigint	= bigint x and y;

x::int<y::bigint	= bigint x<y;
x::int>y::bigint	= bigint x>y;
x::int<=y::bigint	= bigint x<=y;
x::int>=y::bigint	= bigint x>=y;
x::int==y::bigint	= bigint x==y;
x::int~=y::bigint	= bigint x~=y;

x::bigint+y::int	= x+bigint y;
x::bigint-y::int	= x-bigint y;
x::bigint*y::int	= x*bigint y;
x::bigint/y::int	= x/double y;
x::bigint div y::int	= x div bigint y;
x::bigint mod y::int	= x mod bigint y;
x::bigint or y::int	= x or bigint y;
x::bigint and y::int	= x and bigint y;

x::bigint<y::int	= x<bigint y;
x::bigint>y::int	= x>bigint y;
x::bigint<=y::int	= x<=bigint y;
x::bigint>=y::int	= x>=bigint y;
x::bigint==y::int	= x==bigint y;
x::bigint~=y::int	= x~=bigint y;

// mixed double/bigint (promote bigint to double)

x::bigint+y::double	= double x+y;
x::bigint-y::double	= double x-y;
x::bigint*y::double	= double x*y;
x::bigint/y::double	= double x/y;

x::bigint<y::double	= double x<y;
x::bigint>y::double	= double x>y;
x::bigint<=y::double	= double x<=y;
x::bigint>=y::double	= double x>=y;
x::bigint==y::double	= double x==y;
x::bigint~=y::double	= double x~=y;

x::double+y::bigint	= x+double y;
x::double-y::bigint	= x-double y;
x::double*y::bigint	= x*double y;
x::double/y::bigint	= x/double y;

x::double<y::bigint	= x<double y;
x::double>y::bigint	= x>double y;
x::double<=y::bigint	= x<=double y;
x::double>=y::bigint	= x>=double y;
x::double==y::bigint	= x==double y;
x::double~=y::bigint	= x~=double y;

/* The gcd and lcm functions from the GMP library. These return a bigint if at
   least one of the arguments is a bigint, a machine int otherwise. */

namespace __C;
extern expr* bigint_gcd(void*, void*);
extern expr* bigint_lcm(void*, void*);
namespace;

gcd x::bigint y::bigint	= bigint_gcd x y;
lcm x::bigint y::bigint	= bigint_lcm x y;

gcd x::int y::bigint	= bigint_gcd (bigint x) y;
gcd x::bigint y::int	= bigint_gcd x (bigint y);
gcd x::int y::int	= int (bigint_gcd (bigint x) (bigint y));

lcm x::int y::bigint	= bigint_lcm (bigint x) y;
lcm x::bigint y::int	= bigint_lcm x (bigint y);
lcm x::int y::int	= int (bigint_lcm (bigint x) (bigint y));

/* The pow function. Computes exact powers of ints and bigints. The result is
   always a bigint. Note that y must always be nonnegative here, but see
   math.pure which deals with the case y<0 using rational numbers. */

namespace __C;
extern expr* bigint_pow(void*, int);
namespace;

pow x::int y::int	= bigint_pow (bigint x) y if y>=0;
pow x::bigint y::bigint	= bigint_pow x y if y>=0;

// mixed int/bigint
pow x::int y::bigint	= bigint_pow (bigint x) y if y>=0;
pow x::bigint y::int	= bigint_pow x y if y>=0;

/* The ^ operator. Computes inexact powers for any combination of int, bigint
   and double operands. The result is always a double. */

namespace __C;
extern double pow(double, double);
namespace;

x::double^y::double	= __C::pow x y;
x::int^y::int		|
x::bigint^y::bigint	|
x::int^y::bigint	|
x::bigint^y::int	= __C::pow (double x) (double y);
x::double^y::int	|
x::double^y::bigint	= __C::pow x (double y);
x::int^y::double	|
x::bigint^y::double	= __C::pow (double x) y;

/* Pointer arithmetic. We do this using bigints, so that the code is portable
   to 64 bit systems. */

const NULL = pointer 0; // the null pointer

null x::pointer		= bigint x==0;

x::pointer-y::pointer	= bigint x-bigint y;
x::pointer+y::int	= pointer (bigint x+y);
x::pointer+y::bigint	= pointer (bigint x+y);

x::pointer<y::pointer	= bigint x <  bigint y;
x::pointer>y::pointer	= bigint x >  bigint y;
x::pointer<=y::pointer	= bigint x <= bigint y;
x::pointer>=y::pointer	= bigint x >= bigint y;
x::pointer==y::pointer	= bigint x == bigint y;
x::pointer~=y::pointer	= bigint x ~= bigint y;

/* IEEE floating point infinities and NaNs. Place these after the definitions
   of the built-in operators so that the double arithmetic works. */

const inf = 1.0e307 * 1.0e307; const nan = inf-inf;

/* Predicates to check for inf and nan values. */

infp x		= case x of x::double = x==inf || x==-inf; _ = 0 end;
nanp x		= case x of x::double = ~(x==x); _ = 0 end;

/* Some common special cases of finite arithmetic sequences are implemented
   here using the runtime for better performance. */

namespace __C;
extern expr* pure_int_seq(int from, int to, int step);
extern expr* pure_double_seq(double from, double to, double step);
namespace;

n::int..m::int		= __C::pure_int_seq n m 1;
n1::int:n2::int..m::int	= __C::pure_int_seq n1 m (n2-n1) if n1~=n2;

n::double..m::double	= __C::pure_double_seq n m 1.0 if ~infp n && ~infp m;
n::int..m::double	= __C::pure_double_seq (double n) m 1.0 if ~infp m;
n::double..m::int	= __C::pure_double_seq n (double m) 1.0 if ~infp n;

n1::double:n2::double..m::double
			= __C::pure_double_seq n1 m (n2-n1)
			    if ~infp n1 && ~infp m && n1~=n2;
n1::int:n2::double..m::double
			= __C::pure_double_seq (double n1) m (n2-n1)
			    if ~infp m && n1~=n2;
n1::double:n2::int..m::double
			= __C::pure_double_seq n1 m (n2-n1)
			    if ~infp n1 && ~infp m && n1~=n2;
n1::double:n2::double..m::int
			= __C::pure_double_seq n1 (double m) (n2-n1)
			    if ~infp n1 && n1~=n2;
n1::int:n2::int..m::double
			= __C::pure_double_seq (double n1) m (double (n2-n1))
			    if ~infp m && n1~=n2;
n1::int:n2::double..m::int
			= __C::pure_double_seq (double n1) (double m) (n2-n1)
			    if n1~=n2;
n1::double:n2::int..m::int
			= __C::pure_double_seq n1 (double m) (n2-n1)
			    if ~infp n1 && n1~=n2;

/* ..

   Pointer Operations
   ~~~~~~~~~~~~~~~~~~

   These are lowlevel operations dealing with pointer values. The usual
   caveats apply, so *only* use these directly if you know what you're doing!

   .. _addr:

   ``addr symbol``
     Get the address of a C symbol (given as a string) at runtime. The library
     containing the symbol must already be loaded. Note that this can in fact
     be any kind of externally visible C symbol, so it's also possible to get
     the addresses of global variables. The result is returned as a
     pointer. The function fails if the symbol was not found. */

extern expr *pure_addr(char *s) = addr;

/* .. _calloc:
   .. _malloc:
   .. _realloc:
   .. _free:

   ``calloc nmembers size``, ``malloc size``, ``realloc ptr size``, ``free ptr``
     Interface to ``malloc``, ``free`` and friends. These let you allocate
     dynamic buffers (represented as Pure pointer values) for various nasty
     purposes. */

extern void* calloc(size_t nmembers, size_t size);
extern void* malloc(size_t size), void* realloc(void* ptr, size_t size);
extern void free(void* ptr);

/* .. _get_byte:
   .. _get_short:
   .. _get_int:
   .. _get_int64:
   .. _get_long:
   .. _get_float:
   .. _get_double:
   .. _get_string:
   .. _get_pointer:
   .. _put_byte:
   .. _put_short:
   .. _put_int:
   .. _put_int64:
   .. _put_long:
   .. _put_float:
   .. _put_double:
   .. _put_string:
   .. _put_pointer:

   The following operations perform direct memory accesses. Use with care
   ... or else!

   * ``get_byte ptr``, ``get_short ptr``, ``get_int ptr``, ``get_int64 ptr``,
     ``get_long ptr``, ``get_float ptr``, ``get_double ptr``,
     ``get_string ptr``, ``get_pointer ptr``

   * ``put_byte ptr x``, ``put_short ptr x``, ``put_int ptr x``,
     ``put_int64 ptr x``, ``put_long ptr x``, ``put_float ptr x``,
     ``put_double ptr x``, ``put_string ptr x``, ``put_pointer ptr x``
*/

namespace __C;
extern int pointer_get_byte(void *ptr);
extern int pointer_get_short(void *ptr);
extern int pointer_get_int(void *ptr);
extern long pointer_get_long(void *ptr);
extern int64 pointer_get_int64(void *ptr);
extern double pointer_get_float(void *ptr);
extern double pointer_get_double(void *ptr);
extern char *pointer_get_string(void *ptr);
extern void *pointer_get_pointer(void *ptr);
namespace;

get_byte x::pointer = pointer_get_byte x;
get_short x::pointer = pointer_get_short x;
get_int x::pointer = pointer_get_int x;
get_long x::pointer = pointer_get_long x;
get_int64 x::pointer = pointer_get_int64 x;
get_float x::pointer = pointer_get_float x;
get_double x::pointer = pointer_get_double x;
get_string x::pointer = pointer_get_string x;
get_pointer x::pointer = pointer_get_pointer x;

namespace __C;
extern void pointer_put_byte(void *ptr, int x); // IMPURE!
extern void pointer_put_short(void *ptr, int x); // IMPURE!
extern void pointer_put_int(void *ptr, int x); // IMPURE!
extern void pointer_put_long(void *ptr, long x); // IMPURE!
extern void pointer_put_int64(void *ptr, int64 x); // IMPURE!
extern void pointer_put_float(void *ptr, double x); // IMPURE!
extern void pointer_put_double(void *ptr, double x); // IMPURE!
extern void pointer_put_string(void *ptr, char *x); // IMPURE!
extern void pointer_put_pointer(void *ptr, void *x); // IMPURE!
namespace;

put_byte x::pointer y::int = pointer_put_byte x y;
put_short x::pointer y::int = pointer_put_short x y;
put_int x::pointer y::int = pointer_put_int x y;
put_long x::pointer y::int = pointer_put_long x y;
put_long x::pointer y::bigint = pointer_put_long x y;
put_int64 x::pointer y::int = pointer_put_int64 x y;
put_int64 x::pointer y::bigint = pointer_put_int64 x y;
put_float x::pointer y::double = pointer_put_float x y;
put_double x::pointer y::double = pointer_put_double x y;
put_string x::pointer y::string = pointer_put_string x y;
put_pointer x::pointer y::string = pointer_put_pointer x y;
put_pointer x::pointer y::pointer = pointer_put_pointer x y;

/* ..

   Sentries
   ~~~~~~~~

   Sentries are Pure's flavour of object `finalizers`. A sentry is simply a
   function which gets applied to the target expression when it is
   garbage-collected. This is useful to perform automatic cleanup actions on
   objects with internal state, such as files. Pure's sentries are *much* more
   useful than finalizers in other garbage-collected languages, since it is
   guaranteed that they are called as soon as an object "goes out of scope",
   i.e., becomes inaccessible.

   Note that in the current implementation sentries can only be placed at
   applications and pointer objects, but the department of fake statistics has
   assured us that this covers 99% of all practical uses. The sentry itself
   can be any type of object (but usually it's a function). There can be only
   one sentry per expression but, building on the operations provided here,
   it's easy to design a scheme where sentries are chained.

   .. _sentry:

   ``sentry f x``
     Places a sentry ``f`` at an expression ``x`` and returns the modified
     expression.

   .. _clear_sentry:

   ``clear_sentry x``
     Removes the sentry from an expression ``x``.

   .. _get_sentry:

   ``get_sentry x``
     Returns the sentry of an expression ``x`` (if any, fails otherwise). */

extern expr* pure_sentry(expr*,expr*) = sentry; // IMPURE!
extern expr* pure_clear_sentry(expr*) = clear_sentry; // IMPURE!
extern expr* pure_get_sentry(expr*) = get_sentry;

/* .. _cooked:
   .. _cookedp:

   ``cooked ptr``, ``cookedp ptr``
     ``cooked`` is a convenience function to create a `cooked` pointer which
     disposes itself after use. This is just a shorthand for ``sentry
     free``. The given pointer ``ptr`` must be |malloc|_\ ed to make this
     work. There's also a predicate ``cookedp`` to decide whether a given
     pointer is cooked already (we actually assume any pointer to be cooked
     which has a sentry set on it).

   .. |malloc| replace:: ``malloc``

   Example::

     > using system;
     > let p = sentry (\p->puts "I'm done for!" $$ free p) (malloc 1024);
     > cookedp p;
     1
     > clear p
     I'm done for!

*/

cooked p::pointer = sentry free p;
cookedp p = case p of
	      _::pointer =
	       case get_sentry p of
	         get_sentry _ = 0;
	         _ = 1;
	       end;
	      _ = 0;
	    end;

/* ..

   Expression References
   ~~~~~~~~~~~~~~~~~~~~~

   Expression references provide a kind of mutable data cells which can hold
   any Pure expression. If you need these, then you're doomed. ;-) However,
   they can be useful as a last resort when you need to keep track of some
   local state or interface to the messy imperative world. Pure's references
   are actually implemented as expression pointers so that you can readily
   pass them as pointers to a C function which expects a ``pure_expr**``
   parameter. This may even be useful at times.

   .. _ref:

   ``ref x``
     Create a reference pointing to ``x`` initially.

   .. _put:

   ``put r x``
     Set a new value ``x``, and return that value.

   .. _get:

   ``get r``
     Retrieve the current value ``r`` points to.

   .. _unref:

   ``unref r``
     Purge the referenced object and turn the reference into a dangling
     pointer. (This is used as a sentry on reference objects and shouldn't
     normally be called directly.)

   .. _refp:

   ``refp x``
     Predicate to check for reference values.

   Note that manually removing the ``unref`` sentry of a reference turns the
   reference into just a normal pointer object and renders it unusable as a
   reference. Doing this will also leak memory, so don't! */

namespace __C;
extern expr* pure_new(expr*), expr* pure_expr_pointer();
extern void pure_free(expr*);
extern expr* pointer_get_expr(void*), void pointer_put_expr(void*, expr*);
namespace;

ref x = pointer_put_expr r (pure_new x) $$
	sentry unref r when r::pointer = pure_expr_pointer end;

unref r::pointer = pure_free (pointer_get_expr r) $$
		   clear_sentry r if refp r;

put r::pointer x = pure_free (pointer_get_expr r) $$
		   pointer_put_expr r (pure_new x) $$ x if refp r;

get r::pointer = pointer_get_expr r if refp r;

refp r = case r of _::pointer = get_sentry r===unref; _ = 0 end;
