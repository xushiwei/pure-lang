
/* Basic string functions. */

/* Copyright (c) 2008 by Albert Graef <Dr.Graef@t-online.de>.

   This file is part of the Pure programming language and system.

   Pure is free software: you can redistribute it and/or modify it under the
   terms of the GNU General Public License as published by the Free Software
   Foundation, either version 3 of the License, or (at your option) any later
   version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
   details.

   You should have received a copy of the GNU General Public License along
   with this program.  If not, see <http://www.gnu.org/licenses/>. */

using namespace C;

/* ..

   String Functions
   ----------------

   TODO

*/

/* Convert between Pure expressions and strings. The str function gives you
   the print representation of an expression in Pure syntax, as a string. The
   eval function does the opposite, by parsing and returning the value of an
   expression specified as a string in Pure syntax. In fact, eval goes well
   beyond this, as it can parse and execute arbitrary Pure code. In that case
   it will return the last computed expression, if any. Moreover, eval can
   also be invoked on a (quoted) Pure expression, which is recompiled and then
   evaluated. (If the expression cannot be compiled for some reason then eval
   just returns it as is. Also, exceptions during evaluation are reported back
   to the caller.) */

namespace C;
extern void* str(expr*) = pure_str;
namespace;

extern expr* eval(expr*); // IMPURE!

str x			= cstring (pure_str x);

/* evalcmd is like eval, but allows execution of interactive commands and
   returns their captured output as a string. No other results are returned,
   so this operation is most useful for executing Pure definitions and
   interactive commands for their side-effects. (At this time, only the
   regular output of a few commands can be captured, most notably 'clear',
   'save' and 'show'; otherwise the result string will be empty.) */

extern expr* evalcmd(expr*); // IMPURE!

/* Errors in eval and evalcmd are reported with the lasterr routine. This
   string value will be nonempty iff a compilation or execution error was
   encountered during the most recent invokation of eval(). In that case each
   reported error message is terminated with a newline character. */

extern char* lasterr();

/* Convert between Unicode character codes and single character strings. */

namespace C;
extern expr* string_chr(int);
extern expr* string_ord(void*);
namespace;

chr n::int		= string_chr n if n>0;
ord s::string		= string_ord s if #s==1;

/* Low-level conversions. The following routines are provided by the runtime
   to turn a C char* pointer into a Pure string. (Normally you don't have to
   worry about this, because the C interface already takes care of the
   necessary conversions, but in some low-level code these operations are
   useful.) The routines with a _dup suffix take a copy of the original
   string, the ones without take ownership of the string pointer (assuming it
   to be malloc'ed). The _cstring routines also convert from the system
   encoding. */

namespace C;
extern expr* pure_string(void* s);
extern expr* pure_cstring(void* s);
extern expr* pure_string_dup(void* s);
extern expr* pure_cstring_dup(void* s);
namespace;

string s::pointer	= pure_string s;
cstring s::pointer	= pure_cstring s;
string_dup s::pointer	= pure_string_dup s;
cstring_dup s::pointer	= pure_cstring_dup s;

/* Construct a "byte string" from a string. The result is a raw pointer object
   pointing to the converted string. The original string is copied (and, in
   the case of pure_byte_cstring, converted to the system encoding). The
   resulting byte string is a malloc'ed pointer which can be used like a C
   char* (employing pointer arithmetic etc.; the usual caveats apply), and has
   to be freed explicitly by the caller when no longer needed. */

namespace C;
extern expr* pure_byte_string(void *s);
extern expr* pure_byte_cstring(void *s);
namespace;

byte_string s::string	= pure_byte_string s;
byte_cstring s::string	= pure_byte_cstring s;

/* Convert Pure string lists to C byte string vectors and vice versa. These
   are useful if you need to pass an argv-like string vector (i.e., a char **
   or char *[]) to C routines. The returned C vectors are malloc'd pointers
   which have an extra NULL pointer as the last entry, and thus should be
   usable for almost any purpose which requires such a string vector. They
   also take care of garbage-collecting themselves. The original string data
   is always copied. As usual, the 'c' variants do automatic conversions to
   the system encoding. */

byte_string_pointer xs	= if null p then throw malloc_error
			  else make_pointer (map byte_string xs)
with
  make_pointer xs = sentry free_pointer p when
    dowith (\i x -> put_pointer (p+i*SIZEOF_POINTER) x) (0..n-1) xs;
  end;
  free_pointer p = free p when
    do (\i -> free (get_pointer (p+i*SIZEOF_POINTER))) (0..n-1);
  end;
end
when
  n = #xs; p = calloc (n+1) SIZEOF_POINTER;
end if listp xs && all stringp xs;

byte_cstring_pointer xs	= if null p then throw malloc_error
			  else make_pointer (map byte_cstring xs)
with
  make_pointer xs = sentry free_pointer p when
    dowith (\i x -> put_pointer (p+i*SIZEOF_POINTER) x) (0..n-1) xs;
  end;
  free_pointer p = free p when
    do (\i -> free (get_pointer (p+i*SIZEOF_POINTER))) (0..n-1);
  end;
end
when
  n = #xs; p = calloc (n+1) SIZEOF_POINTER;
end if listp xs && all stringp xs;

/* Note that the back conversions take an additional first argument which
   denotes the number of strings to retrieve. If you know that the vector is
   NULL-terminated then this can also be inf in which case the the number of
   elements will be figured out automatically. Processing always stops at the
   first NULL pointer encountered. */

string_list n p::pointer = list $ takewhile stringp [p!i | i = 0..n-1]
with
  p!i = if null q then q else string_dup q
	when q = get_pointer (p+i*SIZEOF_POINTER) end;
end if ~null p && (intp n || infp n);

cstring_list n p::pointer = list $ takewhile stringp [p!i | i = 0..n-1]
with
  p!i = if null q then q else cstring_dup q
	when q = get_pointer (p+i*SIZEOF_POINTER) end;
end if ~null p && (intp n || infp n);

/* Character arithmetic. This allows single-character strings to be used,
   e.g., in arithmetic sequences like "a".."z". */

c::string+n::int	= chr (ord c+n) if #c==1;
c::string-n::int	= chr (ord c-n) if #c==1 && ord c>=n;
c::string-d::string	= ord c-ord d if #c==1 && #d==1;

/* Basic string operations: size, indexing, and concatenation. These properly
   deal with multibyte characters. Therefore indexing every character in a
   string takes quadratic time; as a remedy, we also offer a linear-time
   operation to determine the list of all characters of a string in one go. */

namespace C;
extern bool string_null(void*);
extern int string_size(void*);
extern expr* string_concat(void*, void*);
extern expr* string_char_at(void*, int);
extern expr* string_chars(void*);
namespace;

null s::string		= string_null s;
#s::string		= string_size s;
s::string!n::int	= string_char_at s n if n>=0 && n<#s;
			= throw out_of_bounds otherwise;
s::string+t::string	= string_concat s t;
chars s::string		= string_chars s if varp (:);
/* For the sake of efficiency, string_chars takes some shortcuts when creating
   the output list. This is ok as long as (:) doesn't have any constructor
   equations, but in the (unlikely) case that there are, we need to force
   these to be applied now. */
			= list (string_chars s);

/* Lexicographic string comparison. */

namespace C;
extern int strcmp(void*, void*);
namespace;

x::string<y::string	= strcmp x y < 0;
x::string>y::string	= strcmp x y > 0;
x::string<=y::string	= strcmp x y <= 0;
x::string>=y::string	= strcmp x y >= 0;
x::string==y::string	= strcmp x y == 0;
x::string~=y::string	= strcmp x y ~= 0;

/* Compute and find substrings of a string. */

namespace C;
extern expr* string_substr(void*, int, int);
extern int string_index(void*, void*);
namespace;

substr s::string pos::int size::int
			= string_substr s (max 0 pos) (max 0 size)
			  with max x y = if x>=y then x else y end;
index s::string u::string
			= string_index s u;

/* String slices. The case of contiguous and monotonous ranges is optimized by
   making good use of the 'substr' operation above. */

s::string!!ns		= case ns of
			    ns@(n:_) = substr s n (count ns) if cont ns;
			    _ = string (chars s!!ns);
			  end with
			    cont [n::int] = 1;
			    cont (n::int:ns@(m::int:_)) = cont ns if m==n+1;
			    cont _ = 0 otherwise;
			    count ns = #dropwhile (\n::int->n<0) ns;
			  end;

/* Concatenate a list of strings. */

namespace C;
extern expr* string_concat_list(expr*);
namespace;
strcat xs		= string_concat_list xs if listp xs && all stringp xs;

/* Concatenate a list of strings, interpolating a given delimiter. */

join delim::string []	= "";
join delim::string (x::string:xs)
			= x + strcat [delim+x | x = xs]
			    if listp xs && all stringp xs;

/* Split a string into parts delimited by the given (nonempty) string. */

split delim::string s::string
			= if null s then [] else split1 delim s
with
  split1 delim s	= case index s delim of
			    n = take n s : split1 delim (drop (n+m) s) if n>=0;
			      = [s] otherwise;
			  end;
end when m = #delim end if ~null delim;

/* Conversions between between strings and lists, streams and tuples. */

list s::string		= chars s;
stream s::string	= stream (chars s);
tuple s::string		= tuple (chars s);

string []		= "";
string xs@(_::string:_)	= strcat xs if all stringp xs;

/* Conversions between strings and matrices. */

matrix s::string	= matrix (chars s);
string x::matrix	= string (list x) if all stringp x;

/* Define the customary list operations on strings, so that these can mostly
   be used as if they were lists. */

s::string+[]		= chars s;
s::string+xs@(_:_)	= chars s+xs;
[]+s::string+[]		= chars s;
xs@(_:_)+s::string	= xs+chars s;

reverse s::string	= strcat (reverse (chars s));
catmap f s::string	= catmap f (chars s);
rowcatmap f s::string	= rowcatmap f (chars s);
colcatmap f s::string	= colcatmap f (chars s);
listmap f s::string	= map f (chars s);
rowmap f s::string	= rowmap f (chars s);
colmap f s::string	= colmap f (chars s);

cycle s::string		= cycle (chars s);
cyclen n::int s::string	= cyclen n (chars s) if ~null s;

all p s::string		= all p (chars s);
any p s::string		= any p (chars s);
do f s::string		= do f (chars s);
drop n::int s::string	= substr s n (#s-n);
dropwhile p s::string	= strcat (dropwhile p (chars s));
filter p s::string	= strcat (filter p (chars s));
foldl f a s::string	= foldl f a (chars s);
foldl1 f s::string	= foldl1 f (chars s);
foldr f a s::string	= foldr f a (chars s);
foldr1 f s::string	= foldr1 f (chars s);
head s::string		= s!0 if ~null s;
init s::string		= substr s 0 (#s-1) if ~null s;
last s::string		= s!(#s-1) if ~null s;
map f s::string		= map f (chars s);
scanl f a s::string	= scanl f a (chars s);
scanl1 f s::string	= scanl1 f (chars s);
scanr f a s::string	= scanr f a (chars s);
scanr1 f s::string	= scanr1 f (chars s);
take n::int s::string	= substr s 0 n;
takewhile p s::string	= strcat (takewhile p (chars s));
tail s::string		= substr s 1 (#s-1) if ~null s;
zip s::string t::string	= zip (chars s) (chars t);
zip3 s::string t::string u::string
			= zip3 (chars s) (chars t) (chars u);
zipwith f s::string t::string
			= zipwith f (chars s) (chars t);
zipwith3 f s::string t::string u::string
			= zipwith3 f (chars s) (chars t) (chars u);
dowith f s::string t::string
			= dowith f (chars s) (chars t);
dowith3 f s::string t::string u::string
			= dowith3 f (chars s) (chars t) (chars u);
