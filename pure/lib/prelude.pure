
/* Pure's standard prelude. */

/* Copyright (c) 2008 by Albert Graef <Dr.Graef@t-online.de>.

   This file is part of the Pure programming language and system.

   Pure is free software: you can redistribute it and/or modify it under the
   terms of the GNU General Public License as published by the Free Software
   Foundation, either version 3 of the License, or (at your option) any later
   version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
   details.

   You should have received a copy of the GNU General Public License along
   with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* .. We use docutils to produce the documentation. Docstrings are extracted
   .. with pure-doc. Please see the pure-doc documentation for details.

   .. This module is always the first in the library docs, so produce the
   .. title here.

   ===================
   Pure Library Manual
   ===================

   .. Add all pertaining author and copyright information here.

   :Author: Albert Graef <Dr.Graef@t-online.de>
   :Copyright: Copyright (c) 2009

   .. Add all global docutils declarations here.

   .. role:: dfn(strong)
   .. default-role:: dfn

   .. |GPL| replace:: GNU General Public License
   .. |FDL| replace:: GNU Free Documentation License
   .. _FDL: http://www.gnu.org/copyleft/fdl.html
   .. _GPL: http://www.gnu.org/copyleft/gpl.html

   .. _Pure Manual: file:pure.html

   This document is available under the |FDL|_.

   This manual describes the operations in the standard Pure library,
   including the prelude and the other library modules which come bundled with
   the interpreter. It is woefully incomplete right now, but this is being
   worked on.

   There is a companion to this manual, the `Pure Manual`_ which describes the
   Pure language and the operation of the Pure interpreter.

   .. Table of contents, switch on section numbering.

   .. contents::
   .. sectnum::

   Prelude
   =======

   The prelude defines the basic operations of the Pure language. This
   includes the basic arithmetic and logical operations, string, list and
   matrix functions, as well as the support operations required to implement
   list and matrix comprehensions.

   It also declares a signature of commonly used constant and operator
   symbols. This comprises:

   .. _failed_cond:
   .. _failed_match:
   .. _stack_fault:
   .. _bad_matrix_value:

   * The built-in exception values ``failed_cond`` (failed conditional in
     guard or if-then-else), ``failed_match`` (failed pattern match in lambda,
     case, etc.), ``stack_fault`` (not enough stack space, ``PURE_STACK``
     limit exceeded) and ``bad_matrix_value x`` (error in matrix
     construction).

   .. _bad_list_value:
   .. _bad_tuple_value:
   .. _out_of_bounds:
   .. _malloc_error:

   * Other predefined exceptions: ``bad_list_value x``, ``bad_tuple_value x``
     (which are thrown by some list and tuple operations when they fail to
     find an expected list or tuple value), ``out_of_bounds`` (which is thrown
     by the index operator ``!`` if a list, tuple or matrix index is out of
     bounds), and ``malloc_error`` which indicates a memory allocation error.

   .. _true:
   .. _false:

   * The truth values ``true`` and ``false``. These are actually just integers
     in Pure, but sometimes it's convenient to refer to them using these
     symbolic constants. Note that if you also want to use these on the
     left-hand side of equations, you still have to declare them as
     ``nullary`` symbols yourself, using a declaration like: ``nullary false
     true;``

*/

nullary failed_cond failed_match stack_fault out_of_bounds malloc_error;
public  bad_matrix_value bad_list_value bad_tuple_value;

/* .. _operators:

   Here's the list of predefined operator symbols. Note that the parser will
   automagically give unary minus the same precedence level as the
   corresponding binary operator. Also note that the "mapsto" operator
   a.k.a. "hash rocket" ``=>`` doesn't have a predefined meaning in Pure; the
   prelude only implements the relations ``==`` and ``~=`` to check such "hash
   pairs" ``x=>y`` for equality and inequality. The hash rocket is used in
   several libraries, however, which usually employ it to denote some kind of
   key-value associations. See, e.g., Dictionaries_ for an example. */

// >>>

infixl  0   $$ ;                // sequence operator
infixr  0   $ ;                 // right-associative application
infixr  1   , ;                 // pair (tuple)
infix   2   .. ;                // arithmetic sequences
infix   2   => ;                // mapsto constructor
infixr  2   || ;                // logical or (short-circuit)
infixr  3   && ;                // logical and (short-circuit)
prefix  3   ~ ;                 // logical negation
infix   4   < > <= >= == ~= ;   // relations
infix   4   === ~== ;           // syntactic equality
infixr  4   : ;                 // list cons
infix   5   +: <: ;             // complex numbers (cf. math.pure)
infixl  5   << >> ;             // bit shifts
infixl  6   + - or ;            // addition, bitwise or
infixl  7   * / div mod and ;   // multiplication, bitwise and
infixl  7   % ;                 // exact division (cf. math.pure)
prefix  7   not ;               // bitwise not
postfix 7   ' ;                 // matrix transposition
infixr  8   ^ ;                 // exponentiation
prefix  8   # ;                 // size operator
infixl  9   ! !! ;              // indexing, slicing
infixr  9   . ;                 // function composition
postfix 9   & ;                 // thunk

// <<<

const false, true = 0, 1;

/* Pull in the primitives (arithmetic etc.) and the standard string functions.
   Note that the math and system modules are *not* included here, so you have
   to do that yourself if your program requires any of those operations. */

using primitives, matrices, strings;

/* ..

   Basic Combinators
   -----------------

   .. _combinators:

   The most important function combinators are ``$`` (right-associative
   application) and ``.`` (function composition), which are also defined as
   macros so that saturated calls of these are eliminated automatically.
   Examples::

     > foo $ bar 99;
     foo (bar 99)
     > (foo.bar) 99;
     foo (bar 99)

   .. _id:
   .. _cst:

   The customary identity and constant combinators from the combinatorial
   calculus are also available, in Pure these are named ``id`` and ``cst``,
   respectively::

     > map id (1..5);
     [1,2,3,4,5]
     > map (cst 0) (1..5);
     [0,0,0,0,0]

   .. _void:

   There's also a combinator ``void`` which is basically equivalent to ``cst
   ()``, but with the special twist that it is also defined as a macro
   optimizing the case of "throwaway" list and matrix comprehensions. This is
   useful if a comprehension is evaluated solely for its side effects. E.g.::

     > using system;
     > extern int rand();
     > foo = void [printf "%d\n" rand | _ = 1..3];
     > show foo
     foo = do (\_ -> printf "%d\n" rand) (1..3);
     > foo;
     1714636915
     1957747793
     424238335
     ()

   Note that the above list comprehension is actually implemented using do_
   (instead of map_, which would normally be the case), so that the
   intermediate list value of the comprehension is never constructed. This is
   described in more detail in section `Optimization Rules`_ of the Pure
   Manual.

   .. _Optimization Rules: file:pure.html#optimization-rules

*/

f $ x		= f x;
(f . g) x	= f (g x);

void _		= ();
id x		= x;
cst x y		= x;

/* ..

   In addition, Pure also provides the following combinators adopted from
   Haskell:

   .. _flip:

   * ``flip`` swaps arguments of a binary function, e.g.::

       > map (flip (/) 2) (1..3);
       [0.5,1.0,1.5]

     This idiom is used much more frequently in Pure than in Haskell because
     Pure doesn't have Haskell's operator sections. Note, however, that the
     same effect can also be achieved with a lambda::

       > map (\x -> x/2) (1..3);
       [0.5,1.0,1.5]

   .. _curry:

   * ``curry`` turns a function expecting a pair of values into a curried
     function of two arguments::

       > using system;
       > dowith (curry (printf "%d: %g\n")) (0..2) [0.0,2.718,3.14];
       0: 0
       1: 2.718
       2: 3.14
       ()

   .. _uncurry:

   * Conversely, ``uncurry`` turns a curried function expecting two arguments
     into a function processing a single pair argument::

       > map (uncurry (*)) [(2,3),(4,5),(6,7)];
       [6,20,42]

   .. _curry3:
   .. _uncurry3:

   * ``curry3`` and ``uncurry3`` work analogously, but are used to work with
     ternary functions.

*/

flip f x y	= f y x;
curry f x y	= f (x,y);
curry3 f x y z	= f (x,y,z);
uncurry f (x,y)	= f x y;
uncurry3 f (x,y,z)
		= f x y z;

/* ..

   Finally, the (normal order) fixed point combinator ``fix`` allows you to
   create recursive anonymous functions. It takes a "one step" function ``f``
   as its argument and returns another function which in turn applies ``f`` to
   itself and an argument value, see `Fixed point combinator`_ for a more
   lucid explanation. For instance::

     > let fact = fix (\f n -> if n<=0 then 1 else n*f (n-1));
     > map fact (1..5);
     [1,2,6,24,120]

   .. _Fixed point combinator:
      http://en.wikipedia.org/wiki/Fixed_point_combinator

*/

fix f = y y with y x = f (x x&) end;

/* Some convenient optimization rules which eliminate saturated calls of the
   function composition combinators. */

def f $ x	= f x;
def (f . g) x	= f (g x);

/* The following rules are always valid and optimize the case of "throwaway"
   list comprehensions (useful if a list comprehension is evaluated solely for
   its side effects). */

def void (catmap f x) = do f x;
def void (listmap f x) = do f x;

/* Lisp-like quasiquote. */

def quasiquote (unquote x)	= x;
def quasiquote (f@_ (splice x))	= foldl ($) (quasiquote f) (quasiquote x);
def quasiquote (f@_ x)		= quasiquote f (quasiquote x);
def quasiquote x		= quote x;

/* "Mapsto" operator. This constructor is declared here so that it can be used
   in other standard library modules to denote special kinds of pairs which
   map keys to values. Here we only define equality of such pairs. */

(x=>v)==(y=>w)	= if x==y then v==w else 0;
(x=>v)~=(y=>w)	= if x~=y then 1 else v~=w;

/* ..

   Lists and Tuples
   ----------------

   .. _lists:
   .. _tuples:

   The prelude defines the list and tuple constructors (``x:y``, ``x,y``), as
   well as equality (``==``) and inequality (``~=``) on these structures. It
   also provides the predicate ``null x`` which tests whether ``x`` is the
   empty list or tuple, the function ``reverse x`` which reverses a list or
   tuple, and the operators ``#x`` (size of a list or tuple), ``x!i``
   (indexing), ``x!!is`` (slicing) and ``x+y`` (list concatenation).

   Note that list and tuple equality use the equality of their members to
   decide equality of lists and tuples, so ``==`` must be defined on the list
   or tuple members.

   Also note that there isn't a separate operation for concatenating tuples,
   since the pairing operator already does this::

     > (1,2,3),(10,9,8);
     1,2,3,10,9,8

   This works because the ``(,)`` constructor is associative in Pure and will
   always produce right-recursive pairs. This also implies that tuples are
   always flat in Pure and can't be nested; if you need this, you should use
   lists instead. Also note that the empty tuple ``()`` acts as a neutral
   element with respect to ``(,)``::

     > (),(a,b,c);
     a,b,c
     > (a,b,c),();
     a,b,c

   Lists are the usual right-recursive aggregates, pretty much the same as in
   Lisp or Prolog except that they use a Haskell-like syntax. In difference to
   Haskell, list concatenation is denoted ``+``, and lists may contain an
   arbitrary mixture of arguments, i.e., they are fully polymorphic::

     > 1:2:3:[];
     [1,2,3]
     > [1,2,3]+[u,v,w]+[3.14];
     [1,2,3,u,v,w,3.14]

   Lists are `eager` in Pure by default, but they can also be made `lazy`, see
   section `Lazy Evaluation and Streams`_ in the Pure Manual.

   .. _Lazy Evaluation and Streams: file:pure.html#lazy-evaluation-and-streams

   .. _arithmetic sequences:

   Arithmetic sequences can be constructed with the infix ``..`` operator::

     > 1..5;
     [1,2,3,4,5]
     > 1:3..11;
     [1,3,5,7,9,11]

   Note that the Pure syntax differs slightly from Haskell in that a step
   width is indicated by specifying the first two elements as ``x:y`` instead
   of ``x,y``. Also, to specify infinite sequences you have to use an infinite
   upper bound (``inf`` or ``-inf``)::

     > 1:3..inf;
     1:#<thunk 0x7f696cd2dbd8>
     > -1:-3..-inf;
     -1:#<thunk 0x7f696cd2fde8>

   .. _list:
   .. _tuple:

   You can convert between (finite) lists and tuples using the ``list`` and
   ``tuple`` operations::

     > tuple (1..5);
     1,2,3,4,5
     > list (a,b,c);
     [a,b,c]

   The ``list`` function can also be used to turn a finite lazy list into an
   eager one::

     > list $ take 10 (-1:-3..-inf);
     [-1,-3,-5,-7,-9,-11,-13,-15,-17,-19]

   You can also achieve the same effect by slicing a finite part from a
   stream (see below)::

     > (-1:-3..-inf)!!(0..9);
     [-1,-3,-5,-7,-9,-11,-13,-15,-17,-19]

   .. _stream:

   Conversely, it is also possible to convert a list to a stream::

     > stream (1..10);
     1:#<thunk 0x7fe537fe2b58>

   This might appear a bit useless at first sight, since all elements of the
   stream are in fact already known. However, this operation then allows you
   to apply other functions to the list and have them evaluated in a lazy
   fashion.

   .. _indexing:

   Indexing of lists and tuples is always zero-based (i.e., indices run from
   ``0`` to ``#x-1``), and an exception will be raised if the index is out of
   bounds::

     > [1,2,3]!2;
     3
     > [1,2,3]!4;
     <stdin>, line 34: unhandled exception 'out_of_bounds' while evaluating
     '[1,2,3]!4'

   .. _slicing:

   The slicing operator ``!!`` takes a list or tuple and a list of indices and
   returns the list or tuple of the corresponding elements, respectively.
   Indices which are out of the valid range are silently ignored::

     > (1..5)!!(3..10);
     [4,5]
     > (1,2,3,4,5)!!(3..10);
     4,5

   Indices can actually be specified in any order, so that you can retrieve
   any permutation of the members, also with duplicates. E.g.::

     > (1..5)!![2,4,4,1];
     [3,5,5,2]

   This is less efficient than the case of contiguous index ranges (which is
   optimized so that it always works in linear time), because it requires
   repeated traversals of the list for each index. For larger lists you should
   hence use vectors or matrices instead, to avoid the quadratic complexity.

*/

/* Poor man's tuples(TM). These are constructed with the pairing operator ',',
   are always flat and associate to the right. The empty tuple, denoted (), is
   neutral with respect to ','. Operations are provided to test for equality/
   inequality and emptiness, to determine the size of a tuple, for zero-based
   indexing and slicing, and to reverse a tuple. */

x,()		= x;
(),y		= y;
(x,y),z		= x,(y,z);

()==()		= 1;
(x,xs)==(y,ys)	= if x==y then xs==ys else 0;
(x,xs)==_	|
()==_		|
_==(x,xs)	|
_==()		= 0;

()~=()		= 0;
(x,xs)~=(y,ys)	= if x~=y then 1 else xs~=ys;
(x,xs)~=_	|
()~=_		|
_~=(x,xs)	|
_~=()		= 1;

null ()		= 1;
null (x,xs)	= 0;

#()		= 0;
#(x,xs)		= accum 1 xs with
  accum n::int (x,xs)	= accum (n+1) xs;
  accum n::int x	= n+1;
end;

(x,xs)!n::int	= throw out_of_bounds if n<0;
(x,xs)!0	= x;
(x,y,xs)!n::int	= (y,xs)!(n-1);
(x,y)!1		= y;
(x,y)!n::int	|
()!n::int	= throw out_of_bounds;

xs@()!!ns	|
xs@(_,_)!!ns	= tuple (list xs!!ns);

reverse ()	= ();
reverse (x,xs)	= accum x xs with
  accum ys (x,xs)	= accum (x,ys) xs;
  accum ys x		= x,ys;
end;

/* Lists are the usual "conses" written using the infix ':' operator. '[]'
   denotes the empty list. Moreover, the parser provides the customary sugar
   for proper list values [x] where x is any singleton or tuple (in the latter
   case you'll get a list made from all the elements of x). The usual basic
   operations are provided to test for equality/inequality and emptiness, to
   compute the size of a list, for indexing, slicing and concatenation, and
   for reversing a list. */

[]==[]		= 1;
(x:xs)==[]	= 0;
[]==(x:xs)	= 0;
(x:xs)==(y:ys)	= if x==y then xs==ys else 0;

[]~=[]		= 0;
(x:xs)~=[]	= 1;
[]~=(x:xs)	= 1;
(x:xs)~=(y:ys)	= if x~=y then 1 else xs~=ys;

null []		= 1;
null (x:xs)	= 0;

#[]		= 0;
#(x:xs)		= accum 1 xs with
  accum n::int (x:xs)	= accum (n+1) xs;
  accum n::int []	= n;
  accum	n::int xs	= n+#xs;
end;

[]!n::int	= throw out_of_bounds;
(x:xs)!0	= x;
(x:xs)!n::int	= xs!(n-1) if n>0;
		= throw out_of_bounds otherwise;

/* Slicing. xs!!ns returns the list of xs!n for all members n of the index
   list ns which are in the valid index range. This is a generic fallback
   definition which works with any kind of container data structure which
   defines (!) in such a manner that it throws an exception when the index is
   out of bounds. It also works with any kind of index container that
   implements the catmap operation. Moreover, the special case of finite
   contiguous list slices is optimized using 'take' and 'drop' so that it
   works in linear time. */

xs!!ns		= case ns of
		    ns@(n::int:_) = list $ take (count ns) (drop n xs)
		      if listnp xs && cont ns;
		    _ = catmap (nth xs) ns;
		  end with
		    nth xs n = catch (cst []) [xs!n];
		    count ns = #dropwhile (\n::int->n<0) ns;
		    cont (n::int:ns) = ~thunkp ns &&
		    (case ns of
		       [] = 1;
		       m::int:_ = cont ns if m==n+1;
		       _ = 0 otherwise;
		     end);
		  end;

/* List concatenation. For a robust implementation which works with both
   ordinary lists and streams, we want this to be tail-recursive *and*
   non-strict. So we first walk down the list, popping elements from the first
   operand until we find an empty or thunked tail ('tick'), then walk back up
   again, pushing elements in front of the result list ('tack'). */

[]+ys		= ys;
xs@(_:_)+ys	= tick [] xs ys
with
  tick zs (x:xs) ys	= tack (x:zs) ((xs+ys)&) if thunkp xs;
			= tick (x:zs) xs ys;
  tick zs [] ys		= tack zs ys;
  /* Handle an improper list tail (xs+ys is in normal form here). */
  tick zs xs ys		= tack zs (xs+ys);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

/* List reversal. This is a strict operation, of course, so it will loop on
   infinite lists. Also, this is one of the few list operations which throws
   an exception for improper lists, since in that case there really isn't any
   meaningful value to return. */

reverse []	= [];
reverse (x:xs)	= accum [x] xs with
  accum ys (x:xs)	= accum (x:ys) xs;
  accum ys []		= ys;
  accum	ys xs		= throw (bad_list_value xs);
end;

/* Conversions between lists, tuples and streams. */

list ()		= [];
list (x,xs)	= accum [x] xs with
  accum ys (x,xs)	= accum (x:ys) xs;
  accum ys x		= reverse (x:ys);
end;

tuple []	= ();
tuple (x:xs)	= accum x xs with
  accum ys (x:xs)	= accum (x,ys) xs;
  accum ys []		= if tuplep ys then reverse ys else ys;
  accum	ys xs		= ys,xs;
end;

list []		= [];
list (x:xs)	= accum [x] xs with
  accum ys (x:xs)	= accum (x:ys) xs;
  accum ys []		= reverse ys;
  accum	ys xs		= throw (bad_list_value xs);
end;

stream []	= [];
stream (x:xs)	= x:xs if thunkp xs;
		= x:stream xs& otherwise;

stream ()	= [];
stream xs@(_,_)	= stream (list xs);

/* Arithmetic sequences. */

n1:n2..m	= if m===s*inf then iterate (\x->x+k) n1
		  else while (\i->s*i<=s*m) (\x->x+k) n1
		  when k = n2-n1; s = if k>0 then 1 else -1 end if n1~=n2;
n..m		= if m===inf then iterate (\x->x+1) n
		  else while (\i->i<=m) (\x->x+1) n;

/* ..

   List Functions
   --------------

   This mostly comes straight from the Q prelude which in turn was based on
   the first edition of the Bird/Wadler book, and is very similar to what you
   can find in the Haskell prelude. Some functions have slightly different
   names, though, and of course everything is typed dynamically.

   Common List Functions
   ~~~~~~~~~~~~~~~~~~~~~

   .. _any:

   ``any p xs``
     tests whether the predicate ``p`` holds for any of the members of ``xs``

   .. _all:

   ``all p xs``
     tests whether the predicate ``p`` holds for all of the members of ``xs``

   .. _cat:

   ``cat xs``
     concatenate a list of lists

   .. _catmap:

   ``catmap f xs``
     convenience function which combines cat_ and map_

   .. _do:

   ``do f xs``
     apply ``f`` to all members of ``xs``, like map_, but throw away all
     intermediate results and return ``()``

   .. _drop:

   ``drop n xs``
     remove ``n`` elements from the front of ``xs``

   .. _dropwhile:

   ``dropwhile p xs``
     remove elements from the front of ``xs`` while the predicate ``p`` is
     satisfied

   .. _filter:

   ``filter p xs``
     return the list of all members of ``xs`` satisfying the predicate ``p``

   .. _foldl:

   ``foldl f a xs``
     accumulate the binary function ``f`` over all members of ``xs``,
     starting from the initial value ``a`` and working from the front of the
     list towards its end

   .. _foldl1:

   ``foldl1 f xs``
     accumulate the binary function ``f`` over all members of ``xs``,
     starting from the value ``head xs`` and working from the front of the
     list towards its end; ``xs`` must be nonempty

   .. _foldr:

   ``foldr f a xs``
     accumulate the binary function ``f`` over all members of ``xs``,
     starting from the initial value ``a`` and working from the end of the
     list towards its front

   .. _foldr1:

   ``foldr1 f xs``
     accumulate the binary function ``f`` over all members of ``xs``,
     starting from the value ``last xs`` and working from the end of the
     list towards its front; ``xs`` must be nonempty

   .. _head:

   ``head xs``
     return the first element of ``xs``; ``xs`` must be nonempty

   .. _index:

   ``index xs x``
     search for an occurrence of ``x`` in ``xs`` and return the index of the
     first occurrence, if any, ``-1`` otherwise

     Note: This uses equality (``==``) to decide whether a member of ``xs`` is
     an occurrence of ``x``, so ``==`` must have an appropriate definition on
     the list members.

   .. _init:

   ``init xs``
     return all but the last element of ``xs``; ``xs`` must be nonempty

   .. _last:

   ``last xs``
     return the last element of ``xs``; ``xs`` must be nonempty

   .. _map:

   ``map f xs``
     apply ``f`` to each member of ``xs``

   .. _scanl:

   ``scanl f a xs``
     accumulate the binary function ``f`` over all members of ``xs``,
     as with ``foldl``, but return all intermediate results as a list

   .. _scanl1:

   ``scanl1 f xs``
     accumulate the binary function ``f`` over all members of ``xs``,
     as with ``foldl1``, but return all intermediate results as a list

   .. _scanr:

   ``scanr f a xs``
     accumulate the binary function ``f`` over all members of ``xs``,
     as with ``foldr``, but return all intermediate results as a list

   .. _scanr1:

   ``scanr1 f xs``
     accumulate the binary function ``f`` over all members of ``xs``,
     as with ``foldr1``, but return all intermediate results as a list

   .. _tail:

   ``tail xs``
     return all but the first element of ``xs``; ``xs`` must be nonempty

   .. _take:

   ``take n xs``
     take ``n`` elements from the front of ``xs``

   .. _takewhile:

   ``takewhile p xs``
     take elements from the front of ``xs`` while the predicate ``p`` is
     satisfied

*/

/* Some of the definitions aren't exactly pretty, but they are like that
   because we want them to be both efficient and robust. In particular, we
   require that they do all the necessary argument checking, are
   tail-recursive and handle lazy lists as gracefully as possible. */

all p []		= 1;
all p (x:xs)		= if p x then all p xs else 0;

any p []		= 0;
any p (x:xs)		= if p x then 1 else any p xs;

do f []			= ();
do f (x:xs)		= f x $$ do f xs;

drop n::int []		= [];
drop n::int ys@(x:xs)	= drop (n-1) xs if n>1;
			= xs if n==1;
			= ys otherwise;

dropwhile p []		= [];
dropwhile p ys@(x:xs)	= dropwhile p xs if p x;
			= ys otherwise;

filter p []		= [];
filter p xs@(_:_)	= tick [] xs
with
  add p x xs		= if p x then x:xs else xs;
  tick zs (x:xs)	= tack (add p x zs) (filter p xs&) if thunkp xs;
			= tick (add p x zs) xs;
  tick zs []		= tack zs [];
  tick _ xs		= throw (bad_list_value xs);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

foldl f a []		= a;
foldl f a (x:xs)	= foldl f (f a x) xs;

foldl1 f (x:xs)		= foldl f x xs;

foldr f a []		= a;
foldr f a xs@(_:_)	= tick [] xs
with
  tick zs (x:xs)	= tack (x:zs) (foldr f a xs&) if thunkp xs;
			= tick (x:zs) xs;
  tick zs []		= tack zs a;
  tick zs xs		= tack zs (foldr f a xs);
  tack (x:xs) y		= tack xs (f x y);
  tack [] y		= y;
end;

foldr1 f [x]		= x;
foldr1 f xs@(_:_)	= tick [] xs
with
  /* Do the thunkp check first, before probing the tail. Note that the first
     foldr1 rule above ensures that the topmost tail is already evaluated, so
     that we always make some progress here. */
  tick zs ys@(_:xs)	= tack zs (foldr1 f ys&) if thunkp xs;
  tick zs xs		= case xs of
			    [x]  = tack zs x;
			    x:xs = tick (x:zs) xs;
			    _    = tack zs (foldr1 f xs);
			  end;
  tack (x:xs) y		= tack xs (f x y);
  tack [] y		= y;
end;

head (x:xs)		= x;

init [x]		= [];
init xs@(_:_)		= tick [] xs
with
  tick zs ys@(_:xs)	= tack zs (init ys&) if thunkp xs;
  tick zs xs		= case xs of
			    [x]  = tack zs [];
			    x:xs = tick (x:zs) xs;
			    _    = tack zs (init xs);
			  end;
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

last [x]		= x;
last (x:xs)		= last xs;

map f []		= [];
map f xs@(_:_)		= tick [] xs
with
  tick zs (x:xs)	= tack (f x:zs) (map f xs&) if thunkp xs;
			= tick (f x:zs) xs;
  tick zs []		= tack zs [];
  tick zs xs		= tack zs (map f xs);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

scanl f a []		= [a];
scanl f a xs@(_:_)	= tick a [] xs
with
  tick a zs (x:xs)	= tack (a:zs) (scanl f (f a x) xs&) if thunkp xs;
			= tick (f a x) (a:zs) xs;
  tick a zs []		= tack zs [a];
  tick a zs xs		= tack zs (scanl f a xs);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

scanl1 f []		= [];
scanl1 f (x:xs)		= scanl f x xs;

scanr f a []		= [a];
scanr f a xs@(_:_)	= tick [] xs
with
  /* Hack around with thunks to make these matches irrefutable. */
  tick zs (x:xs)	= tack zs us when
			    ys = scanr f a xs&;
			    y  = (case ys of
				    y:_ = y;
				    scanr _ _ ys = throw (bad_list_value ys);
				    _ = throw (bad_list_value ys);
				  end)&;
			    us = f x y : ys;
			  end if thunkp xs;
  tick zs (x:xs)	= tack zs (f x (y when y:_ = ys end)&:ys
				   when ys = scanr f a xs& end) if thunkp xs;
			= tick (x:zs) xs;
  tick zs []		= tack zs [a];
  tick zs xs		= throw (bad_list_value xs);
  tack (x:xs) ys	= tack xs (f x y:ys) when y:_ = ys end;
  tack [] ys		= ys;
end;

scanr1 f []		= [];
scanr1 f [x]		= [x];
scanr1 f xs@(_:_)	= tick [] xs
with
  tick zs (x:xs)	= tack zs us when
			    ys = scanr1 f xs&;
			    y  = (case ys of
				    y:_ = y;
				    scanr1 _ ys = throw (bad_list_value ys);
				    _ = throw (bad_list_value ys);
				  end)&;
			    us = f x y : ys;
			  end if thunkp xs;
  tick zs xs		= case xs of
			    [x]  = tack zs [x];
			    x:xs = tick (x:zs) xs;
			    _    = throw (bad_list_value xs);
			  end;
  tack (x:xs) ys	= tack xs (f x y:ys) when y:_ = ys end;
  tack [] ys		= ys;
end;

tail (x:xs)		= xs;

take n::int []		= [];
take n::int xs@(_:_)	= tick n [] xs
with
  tick n::int zs xs	= tack zs [] if n<=0;
			= tack zs (take n xs&) if thunkp xs;
			= case xs of
			    []   = tack zs [];
			    x:xs = tick (n-1) (x:zs) xs;
			    _    = tack zs (take n xs);
			  end;
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

takewhile p []	= [];
takewhile p xs@(_:_)	= tick [] xs
with
  tick zs xs		= tack zs (takewhile p xs&) if thunkp xs;
			= case xs of
			    []   = tack zs [];
			    x:xs = tick (x:zs) xs if p x;
			         = tack zs [];
			    _    = tack zs (takewhile p xs);
			  end;
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

/* Concatenate a list of lists. */

cat []			= [];
cat xs@(_:_)		= foldr (tick []) [] xs
with
  /* Unfortunately, the global list concatenation operator (+) isn't fully
     lazy in Pure, because it's also used for arithmetic operations. Using it
     here would make foldr (and hence cat) eager. Therefore we use our own
     concatenation operation here, which properly deals with the case that ys
     is an infinite stream when applied recursively. */
  tick zs (x:xs) ys	= tack (x:zs) (tick [] xs ys&) if thunkp xs;
			= tick (x:zs) xs ys;
  tick zs [] ys		= tack zs ys;
  tick zs xs ys		= tack zs (xs+ys);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

/* Map a function to a list and concatenate the results. This is used by list
   comprehensions. */

catmap f []		= [];
catmap f xs@(_:_)	= cat (map f xs);

/* NOTE: This definition (from the Haskell prelude) is better, but doesn't
   preserve left-to-right execution order. */
//catmap f xs@(_:_)	= foldr ((+).f) [] xs;

/* Map a function to a list, like map, but first promote the argument to a
   list if possible. This is used by list comprehensions. */

listmap f []		= [];
listmap f xs@(_:_)	= map f xs;

/* Search an element in a list. Returns -1 if not found, index of first
   occurrence otherwise. */

index [] _		= -1;
index (x:xs) y		= search 0 (x:xs) with
  search _ []		= -1;
  search n::int (x:xs)	= n if x==y;
			= search (n+1) xs;
  search _ xs		= index xs y;
end;

/* ..

   List Generators
   ~~~~~~~~~~~~~~~

   .. _cycle:

   ``cycle xs``
     cycles through the elements of the nonempty list ``xs``, ad infinitum

   .. _cyclen:

   ``cyclen n xs``
     eager version of ``cycle``, returns the first ``n`` elements of
     ``cycle xs``

   .. _iterate:

   ``iterate f x``
     returns the stream containing ``x``, ``f x``, ``f (f x)``, etc.,
     ad infinitum

   .. _repeat:

   ``repeat x``
     returns an infinite stream of ``x``\ s

   .. _repeatn:

   ``repeatn n x``
     eager version of ``repeat``, returns a list with ``n`` ``x``\ s

   .. _while:

   ``while p f x``
     eager version of ``iterate``, returns the list of all elements from
     the front of ``iterate f xs`` for which the predicate ``p`` holds

*/

/* Some useful (infinite) list generators. */

iterate f x		= x : iterate f (f x)&;
repeat x		= x : repeat x&;
cycle ys@(x:xs)		= x : (xs+cycle ys)&;

/* Some finite (and strict) generators. These work like the a combination of
   takewhile/take and the above, but are implemented directly for maximum
   efficiency. */

while p f x		= accum [] p f x with
			    accum xs p f x = accum (x:xs) p f (f x) if p x;
				           = reverse xs otherwise;
			  end;

repeatn n::int x	= accum [] n x with
  accum xs n::int x	= xs if n<=0;
			= accum (x:xs) (n-1) x;
end;

cyclen n::int (x:xs)	= [] if n<=0;
			= accum [] n with
			    accum ys n::int = cat ys+take n xs if n<=m;
			                    = accum (xs:ys) (n-m) otherwise;
			  end when xs = x:xs; m::int = #xs end if listp xs;

/* ..

   Zip and Friends
   ~~~~~~~~~~~~~~~

   .. _unzip:

   ``unzip xys``
     takes a list of pairs to a pair of lists of corresponding elements

   .. _unzip3:

   ``unzip3 xyzs``
     ``unzip`` with triples

   .. _zip:

   ``zip xs ys``
     return the list of corresponding pairs ``(x,y)`` where ``x`` runs
     through the elements of ``xs`` and ``y`` runs through the elements
     of ``y``

   .. _zip3:

   ``zip3 xs ys zs``
     ``zip`` with three lists, returns a list of triples

   .. _zipwith:

   ``zipwith f xs ys``
     apply the binary function ``f`` to corresponding elements of ``xs``
     and ``ys``

   .. _zipwith3:

   ``zipwith3 f xs ys zs``
     apply the ternary function ``f`` to corresponding elements of ``xs``,
     ``ys`` and ``zs``

   Pure also has the following variations of ``zipwith``/``zipwith3`` which
   throw away all intermediate results and return ``()``. That is, these work
   like do_ but pull arguments from two or three lists, respectively:

   .. _dowith:

   ``dowith f xs ys``
     apply the binary function ``f`` to corresponding elements of ``xs``
     and ``ys``, return ``()``

   .. _dowith3:

   ``dowith3 f xs ys zs``
     apply the ternary function ``f`` to corresponding elements of ``xs``,
     ``ys`` and ``zs``, return ``()``

*/

zip [] _		|
zip _ []		= [];
zip xs@(_:_) ys@(_:_)	= tick [] xs ys
with
  tick us (x:xs) (y:ys)	= tack ((x,y):us) (zip xs ys&)
			    if thunkp xs || thunkp ys;
			= tick ((x,y):us) xs ys;
  tick us [] _		|
  tick us _ []		= tack us [];
  tick us xs ys		= tack us (zip xs ys);
  tack (u:us) vs	= tack us (u:vs);
  tack [] vs		= vs;
end;

zip3 [] _ _		|
zip3 _ [] _		|
zip3 _ _ []		= [];
zip3 xs@(_:_) ys@(_:_) zs@(_:_)
			= tick [] xs ys zs
with
  tick us (x:xs) (y:ys) (z:zs)
			= tack ((x,y,z):us) (zip3 xs ys zs&)
			    if thunkp xs || thunkp ys || thunkp zs;
			= tick ((x,y,z):us) xs ys zs;
  tick us [] _ _	|
  tick us _ [] _	|
  tick us _ _ []	= tack us [];
  tick us xs ys zs	= tack us (zip3 xs ys zs);
  tack (u:us) vs	= tack us (u:vs);
  tack [] vs		= vs;
end;

zipwith f [] _		|
zipwith f _ []		= [];
zipwith f xs@(_:_) ys@(_:_)
			= tick [] xs ys
with
  tick us (x:xs) (y:ys)	= tack (f x y:us) (zipwith f xs ys&)
			    if thunkp xs || thunkp ys;
			= tick (f x y:us) xs ys;
  tick us [] _		|
  tick us _ []		= tack us [];
  tick us xs ys		= tack us (zipwith f xs ys);
  tack (u:us) vs	= tack us (u:vs);
  tack [] vs		= vs;
end;

zipwith3 f [] _ _		|
zipwith3 f _ [] _		|
zipwith3 f _ _ []		= [];
zipwith3 f xs@(_:_) ys@(_:_) zs@(_:_)
			= tick [] xs ys zs
with
  tick us (x:xs) (y:ys) (z:zs)
			= tack (f x y z:us) (zipwith3 f xs ys zs&)
			    if thunkp xs || thunkp ys || thunkp zs;
			= tick (f x y z:us) xs ys zs;
  tick us [] _ _	|
  tick us _ [] _	|
  tick us _ _ []	= tack us [];
  tick us xs ys zs	= tack us (zipwith3 f xs ys zs);
  tack (u:us) vs	= tack us (u:vs);
  tack [] vs		= vs;
end;

dowith f (x:xs) (y:ys)	= f x y $$ dowith f xs ys;
dowith f _ _		= () otherwise;

dowith3 f (x:xs) (y:ys) (z:zs)
			= f x y z $$ dowith3 f xs ys zs;
dowith3 f _ _ _		= () otherwise;

unzip []		= [],[];
unzip us@(_:_)		= foldr accum ([],[]) us
with
  accum u@(x,y) us	= x:(xs when xs,_ = check us end)&,
			  y:(ys when _,ys = check us end)& if thunkp us;
			= x:xs,y:ys when xs,ys = check us end;
  accum u _		= throw (bad_tuple_value u);
  check us@(_,_)	= us;
  check (foldr _ _ us)	= throw (bad_list_value us);
  check us		= throw (bad_tuple_value us);
end;

unzip3 []		= [],[],[];
unzip3 us@(_:_)		= foldr accum ([],[],[]) us
with
  accum u@(x,y,z) us	= x:(xs when xs,_,_ = check us end)&,
			  y:(ys when _,ys,_ = check us end)&,
			  z:(zs when _,_,zs = check us end)& if thunkp us;
			= x:xs,y:ys,z:zs when xs,ys,zs = check us end;
  accum u _		= throw (bad_tuple_value u);
  check us@(_,_,_)	= us;
  check (foldr _ _ us)	= throw (bad_list_value us);
  check us		= throw (bad_tuple_value us);
end;
