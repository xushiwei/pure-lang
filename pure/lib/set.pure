/* Pure's set and bag data types based on AVL trees. */

/* Copyright (c) 2008-2010 by Albert Graef <Dr.Graef@t-online.de>.
   Copyright (c) 2008-2010 by Jiri Spitz <jiri.spitz@bluetone.cz>.

   This file is part of the Pure standard library.

   The Pure standard library is free software: you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
   more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* ..

   Sets and Bags
   -------------

   The set.pure module implements Pure's ``Set`` and ``Bag`` (multiset) data
   types based on AVL trees. Set and bag elements must be ordered, i.e., the
   predicates ``==``, ``<`` and ``>`` must be defined on them. The used AVL
   tree algorithm has its origin in the SWI-Prolog implementation of
   association lists and was ported to Pure by Jiri Spitz, see Dictionaries_
   for details.

   Imports
   ~~~~~~~

   To use the operations of this module, add the following import declaration
   to your program::

     using set;

   Data Structure
   ~~~~~~~~~~~~~~

   Sets and bags are represented as balanced tree structures of the form ``Set
   T`` or ``Bag T``, respectively, thus ``Set`` and ``Bag`` may be used as
   type tags to restrict variables in pattern matching.

   The internal data structure ``T`` is an AVL tree built with the following
   constructors:

   ``nil``
     the empty tree.

   ``bin key balance left right``
     a nonempty tree with given ``key`` (set element) in the root node, where
     ``left`` and ``right`` are the left and right subtree, and ``balance`` is
     either 1, 0 or -1, denoting ``|left|-|right|`` = 1, 0, or -1,
     respectively.

   (This is for informational purposes only. The tree constructors are
   private, and client modules must not rely on the internal representation.)

   Operations
   ~~~~~~~~~~

   .. _emptyset:
   .. _emptybag:

   ``emptyset``, ``emptybag``
     return the empty set or bag

   .. _set:
   .. _bag:

   ``set xs``, ``bag xs``
     create a set or bag from a list ``xs``

   .. _setp:
   .. _bagp:

   ``setp x``, ``bagp x``
     check whether ``x`` is a set or bag

   .. _# (set):
   .. _# (bag):

   ``#m``
     size of set or bag ``m``

   .. _+ (set):
   .. _+ (bag):

   ``m1+m2``
     set and bag union: ``m1+m2`` adds the members of ``m2`` to ``m1``

   .. _- (set):
   .. _- (bag):

   ``m1-m2``
     set and bag difference: ``m1-m2`` removes the members of ``m2`` from
     ``m1``

   .. _* (set):
   .. _* (bag):

   ``m1*m2``
     set and bag intersection: ``m1*m2`` removes the members *not* in ``m2``
     from ``m1``

   .. _null (set):
   .. _null (bag):

   ``null m``
     test whether ``m`` is the empty set or bag

   .. _member (set):
   .. _member (bag):

   ``member m x``
     test whether ``m`` contains ``x``

   .. _members (set):
   .. _members (bag):
   .. _list (set):
   .. _list (bag):

   ``members m``, ``list m``
     list members of ``m`` in ascending order

   .. _first (set):
   .. _first (bag):
   .. _last (set):
   .. _last (bag):

   ``first m``, ``last m``
     return first and last member of ``m``

   .. _rmfirst (set):
   .. _rmfirst (bag):
   .. _rmlast (set):
   .. _rmlast (bag):

   ``rmfirst m``, ``rmlast m``
     remove first and last member from ``m``

   .. _insert (set):
   .. _insert (bag):

   ``insert m x``
     insert ``x`` into ``m`` (replaces an existing element in the ``set`` case)

   .. _delete (set):
   .. _delete (bag):

   ``delete m x``
     remove ``x`` from ``m`` (in the ``bag`` case, only a single instance of
     ``x`` is removed)

   Examples
   ~~~~~~~~

   Some basic set operations::

     > let m::Set = set [5,1,3,11,3];
     > members m;
     [1,3,5,11]
     > map (member m) (1..5);
     [1,0,1,0,1]
     > members $ m+set (3..6);
     [1,3,4,5,6,11]
     > members $ m-set (3..6);
     [1,11]
     > members $ m*set (3..6);
     [3,5]

   The bag operations work in a similar fashion, but note that multiple
   instances are permitted in this case, and each instance counts as a
   separate member::

     > let m::Bag = bag [5,1,3,11,3];
     > members m;
     [1,3,3,5,11]
     > members $ delete m 3;
     [1,3,5,11]
     > members $ insert m 1;
     [1,1,3,3,5,11]
     > members $ m+bag (3..6);
     [1,3,3,3,4,5,5,6,11]
     > members $ m-bag (3..6);
     [1,3,11]
     > members $ m*bag (3..6);
     [3,5]

*/

using avltrees;

// type checks
bagp _::Bag	= 1;
bagp _		= 0;

setp _::Set	= 1;
setp _		= 0;

// create an empty set
emptyset	= Set avl::emptytree;
emptybag	= Bag avl::emptytree;

// create set from a list
set xs		= foldl insert emptyset xs if listp xs;
bag xs		= foldl insert emptybag xs if listp xs;

// insert a member
insert (Set m) y = Set (avl::insert  m y);
insert (Bag m) y = Bag (avl::insertm m y);

// delete a member
delete (Set m) y = Set (avl::delete m y);
delete (Bag m) y = Bag (avl::delete m y);

// check for the empty set
null (Set m)	|
null (Bag m)	= avl::null m;

// get size
#(Set m)	|
#(Bag m)	= avl::size m;

// membership test
member (Set m) y |
member (Bag m) y = avl::member m y;

// get all members of a set as a list
members (Set m) |
members (Bag m)	= avl::members m;

list m::Set | list m::Bag = members m;

// get the first and last member
first (Set m) |
first (Bag m) = avl::first m;
last (Set m)  |
last (Bag m)  = avl::last  m;

// remove the first and last member
rmfirst (Set m) = Set (avl::rmfirst m);
rmfirst (Bag m) = Bag (avl::rmfirst m);
rmlast  (Set m) = Set (avl::rmlast  m);
rmlast  (Bag m) = Bag (avl::rmlast  m);

// comparisons
m1::Set == m2::Set	|
m1::Bag == m2::Bag	= (members m1 == members m2);

m1::Set ~= m2::Set	|
m1::Bag ~= m2::Bag	= (members m1 ~= members m2);

m1::Set <= m2::Set	= all (member m2) (members m1);
m1::Bag <= m2::Bag	= null (m1 - m2);

m1::Set >= m2::Set	= all (member m1) (members m2);
m1::Bag >= m2::Bag	= null (m2 - m1);

m1::Set < m2::Set	|
m1::Bag < m2::Bag	= m1 <= m2 && m1 ~= m2;

m1::Set > m2::Set	|
m1::Bag > m2::Bag	= m1 >= m2 && m1 ~= m2;

// set union
m1::Set + m2::Set	|
m1::Bag + m2::Bag	= foldl insert m1 (members m2);

// set difference
m1::Set - m2::Set	|
m1::Bag - m2::Bag	= foldl delete m1 (members m2);

// set intersection
m1::Set * m2::Set	|
m1::Bag * m2::Bag	= m1 -  (m1 - m2);
