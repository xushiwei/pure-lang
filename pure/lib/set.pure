/* Pure's set and bag data types based on AVL trees. */

/* Copyright (c) 2008-2010 by Albert Graef <Dr.Graef@t-online.de>.
   Copyright (c) 2008-2010 by Jiri Spitz <jiri.spitz@bluetone.cz>.

   This file is part of the Pure standard library.

   The Pure standard library is free software: you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
   more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* ..

   Sets and Bags
   -------------

   The set.pure module implements Pure's set data types based on AVL trees.
   There are four variations of this data structure to choose from, depending
   on whether the set members are ordered or hashed, and whether multiple
   instances of the same element are allowed (in this case the set is actually
   called a *multiset* or a *bag*).

   * ``Set`` and ``Bag`` implement the ordered set types. They require that
     members be ordered, i.e., the predicates ``==``, ``<`` and ``>`` must be
     defined on them.

   * ``HSet`` and ``HBag`` implement the hashed set types which don't require
     an order of the members, and thus store distinct members in an apparently
     random order.

   The underlying AVL tree data structure can be found in the avltrees.pure
   module which is included in the library, but not to be invoked directly.
   The AVL tree algorithm has its origin in the SWI-Prolog implementation of
   association lists and was ported to Pure by Jiri Spitz, see Dictionaries_
   for details.

   Imports
   ~~~~~~~

   To use the operations of this module, add the following import declaration
   to your program::

     using set;

   Data Structure
   ~~~~~~~~~~~~~~

   Sets and bags are represented as balanced tree structures of the form ``S
   T``, where ``S`` may be any of ``Set``, ``Bag``, ``HSet`` and ``HBag``.
   These constructors may be used as type tags to restrict variables in
   pattern matching.

   In any case, the internal data structure ``T`` is an AVL tree built with
   the following constructors (from the avltrees module):

   ``avl::nil``
     the empty tree.

   ``avl::bin key balance left right``
     a nonempty tree with given ``key`` (set element) in the root node, where
     ``left`` and ``right`` are the left and right subtree, and ``balance`` is
     either 1, 0 or -1, denoting ``|left|-|right|`` = 1, 0, or -1,
     respectively.

   (This is for informational purposes only. The tree constructors are
   private, and client modules must not rely on the internal representation.)

   All kinds of sets can be compared for equality and inequality (``==`` and
   ``~=``), but note that there are no implicit conversions between the
   different set types and thus the operand types must match. Ordered sets
   compare their members using the ``==`` predicate, while hashed sets check
   for syntactical equality (using ``same``). Operands in subset/subbag
   comparisons must also match up. Here it is checked that all members of one
   set/bag are contained in the other (also taking into account multiplicities
   in the bag case).

   Operations
   ~~~~~~~~~~

   .. _emptyset:
   .. _emptybag:
   .. _emptyhset:
   .. _emptyhbag:

   ``emptyset``, ``emptybag``, ``emptyhset``, ``emptyhbag``
     return an empty set or bag

   .. _set:
   .. _bag:
   .. _hset:
   .. _hbag:

   ``set xs``, ``bag xs``, ``hset xs``, ``hbag xs``
     create a set or bag of the corresponding type from a list or another set
     or bag ``xs``; in the latter case the argument is converted to a set or
     bag of the desired target type

   .. _setp:
   .. _bagp:
   .. _setp:
   .. _bagp:

   ``setp x``, ``bagp x``, ``hsetp x``, ``hbagp x``
     check whether ``x`` is a set or bag of the corresponding type

   .. _# (set):
   .. _# (bag):

   ``#m``
     size of a set or bag ``m``

   .. _null (set):
   .. _null (bag):

   ``null m``
     test whether ``m`` is an empty set or bag

   .. _member (set):
   .. _member (bag):

   ``member m x``
     test whether ``m`` contains ``x``

   .. _members (set):
   .. _members (bag):
   .. _list (set):
   .. _list (bag):

   ``members m``, ``list m``
     list the members of ``m`` (in ascending order for ordered sets and bags)

   .. _first (set):
   .. _first (bag):
   .. _last (set):
   .. _last (bag):

   ``first m``, ``last m``
     return the first and the last member of ``m``, respectively

   .. _rmfirst (set):
   .. _rmfirst (bag):
   .. _rmlast (set):
   .. _rmlast (bag):

   ``rmfirst m``, ``rmlast m``
     remove the first and the last member from ``m``, respectively

   .. _insert (set):
   .. _insert (bag):

   ``insert m x``
     insert ``x`` into ``m`` (replaces an existing element in the case of a set)

   .. _delete (set):
   .. _delete (bag):

   ``delete m x``
     remove ``x`` from ``m`` (in the ``bag`` case, only the first instance of
     ``x`` is removed)

   .. _delete_all (set):
   .. _delete_all (bag):

   ``delete_all m x``
     remove all instances of ``x`` from ``m`` (in the set case, this is just
     the same as ``delete``)

   In addition, the infix operators ``+``, ``-`` and ``*`` are defined as
   set/bag union, difference and intersection. Please note that there are no
   implicit conversions, so the operand types must match exactly. (As already
   mentioned, the same restriction applies to the comparison predicates
   ``==``, ``<=`` etc.)

   .. _+ (set):
   .. _+ (bag):

   ``m1+m2``
     set and bag union: ``m1+m2`` adds the members of ``m2`` to ``m1``

   .. _- (set):
   .. _- (bag):

   ``m1-m2``
     set and bag difference: ``m1-m2`` removes the members of ``m2`` from
     ``m1``

   .. _* (set):
   .. _* (bag):

   ``m1*m2``
     set and bag intersection: ``m1*m2`` removes the members *not* in ``m2``
     from ``m1``

   Examples
   ~~~~~~~~

   Some basic set operations::

     > let m::Set = set [5,1,3,11,3];
     > members m;
     [1,3,5,11]
     > map (member m) (1..5);
     [1,0,1,0,1]
     > members $ m+set (3..6);
     [1,3,4,5,6,11]
     > members $ m-set (3..6);
     [1,11]
     > members $ m*set (3..6);
     [3,5]

   The bag operations work in a similar fashion, but multiple instances are
   permitted in this case, and each instance counts as a separate member::

     > let m::Bag = bag [5,1,3,11,3];
     > members m;
     [1,3,3,5,11]
     > members $ delete m 3;
     [1,3,5,11]
     > members $ insert m 1;
     [1,1,3,3,5,11]
     > members $ m+bag (3..6);
     [1,3,3,3,4,5,5,6,11]
     > members $ m-bag (3..6);
     [1,3,11]
     > members $ m*bag (3..6);
     [3,5]

   As already mentioned, operands in set/bag unions, differences and
   intersections as well as the comparison operators must match. If necessary,
   one of the operands can be converted to the desired target type using a
   combination of ``members`` and the corresponding construction function.
   E.g., here's how you can add a set to a bag, yielding a bag::

     > let m1::Bag = bag [5,1,3,11,3];
     > let m2::Set = set (3..6);
     > let m::Bag = m1+bag m2;
     > members m;
     [1,3,3,3,4,5,5,6,11]

   If set members aren't ordered, hashed sets and bags must be used. These
   work analogously, but distinct members are stored in an apparently random
   order::

     > members $ hset [a,b,c] * hset [c,d,e];
     [c]
     > members $ hbag [a,b,c] + hbag [c,d,e];
     [a,c,c,b,d,e]

*/

using avltrees;

// type checks
setp _::Set	= 1;
setp _		= 0;

bagp _::Bag	= 1;
bagp _		= 0;

hsetp _::HSet	= 1;
hsetp _		= 0;

hbagp _::HBag	= 1;
hbagp _		= 0;

// create an empty set
emptyset	= Set  avl::emptytree;
emptybag	= Bag  avl::emptytree;
emptyhset	= HSet avl::emptytree;
emptyhbag	= HBag avl::emptytree;

// conversions between the different set types
set  m::Set | hset m::HSet | bag  m::Bag  | hbag m::HBag = m;
set  m::Bag | set  m::HSet | set  m::HBag = set  (members m);
hset m::Set | hset m::Bag  | hset m::HBag = hset (members m);
bag  m::Set | bag  m::HSet | bag  m::HBag = bag  (members m);
hbag m::Set | hbag m::Bag  | hbag m::HSet = hbag (members m);

// create set from a list
set  xs		= foldl insert emptyset  xs if listp xs;
bag  xs		= foldl insert emptybag  xs if listp xs;
hset xs		= foldl insert emptyhset xs if listp xs;
hbag xs		= foldl insert emptyhbag xs if listp xs;

// insert a member
insert (Set  m) y = Set  (avl::insert   m y);
insert (Bag  m) y = Bag  (avl::minsert  m y);
insert (HSet m) y = HSet (avl::hinsert  m y);
insert (HBag m) y = HBag (avl::mhinsert m y);

// delete a member
delete (Set  m) y = Set  (avl::delete   m y);
delete (Bag  m) y = Bag  (avl::mdelete  m y);
delete (HSet m) y = HSet (avl::hdelete  m y);
delete (HBag m) y = HBag (avl::mhdelete m y);

// delete all instances of a given member
delete_all (Set  m) y = Set  (avl::delete    m y);
delete_all (Bag  m) y = Bag  (avl::mdeletea  m y);
delete_all (HSet m) y = HSet (avl::hdelete   m y);
delete_all (HBag m) y = HBag (avl::mhdeletea m y);

// check for the empty set
null (Set  m) | null (Bag  m) |
null (HSet m) | null (HBag m) = avl::null m;

// get size
#(Set  m) = avl::size  m;
#(Bag  m) = avl::msize m;
#(HSet m) = avl::hsize m;
#(HBag m) = avl::hsize m;

// membership test
member (Set  m) y = avl::member  m y;
member (Bag  m) y = avl::memberk m y;
member (HSet m) y = avl::hmember m y;
member (HBag m) y = avl::hmember m y;

// get all members of a set as a list
members (Set  m) = avl::members  m;
members (Bag  m) = avl::mmembers m;
members (HSet m) = avl::hmembers m;
members (HBag m) = avl::hmembers m;

list m::Set  | list m::Bag  |
list m::HSet | list m::HBag = members m;

// get the first and last member
first (Set  m) = avl::first  m;
first (Bag  m) = avl::mfirst m;
last  (Set  m) = avl::last   m;
last  (Bag  m) = avl::mlast  m;
first (HSet m) = avl::hfirst m;
first (HBag m) = avl::hfirst m;
last  (HSet m) = avl::hlast  m;
last  (HBag m) = avl::hlast  m;

// remove the first and last member
rmfirst (Set  m) = Set  (avl::rmfirst  m);
rmfirst (Bag  m) = Bag  (avl::mrmfirst m);
rmlast  (Set  m) = Set  (avl::rmlast   m);
rmlast  (Bag  m) = Bag  (avl::mrmlast  m);
rmfirst (HSet m) = HSet (avl::hrmfirst m);
rmfirst (HBag m) = HBag (avl::hrmfirst m);
rmlast  (HSet m) = HSet (avl::hrmlast  m);
rmlast  (HBag m) = HBag (avl::hrmlast  m);

// comparisons
m1::Set  == m2::Set  | m1::Bag  == m2::Bag  = members m1 == members m2;
m1::HSet == m2::HSet | m1::HBag == m2::HBag = m1 <= m2 && m2 <= m1;

m1::Set  ~= m2::Set  | m1::Bag  ~= m2::Bag  = members m1 ~= members m2;
m1::HSet ~= m2::HSet | m1::HBag ~= m2::HBag = ~(m1 == m2);

m1::Set  <= m2::Set  | m1::HSet <= m2::HSet = all (member m2) (members m1);
m1::Bag  <= m2::Bag  | m1::HBag <= m2::HBag = null (m1 - m2);

m1::Set  >= m2::Set  | m1::HSet >= m2::HSet = all (member m1) (members m2);
m1::Bag  >= m2::Bag  | m1::HBag >= m2::HBag = null (m2 - m1);

m1::Set  <  m2::Set  | m1::Bag  <  m2::Bag  |
m1::HSet <  m2::HSet | m1::HBag <  m2::HBag = m1 <= m2 && ~(m1 >= m2);

m1::Set  >  m2::Set  | m1::Bag  >  m2::Bag  |
m1::HSet >  m2::HSet | m1::HBag >  m2::HBag = m1 >= m2 && ~(m1 <= m2);

// set union
m1::Set  + m2::Set  | m1::Bag  + m2::Bag  |
m1::HSet + m2::HSet | m1::HBag + m2::HBag = foldl insert m1 (members m2);

// set difference
m1::Set  - m2::Set  | m1::Bag  - m2::Bag  |
m1::HSet - m2::HSet | m1::HBag - m2::HBag = foldl delete m1 (members m2);

// set intersection
m1::Set  * m2::Set  | m1::Bag  * m2::Bag  |
m1::HSet * m2::HSet | m1::HBag * m2::HBag = m1 - (m1 - m2);
