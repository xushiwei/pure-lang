
/* TeXmacs support module 2012-10-18 AG. */

/* Copyright (c) 2012 Albert Graef

   Copying and distribution of this file, with or without modification,
   are permitted in any medium without royalty provided the copyright
   notice and this notice are preserved.  This file is offered as-is,
   without any warranty. */

/* Some auxiliary definitions for use with Pure in TeXmacs. This gets loaded
   automatically if you run the Pure scripting plugin (Document|Scripts|Pure).
   Inside a Pure session, you can invoke this module with `using texmacs;`. */

// Additional operators provided by TeXmacs.
infixl (+) oplus ominus pm mp cup uplus;
infixl (*) otimes oslash div cap;

// Sum and product (used by the big operators in TeXmacs).
sum xs::list = foldl (+) 0 xs;
prod xs::list = foldl (*) 1 xs;

/* These rules bring some TeXmacs constructs into a form which can be readily
   processed with Reduce. */

// Limits. Simple change of argument order.
public limit;
lim v l x = limit x v l;

/* Differentials. Expands d f/d x and variants (d k f/d x k etc.) to the
   df f x ... form used by Reduce. NOTE: Multiple differentials may be
   specified in a single expression, but the orders of the differentials must
   be integer constants; for differentials of variable order you'll have to
   use the df operator in a direct fashion. */

public d df bad_diff;
d f/d x = df f x;
d f/y = d f 1/y;
f/d x = f/d x 1;
d k::int f/d x l::int = df f x k if k==l && k>=0;
f/(y*d x) = f/(y*d x 1);
d k::int f/(y*d x l::int) = (d (k-l) f/y) x l if k>=l && l>=0;
x@(d _ _)/y | x/y@(d _ _) = throw (bad_diff ('(x/y))) otherwise;

/* The ? convenience macro simplifies an expression using Reduce. To make
   this work, you'll also have to import the reduce module. This isn't done
   here so that this module also works without having the pure-reduce package
   installed.

   ? passes the argument as a quoted expression and automatically applies the
   necessary massaging of limits and differentials, see above. ?: does the
   same but evaluates its argument. We also define these as functions, so that
   they can be passed around as function arguments if needed, but note that in
   this case ? looses its call-by-name argument processing.

   These operators are at the lowest possible precendence so that their
   arguments don't have to be parenthesized (but applications of ?  and ?:
   must be parenthesized when used in any larger context). */

prefix 0 ? ?: ;
public simplify preproc;
def ? x = simplify (preproc ('x));
def ?:x = simplify (preproc x);

? x = ? x;
?:x = ?:x;

// Local rule set to expand lim and d f/d x in a safe fashion, without
// evaluating the argument expression.
preproc = reduce with
  lim v l x = limit x v l;
  d f/d x = df f x;
  d f/y = d f 1/y;
  f/d x = f/d x 1;
  d k::int f/d x l::int = df f x k if k==l && k>=0;
  f/(y*d x) = f/(y*d x 1);
  d k::int f/(y*d x l::int) = (d (k-l) f/y) x l if k>=l && l>=0;
  x@(d _ _)/y | x/y@(d _ _) = throw (bad_diff ('(x/y))) otherwise;
end;

/* LaTeX pretty-printing using the tmprint package of Reduce. Thanks are due
   to Kurt Pagani who figured out the necessary Lisp magic to make that work.
   You enable this with a call to the parameterless `math` function;
   `verbatim` switches back to program mode again. This also starts up Reduce
   in a lazy fashion when `math` is invoked, so that we avoid depending on the
   pure-reduce package. Note, however, that pure-reduce *is* required to make
   the pretty-printing work. */

// Enable this pragma to enable math mode by default.
//#! --enable tmmath

let tminit = ref false;
let tmmode = ref false;

namespace reduce with
  public capture output load;
end;

tmstart = () when
  eval "using reduce;";
  reduce::capture 1;
  reduce::load "tmprint";
  reduce::capture 0;
  put tminit true;
end if ~get tminit;

public lisp lispval lispsym;

tmprint x = s when
  tmstart;
  x = lispval x;
  lisp (lispsym "fancy-output" (''maprin) ('aeval ('x)));
  reduce::capture 1;
  lisp (lispsym "fancy-flush");
  reduce::capture 0;
  s = reduce::output;
  // For some reason tmprint prepends a newline to all but the first
  // invocation. Get rid of that here.
  s = strip s with
    strip s::string = tail s if ~null s && s!0=="\n";
    strip s = s;
  end;
end;

// Switch between math and verbatim output.
math = tmstart $$ put tmmode true;
verbatim = put tmmode false;

// Pretty-printing routine for Pure's --texmacs mode.
__texmacs__ x = tmprint x if get tmmode;

#! --ifndef tmmath
#! --disable tmmath
#! --endif
#! --if tmmath
math;
#! --endif
