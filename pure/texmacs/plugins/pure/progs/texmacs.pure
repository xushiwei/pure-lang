
/* texmacs support module 2012-10-18 Albert Graef <Dr.Graef@t-online.de>. */

/* Copyright (c) 2012 Albert Graef

   Copying and distribution of this file, with or without modification,
   are permitted in any medium without royalty provided the copyright
   notice and this notice are preserved.  This file is offered as-is,
   without any warranty. */

/* Some auxiliary definitions for use with Pure in TeXmacs. This gets loaded
   automatically if you run the Pure scripting plugin (Document|Scripts|Pure).
   Inside a Pure session, you can invoke this module with `using texmacs;`. */

// Additional operators provided by TeXmacs.
infixl (+) oplus ominus pm mp cup uplus;
infixl (*) otimes oslash div cap;

// Sum and product (used by the big operators in TeXmacs).
sum xs::list = foldl (+) 0 xs;
prod xs::list = foldl (*) 1 xs;

/* These rules bring some TeXmacs constructs into a form which can be readily
   processed with Reduce. */

// Limits. Simple change of argument order.
public limit;
lim v l x = limit x v l;

/* Differentials. Expands d f/d x and variants (d k f/d x k etc.) to the
   df f x ... form used by Reduce. NOTE: Multiple differentials may be
   specified in a single expression, but the orders of the differentials must
   be integer constants; for differentials of variable order you'll have to
   use the df operator in a direct fashion. */

public d df bad_diff;
d f/d x = df f x;
d f/y = d f 1/y;
f/d x = f/d x 1;
d k::int f/d x l::int = df f x k if k==l && k>=0;
f/(y*d x) = f/(y*d x 1);
d k::int f/(y*d x l::int) = (d (k-l) f/y) x l if k>=l && l>=0;
x@(d _ _)/y | x/y@(d _ _) = throw (bad_diff ('(x/y))) otherwise;

/* The ? convenience macro simplifies an expression using Reduce. To make
   this work, you'll also have to import the reduce module. This isn't done
   here so that this module also works without having the pure-reduce package
   installed.

   ? passes the argument as a quoted expression and automatically applies the
   necessary massaging of limits and differentials, see above. ?: does the
   same but evaluates its argument. We also define these as functions, so that
   they can be passed around as function arguments if needed, but note that in
   this case ? looses its call-by-name argument processing.

   These operators are at the lowest possible precendence so that their
   arguments don't have to be parenthesized (but applications of ?  and ?:
   must be parenthesized when used in any larger context). */

prefix 0 ? ?: ;
public simplify preproc;
def ? x = simplify (preproc ('x));
def ?:x = simplify (preproc x);

? x = ? x;
?:x = ?:x;

// Local rule set to expand lim and d f/d x in a safe fashion, without
// evaluating the argument expression.
preproc = reduce with
  lim v l x = limit x v l;
  d f/d x = df f x;
  d f/y = d f 1/y;
  f/d x = f/d x 1;
  d k::int f/d x l::int = df f x k if k==l && k>=0;
  f/(y*d x) = f/(y*d x 1);
  d k::int f/(y*d x l::int) = (d (k-l) f/y) x l if k>=l && l>=0;
  x@(d _ _)/y | x/y@(d _ _) = throw (bad_diff ('(x/y))) otherwise;
end;

/* LaTeX pretty-printing using the tmprint package of Reduce. Thanks are due
   to Kurt Pagani who figured out the necessary Lisp magic to make that work.
   You enable this with a call to the parameterless `math` function;
   `verbatim` switches back to program mode again. This also starts up Reduce
   in a lazy fashion when `math` is invoked, so that we avoid depending on the
   pure-reduce package. Note, however, that pure-reduce *is* required to make
   the pretty-printing work. */

// Enable this pragma to enable math mode by default.
//#! --enable tmmath

let tminit, tmmode = ref false, ref false;
let texmacs_valid_fun, texmacs_post_fun = ref (), ref ();

public texmacs_valid texmacs_post;
namespace reduce with
  public capture output load pure_syms;
end;

tmstart = () when
  // The externals are in the reduce module.
  eval "using reduce;\
extern int texmacs_valid(char *s);\
extern char *texmacs_post(char *s);";
  put texmacs_valid_fun (eval "texmacs_valid");
  put texmacs_post_fun (eval "texmacs_post");
  reduce::capture 1;
  reduce::load "tmprint";
  reduce::capture 0;
  put tminit true;
end if ~get tminit;

public lisp lispval lispsym;

/* NOTE: This recursively descends into the (already simplified) term to see
   whether it's actually printable. tmprint chokes on strings (wants them to
   be symbols) and of course doesn't know about C pointers, closures and
   similar special Pure objects, so we exclude them here, also any operator
   symbols which are not in the reduce::pure_syms table.

   If the check fails on this expression, Pure's pretty printer will invoke us
   again on its subterms so that parts of the expression may still be rendered
   in LaTeX mode. This shouldn't normally be a problem unless the terms become
   prohibitively large, in which case you can disable the `recurse`
   compilation option below to prevent the recursion. */

//#! --disable recurse

tmprint x = s when
  tmstart;
  x = lispval x;
  lisp (lispsym "fancy-output" (''maprin) ('aeval ('x)));
  reduce::capture 1;
  lisp (lispsym "fancy-flush");
  reduce::capture 0;
  s = reduce::output;
  // There's still have some postprocessing to do...
  s = get texmacs_post_fun s;
end if printable x when
  /* We need to simplify first (even though tmprint will do it anyway), in
     order to decide whether the expression is printable. However, if the
     original expression doesn't look printable already, simplify itself will
     probably choke on it as well (the typical symptom are spurious "operator
     declared" messages), so we give up right away in this case. */
  x = if printable x then simplify x else "no";
end with
  printable x::number = true;
  printable x::list |
  printable x::matrix = all printable x;
  printable (x@_ y) = printable x && printable y;
  printable x::symbol = get texmacs_valid_fun (str x) ||
    member reduce::pure_syms x;
  printable _ = false;
end;
#! --ifnot recurse
tmprint x = str x;
#! --endif

// Switch between math and verbatim output.
math = tmstart $$ put tmmode true;
verbatim = put tmmode false;

// Pretty-printing routine for Pure's --texmacs mode.
__texmacs__ x = tmprint x if get tmmode;

#! --ifndef tmmath
#! --disable tmmath
#! --endif
#! --if tmmath
math;
#! --endif
