
** Pure 0.34 (in progress)

This release sports some additional fixes for various compilation quirks
reported by Roman Neuhauser. Moreover, the pure_interp_compile() routine in
the runtime library was beefed up to better support realtime modules such as
pd-pure. (This required a bump of the runtime library version, so you'll have
to recompile addon modules once again, sorry for the hassle.)

** Pure 0.33 2009-08-28

Another bugfix release. This one fixes some more incompatibilities with latest
LLVM revisions and some failed LLVM assertions hit by the overhauled version
of the batch compiler if LLVM was compiled with --enable-assertions. Moreover,
the linkage options were massaged a bit, reportedly they work better with
FreeBSD and FC12 now.

Emacs Pure mode now provides sensible defaults for the location of the Pure
interpreter executable and the library directory if PATH and/or the PURELIB
environment variable are set accordingly. This makes it easier to install Pure
mode on Windows, as you don't have to edit the file any more if you want to
use it with the Pure MSI package.

Thanks are due to Roman Neuhauser for helping to sort out the issues
preventing Pure to work on FreeBSD.

** Pure 0.32 2009-08-27

This release fixes the performance issues with the batch compiler on the
latest LLVM versions in svn, and the source was updated once more to make it
compile with the latest LLVM revision. Also, 'pure --version' now prints the
LLVM version the interpreter was compiled with. The test system was revised so
that 'make check' returns a proper error code now. Emacs Pure mode was
overhauled as well. The new mode is derived from fundamental mode and the
broken auto-indentation stuff was removed.

** Pure 0.31 2009-08-24

This release brings support for LLVM 2.6+ and some further improvements in the
parser and the batch compiler, please see the ChangeLog for details.

** Pure 0.30 2009-08-22

This release sports a new -s option for the batch compiler which strips unused
functions from the generated code. This considerably reduces both compilation
times and code size (especially if the program imports huge libraries such as
pure-gtk). However, note that the batch compiler only does a static analysis
of which functions can be reached from the initialization code, so you have to
be careful if your program uses 'eval', 'evalcmd' or 'val'.

** Pure 0.29 2009-08-20

Another bugfix release. This one fixes some Windows-related issues (see the
ChangeLog for details) and a bug in the 'clear ans' command which prevented
the 'ans' value from being garbage-collected. Moreover, sentries can now
be placed also on symbols and function objects.

** Pure 0.28 2009-08-16

This release fixes an annoying bug in the new operator precedence parser.
Also, namespace settings now stick when running a script interactively or
sourcing the interactive initialization files, as suggested by Max Wolf.

In addition, various useful process and I/O-related functions were added to
the system module and the following new primitives are now available in the
prelude (see the library manual for details):

- The 'reduce' macro enables you to implement local rewriting rules. See
  examples/rules.pure for an example.

- The 'blob' and 'val' functions provide for safe expression serialization.
  See examples/fork.pure for an example.

** Pure 0.27 2009-08-09

This is a bugfix release which cleans up some of the mess in qualid/type tag
resolution left behind by the changes in the namespace system and the addition
of user-defined type tags in the 0.26 release. In particular, it fixes a
critical bug in the lexer which caused any global qualid of the form ::foo to
be mistaken for a type tag. Also, it is now also possible to specify a qualid
as a type tag.

** Pure 0.26 2009-08-07

This started out as a mere bugfix release, but then it became much more. A
bunch of bugs were fixed, some implementation restrictions were removed, and
some interesting new features were implemented. (This also required some
changes in the internal runtime API, so existing modules have to be
recompiled.)

You can find the most important fixes and improvements in this release
below. As usual, please see the ChangeLog for details.

- As suggested by John Cowan, the 'nullary' keyword has been replaced with
  'nonfix', which is more in line with the other fixity keywords. Existing
  Pure scripts should be edited accordingly. For the time being, 'nullary'
  still works as a synonym for 'nonfix', but the compiler warns that it is
  deprecated.

- The expression parser went through a major overhaul so that it essentially
  supports an unlimited number of precedence levels now. (The implementation
  still imposes a limit, but it's very large.) The standard operator system
  has been overhauled as well, so that it becomes much easier to sneak in
  additional levels. There are now 20 standard precedence levels which are
  numbered from 1000 to 2900, see prelude.pure for details. The relative
  priorities aren't changed, so most existing scripts should be unaffected,
  but of course you may have to adjust the precedences of your own operator
  declarations accordingly.

- The code generated for numeric and string list/tuple/matrix constants has
  been improved a lot. This speeds up compilation and enables the interpreter
  to handle much bigger constant aggregates of these types than before.

- Values used in constant definitions and 'eval' calls may now contain
  arbitrary run time data. Thus you can now write stuff like 'const x = malloc
  10;' or 'const y = \x->x*x;'. (This only works in interpreted scripts, the
  batch compiler still forbids run time data in constants.)

- Tail call elimination now works in batch-compiled scripts.

In addition, the following new features have been implemented (please see the
manual for details):

- Added support for Miranda/Haskell-style operator sections. Thus you can now
  write '(x+)' for '(+) x' and '(+x)' for 'flip (+) x', respectively.

- Added support for 'outfix' operators which let you declare unary operators
  in the form of pairs of custom bracket symbols, such as: 'outfix BEGIN END;'.
  These have been adopted from Wm Leler's Bertrand language.

- Added support for hierarchical namespaces (suggested by Max Wolf). Also,
  qualified module names are now permitted in 'using' clauses and will be
  translated to corresponding pathnames, as suggested by Eddie Rucker.

- Added the notation 'x::bar', where 'bar' must be a known function identifier
  or nonfix symbol, as a shorthand for the "as" pattern 'x@(bar _)'. This is
  convenient with special data types (like the dictionaries and sets in the
  standard library) which are represented using their own unary data
  constructors.

- Added readdir function to the system module (constributed by Jiri Spitz).

Many thanks to all who reported bugs and suggested improvements!

** Pure 0.25 2009-06-19

The biggest change in this release is that in the C interface, 'long' now
denotes a real C long int (whose size usually depends on the architecture),
instead of always assuming 64 bit integers. This makes it easier to interface
to C functions involving such values. Real 64 bit integers are now denoted
'int64', and 'int8/int16/int32' are provided as synonyms for the
'char/short/int' types. Affected bits and pieces in the standard library were
fixed to accommodate these changes, see the ChangeLog for details.

Unfortunately, this also required changes which break backward compatibility
in the runtime library, so existing addon modules must be recompiled as
well. Moreover, the following addons have been updated, so you should make
sure that you run the latest releases of these (required versions are
indicated): pure-ffi (0.6), pure-gen (0.6), pure-gl (0.6), pure-gtk (0.3),
pure-odbc (0.3).

In addition, there is a new 'ans' function to retrieve the most recent result
printed on the interactive command line. Some minor bugs that crept into the
0.23/0.24 releases were fixed as well. Please see the ChangeLog for details.

** Pure 0.24 2009-05-30

This is a maintenance release featuring some additions and cosmetic changes in
the runtime API (as requested by John Cowan), and an overhaul of arithmetic
sequences of double values (these now round the upper bound to the nearest
grid point, in order to prevent rounding artifacts, as reported by Eddie
Rucker).

** Pure 0.23 2009-05-27

This release features various bugfixes and optimizations in interpreter and
library, see the ChangeLog for details. Also, support for quoted expressions
was improved in various ways. In particular, please note the following
user-visible changes:

- Matrix transposition is now a function, transpose x. (The single quote is
  now used for quoting expressions, see below.)

- 'x is provided as a synonym for quote x. Moreover, macro and constant
  substitution is now inhibited in quoted subterms. (OTOH, special constructs
  and local variables inside quoted expressions are still evaluated as usual.
  Please see the new subsection "The Quote" of the "Caveats and Notes" section
  in the manual for details.)

- For a symbolic matrix x, 'x now inhibits the implicit splicing of nested
  submatrices. Symbolic matrices with nested submatrices are now printed in
  quoted form, so that they can be reconstructed from their textual
  representation.

- Two new (and much improved) alternative implementations of Lisp-like
  quasiquote are available. These are now provided as separate library
  modules. Please note that these are still considered experimental right now.

Also, as suggested by John Cowan, the BROWSER environment variable is now used
by the interpreter to determine the help browser if PURE_HELP is not set. See
http://www.catb.org/~esr/BROWSER/.

Finally note that the runtime library number was bumped to 1.0, so addon
modules need to be recompiled for the new version.

** Pure 0.22 2009-04-03

The interpreter now provides a simple symbolic debugger in interactive mode.
To enable this, it must be invoked with the new -g option. (Please note that
this will make your scripts run *much* slower and thus should be used only to
run the debugger.) Please see section "Debugging" in the Pure Manual for
details.

** Pure 0.21 2009-03-29

This release sports some changes in the build system to make things easier for
package maintainers, and the addition of a batch compiler which allows you to
compile Pure scripts to native executables. See below for details.

Build System
------------

In preparation for the 1.0 release, the Pure runtime library now uses a proper
major.minor versioning scheme, which is independent from the interpreter
version.

Moreover, "versioned" installs (i.e., parallel installations of different Pure
versions) are now disabled by default. We decided to do this because versioned
installs presented a real headache to package maintainers. You can still do a
versioned install by running configure with the --enable-versioned option. It
is also possible to have versioned and unversioned installations coexist if
they live under different install prefixes, please see the INSTALL file for
details.

*IMPORTANT:* Because of the different installation layout, you should
uninstall any earlier Pure version before installing this release.

Also, if you're compiling from svn sources, please make sure that you rerun
configure before building the new version. You should do that anyway when
installing a new version, but it's really essential this time. :)

Batch Compiler
--------------

The interpreter now offers an experimental batch compilation option -c to
translate scripts to native executables or object files. For instance,

	pure -c foo.pure -o foo

creates the executable 'foo' from the script 'foo.pure', after executing the
script as usual. This requires the *full* LLVM toolchain (including llvmc,
llvm-gcc, etc.) to work, see the INSTALL file which now also has instructions
on how to build llvm-gcc.

You can also use a command like 'pure -c foo.pure -o foo.o' to create a native
object file which can then be linked into other C/C++ programs or libraries.

For utmost flexibility, 'pure -c foo.pure -o foo.ll' allows you to create an
LLVM assembler (.ll) file. This can then be handed over to the LLVM tools,
e.g., to apply special kinds of program transformations and optimizations,
before finally compiling and linking the native executable or library.

Note that even when batch-compiling, the compiled program is executed as
usual. This is necessary because some parts of a Pure program (in particular,
'eval' as well as 'const' definitions) may be used to modify the program at
compile time, possibly depending on previous evaluations of other expressions.
There's a new system variable 'compiling' which gives the program an
indication whether it is running under the auspices of the batch compiler, so
that it can adjust accordingly. This also enables you to play with advanced
program optimization techniques such as partial evaluation
(http://en.wikipedia.org/wiki/Partial_evaluation).

Also note that the compiled executable is essentially a static snapshot of
your program at the end of the compile time execution, which is then executed
on the "bare metal", without a hosting interpreter. Only a minimal runtime
system is provided. This considerably reduces startup times and makes it
possible to deploy the executable (along with the runtime library) on systems
without a Pure installation, but also implies some limitations, mostly
concerning the use of the built-in 'eval' function.

Please see the manual for details. In particular, have a look at
pure.html#compiling-scripts and pure.html#batch-compilation to get started
with this useful new feature.

** Pure 0.20 2009-03-19

This is a bugfix release. Most notably, two unrelated bugs in pattern matching
code were fixed, please see the ChangeLog for details.

** Pure 0.19 2009-03-14

This release brings a completely revamped online documentation system ('help'
command), which now uses documentation in html format (generated with
docutils, see http://docutils.sf.net/) and an external web browser (w3m by
default, http://w3m.sf.net/) to read the documentation. The Pure manual has
been converted, and fairly extensive library documentation is now also
available. (This was generated from the library sources, using the new
pure-doc utility which is now available as a separate package.)

The other major advance is the integration of Scott E. Dillard's optimized
list-style matrix operations (map, foldl et al), which have been living on a
separate branch for a while already, and have now been merged back into the
trunk. These are *much* faster (usually an order of magnitude or more) than
the previous implementation which employed the corresponding list functions to
realize these operations.

List and matrix comprehensions have also been optimized to fully take
advantage of the new operations. This is most noticeable with matrix
comprehensions, but list comprehensions should be faster as well. Moreover,
matrix comprehensions drawing values from other matrices now preserve the
block layout of component matrices, see the ChangeLog and the manual for
details.

Special thanks are due to Scott Dillard for his substantial contributions
which, besides the new matrix operations, also include the OpenGL bindings and
his OpenGL bindings generator which became the new pure-gen utility.

** Pure 0.18 2009-02-22

Besides some bugfixes, fixes in the build system and some refactoring of the
standard library (e.g., malloc and friends are now in primitives.pure), this
release adds a getopt module (ported from Q) and marshalling of matrices to
short*, int*, float*, double* and void* arguments in the C interface.
Moreover, the language now permits 'public' and 'private' in an 'extern'
declaration. As usual, please check the ChangeLog for details.

** Pure 0.17 2009-01-30

This release features several minor bugfixes and a few changes and additions
in the library, please see the ChangeLog for details. Also, a severe
performance issue with the creation of symbolic matrices (reported by Scott
E. Dillard) was fixed.

** Pure 0.16 2009-01-12

Yet another bugfix release. Fixes a critical bug reported by Vili Aapro which
caused generation of wrong pattern-matching tables in some cases. Also adds
some missing and corrects some existing definitions in the prelude, and fixes
some quirks with the Makefile. Last but not least, the sources now compile
cleanly with Bison 2.4 and the forthcoming LLVM 2.5 (svn). As usual, the gory
details can be found in the ChangeLog.

** Pure 0.15 2008-12-16

Another bugfix release. Moreover, local definitions (when, with) may now span
the right-hand side and the guard of a rule. Thus local definitions like in
'foo x = bar y if y>0 when y = baz x end;' now apply to both the rhs and the
guard. Clauses can still be made local to the guard by placing parentheses.
Please see the manual for details.

** Pure 0.14 2008-11-21

This release features support for the recently released LLVM 2.4, as well as
some minor changes in the Unicode support and the C interface, see the
ChangeLog for details. The biggest change in this release is the new support
for namespaces, which is based on John Cowan's proposal on the mailing
list. This encompasses the following language changes:

- New 'public' keyword to explicitly declare public symbols. (This is still
  the default for all special symbol declarations, such as 'nullary' or
  'infix'.)

- New 'namespace' keyword which serves to declare and use namespaces. Please
  refer to the manual for details. Briefly, you create a new namespace with
  a declaration of the form 'namespace <identifier>;' and then declare the
  symbols which should belong to the namespace. For instance:

  namespace foo;
  public foo bar; // 'foo' and 'bar' are public symbols in namespace 'foo'
  foo x = x-1;
  bar x = x+1;
  // ...
  namespace; // switches back to the default namespace

  The 'namespace' declaration affects *all* symbols in subsequent symbol
  declarations, including 'extern' declarations. For instance:

  namespace foo;
  extern double sin(double);
  foo::sin(0.1);

- New qualified symbol syntax: foo::bar. This gives you access to the (public)
  symbols in a namespace, and works with both ordinary identifiers and special
  (nullary and operator) symbols. The namespace must first be introduced with
  a 'namespace' or 'using namespace' declaration (see above for the former,
  and below for the latter).

- New 'using namespace' declaration. This gives you access to the (public)
  symbols in the given namespace(s) without proper qualification. For
  instance:

  using namespace foo; // opens the namespace 'foo' for searching
  foo (bar x); // 'foo' and 'bar' resolve to 'foo::foo' and 'foo::bar' here
  using namespace; // closes the search namespace(s)
  foo (bar x); // 'foo' and 'bar' are symbols in the default namespace here

  The interpreter first searches the current namespace (as specified with the
  'namespace' declaration), then the search namespaces specified in the most
  recent 'using namespace' clause, and finally the default namespace. Note
  that 'private' symbols are only visible in the *current* namespace, see
  below for more details on this.

- Private symbols are now limited in scope to a namespace, not a source file.
  To create and use private symbols, a namespace declaration has to be in
  effect. You'll have to adapt existing scripts accordingly. For instance:

  namespace foo;
  private baz; // 'baz' is a private symbol in namespace 'foo'
  baz x = 2*x;
  // ...
  namespace;   // 'baz' is now invisible

** Pure 0.13 2008-11-04

This release sports a lot of minor bugfixes and other cosmetic changes, see
the ChangeLog for details.

In addition, please note the following language and library changes, as
discussed on the mailing list. Special thanks are due to John Cowan, Eddie
Rucker and Max Wolf for bringing these up and helping to get them sorted out.

- Allow 'const nullary' symbols which can be matched, e.g., in 'case'
  expressions just like a real 'nullary' symbol.

- Swapped '~' and 'not', so that the logical and bitwise operations are now
  more consistently named ~, &&, || and not/and/or, respectively.
  Consequently, '!=' and '!==' were also renamed to '~=' and '~==',
  respectively. Note that previously ~ was used for bitwise and 'not' for
  logical negation, which was rather confusing, albeit compatible with the
  naming of the 'not' operation in Haskell and ML.

- Improved Unicode support. As proposed by John Cowan, extended characters in
  operator symbols are now restricted to symbols U+00A1 through U+00BF,
  U+00D7, U+00F7 and U+2100 through U+2BFF. All other Unicode characters are
  now usable in ordinary identifiers just like any ASCII letter, which permits
  writing Pure programs in almost any language.

Last but not least, Eddie Rucker contributed Pure syntax highlighting for GNU
nano (http://www.nano-editor.org). Thanks Eddie!

** Pure 0.12 2008-10-09

Another step on the road to Pure 1.0.

- Cosmetic syntax change: Allow the lhs to be omitted in simple rules ('when',
  'let' etc.) if it is just '_'. This lets you write stuff like, e.g.,
  'foo x = y when y = ...; puts y; end', which is useful for debugging
  purposes. Also, 'let x;' provides an alternative to just 'x;' at the
  toplevel, which suppresses printing the result of x.

- New Lisp-like 'quote' builtin (special form) for quoting expressions.
  Added a Lisp-like 'quasiquote' to the prelude (see examples/quasiquote.pure
  for an example).

- 'eval' can now evaluate expressions as well as strings. Also added a new
  'evalcmd' primitive for executing interactive interpreter commands like
  'clear' and 'show' (see examples/reflection.pure for an example).

- Overhauled the 'clear', 'dump' and 'show' commands so that they take the
  same basic set of selection options and work in a consistent fashion now.

- For all practical purposes, the number of definition levels is unlimited
  now (previous limit was 256).

** Pure 0.11 2008-10-06

This release sports some minor bugfixes as well as a few changes in the
language as detailed below.

- The old [x;...] list comprehension syntax has been removed (this has already
been deprecated since Pure 0.7.)

- The grammar was changed to allow arbitrary expressions as guards in
equations. This means that syntax like 'foo x = bar x if y when y = baz x
end' is now recognized (previously you had to enclose the 'y when ... end'
term in parentheses).

- There's direct support for empty lists and tuples in the grammar now, so
that these are treated in the same way as empty matrices, rather than being
defined as nullary symbols in the prelude.

- The -F (filename) option of the 'dump' command was renamed to -n, since it
was too easy to confuse -F with the -f (dump functions) option.

- As a bonus, there's also a new example (trace.pure) showing how to trace
function calls for debugging purposes.

** Pure 0.10 2008-10-05

Fixed a bug in the expression printer, and added some operations to create
(sub/super-) diagonal matrices to matrices.pure.

Also please note that the Pure project has moved to Google Code, see
http://pure-lang.googlecode.com. There's also a new mailing list at
http://groups.google.com/group/pure-lang.

** Pure 0.9 2008-10-01

Another bugfix release. This one fixes some minor issues with string slices.
Moreover, contiguous list and string slices of the form x!!(i..j) are now
optimized to make them work in linear time.

** Pure 0.8 2008-09-28

This is a maintenance release. It fixes a bug in catmap which slipped into the
0.6 release (reported by Eddie Rucker) and some minor glitches in the Makefile
and the documentation. Also, the matrix conversion operations in matrices.pure
have been overhauled (in particular, the matrix-pointer conversions are much
more complete now). Details can be found in the ChangeLog.

** Pure 0.7 2008-09-26

This release brings an important new feature: GSL (GNU Scientific Library)
matrix support. Here's a brief overview of the new stuff. For more
information on GSL please refer to http://www.gnu.org/software/gsl.

GSL double, complex and integer matrices can be created with the new {x,y;u,v}
syntax, which works more or less like Octave/MATLAB matrices, but using curly
braces instead of brackets. Also, indices are zero-based (rather than
one-based) to be consistent with Pure's list and tuple structures. Here are
some simple examples of matrices:

- {1,2,3}		a row vector consisting of machine ints
- {1.0;2.0;3.0}		a column vector of double values (';' separates rows)
- {1,2;3,4}		a 2x2 int matrix
- {1L,y+1;foo,bar}	a symbolic matrix

Symbolic matrices work like the numeric matrices, but can contain an arbitrary
mixture of Pure values, and also work if GSL support isn't available. GSL
matrices are always homogeneous, i.e., they only contain values from one
numeric type, which in the Pure implementation can be machine ints, double and
complex double values. If a matrix contains values of different types, or Pure
values which cannot be stored in a GSL matrix, then a symbolic matrix is
created instead (this also includes the case of bigints, which are considered
as symbolic values as far as matrix construction is concerned). If the
interpreter was built without GSL support then symbolic matrices are the only
kind of matrices supported by the interpreter.

Pure also provides so-called matrix comprehensions as a convenient means to
create matrices from a template expression (which can denote either a scalar
or a submatrix), drawing values from lists or matrices and (optionally)
filtering the elements with predicates. These work pretty much like list
comprehensions, but return matrices instead of lists. Generator clauses in
matrix comprehensions alternate between row and column generation so that
customary mathematical notation carries over quite easily. Here's a simple
example showing how to define a function which returns a square identity
matrix of a given dimension:

> eye n = {i==j|i=1..n;j=1..n};
> eye 3;
{1,0,0;0,1,0;0,0,1}

The prelude provides some additional basic matrix operations like determining
the size and dimensions of a matrix, indexing and slicing, transposition,
type-checking and various conversions between the different kinds of
matrices. To these ends, various basic operations to deal with matrix objects
have been added to the runtime, including some public API operations to create
and inspect Pure matrix values from external C modules. Moreover, the
'pointer' function in the prelude can be used to convert matrices to Pure
pointer values, and marshalling of GSL matrices in the C interface is also
provided.

Here is a brief synopsis of some important operations which are implemented in
the prelude (you can find the definitions of these and a bunch of other matrix
operations in matrices.pure):

- #x			total number of elements
- dim x			number of rows and columns (as a pair)
- x'			transpose of a matrix
- x!i			ith matrix element in row-major order (zero-based)
- x!(i,j)		jth element in ith row of the matrix (zero-based)
- x!!is, x!!(is,js)	slicing (is and js are lists of machine ints)
- x==y, x!=y		matrix comparisons

Adding other operations by interfacing to GSL should be a piece of cake. In
fact, we plan to provide a comprehensive Pure interface to GSL as a separate
library in the future.

Other user-visible changes prompted by the introduction of the matrix syntax
are listed below:

- Changes in the comprehension syntax: '|' is now used to separate the
template expression and the generator and filter clauses. This change was
necessary to accommodate the matrix syntax which uses ';' to separate
different rows in a matrix. For consistency, this applies to both list and
matrix comprehensions. The old [x;...] syntax is still supported in list
comprehensions, but is flagged with a "deprecated" warning by the compiler.

- Arithmetic sequences with a stepsize different from 1 are now written x:y..z
instead of x,y..z. This makes it possible to give the .. operator a higher
precedence than the ',' operator, which makes writing matrix slices like
x!!(i..j,k..l) much more convenient.

** Pure 0.6 2008-09-12

New stuff in this release (please see the ChangeLog and the manual for
details):

- Macros: These are implemented as rewriting rules which are applied at
compile time, and can be used for all usual preprocessing purposes, including
the optimization and inlining of function calls at the source level, and the
programming of user-defined special forms.

- Thunks a.k.a. "futures": These are realized as anonymous parameterless
closures (a la Alice ML), and are used to implement call-by-need and lazy data
structures. In particular, the prelude now implements lazy lists a.k.a.
"streams".

- Private namespaces. You can now declare symbols as private in a module, to
hide away internal helper functions and constructor symbols, and to keep the
global public namespace clean.

- Sentries (object finalizers) and references (mutable expression pointers).
File objects in the system module now employ sentries in order to close
themselves when they're garbage-collected.

- New interactive startup files (.purerc). These are just normal Pure scripts
with additional definitions for interactive usage.

- The 'list' command was renamed to 'show' (to avoid a clash with the prelude
function 'list'), and a new 'dump' command was added. The latter is similar to
'show', but saves a snapshot of your current interactive environment in a
file.

- User-defined hook for the expression printer (__show__). This allows you to
define your own custom print representations for expressions at runtime.

- Syntax highlighting for gedit (contributed by Eddie Rucker, thanks!).

- "PurePad", a little graphical frontend for the Pure interpreter on Windows.

** Pure 0.5 2008-08-24

This release sports LLVM 2.3 support and a bunch of bug fixes and improvements
in the language, the standard library and the code generator. As usual, please
check the ChangeLog for details. Here is a brief rundown of the most important
changes:

- Language: Haskell-like 'as' patterns. Constant definitions. Revised
list-of-tuples and 'using' syntax, as discussed on the mailing list. New $$
sequence operator. The XML entity character escapes were updated to the latest
from W3C.

- Updated syntax highlighting modes. Kate mode now supports folding of
comments and block structure.

- Improved script and dynamic library search algorithms, as discussed on the
mailing list.

- Various improvements in the C interface. Also refactored the runtime library
to provide a semantically complete public API for module writers.

- Improvements and bugfixes in the code generator.

- Library: Jiri Spitz' port of the Q container types (array.pure, dict.pure,
heap.pure, set.pure). New math.pure module which implements additional
mathematical functions as well as complex and rational numbers. New time- and
signal-related functions in the system module.

- More examples. In particular, make sure you have a look at Libor Spacek's
cool Mayan calendar and his unbelievingly fast n-queens algorithm. :)

- Better OSX support.

- Thanks to Rooslan S. Khayrov's patches, this release now works with LLVM
2.3. Please note that LLVM 2.2 support has been dropped, as we encountered
various issues with the LLVM 2.2 JIT.

- Toni Graffy has contributed openSUSE packages (available via Packman),
Alvaro Castro Castilla a Gentoo ebuild. Ryan Schmidt continues to maintain the
MacPorts package.

A big thank you to all who reported bugs and contributed code and patches, in
particular: Alvaro Castro Castilla, Toni Graffy, Rooslan S. Khayrov, Eddie
Rucker, Ryan Schmidt, Libor Spacek and Jiri Spitz.

** Pure 0.4 2008-06-19

This release features some more bug and portability fixes, a cleanup of the
source tree and an overhaul of the build system, see the ChangeLog for
details. Building a separate runtime lib on x86-64 works now (but requires a
patched LLVM, see the INSTALL file for details). Moreover, it is now possible
to install different Pure versions in parallel.

An Emacs mode for Pure and support for executing Pure scripts using "shebangs"
has been added. Paging of the 'list' command is now implemented using the
program specified with the PURE_MORE environment variable. This allows you to
disable this option (if PURE_MORE is undefined) or choose any pager program
and options that you prefer. Define PURE_MORE=more in your shell startup files
to get back the old behaviour of piping 'list' output through 'more'.

There's also a new syntax for multiple left-hand sides in function definitions
and 'case' rules, as suggested by Jiri Spitz and discussed on the mailing
list. Please refer to the manual page for details. To accommodate this change,
the bitwise operators '&' and '|' were renamed to 'and' and 'or',
respectively.

** Pure 0.3 2008-06-06

This release sports a lot of improvements as well as bug and portability
fixes, see the ChangeLog for details. Many memory leaks have been plugged, and
tail call elimination has been improved a lot. The build system has gone
through a major overhaul, adding autoconf support. 64 bit support has been
improved as well, and Pure now builds and runs fine on MS Windows. Many
library functions have been rewritten to make them tail-recursive, and some
new functions have been added. Last but not least, the runtime support is now
implemented as a separate shared library which makes it possible to link
external modules against the runtime, and reduces the memory footprint when
multiple instances of the interpreter are run as different processes.

Special thanks to Tim Haynes, John Lunney, Eddie Rucker, Ryan Schmidt, Libor
Spacek and Jiri Spitz for contributions, suggestions and bug reports.

** Pure 0.2 2008-05-04

On the heels of Pure 0.1 comes the first bugfix release which addresses a
couple of bugs, misfeatures and Mac OSX compatibility issues, please refer to
the ChangeLog for details. I also added a more detailed INSTALL guide (thanks
are due to Eddie Rucker who wrote most of the new material in this guide) and
updated the manpage with a few minor corrections and some remarks about issues
raised on the Pure mailing list.

Please note that there are still some issues with Pure on 64 bit systems (as
well as on Ubuntu running on PowerPC) which are still on my TODO list, these
will hopefully be fixed in the next release.

Thanks to all who sent in bug reports and patches, in particular: Chris
Double, Tim Haynes, Eddie Rucker, Ryan Schmidt and Libor Spacek. (I hope I
didn't forget anyone.)

** Pure 0.1 2008-04-29

The much-awaited initial release. ;-) The interpreter is already fully
functional, but of course there's still a lot to be done (see the TODO file
for details). Please note that this is a preliminary, "beta" release, so
expect some bugs (and please report them to the author!).

The Pure project is now hosted at SourceForge, see http://pure-lang.sf.net. A
mailing list should soon be available, too.

See the INSTALLATION section in the README file to get up and running quickly.
After Pure is installed, read the Pure manual page (also available in various
formats from the Pure website) and have a look at the stuff in the examples
subdir, especially hello.pure, and review the standard library modules
(lib/*.pure).

Enjoy!

Albert Graef <Dr.Graef@t-online.de>
