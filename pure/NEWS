
** Pure 0.16 (in progress)

Yet another bugfix release. Fixes a critical bug reported by Vili Aapro which
caused generation of wrong pattern-matching tables in some cases. Also adds
some missing and corrects some existing definitions in the prelude, and fixes
some quirks with the Makefile. Last but not least, the sources now compile
cleanly with Bison 2.4 and the forthcoming LLVM 2.5 (svn). As usual, the gory
details can be found in the ChangeLog.

** Pure 0.15 2008-12-16

Another bugfix release. Moreover, local definitions (when, with) may now span
the right-hand side and the guard of a rule. Thus local definitions like in
'foo x = bar y if y>0 when y = baz x end;' now apply to both the rhs and the
guard. Clauses can still be made local to the guard by placing parentheses.
Please see the manual for details.

** Pure 0.14 2008-11-21

This release features support for the recently released LLVM 2.4, as well as
some minor changes in the Unicode support and the C interface, see the
ChangeLog for details. The biggest change in this release is the new support
for namespaces, which is based on John Cowan's proposal on the mailing
list. This encompasses the following language changes:

- New 'public' keyword to explicitly declare public symbols. (This is still
  the default for all special symbol declarations, such as 'nullary' or
  'infix'.)

- New 'namespace' keyword which serves to declare and use namespaces. Please
  refer to the manual for details. Briefly, you create a new namespace with
  a declaration of the form 'namespace <identifier>;' and then declare the
  symbols which should belong to the namespace. For instance:

  namespace foo;
  public foo bar; // 'foo' and 'bar' are public symbols in namespace 'foo'
  foo x = x-1;
  bar x = x+1;
  // ...
  namespace; // switches back to the default namespace

  The 'namespace' declaration affects *all* symbols in subsequent symbol
  declarations, including 'extern' declarations. For instance:

  namespace foo;
  extern double sin(double);
  foo::sin(0.1);

- New qualified symbol syntax: foo::bar. This gives you access to the (public)
  symbols in a namespace, and works with both ordinary identifiers and special
  (nullary and operator) symbols. The namespace must first be introduced with
  a 'namespace' or 'using namespace' declaration (see above for the former,
  and below for the latter).

- New 'using namespace' declaration. This gives you access to the (public)
  symbols in the given namespace(s) without proper qualification. For
  instance:

  using namespace foo; // opens the namespace 'foo' for searching
  foo (bar x); // 'foo' and 'bar' resolve to 'foo::foo' and 'foo::bar' here
  using namespace; // closes the search namespace(s)
  foo (bar x); // 'foo' and 'bar' are symbols in the default namespace here

  The interpreter first searches the current namespace (as specified with the
  'namespace' declaration), then the search namespaces specified in the most
  recent 'using namespace' clause, and finally the default namespace. Note
  that 'private' symbols are only visible in the *current* namespace, see
  below for more details on this.

- Private symbols are now limited in scope to a namespace, not a source file.
  To create and use private symbols, a namespace declaration has to be in
  effect. You'll have to adapt existing scripts accordingly. For instance:

  namespace foo;
  private baz; // 'baz' is a private symbol in namespace 'foo'
  baz x = 2*x;
  // ...
  namespace;   // 'baz' is now invisible

** Pure 0.13 2008-11-04

This release sports a lot of minor bugfixes and other cosmetic changes, see
the ChangeLog for details.

In addition, please note the following language and library changes, as
discussed on the mailing list. Special thanks are due to John Cowan, Eddie
Rucker and Max Wolf for bringing these up and helping to get them sorted out.

- Allow 'const nullary' symbols which can be matched, e.g., in 'case'
  expressions just like a real 'nullary' symbol.

- Swapped '~' and 'not', so that the logical and bitwise operations are now
  more consistently named ~, &&, || and not/and/or, respectively.
  Consequently, '!=' and '!==' were also renamed to '~=' and '~==',
  respectively. Note that previously ~ was used for bitwise and 'not' for
  logical negation, which was rather confusing, albeit compatible with the
  naming of the 'not' operation in Haskell and ML.

- Improved Unicode support. As proposed by John Cowan, extended characters in
  operator symbols are now restricted to symbols U+00A1 through U+00BF,
  U+00D7, U+00F7 and U+2100 through U+2BFF. All other Unicode characters are
  now usable in ordinary identifiers just like any ASCII letter, which permits
  writing Pure programs in almost any language.

Last but not least, Eddie Rucker contributed Pure syntax highlighting for GNU
nano (http://www.nano-editor.org). Thanks Eddie!

** Pure 0.12 2008-10-09

Another step on the road to Pure 1.0.

- Cosmetic syntax change: Allow the lhs to be omitted in simple rules ('when',
  'let' etc.) if it is just '_'. This lets you write stuff like, e.g.,
  'foo x = y when y = ...; puts y; end', which is useful for debugging
  purposes. Also, 'let x;' provides an alternative to just 'x;' at the
  toplevel, which suppresses printing the result of x.

- New Lisp-like 'quote' builtin (special form) for quoting expressions.
  Added a Lisp-like 'quasiquote' to the prelude (see examples/quasiquote.pure
  for an example).

- 'eval' can now evaluate expressions as well as strings. Also added a new
  'evalcmd' primitive for executing interactive interpreter commands like
  'clear' and 'show' (see examples/reflection.pure for an example).

- Overhauled the 'clear', 'dump' and 'show' commands so that they take the
  same basic set of selection options and work in a consistent fashion now.

- For all practical purposes, the number of definition levels is unlimited
  now (previous limit was 256).

** Pure 0.11 2008-10-06

This release sports some minor bugfixes as well as a few changes in the
language as detailed below.

- The old [x;...] list comprehension syntax has been removed (this has already
been deprecated since Pure 0.7.)

- The grammar was changed to allow arbitrary expressions as guards in
equations. This means that syntax like 'foo x = bar x if y when y = baz x
end' is now recognized (previously you had to enclose the 'y when ... end'
term in parentheses).

- There's direct support for empty lists and tuples in the grammar now, so
that these are treated in the same way as empty matrices, rather than being
defined as nullary symbols in the prelude.

- The -F (filename) option of the 'dump' command was renamed to -n, since it
was too easy to confuse -F with the -f (dump functions) option.

- As a bonus, there's also a new example (trace.pure) showing how to trace
function calls for debugging purposes.

** Pure 0.10 2008-10-05

Fixed a bug in the expression printer, and added some operations to create
(sub/super-) diagonal matrices to matrices.pure.

Also please note that the Pure project has moved to Google Code, see
http://pure-lang.googlecode.com. There's also a new mailing list at
http://groups.google.com/group/pure-lang.

** Pure 0.9 2008-10-01

Another bugfix release. This one fixes some minor issues with string slices.
Moreover, contiguous list and string slices of the form x!!(i..j) are now
optimized to make them work in linear time.

** Pure 0.8 2008-09-28

This is a maintenance release. It fixes a bug in catmap which slipped into the
0.6 release (reported by Eddie Rucker) and some minor glitches in the Makefile
and the documentation. Also, the matrix conversion operations in matrices.pure
have been overhauled (in particular, the matrix-pointer conversions are much
more complete now). Details can be found in the ChangeLog.

** Pure 0.7 2008-09-26

This release brings an important new feature: GSL (GNU Scientific Library)
matrix support. Here's a brief overview of the new stuff. For more
information on GSL please refer to http://www.gnu.org/software/gsl.

GSL double, complex and integer matrices can be created with the new {x,y;u,v}
syntax, which works more or less like Octave/MATLAB matrices, but using curly
braces instead of brackets. Also, indices are zero-based (rather than
one-based) to be consistent with Pure's list and tuple structures. Here are
some simple examples of matrices:

- {1,2,3}		a row vector consisting of machine ints
- {1.0;2.0;3.0}		a column vector of double values (';' separates rows)
- {1,2;3,4}		a 2x2 int matrix
- {1L,y+1;foo,bar}	a symbolic matrix

Symbolic matrices work like the numeric matrices, but can contain an arbitrary
mixture of Pure values, and also work if GSL support isn't available. GSL
matrices are always homogeneous, i.e., they only contain values from one
numeric type, which in the Pure implementation can be machine ints, double and
complex double values. If a matrix contains values of different types, or Pure
values which cannot be stored in a GSL matrix, then a symbolic matrix is
created instead (this also includes the case of bigints, which are considered
as symbolic values as far as matrix construction is concerned). If the
interpreter was built without GSL support then symbolic matrices are the only
kind of matrices supported by the interpreter.

Pure also provides so-called matrix comprehensions as a convenient means to
create matrices from a template expression (which can denote either a scalar
or a submatrix), drawing values from lists or matrices and (optionally)
filtering the elements with predicates. These work pretty much like list
comprehensions, but return matrices instead of lists. Generator clauses in
matrix comprehensions alternate between row and column generation so that
customary mathematical notation carries over quite easily. Here's a simple
example showing how to define a function which returns a square identity
matrix of a given dimension:

> eye n = {i==j|i=1..n;j=1..n};
> eye 3;
{1,0,0;0,1,0;0,0,1}

The prelude provides some additional basic matrix operations like determining
the size and dimensions of a matrix, indexing and slicing, transposition,
type-checking and various conversions between the different kinds of
matrices. To these ends, various basic operations to deal with matrix objects
have been added to the runtime, including some public API operations to create
and inspect Pure matrix values from external C modules. Moreover, the
'pointer' function in the prelude can be used to convert matrices to Pure
pointer values, and marshalling of GSL matrices in the C interface is also
provided.

Here is a brief synopsis of some important operations which are implemented in
the prelude (you can find the definitions of these and a bunch of other matrix
operations in matrices.pure):

- #x			total number of elements
- dim x			number of rows and columns (as a pair)
- x'			transpose of a matrix
- x!i			ith matrix element in row-major order (zero-based)
- x!(i,j)		jth element in ith row of the matrix (zero-based)
- x!!is, x!!(is,js)	slicing (is and js are lists of machine ints)
- x==y, x!=y		matrix comparisons

Adding other operations by interfacing to GSL should be a piece of cake. In
fact, we plan to provide a comprehensive Pure interface to GSL as a separate
library in the future.

Other user-visible changes prompted by the introduction of the matrix syntax
are listed below:

- Changes in the comprehension syntax: '|' is now used to separate the
template expression and the generator and filter clauses. This change was
necessary to accommodate the matrix syntax which uses ';' to separate
different rows in a matrix. For consistency, this applies to both list and
matrix comprehensions. The old [x;...] syntax is still supported in list
comprehensions, but is flagged with a "deprecated" warning by the compiler.

- Arithmetic sequences with a stepsize different from 1 are now written x:y..z
instead of x,y..z. This makes it possible to give the .. operator a higher
precedence than the ',' operator, which makes writing matrix slices like
x!!(i..j,k..l) much more convenient.

** Pure 0.6 2008-09-12

New stuff in this release (please see the ChangeLog and the manual for
details):

- Macros: These are implemented as rewriting rules which are applied at
compile time, and can be used for all usual preprocessing purposes, including
the optimization and inlining of function calls at the source level, and the
programming of user-defined special forms.

- Thunks a.k.a. "futures": These are realized as anonymous parameterless
closures (a la Alice ML), and are used to implement call-by-need and lazy data
structures. In particular, the prelude now implements lazy lists a.k.a.
"streams".

- Private namespaces. You can now declare symbols as private in a module, to
hide away internal helper functions and constructor symbols, and to keep the
global public namespace clean.

- Sentries (object finalizers) and references (mutable expression pointers).
File objects in the system module now employ sentries in order to close
themselves when they're garbage-collected.

- New interactive startup files (.purerc). These are just normal Pure scripts
with additional definitions for interactive usage.

- The 'list' command was renamed to 'show' (to avoid a clash with the prelude
function 'list'), and a new 'dump' command was added. The latter is similar to
'show', but saves a snapshot of your current interactive environment in a
file.

- User-defined hook for the expression printer (__show__). This allows you to
define your own custom print representations for expressions at runtime.

- Syntax highlighting for gedit (contributed by Eddie Rucker, thanks!).

- "PurePad", a little graphical frontend for the Pure interpreter on Windows.

** Pure 0.5 2008-08-24

This release sports LLVM 2.3 support and a bunch of bug fixes and improvements
in the language, the standard library and the code generator. As usual, please
check the ChangeLog for details. Here is a brief rundown of the most important
changes:

- Language: Haskell-like 'as' patterns. Constant definitions. Revised
list-of-tuples and 'using' syntax, as discussed on the mailing list. New $$
sequence operator. The XML entity character escapes were updated to the latest
from W3C.

- Updated syntax highlighting modes. Kate mode now supports folding of
comments and block structure.

- Improved script and dynamic library search algorithms, as discussed on the
mailing list.

- Various improvements in the C interface. Also refactored the runtime library
to provide a semantically complete public API for module writers.

- Improvements and bugfixes in the code generator.

- Library: Jiri Spitz' port of the Q container types (array.pure, dict.pure,
heap.pure, set.pure). New math.pure module which implements additional
mathematical functions as well as complex and rational numbers. New time- and
signal-related functions in the system module.

- More examples. In particular, make sure you have a look at Libor Spacek's
cool Mayan calendar and his unbelievingly fast n-queens algorithm. :)

- Better OSX support.

- Thanks to Rooslan S. Khayrov's patches, this release now works with LLVM
2.3. Please note that LLVM 2.2 support has been dropped, as we encountered
various issues with the LLVM 2.2 JIT.

- Toni Graffy has contributed openSUSE packages (available via Packman),
Alvaro Castro Castilla a Gentoo ebuild. Ryan Schmidt continues to maintain the
MacPorts package.

A big thank you to all who reported bugs and contributed code and patches, in
particular: Alvaro Castro Castilla, Toni Graffy, Rooslan S. Khayrov, Eddie
Rucker, Ryan Schmidt, Libor Spacek and Jiri Spitz.

** Pure 0.4 2008-06-19

This release features some more bug and portability fixes, a cleanup of the
source tree and an overhaul of the build system, see the ChangeLog for
details. Building a separate runtime lib on x86-64 works now (but requires a
patched LLVM, see the INSTALL file for details). Moreover, it is now possible
to install different Pure versions in parallel.

An Emacs mode for Pure and support for executing Pure scripts using "shebangs"
has been added. Paging of the 'list' command is now implemented using the
program specified with the PURE_MORE environment variable. This allows you to
disable this option (if PURE_MORE is undefined) or choose any pager program
and options that you prefer. Define PURE_MORE=more in your shell startup files
to get back the old behaviour of piping 'list' output through 'more'.

There's also a new syntax for multiple left-hand sides in function definitions
and 'case' rules, as suggested by Jiri Spitz and discussed on the mailing
list. Please refer to the manual page for details. To accommodate this change,
the bitwise operators '&' and '|' were renamed to 'and' and 'or',
respectively.

** Pure 0.3 2008-06-06

This release sports a lot of improvements as well as bug and portability
fixes, see the ChangeLog for details. Many memory leaks have been plugged, and
tail call elimination has been improved a lot. The build system has gone
through a major overhaul, adding autoconf support. 64 bit support has been
improved as well, and Pure now builds and runs fine on MS Windows. Many
library functions have been rewritten to make them tail-recursive, and some
new functions have been added. Last but not least, the runtime support is now
implemented as a separate shared library which makes it possible to link
external modules against the runtime, and reduces the memory footprint when
multiple instances of the interpreter are run as different processes.

Special thanks to Tim Haynes, John Lunney, Eddie Rucker, Ryan Schmidt, Libor
Spacek and Jiri Spitz for contributions, suggestions and bug reports.

** Pure 0.2 2008-05-04

On the heels of Pure 0.1 comes the first bugfix release which addresses a
couple of bugs, misfeatures and Mac OSX compatibility issues, please refer to
the ChangeLog for details. I also added a more detailed INSTALL guide (thanks
are due to Eddie Rucker who wrote most of the new material in this guide) and
updated the manpage with a few minor corrections and some remarks about issues
raised on the Pure mailing list.

Please note that there are still some issues with Pure on 64 bit systems (as
well as on Ubuntu running on PowerPC) which are still on my TODO list, these
will hopefully be fixed in the next release.

Thanks to all who sent in bug reports and patches, in particular: Chris
Double, Tim Haynes, Eddie Rucker, Ryan Schmidt and Libor Spacek. (I hope I
didn't forget anyone.)

** Pure 0.1 2008-04-29

The much-awaited initial release. ;-) The interpreter is already fully
functional, but of course there's still a lot to be done (see the TODO file
for details). Please note that this is a preliminary, "beta" release, so
expect some bugs (and please report them to the author!).

The Pure project is now hosted at SourceForge, see http://pure-lang.sf.net. A
mailing list should soon be available, too.

See the INSTALLATION section in the README file to get up and running quickly.
After Pure is installed, read the Pure manual page (also available in various
formats from the Pure website) and have a look at the stuff in the examples
subdir, especially hello.pure, and review the standard library modules
(lib/*.pure).

Enjoy!

Albert Graef <Dr.Graef@t-online.de>
