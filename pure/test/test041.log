blobp _/*0:1*/ = 0;
#p/*0:1*/::pointer = blob_size p/*0:1*/ if blobp p/*0:1*/;
{
  rule #0: #x::matrix = __C::matrix_size x
  rule #1: #s::string = __C::string_size s
  rule #2: #() = 0
  rule #3: #(x,xs) = accum 1 xs with accum n::int (x,xs) = accum (n+1) xs; accum n::int x = n+1 end
  rule #4: #[] = 0
  rule #5: #(x:xs) = accum 1 xs with accum n::int (x:xs) = accum (n+1) xs; accum n::int [] = n; accum n::int xs = n+#xs end
  rule #6: #p::pointer = blob_size p if blobp p
  state 0: #0 #1 #2 #3 #4 #5 #6
	<var>::string state 1
	<var>::pointer state 2
	<var>::matrix state 3
	<app> state 4
	[] state 12
	() state 13
  state 1: #1
  state 2: #6
  state 3: #0
  state 4: #3 #5
	<app> state 5
  state 5: #3 #5
	, state 6
	: state 9
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #5
	<var> state 10
  state 10: #5
	<var> state 11
  state 11: #5
  state 12: #4
  state 13: #2
}
{
  rule #0: blobp _ = 0
  state 0: #0
	<var> state 1
  state 1: #0
}
val (blob (x+1));
x+1
blobp (blob (\x/*0:*/ -> x/*0:*/+1 {
  rule #0: x = x+1
  state 0: #0
	<var> state 1
  state 1: #0
}));
0
blobp (blob foo/*0*/) with foo x/*0:1*/ = x/*0:1*/+1 {
  rule #0: foo x = x+1
  state 0: #0
	<var> state 1
  state 1: #0
} end;
0
blobp (blob (malloc 10));
0
val (blob #<pointer 0>);
#<pointer 0>
blobp #<pointer 0>;
0
blobp (malloc 10);
0
blobp (blob (1..10));
1
#blob (1..10);
208L
#blob (1..10000);
160048L
val (blob (17+1));
18
val (blob (17L+1));
18L
val (blob (17.0+1));
18.0
val (blob "Hello, world!");
"Hello, world!"
val (blob (x:y:z));
x:y:z
val (blob (1/3,4711,#<pointer 0>));
0.333333333333333,4711,#<pointer 0>
val (blob [1/3,4711,#<pointer 0>]);
[0.333333333333333,4711,#<pointer 0>]
val (blob {1/3,4711,#<pointer 0>});
{0.333333333333333,4711,#<pointer 0>}
let x = {1,2,3;4,5,6};
val (blob x);
{1,2,3;4,5,6}
val (blob (dmatrix x));
{1.0,2.0,3.0;4.0,5.0,6.0}
val (blob (cmatrix x));
{1.0+:0.0,2.0+:0.0,3.0+:0.0;4.0+:0.0,5.0+:0.0,6.0+:0.0}
{
  rule #0: x = 1..100
  state 0: #0
	<var> state 1
  state 1: #0
}
let x = 1..100;
#blob (x,x);
1680L
val (blob (x,x));
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]
get_pointer p/*0:01*/==get_pointer q/*0:1*/ when u/*0:01*/,v/*0:1*/ = val (blob (x,x)); p/*0:01*/,q/*0:1*/ = ref u/*0:01*/,ref v/*0:1*/ {
  rule #0: p,q = ref u,ref v
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} {
  rule #0: u,v = val (blob (x,x))
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end;
1
