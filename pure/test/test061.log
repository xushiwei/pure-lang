'__lambda__ [x] (x+1);
__lambda__ [x] (x+1)
foo = '__lambda__ [x] (x+1);
{
  rule #0: foo = '__lambda__ [x] (x+1)
  state 0: #0
}
foo;
__lambda__ [x] (x+1)
let x = '__case__ 99 [x __type__ int-->x+1 __if__ x>0];
x;
__case__ 99 [x __type__ int-->x+1 __if__ x>0]
eval x;
100
let x = '(x+1 __when__ [x __type__ int-->99]);
x;
x+1 __when__ [x __type__ int-->99]
eval x;
100
let x = '(f 99 __with__ [f (x __type__ int)-->x+1]);
x;
f 99 __with__ [f (x __type__ int)-->x+1]
eval x;
100
bar (__lambda__ [x/*0:10101*/,y/*0:101101*/] z/*0:11*/) = '__lambda__ [y/*0:101101*/,x/*0:10101*/] z/*0:11*/;
{
  rule #0: bar (__lambda__ [x,y] z) = '__lambda__ [y,x] z
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	__lambda__ state 3
  state 3: #0
	<app> state 4
  state 4: #0
	<app> state 5
  state 5: #0
	: state 6
  state 6: #0
	<var> state 7
  state 7: #0
	<app> state 8
  state 8: #0
	<app> state 9
  state 9: #0
	: state 10
  state 10: #0
	<var> state 11
  state 11: #0
	[] state 12
  state 12: #0
	<var> state 13
  state 13: #0
}
{
  rule #0: x = bar ('__lambda__ [a,b] (a-b))
  state 0: #0
	<var> state 1
  state 1: #0
}
let x = bar ('__lambda__ [a,b] (a-b));
x;
__lambda__ [b,a] (a-b)
eval x 2 3;
1
baz x/*0:1*/ = '__lambda__ [x/*0:1*/] (x/*0:1*/+1);
{
  rule #0: baz x = '__lambda__ [x] (x+1)
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: x = baz y
  state 0: #0
	<var> state 1
  state 1: #0
}
let x = baz y;
x;
__lambda__ [y] (y+1)
eval x 99;
100
def bar (__lambda__ [x/*0:10101*/,y/*0:101101*/] z/*0:11*/) = __eval__ ('__lambda__ [y/*0:101101*/,x/*0:10101*/] z/*0:11*/);
def baz x/*0:1*/ = __eval__ ('__lambda__ [x/*0:1*/] (x/*0:1*/+1));
f = \b/*0:01*/ a/*0:1*/ -> a/*0:1*/-b/*0:01*/ {
  rule #0: _ b a = a-b
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
};
{
  rule #0: f = \b a -> a-b
  state 0: #0
}
f 2 3;
1
g = \y/*0:1*/ -> y/*0:1*/+1 {
  rule #0: _ y = y+1
  state 0: #0
	<var> state 1
  state 1: #0
};
{
  rule #0: g = \y -> y+1
  state 0: #0
}
f/*0*/ with f x/*0:1*/ = y/*0:*/ when y/*0:*/ = x/*0:1*/+1 {
  rule #0: y = x+1
  state 0: #0
	<var> state 1
  state 1: #0
} end {
  rule #0: f x = y when y = x+1 end
  state 0: #0
	<var> state 1
  state 1: #0
} end;
f
f/*0*/ with f x/*0:1*/ = y/*0*/ with y = x/*1:1*/+1 {
  rule #0: y = x+1
  state 0: #0
} end {
  rule #0: f x = y with y = x+1 end
  state 0: #0
	<var> state 1
  state 1: #0
} end;
f
get_macdef (*);
[]
get_macdef ($);
[f$x-->f x]
get_fundef bla;
[]
get_fundef ($);
[f$x-->f x]
fact n/*0:1*/ = n/*0:1*/*fact (n/*0:1*/-1) if n/*0:1*/>0;
fact n/*0:1*/ = 1;
{
  rule #0: fact n = n*fact (n-1) if n>0
  rule #1: fact n = 1
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
}
fact __with__ get_fundef fact;
fact __with__ [(fact n-->n*fact (n-1) __if__ n>0),(fact n-->1)]
{
  rule #0: x = eval (fact __with__ get_fundef fact)
  state 0: #0
	<var> state 1
  state 1: #0
}
let x = eval (fact __with__ get_fundef fact);
map x (0..10);
[1,1,2,6,24,120,720,5040,40320,362880,3628800]
foldr __with__ get_fundef foldr;
foldr __with__ [(foldr f a (x __type__ matrix)-->__C::matrix_foldr f a x),(foldr f a (s __type__ string)-->foldr f a (chars s)),(foldr f a []-->a),(foldr f a (xs __as__ (_:_))-->tick [] xs __with__ [(tick zs (x:xs)-->tack (x:zs) (foldr f a xs&) __if__ thunkp xs),(tick zs (x:xs)-->tick (x:zs) xs),(tick zs []-->tack zs a),(tick zs xs-->tack zs (foldr f a xs)),(tack (x:xs) y-->tack xs (f x y)),(tack [] y-->y)])]
{
  rule #0: x = eval (foldr __with__ get_fundef foldr)
  state 0: #0
	<var> state 1
  state 1: #0
}
let x = eval (foldr __with__ get_fundef foldr);
x (*) 1 (1..10);
3628800
