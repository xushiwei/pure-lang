const false,true = 0,1;
f/*0:01*/$x/*0:1*/ = f/*0:01*/ x/*0:1*/;
(f/*0:001*/.g/*0:01*/) x/*0:1*/ = f/*0:001*/ (g/*0:01*/ x/*0:1*/);
void _/*0:1*/ = ();
id x/*0:1*/ = x/*0:1*/;
cst x/*0:01*/ y/*0:1*/ = x/*0:01*/;
flip f/*0:001*/ x/*0:01*/ y/*0:1*/ = f/*0:001*/ y/*0:1*/ x/*0:01*/;
curry f/*0:001*/ x/*0:01*/ y/*0:1*/ = f/*0:001*/ (x/*0:01*/,y/*0:1*/);
curry3 f/*0:0001*/ x/*0:001*/ y/*0:01*/ z/*0:1*/ = f/*0:0001*/ (x/*0:001*/,y/*0:01*/,z/*0:1*/);
uncurry f/*0:01*/ (x/*0:101*/,y/*0:11*/) = f/*0:01*/ x/*0:101*/ y/*0:11*/;
uncurry3 f/*0:01*/ (x/*0:101*/,y/*0:1101*/,z/*0:111*/) = f/*0:01*/ x/*0:101*/ y/*0:1101*/ z/*0:111*/;
fix f/*0:1*/ = f/*0:1*/ (fix f/*1:1*/&);
def f/*0:01*/$x/*0:1*/ = f/*0:01*/ x/*0:1*/;
def (f/*0:001*/.g/*0:01*/) x/*0:1*/ = f/*0:001*/ (g/*0:01*/ x/*0:1*/);
def void () = ();
def void [] = ();
def void {} = ();
def void [x/*0:101*/] = void x/*0:101*/;
def void {x/*0:100*/} = void x/*0:100*/;
(x/*0:0101*/=>v/*0:011*/)==(y/*0:101*/=>w/*0:11*/) = x/*0:0101*/==y/*0:101*/&&v/*0:011*/==w/*0:11*/;
(x/*0:0101*/=>v/*0:011*/)~=(y/*0:101*/=>w/*0:11*/) = x/*0:0101*/~=y/*0:101*/||v/*0:011*/~=w/*0:11*/;
key (x/*0:101*/=>v/*0:11*/) = x/*0:101*/;
val (x/*0:101*/=>v/*0:11*/) = v/*0:11*/;
x/*0:01*/,() = x/*0:01*/;
(),y/*0:1*/ = y/*0:1*/;
(x/*0:0101*/,y/*0:011*/),z/*0:1*/ = x/*0:0101*/,y/*0:011*/,z/*0:1*/;
()==() = 1;
(x/*0:0101*/,xs/*0:011*/)==(y/*0:101*/,ys/*0:11*/) = x/*0:0101*/==y/*0:101*/&&xs/*0:011*/==ys/*0:11*/;
(x/*0:0101*/,xs/*0:011*/)==_/*0:1*/ = 0;
()==_/*0:1*/ = 0;
_/*0:01*/==(x/*0:101*/,xs/*0:11*/) = 0;
_/*0:01*/==() = 0;
()~=() = 0;
(x/*0:0101*/,xs/*0:011*/)~=(y/*0:101*/,ys/*0:11*/) = x/*0:0101*/~=y/*0:101*/||xs/*0:011*/~=ys/*0:11*/;
(x/*0:0101*/,xs/*0:011*/)~=_/*0:1*/ = 1;
()~=_/*0:1*/ = 1;
_/*0:01*/~=(x/*0:101*/,xs/*0:11*/) = 1;
_/*0:01*/~=() = 1;
null () = 1;
null (x/*0:101*/,xs/*0:11*/) = 0;
#() = 0;
#(x/*0:101*/,xs/*0:11*/) = accum/*0*/ 1 xs/*0:11*/ with accum n/*0:01*/::int (x/*0:101*/,xs/*0:11*/) = accum/*1*/ (n/*0:01*/+1) xs/*0:11*/; accum n/*0:01*/::int x/*0:1*/ = n/*0:01*/+1 {
  rule #0: accum n::int (x,xs) = accum (n+1) xs
  rule #1: accum n::int x = n+1
  state 0: #0 #1
	<var>::int state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	, state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
} end;
(x/*0:0101*/,xs/*0:011*/)!n/*0:1*/::int = throw out_of_bounds if n/*0:1*/<0;
(x/*0:0101*/,xs/*0:011*/)!0 = x/*0:0101*/;
(x/*0:0101*/,y/*0:01101*/,xs/*0:0111*/)!n/*0:1*/::int = (y/*0:01101*/,xs/*0:0111*/)!(n/*0:1*/-1);
(x/*0:0101*/,y/*0:011*/)!1 = y/*0:011*/;
(x/*0:0101*/,y/*0:011*/)!n/*0:1*/::int = throw out_of_bounds;
()!n/*0:1*/::int = throw out_of_bounds;
xs@()!!ns/*0:1*/ = tuple (list xs/*0:01*/!!ns/*0:1*/);
xs@(_/*0:0101*/,_/*0:011*/)!!ns/*0:1*/ = tuple (list xs/*0:01*/!!ns/*0:1*/);
reverse () = ();
reverse (x/*0:101*/,xs/*0:11*/) = accum/*0*/ x/*0:101*/ xs/*0:11*/ with accum ys/*0:01*/ (x/*0:101*/,xs/*0:11*/) = accum/*1*/ (x/*0:101*/,ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ x/*0:1*/ = x/*0:1*/,ys/*0:01*/ {
  rule #0: accum ys (x,xs) = accum (x,ys) xs
  rule #1: accum ys x = x,ys
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	, state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
} end;
[]==[] = 1;
x/*0:0101*/:xs/*0:011*/==[] = 0;
[]==x/*0:101*/:xs/*0:11*/ = 0;
x/*0:0101*/:xs/*0:011*/==y/*0:101*/:ys/*0:11*/ = x/*0:0101*/==y/*0:101*/&&xs/*0:011*/==ys/*0:11*/;
[]~=[] = 0;
x/*0:0101*/:xs/*0:011*/~=[] = 1;
[]~=x/*0:101*/:xs/*0:11*/ = 1;
x/*0:0101*/:xs/*0:011*/~=y/*0:101*/:ys/*0:11*/ = x/*0:0101*/~=y/*0:101*/||xs/*0:011*/~=ys/*0:11*/;
null [] = 1;
null (x/*0:101*/:xs/*0:11*/) = 0;
#[] = 0;
#(x/*0:101*/:xs/*0:11*/) = accum/*0*/ 1 xs/*0:11*/ with accum n/*0:01*/::int (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (n/*0:01*/+1) xs/*0:11*/; accum n/*0:01*/::int [] = n/*0:01*/; accum n/*0:01*/::int xs/*0:1*/ = n/*0:01*/+#xs/*0:1*/ {
  rule #0: accum n::int (x:xs) = accum (n+1) xs
  rule #1: accum n::int [] = n
  rule #2: accum n::int xs = n+#xs
  state 0: #0 #1 #2
	<var>::int state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
	<var> state 12
  state 12: #0 #2
  state 13: #1 #2
} end;
[]!n/*0:1*/::int = throw out_of_bounds;
(x/*0:0101*/:xs/*0:011*/)!0 = x/*0:0101*/;
(x/*0:0101*/:xs/*0:011*/)!n/*0:1*/::int = xs/*0:011*/!(n/*0:1*/-1) if n/*0:1*/>0;
(x/*0:0101*/:xs/*0:011*/)!n/*0:1*/::int = throw out_of_bounds;
xs/*0:01*/!!ns/*0:1*/ = ys/*0:*/ if ok/*1*/ ys/*0:*/ when ys/*0:*/ = case ns/*0:1*/ of ns@(n/*0:01*/::int:_/*0:1*/) = list (take (count/*1*/ ns/*0:*/) (drop n/*0:01*/ xs/*1:01*/)) if listp xs/*1:01*/&&cont/*1*/ ns/*0:*/; _/*0:*/ = catmap (nth/*1*/ xs/*1:01*/) ns/*1:1*/ {
  rule #0: ns@(n::int:_) = list (take (count ns) (drop n xs)) if listp xs&&cont ns
  rule #1: _ = catmap (nth xs) ns
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	: state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
	<var>::int state 12
  state 10: #1
	<var> state 11
  state 11: #1
  state 12: #0 #1
	<var> state 13
  state 13: #0 #1
} end {
  rule #0: ys = case ns of ns@(n::int:_) = list (take (count ns) (drop n xs)) if listp xs&&cont ns; _ = catmap (nth xs) ns end
  state 0: #0
	<var> state 1
  state 1: #0
} end with cont (n/*0:101*/::int:ns/*0:11*/) = ~thunkp ns/*0:11*/&&(case ns/*0:11*/ of [] = 1; m/*0:01*/::int:_/*0:1*/ = cont/*2*/ ns/*1:11*/ if m/*0:01*/==n/*1:101*/+1; _/*0:*/ = 0 {
  rule #0: [] = 1
  rule #1: m::int:_ = cont ns if m==n+1
  rule #2: _ = 0
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
	[] state 14
  state 1: #2
  state 2: #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
	<var>::int state 12
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #1 #2
	<var> state 13
  state 13: #1 #2
  state 14: #0 #2
} end) {
  rule #0: cont (n::int:ns) = ~thunkp ns&&(case ns of [] = 1; m::int:_ = cont ns if m==n+1; _ = 0 end)
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var>::int state 4
  state 4: #0
	<var> state 5
  state 5: #0
}; nth xs/*0:01*/ n/*0:1*/ = catch (cst []) [xs/*1:01*/!n/*1:1*/] {
  rule #0: nth xs n = catch (cst []) [xs!n]
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}; count ns/*0:1*/ = #dropwhile (\n/*0:1*/::int -> n/*0:1*/<0 {
  rule #0: _ n::int = n<0
  state 0: #0
	<var>::int state 1
  state 1: #0
}) ns/*0:1*/ {
  rule #0: count ns = #dropwhile (\n::int -> n<0) ns
  state 0: #0
	<var> state 1
  state 1: #0
}; ok (catmap (nth _/*0:1011*/) _/*0:11*/) = 0; ok _/*0:1*/ = 1 {
  rule #0: ok (catmap (nth _) _) = 0
  rule #1: ok _ = 1
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	catmap state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
	<app> state 12
  state 10: #1
	<var> state 11
  state 11: #1
  state 12: #0 #1
	<var> state 13
	nth state 16
  state 13: #1
	<var> state 14
  state 14: #1
	<var> state 15
  state 15: #1
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
} end;
def x/*0:01*/!!(a/*0:101*/..b/*0:11*/) = subseq x/*0:01*/ a/*0:101*/ b/*0:11*/;
subseq [] a/*0:01*/::int b/*0:1*/::int = [];
subseq xs@(_/*0:00101*/:_/*0:0011*/) a/*0:01*/::int b/*0:1*/::int = take (b/*0:1*/-a/*0:01*/+1) (drop a/*0:01*/ xs/*0:001*/);
subseq x/*0:001*/ a/*0:01*/ b/*0:1*/ = slice x/*0:001*/ (a/*0:01*/..b/*0:1*/);
slice x/*0:01*/ y/*0:1*/ = id (!!) x/*0:01*/ y/*0:1*/;
[]+ys/*0:1*/ = ys/*0:1*/;
xs@(_/*0:0101*/:_/*0:011*/)+ys/*0:1*/ = tick/*0*/ [] xs/*0:01*/ ys/*0:1*/ with tick zs/*0:001*/ (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ (x/*0:0101*/:zs/*0:001*/) ((xs/*1:011*/+ys/*1:1*/)&) if thunkp xs/*0:011*/; tick zs/*0:001*/ (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tick/*1*/ (x/*0:0101*/:zs/*0:001*/) xs/*0:011*/ ys/*0:1*/; tick zs/*0:001*/ [] ys/*0:1*/ = tack/*1*/ zs/*0:001*/ ys/*0:1*/; tick zs/*0:001*/ xs/*0:01*/ ys/*0:1*/ = tack/*1*/ zs/*0:001*/ (xs/*0:01*/+ys/*0:1*/) {
  rule #0: tick zs (x:xs) ys = tack (x:zs) ((xs+ys)&) if thunkp xs
  rule #1: tick zs (x:xs) ys = tick (x:zs) xs ys
  rule #2: tick zs [] ys = tack zs ys
  rule #3: tick zs xs ys = tack zs (xs+ys)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<app> state 4
	[] state 17
  state 2: #3
	<var> state 3
  state 3: #3
  state 4: #0 #1 #3
	<var> state 5
	<app> state 8
  state 5: #3
	<var> state 6
  state 6: #3
	<var> state 7
  state 7: #3
  state 8: #0 #1 #3
	<var> state 9
	: state 13
  state 9: #3
	<var> state 10
  state 10: #3
	<var> state 11
  state 11: #3
	<var> state 12
  state 12: #3
  state 13: #0 #1 #3
	<var> state 14
  state 14: #0 #1 #3
	<var> state 15
  state 15: #0 #1 #3
	<var> state 16
  state 16: #0 #1 #3
  state 17: #2 #3
	<var> state 18
  state 18: #2 #3
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ xs/*0:011*/ (x/*0:0101*/:ys/*0:1*/); tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (x:ys)
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
reverse [] = [];
reverse (x/*0:101*/:xs/*0:11*/) = accum/*0*/ [x/*0:101*/] xs/*0:11*/ with accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (x/*0:101*/:ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ [] = ys/*0:01*/; accum ys/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: accum ys (x:xs) = accum (x:ys) xs
  rule #1: accum ys [] = ys
  rule #2: accum ys xs = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
	<var> state 12
  state 12: #0 #2
  state 13: #1 #2
} end;
list () = [];
list (x/*0:101*/,xs/*0:11*/) = accum/*0*/ [x/*0:101*/] xs/*0:11*/ with accum ys/*0:01*/ (x/*0:101*/,xs/*0:11*/) = accum/*1*/ (x/*0:101*/:ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ x/*0:1*/ = reverse (x/*0:1*/:ys/*0:01*/) {
  rule #0: accum ys (x,xs) = accum (x:ys) xs
  rule #1: accum ys x = reverse (x:ys)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	, state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
} end;
tuple [] = ();
tuple (x/*0:101*/:xs/*0:11*/) = accum/*0*/ (t/*0*/ x/*0:101*/) xs/*0:11*/ with t x@(_/*0:101*/,_/*0:11*/) = reverse x/*0:1*/; t x/*0:1*/ = x/*0:1*/ {
  rule #0: t x@(_,_) = reverse x
  rule #1: t x = x
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	, state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
}; accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (t/*1*/ x/*0:101*/,ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ [] = t/*1*/ ys/*0:01*/; accum ys/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: accum ys (x:xs) = accum (t x,ys) xs
  rule #1: accum ys [] = t ys
  rule #2: accum ys xs = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
	<var> state 12
  state 12: #0 #2
  state 13: #1 #2
} end;
tuple x@() = x/*0:1*/;
tuple x@(_/*0:101*/,_/*0:11*/) = x/*0:1*/;
list [] = [];
list (x/*0:101*/:xs/*0:11*/) = accum/*0*/ [x/*0:101*/] xs/*0:11*/ with accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (x/*0:101*/:ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ [] = reverse ys/*0:01*/; accum ys/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: accum ys (x:xs) = accum (x:ys) xs
  rule #1: accum ys [] = reverse ys
  rule #2: accum ys xs = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
	<var> state 12
  state 12: #0 #2
  state 13: #1 #2
} end;
stream [] = [];
stream (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:xs/*0:11*/ if thunkp xs/*0:11*/;
stream (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:stream xs/*1:11*/&;
stream () = [];
stream xs@(_/*0:101*/,_/*0:11*/) = stream (list xs/*0:1*/);
n1/*0:0101*/:n2/*0:011*/..m/*0:1*/ = if nanp n1/*2:0101*/||nanp m/*2:1*/||double m/*2:1*/===-s/*0:01*/ then [] else if double m/*2:1*/===s/*0:01*/ then iterate (flip (+) k/*1:*/) n1/*2:0101*/ else iterwhile (p/*0:1*/ (m/*2:1*/+0.5*k/*1:*/)) (flip (+) k/*1:*/) n1/*2:0101*/ when s/*0:01*/,p/*0:1*/ = if k/*0:*/>0 then inf,(>=) else -inf,(<=) {
  rule #0: s,p = if k>0 then inf,(>=) else -inf,(<=)
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end if realp k/*0:*/&&k/*0:*/~=0&&~infp n1/*1:0101*/&&~infp n2/*1:011*/ when k/*0:*/ = n2/*0:011*/-n1/*0:0101*/ {
  rule #0: k = n2-n1
  state 0: #0
	<var> state 1
  state 1: #0
} end;
n/*0:01*/..m/*0:1*/ = if nanp n/*0:01*/||nanp m/*0:1*/||double m/*0:1*/===-inf then [] else if double m/*0:1*/===inf then iterate (flip (+) 1) n/*0:01*/ else iterwhile ((>=) m/*0:1*/) (flip (+) 1) n/*0:01*/ if ~listp n/*0:01*/&&~infp n/*0:01*/;
all p/*0:01*/ [] = 1;
all p/*0:01*/ (x/*0:101*/:xs/*0:11*/) = p/*0:01*/ x/*0:101*/&&all p/*0:01*/ xs/*0:11*/;
any p/*0:01*/ [] = 0;
any p/*0:01*/ (x/*0:101*/:xs/*0:11*/) = p/*0:01*/ x/*0:101*/||any p/*0:01*/ xs/*0:11*/;
do f/*0:01*/ [] = ();
do f/*0:01*/ (x/*0:101*/:xs/*0:11*/) = f/*0:01*/ x/*0:101*/$$do f/*0:01*/ xs/*0:11*/;
drop n/*0:01*/::int [] = [];
drop n/*0:01*/::int ys@(x/*0:101*/:xs/*0:11*/) = drop (n/*0:01*/-1) xs/*0:11*/ if n/*0:01*/>1;
drop n/*0:01*/::int ys@(x/*0:101*/:xs/*0:11*/) = xs/*0:11*/ if n/*0:01*/==1;
drop n/*0:01*/::int ys@(x/*0:101*/:xs/*0:11*/) = ys/*0:1*/;
dropwhile p/*0:01*/ [] = [];
dropwhile p/*0:01*/ ys@(x/*0:101*/:xs/*0:11*/) = dropwhile p/*0:01*/ xs/*0:11*/ if p/*0:01*/ x/*0:101*/;
dropwhile p/*0:01*/ ys@(x/*0:101*/:xs/*0:11*/) = ys/*0:1*/;
filter p/*0:01*/ [] = [];
filter p/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*1*/ (add/*1*/ p/*1:01*/ x/*0:101*/ zs/*0:01*/) (filter p/*2:01*/ xs/*1:11*/&) if thunkp xs/*0:11*/; tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tick/*1*/ (add/*1*/ p/*1:01*/ x/*0:101*/ zs/*0:01*/) xs/*0:11*/; tick zs/*0:01*/ [] = tack/*1*/ zs/*0:01*/ []; tick _/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: tick zs (x:xs) = tack (add p x zs) (filter p xs&) if thunkp xs
  rule #1: tick zs (x:xs) = tick (add p x zs) xs
  rule #2: tick zs [] = tack zs []
  rule #3: tick _ xs = throw (bad_list_value xs)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #3
  state 3: #0 #1 #3
	<var> state 4
	<app> state 6
  state 4: #3
	<var> state 5
  state 5: #3
  state 6: #0 #1 #3
	<var> state 7
	: state 10
  state 7: #3
	<var> state 8
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #0 #1 #3
	<var> state 11
  state 11: #0 #1 #3
	<var> state 12
  state 12: #0 #1 #3
  state 13: #2 #3
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ xs/*0:011*/ (x/*0:0101*/:ys/*0:1*/); tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (x:ys)
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
}; add p/*0:001*/ x/*0:01*/ xs/*0:1*/ = if p/*0:001*/ x/*0:01*/ then x/*0:01*/:xs/*0:1*/ else xs/*0:1*/ {
  rule #0: add p x xs = if p x then x:xs else xs
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
	<var> state 3
  state 3: #0
} end;
foldl f/*0:001*/ a/*0:01*/ [] = a/*0:01*/;
foldl f/*0:001*/ a/*0:01*/ (x/*0:101*/:xs/*0:11*/) = foldl f/*0:001*/ (f/*0:001*/ a/*0:01*/ x/*0:101*/) xs/*0:11*/;
foldl1 f/*0:01*/ (x/*0:101*/:xs/*0:11*/) = foldl f/*0:01*/ x/*0:101*/ xs/*0:11*/;
foldr f/*0:001*/ a/*0:01*/ [] = a/*0:01*/;
foldr f/*0:001*/ a/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*1*/ (x/*0:101*/:zs/*0:01*/) (foldr f/*2:001*/ a/*2:01*/ xs/*1:11*/&) if thunkp xs/*0:11*/; tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tick/*1*/ (x/*0:101*/:zs/*0:01*/) xs/*0:11*/; tick zs/*0:01*/ [] = tack/*1*/ zs/*0:01*/ a/*1:01*/; tick zs/*0:01*/ xs/*0:1*/ = tack/*1*/ zs/*0:01*/ (foldr f/*1:001*/ a/*1:01*/ xs/*0:1*/) {
  rule #0: tick zs (x:xs) = tack (x:zs) (foldr f a xs&) if thunkp xs
  rule #1: tick zs (x:xs) = tick (x:zs) xs
  rule #2: tick zs [] = tack zs a
  rule #3: tick zs xs = tack zs (foldr f a xs)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #3
  state 3: #0 #1 #3
	<var> state 4
	<app> state 6
  state 4: #3
	<var> state 5
  state 5: #3
  state 6: #0 #1 #3
	<var> state 7
	: state 10
  state 7: #3
	<var> state 8
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #0 #1 #3
	<var> state 11
  state 11: #0 #1 #3
	<var> state 12
  state 12: #0 #1 #3
  state 13: #2 #3
}; tack (x/*0:0101*/:xs/*0:011*/) y/*0:1*/ = tack/*1*/ xs/*0:011*/ (f/*1:001*/ x/*0:0101*/ y/*0:1*/); tack [] y/*0:1*/ = y/*0:1*/ {
  rule #0: tack (x:xs) y = tack xs (f x y)
  rule #1: tack [] y = y
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
foldr1 f/*0:01*/ [x/*0:101*/] = x/*0:101*/;
foldr1 f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ ys@(_/*0:101*/:xs/*0:11*/) = tack/*1*/ zs/*0:01*/ (foldr1 f/*2:01*/ ys/*1:1*/&) if thunkp xs/*0:11*/; tick zs/*0:01*/ xs/*0:1*/ = case xs/*0:1*/ of [x/*0:01*/] = tack/*2*/ zs/*1:01*/ x/*0:01*/; x/*0:01*/:xs/*0:1*/ = tick/*2*/ (x/*0:01*/:zs/*1:01*/) xs/*0:1*/; _/*0:*/ = tack/*2*/ zs/*1:01*/ (foldr1 f/*2:01*/ xs/*1:1*/) {
  rule #0: [x] = tack zs x
  rule #1: x:xs = tick (x:zs) xs
  rule #2: _ = tack zs (foldr1 f xs)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #1 #2
	<var> state 10
  state 10: #0 #1 #2
	<var> state 11
	[] state 12
  state 11: #1 #2
  state 12: #0 #1 #2
} end {
  rule #0: tick zs ys@(_:xs) = tack zs (foldr1 f ys&) if thunkp xs
  rule #1: tick zs xs = case xs of [x] = tack zs x; x:xs = tick (x:zs) xs; _ = tack zs (foldr1 f xs) end
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	: state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
}; tack (x/*0:0101*/:xs/*0:011*/) y/*0:1*/ = tack/*1*/ xs/*0:011*/ (f/*1:01*/ x/*0:0101*/ y/*0:1*/); tack [] y/*0:1*/ = y/*0:1*/ {
  rule #0: tack (x:xs) y = tack xs (f x y)
  rule #1: tack [] y = y
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
head (x/*0:101*/:xs/*0:11*/) = x/*0:101*/;
init [x/*0:101*/] = [];
init xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ ys@(_/*0:101*/:xs/*0:11*/) = tack/*1*/ zs/*0:01*/ (init ys/*1:1*/&) if thunkp xs/*0:11*/; tick zs/*0:01*/ xs/*0:1*/ = case xs/*0:1*/ of [x/*0:01*/] = tack/*2*/ zs/*1:01*/ []; x/*0:01*/:xs/*0:1*/ = tick/*2*/ (x/*0:01*/:zs/*1:01*/) xs/*0:1*/; _/*0:*/ = tack/*2*/ zs/*1:01*/ (init xs/*1:1*/) {
  rule #0: [x] = tack zs []
  rule #1: x:xs = tick (x:zs) xs
  rule #2: _ = tack zs (init xs)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #1 #2
	<var> state 10
  state 10: #0 #1 #2
	<var> state 11
	[] state 12
  state 11: #1 #2
  state 12: #0 #1 #2
} end {
  rule #0: tick zs ys@(_:xs) = tack zs (init ys&) if thunkp xs
  rule #1: tick zs xs = case xs of [x] = tack zs []; x:xs = tick (x:zs) xs; _ = tack zs (init xs) end
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	: state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ xs/*0:011*/ (x/*0:0101*/:ys/*0:1*/); tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (x:ys)
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
last [x/*0:101*/] = x/*0:101*/;
last (x/*0:101*/:xs/*0:11*/) = last xs/*0:11*/;
map f/*0:01*/ [] = [];
map f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*1*/ (f/*1:01*/ x/*0:101*/:zs/*0:01*/) (map f/*2:01*/ xs/*1:11*/&) if thunkp xs/*0:11*/; tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tick/*1*/ (f/*1:01*/ x/*0:101*/:zs/*0:01*/) xs/*0:11*/; tick zs/*0:01*/ [] = tack/*1*/ zs/*0:01*/ []; tick zs/*0:01*/ xs/*0:1*/ = tack/*1*/ zs/*0:01*/ (map f/*1:01*/ xs/*0:1*/) {
  rule #0: tick zs (x:xs) = tack (f x:zs) (map f xs&) if thunkp xs
  rule #1: tick zs (x:xs) = tick (f x:zs) xs
  rule #2: tick zs [] = tack zs []
  rule #3: tick zs xs = tack zs (map f xs)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #3
  state 3: #0 #1 #3
	<var> state 4
	<app> state 6
  state 4: #3
	<var> state 5
  state 5: #3
  state 6: #0 #1 #3
	<var> state 7
	: state 10
  state 7: #3
	<var> state 8
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #0 #1 #3
	<var> state 11
  state 11: #0 #1 #3
	<var> state 12
  state 12: #0 #1 #3
  state 13: #2 #3
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ xs/*0:011*/ (x/*0:0101*/:ys/*0:1*/); tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (x:ys)
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
scanl f/*0:001*/ a/*0:01*/ [] = [a/*0:01*/];
scanl f/*0:001*/ a/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ a/*0:01*/ [] xs/*0:1*/ with tick a/*0:001*/ zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*1*/ (a/*0:001*/:zs/*0:01*/) (scanl f/*2:001*/ (f/*2:001*/ a/*1:001*/ x/*1:101*/) xs/*1:11*/&) if thunkp xs/*0:11*/; tick a/*0:001*/ zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tick/*1*/ (f/*1:001*/ a/*0:001*/ x/*0:101*/) (a/*0:001*/:zs/*0:01*/) xs/*0:11*/; tick a/*0:001*/ zs/*0:01*/ [] = tack/*1*/ zs/*0:01*/ [a/*0:001*/]; tick a/*0:001*/ zs/*0:01*/ xs/*0:1*/ = tack/*1*/ zs/*0:01*/ (scanl f/*1:001*/ a/*0:001*/ xs/*0:1*/) {
  rule #0: tick a zs (x:xs) = tack (a:zs) (scanl f (f a x) xs&) if thunkp xs
  rule #1: tick a zs (x:xs) = tick (f a x) (a:zs) xs
  rule #2: tick a zs [] = tack zs [a]
  rule #3: tick a zs xs = tack zs (scanl f a xs)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
  state 2: #0 #1 #2 #3
	<var> state 3
	<app> state 4
	[] state 14
  state 3: #3
  state 4: #0 #1 #3
	<var> state 5
	<app> state 7
  state 5: #3
	<var> state 6
  state 6: #3
  state 7: #0 #1 #3
	<var> state 8
	: state 11
  state 8: #3
	<var> state 9
  state 9: #3
	<var> state 10
  state 10: #3
  state 11: #0 #1 #3
	<var> state 12
  state 12: #0 #1 #3
	<var> state 13
  state 13: #0 #1 #3
  state 14: #2 #3
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ xs/*0:011*/ (x/*0:0101*/:ys/*0:1*/); tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (x:ys)
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
scanl1 f/*0:01*/ [] = [];
scanl1 f/*0:01*/ (x/*0:101*/:xs/*0:11*/) = scanl f/*0:01*/ x/*0:101*/ xs/*0:11*/;
scanr f/*0:001*/ a/*0:01*/ [] = [a/*0:01*/];
scanr f/*0:001*/ a/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*4*/ zs/*3:01*/ us/*0:*/ when ys/*0:*/ = scanr f/*2:001*/ a/*2:01*/ xs/*1:11*/&; y/*0:*/ = (case ys/*1:*/ of y/*0:01*/:_/*0:1*/ = y/*0:01*/; scanr _/*0:001*/ _/*0:01*/ ys/*0:1*/ = throw (bad_list_value ys/*0:1*/); _/*0:*/ = throw (bad_list_value ys/*2:*/) {
  rule #0: y:_ = y
  rule #1: scanr _ _ ys = throw (bad_list_value ys)
  rule #2: _ = throw (bad_list_value ys)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	<app> state 9
	: state 18
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
	scanr state 14
  state 10: #2
	<var> state 11
  state 11: #2
	<var> state 12
  state 12: #2
	<var> state 13
  state 13: #2
  state 14: #1 #2
	<var> state 15
  state 15: #1 #2
	<var> state 16
  state 16: #1 #2
	<var> state 17
  state 17: #1 #2
  state 18: #0 #2
	<var> state 19
  state 19: #0 #2
	<var> state 20
  state 20: #0 #2
} end)&; us/*0:*/ = f/*3:001*/ x/*2:101*/ y/*0:*/:ys/*1:*/ {
  rule #0: us = f x y:ys
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: y = (case ys of y:_ = y; scanr _ _ ys = throw (bad_list_value ys); _ = throw (bad_list_value ys) end)&
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: ys = scanr f a xs&
  state 0: #0
	<var> state 1
  state 1: #0
} end if thunkp xs/*0:11*/; tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*1*/ zs/*0:01*/ (f/*3:001*/ x/*2:101*/ (y/*0:01*/ when y/*0:01*/:_/*0:1*/ = ys/*1:*/ {
  rule #0: y:_ = ys
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end)&:ys/*0:*/ when ys/*0:*/ = scanr f/*2:001*/ a/*2:01*/ xs/*1:11*/& {
  rule #0: ys = scanr f a xs&
  state 0: #0
	<var> state 1
  state 1: #0
} end) if thunkp xs/*0:11*/; tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tick/*1*/ (x/*0:101*/:zs/*0:01*/) xs/*0:11*/; tick zs/*0:01*/ [] = tack/*1*/ zs/*0:01*/ [a/*1:01*/]; tick zs/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: tick zs (x:xs) = tack zs us when ys = scanr f a xs&; y = (case ys of y:_ = y; scanr _ _ ys = throw (bad_list_value ys); _ = throw (bad_list_value ys) end)&; us = f x y:ys end if thunkp xs
  rule #1: tick zs (x:xs) = tack zs (f x (y when y:_ = ys end)&:ys when ys = scanr f a xs& end) if thunkp xs
  rule #2: tick zs (x:xs) = tick (x:zs) xs
  rule #3: tick zs [] = tack zs [a]
  rule #4: tick zs xs = throw (bad_list_value xs)
  state 0: #0 #1 #2 #3 #4
	<var> state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #4
  state 3: #0 #1 #2 #4
	<var> state 4
	<app> state 6
  state 4: #4
	<var> state 5
  state 5: #4
  state 6: #0 #1 #2 #4
	<var> state 7
	: state 10
  state 7: #4
	<var> state 8
  state 8: #4
	<var> state 9
  state 9: #4
  state 10: #0 #1 #2 #4
	<var> state 11
  state 11: #0 #1 #2 #4
	<var> state 12
  state 12: #0 #1 #2 #4
  state 13: #3 #4
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*2*/ xs/*1:011*/ (f/*2:001*/ x/*1:0101*/ y/*0:01*/:ys/*1:1*/) when y/*0:01*/:_/*0:1*/ = ys/*0:1*/ {
  rule #0: y:_ = ys
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end; tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (f x y:ys) when y:_ = ys end
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
scanr1 f/*0:01*/ [] = [];
scanr1 f/*0:01*/ [x/*0:101*/] = [x/*0:101*/];
scanr1 f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*4*/ zs/*3:01*/ us/*0:*/ when ys/*0:*/ = scanr1 f/*2:01*/ xs/*1:11*/&; y/*0:*/ = (case ys/*1:*/ of y/*0:01*/:_/*0:1*/ = y/*0:01*/; scanr1 _/*0:01*/ ys/*0:1*/ = throw (bad_list_value ys/*0:1*/); _/*0:*/ = throw (bad_list_value ys/*2:*/) {
  rule #0: y:_ = y
  rule #1: scanr1 _ ys = throw (bad_list_value ys)
  rule #2: _ = throw (bad_list_value ys)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	: state 9
	scanr1 state 12
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #2
	<var> state 10
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
  state 12: #1 #2
	<var> state 13
  state 13: #1 #2
	<var> state 14
  state 14: #1 #2
} end)&; us/*0:*/ = f/*3:01*/ x/*2:101*/ y/*0:*/:ys/*1:*/ {
  rule #0: us = f x y:ys
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: y = (case ys of y:_ = y; scanr1 _ ys = throw (bad_list_value ys); _ = throw (bad_list_value ys) end)&
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: ys = scanr1 f xs&
  state 0: #0
	<var> state 1
  state 1: #0
} end if thunkp xs/*0:11*/; tick zs/*0:01*/ xs/*0:1*/ = case xs/*0:1*/ of [x/*0:01*/] = tack/*2*/ zs/*1:01*/ [x/*0:01*/]; x/*0:01*/:xs/*0:1*/ = tick/*2*/ (x/*0:01*/:zs/*1:01*/) xs/*0:1*/; _/*0:*/ = throw (bad_list_value xs/*1:1*/) {
  rule #0: [x] = tack zs [x]
  rule #1: x:xs = tick (x:zs) xs
  rule #2: _ = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #1 #2
	<var> state 10
  state 10: #0 #1 #2
	<var> state 11
	[] state 12
  state 11: #1 #2
  state 12: #0 #1 #2
} end {
  rule #0: tick zs (x:xs) = tack zs us when ys = scanr1 f xs&; y = (case ys of y:_ = y; scanr1 _ ys = throw (bad_list_value ys); _ = throw (bad_list_value ys) end)&; us = f x y:ys end if thunkp xs
  rule #1: tick zs xs = case xs of [x] = tack zs [x]; x:xs = tick (x:zs) xs; _ = throw (bad_list_value xs) end
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	: state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*2*/ xs/*1:011*/ (f/*2:01*/ x/*1:0101*/ y/*0:01*/:ys/*1:1*/) when y/*0:01*/:_/*0:1*/ = ys/*0:1*/ {
  rule #0: y:_ = ys
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end; tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (f x y:ys) when y:_ = ys end
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
tail (x/*0:101*/:xs/*0:11*/) = xs/*0:11*/;
take n/*0:01*/::int [] = [];
take n/*0:01*/::int xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ n/*0:01*/ [] xs/*0:1*/ with tick n/*0:001*/::int zs/*0:01*/ xs/*0:1*/ = tack/*1*/ zs/*0:01*/ [] if n/*0:001*/<=0; tick n/*0:001*/::int zs/*0:01*/ xs/*0:1*/ = tack/*1*/ zs/*0:01*/ (take n/*1:001*/ xs/*1:1*/&) if thunkp xs/*0:1*/; tick n/*0:001*/::int zs/*0:01*/ xs/*0:1*/ = case xs/*0:1*/ of [] = tack/*2*/ zs/*1:01*/ []; x/*0:01*/:xs/*0:1*/ = tick/*2*/ (n/*1:001*/-1) (x/*0:01*/:zs/*1:01*/) xs/*0:1*/; _/*0:*/ = tack/*2*/ zs/*1:01*/ (take n/*1:001*/ xs/*1:1*/) {
  rule #0: [] = tack zs []
  rule #1: x:xs = tick (n-1) (x:zs) xs
  rule #2: _ = tack zs (take n xs)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
	[] state 12
  state 1: #2
  state 2: #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
  state 10: #1 #2
	<var> state 11
  state 11: #1 #2
  state 12: #0 #2
} end {
  rule #0: tick n::int zs xs = tack zs [] if n<=0
  rule #1: tick n::int zs xs = tack zs (take n xs&) if thunkp xs
  rule #2: tick n::int zs xs = case xs of [] = tack zs []; x:xs = tick (n-1) (x:zs) xs; _ = tack zs (take n xs) end
  state 0: #0 #1 #2
	<var>::int state 1
  state 1: #0 #1 #2
	<var> state 2
  state 2: #0 #1 #2
	<var> state 3
  state 3: #0 #1 #2
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ xs/*0:011*/ (x/*0:0101*/:ys/*0:1*/); tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (x:ys)
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
takewhile p/*0:01*/ [] = [];
takewhile p/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ xs/*0:1*/ = tack/*1*/ zs/*0:01*/ (takewhile p/*2:01*/ xs/*1:1*/&) if thunkp xs/*0:1*/; tick zs/*0:01*/ xs/*0:1*/ = case xs/*0:1*/ of [] = tack/*2*/ zs/*1:01*/ []; x/*0:01*/:xs/*0:1*/ = tick/*2*/ (x/*0:01*/:zs/*1:01*/) xs/*0:1*/ if p/*2:01*/ x/*0:01*/; x/*0:01*/:xs/*0:1*/ = tack/*2*/ zs/*1:01*/ []; _/*0:*/ = tack/*2*/ zs/*1:01*/ (takewhile p/*2:01*/ xs/*1:1*/) {
  rule #0: [] = tack zs []
  rule #1: x:xs = tick (x:zs) xs if p x
  rule #2: x:xs = tack zs []
  rule #3: _ = tack zs (takewhile p xs)
  state 0: #0 #1 #2 #3
	<var> state 1
	<app> state 2
	[] state 12
  state 1: #3
  state 2: #1 #2 #3
	<var> state 3
	<app> state 5
  state 3: #3
	<var> state 4
  state 4: #3
  state 5: #1 #2 #3
	<var> state 6
	: state 9
  state 6: #3
	<var> state 7
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #1 #2 #3
	<var> state 10
  state 10: #1 #2 #3
	<var> state 11
  state 11: #1 #2 #3
  state 12: #0 #3
} end {
  rule #0: tick zs xs = tack zs (takewhile p xs&) if thunkp xs
  rule #1: tick zs xs = case xs of [] = tack zs []; x:xs = tick (x:zs) xs if p x; x:xs = tack zs []; _ = tack zs (takewhile p xs) end
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ xs/*0:011*/ (x/*0:0101*/:ys/*0:1*/); tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (x:ys)
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
cat [] = [];
cat xs@(_/*0:101*/:_/*0:11*/) = foldr/*0*/ (tick/*0*/ []) [] xs/*0:1*/ with foldr f/*0:001*/ a/*0:01*/ [] = a/*0:01*/; foldr f/*0:001*/ a/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*1*/ (x/*0:101*/:zs/*0:01*/) (foldr/*3*/ f/*2:001*/ a/*2:01*/ xs/*1:11*/&) if thunkp xs/*0:11*/; tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tick/*1*/ (x/*0:101*/:zs/*0:01*/) xs/*0:11*/; tick zs/*0:01*/ [] = tack/*1*/ zs/*0:01*/ a/*1:01*/; tick zs/*0:01*/ xs/*0:1*/ = tack/*1*/ zs/*0:01*/ (foldr/*2*/ f/*1:001*/ a/*1:01*/ xs/*0:1*/) {
  rule #0: tick zs (x:xs) = tack (x:zs) (foldr f a xs&) if thunkp xs
  rule #1: tick zs (x:xs) = tick (x:zs) xs
  rule #2: tick zs [] = tack zs a
  rule #3: tick zs xs = tack zs (foldr f a xs)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #3
  state 3: #0 #1 #3
	<var> state 4
	<app> state 6
  state 4: #3
	<var> state 5
  state 5: #3
  state 6: #0 #1 #3
	<var> state 7
	: state 10
  state 7: #3
	<var> state 8
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #0 #1 #3
	<var> state 11
  state 11: #0 #1 #3
	<var> state 12
  state 12: #0 #1 #3
  state 13: #2 #3
}; tack (x/*0:0101*/:xs/*0:011*/) y/*0:1*/ = tack/*1*/ xs/*0:011*/ (f/*1:001*/ x/*0:0101*/ y/*0:1*/); tack [] y/*0:1*/ = y/*0:1*/ {
  rule #0: tack (x:xs) y = tack xs (f x y)
  rule #1: tack [] y = y
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end; foldr (tick _/*0:0011*/) [] x/*0:1*/ = cat x/*0:1*/ {
  rule #0: foldr f a [] = a
  rule #1: foldr f a xs@(_:_) = tick [] xs with tick zs (x:xs) = tack (x:zs) (foldr f a xs&) if thunkp xs; tick zs (x:xs) = tick (x:zs) xs; tick zs [] = tack zs a; tick zs xs = tack zs (foldr f a xs); tack (x:xs) y = tack xs (f x y); tack [] y = y end
  rule #2: foldr (tick _) [] x = cat x
  state 0: #0 #1 #2
	<var> state 1
	<app> state 9
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
	<app> state 3
	[] state 8
  state 3: #1
	<app> state 4
  state 4: #1
	: state 5
  state 5: #1
	<var> state 6
  state 6: #1
	<var> state 7
  state 7: #1
  state 8: #0
  state 9: #0 #1 #2
	<var> state 10
	tick state 19
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
	<app> state 13
	[] state 18
  state 13: #1
	<app> state 14
  state 14: #1
	: state 15
  state 15: #1
	<var> state 16
  state 16: #1
	<var> state 17
  state 17: #1
  state 18: #0
  state 19: #0 #1 #2
	<var> state 20
  state 20: #0 #1 #2
	<var> state 21
	[] state 28
  state 21: #0 #1
	<app> state 22
	[] state 27
  state 22: #1
	<app> state 23
  state 23: #1
	: state 24
  state 24: #1
	<var> state 25
  state 25: #1
	<var> state 26
  state 26: #1
  state 27: #0
  state 28: #0 #1 #2
	<var> state 29
	<app> state 30
	[] state 40
  state 29: #2
  state 30: #1 #2
	<var> state 31
	<app> state 33
  state 31: #2
	<var> state 32
  state 32: #2
  state 33: #1 #2
	<var> state 34
	: state 37
  state 34: #2
	<var> state 35
  state 35: #2
	<var> state 36
  state 36: #2
  state 37: #1 #2
	<var> state 38
  state 38: #1 #2
	<var> state 39
  state 39: #1 #2
  state 40: #0 #2
}; tick zs/*0:001*/ (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ (x/*0:0101*/:zs/*0:001*/) (tick/*2*/ [] xs/*1:011*/ ys/*1:1*/&) if thunkp xs/*0:011*/; tick zs/*0:001*/ (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tick/*1*/ (x/*0:0101*/:zs/*0:001*/) xs/*0:011*/ ys/*0:1*/; tick zs/*0:001*/ [] ys/*0:1*/ = tack/*1*/ zs/*0:001*/ ys/*0:1*/; tick zs/*0:001*/ xs/*0:01*/ ys/*0:1*/ = tack/*1*/ zs/*0:001*/ (xs/*0:01*/+ys/*0:1*/) {
  rule #0: tick zs (x:xs) ys = tack (x:zs) (tick [] xs ys&) if thunkp xs
  rule #1: tick zs (x:xs) ys = tick (x:zs) xs ys
  rule #2: tick zs [] ys = tack zs ys
  rule #3: tick zs xs ys = tack zs (xs+ys)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<app> state 4
	[] state 17
  state 2: #3
	<var> state 3
  state 3: #3
  state 4: #0 #1 #3
	<var> state 5
	<app> state 8
  state 5: #3
	<var> state 6
  state 6: #3
	<var> state 7
  state 7: #3
  state 8: #0 #1 #3
	<var> state 9
	: state 13
  state 9: #3
	<var> state 10
  state 10: #3
	<var> state 11
  state 11: #3
	<var> state 12
  state 12: #3
  state 13: #0 #1 #3
	<var> state 14
  state 14: #0 #1 #3
	<var> state 15
  state 15: #0 #1 #3
	<var> state 16
  state 16: #0 #1 #3
  state 17: #2 #3
	<var> state 18
  state 18: #2 #3
}; tack (x/*0:0101*/:xs/*0:011*/) ys/*0:1*/ = tack/*1*/ xs/*0:011*/ (x/*0:0101*/:ys/*0:1*/); tack [] ys/*0:1*/ = ys/*0:1*/ {
  rule #0: tack (x:xs) ys = tack xs (x:ys)
  rule #1: tack [] ys = ys
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
catmap f/*0:01*/ [] = [];
catmap f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = cat (map f/*0:01*/ xs/*0:1*/);
listmap f/*0:01*/ [] = [];
listmap f/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = map f/*0:01*/ xs/*0:1*/;
index [] _/*0:1*/ = -1;
index (x/*0:0101*/:xs/*0:011*/) y/*0:1*/ = search/*0*/ 0 (x/*0:0101*/:xs/*0:011*/) with search _/*0:01*/ [] = -1; search n/*0:01*/::int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ if x/*0:101*/==y/*1:1*/; search n/*0:01*/::int (x/*0:101*/:xs/*0:11*/) = search/*1*/ (n/*0:01*/+1) xs/*0:11*/; search _/*0:01*/ xs/*0:1*/ = index xs/*0:1*/ y/*1:1*/ {
  rule #0: search _ [] = -1
  rule #1: search n::int (x:xs) = n if x==y
  rule #2: search n::int (x:xs) = search (n+1) xs
  rule #3: search _ xs = index xs y
  state 0: #0 #1 #2 #3
	<var> state 1
	<var>::int state 4
  state 1: #0 #3
	<var> state 2
	[] state 3
  state 2: #3
  state 3: #0 #3
  state 4: #0 #1 #2 #3
	<var> state 5
	<app> state 6
	[] state 16
  state 5: #3
  state 6: #1 #2 #3
	<var> state 7
	<app> state 9
  state 7: #3
	<var> state 8
  state 8: #3
  state 9: #1 #2 #3
	<var> state 10
	: state 13
  state 10: #3
	<var> state 11
  state 11: #3
	<var> state 12
  state 12: #3
  state 13: #1 #2 #3
	<var> state 14
  state 14: #1 #2 #3
	<var> state 15
  state 15: #1 #2 #3
  state 16: #0 #3
} end;
iterate f/*0:01*/ x/*0:1*/ = x/*0:1*/:iterate f/*1:01*/ (f/*1:01*/ x/*1:1*/)&;
repeat x/*0:1*/ = x/*0:1*/:repeat x/*1:1*/&;
cycle ys@(x/*0:101*/:xs/*0:11*/) = x/*0:101*/:(xs/*1:11*/+cycle ys/*1:1*/)&;
iterwhile p/*0:001*/ f/*0:01*/ x/*0:1*/ = accum/*0*/ [] p/*0:001*/ f/*0:01*/ x/*0:1*/ with accum xs/*0:0001*/ p/*0:001*/ f/*0:01*/ x/*0:1*/ = accum/*1*/ (x/*0:1*/:xs/*0:0001*/) p/*0:001*/ f/*0:01*/ (f/*0:01*/ x/*0:1*/) if p/*0:001*/ x/*0:1*/; accum xs/*0:0001*/ p/*0:001*/ f/*0:01*/ x/*0:1*/ = reverse xs/*0:0001*/ {
  rule #0: accum xs p f x = accum (x:xs) p f (f x) if p x
  rule #1: accum xs p f x = reverse xs
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
	<var> state 3
  state 3: #0 #1
	<var> state 4
  state 4: #0 #1
} end;
iteraten n/*0:001*/::int f/*0:01*/ x/*0:1*/ = [] if n/*0:001*/<=0;
iteraten n/*0:001*/::int f/*0:01*/ x/*0:1*/ = accum/*0*/ [] n/*0:001*/ f/*0:01*/ x/*0:1*/ with accum xs/*0:0001*/ n/*0:001*/::int f/*0:01*/ x/*0:1*/ = reverse (x/*0:1*/:xs/*0:0001*/) if n/*0:001*/==1; accum xs/*0:0001*/ n/*0:001*/::int f/*0:01*/ x/*0:1*/ = accum/*1*/ (x/*0:1*/:xs/*0:0001*/) (n/*0:001*/-1) f/*0:01*/ (f/*0:01*/ x/*0:1*/) {
  rule #0: accum xs n::int f x = reverse (x:xs) if n==1
  rule #1: accum xs n::int f x = accum (x:xs) (n-1) f (f x)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::int state 2
  state 2: #0 #1
	<var> state 3
  state 3: #0 #1
	<var> state 4
  state 4: #0 #1
} end;
repeatn n/*0:01*/::int x/*0:1*/ = accum/*0*/ [] n/*0:01*/ x/*0:1*/ with accum xs/*0:001*/ n/*0:01*/::int x/*0:1*/ = xs/*0:001*/ if n/*0:01*/<=0; accum xs/*0:001*/ n/*0:01*/::int x/*0:1*/ = accum/*1*/ (x/*0:1*/:xs/*0:001*/) (n/*0:01*/-1) x/*0:1*/ {
  rule #0: accum xs n::int x = xs if n<=0
  rule #1: accum xs n::int x = accum (x:xs) (n-1) x
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::int state 2
  state 2: #0 #1
	<var> state 3
  state 3: #0 #1
} end;
cyclen n/*0:01*/::int (x/*0:101*/:xs/*0:11*/) = [] if n/*0:01*/<=0;
cyclen n/*0:01*/::int (x/*0:101*/:xs/*0:11*/) = accum/*0*/ [] n/*2:01*/ with accum ys/*0:01*/ n/*0:1*/::int = cat ys/*0:01*/+take n/*0:1*/ xs/*2:*/ if n/*0:1*/<=m/*1:*/; accum ys/*0:01*/ n/*0:1*/::int = accum/*1*/ (xs/*2:*/:ys/*0:01*/) (n/*0:1*/-m/*1:*/) {
  rule #0: accum ys n::int = cat ys+take n xs if n<=m
  rule #1: accum ys n::int = accum (xs:ys) (n-m)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::int state 2
  state 2: #0 #1
} end when xs/*0:*/ = x/*0:101*/:xs/*0:11*/; m/*0:*/::int = #xs/*0:*/ {
  rule #0: m::int = #xs
  state 0: #0
	<var>::int state 1
  state 1: #0
} {
  rule #0: xs = x:xs
  state 0: #0
	<var> state 1
  state 1: #0
} end if rlistp xs/*0:11*/;
zip [] _/*0:1*/ = [];
zip _/*0:01*/ [] = [];
zip xs@(_/*0:0101*/:_/*0:011*/) ys@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:01*/ ys/*0:1*/ with tick us/*0:001*/ (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = tack/*1*/ ((x/*0:0101*/,y/*0:101*/):us/*0:001*/) (zip xs/*1:011*/ ys/*1:11*/&) if thunkp xs/*0:011*/||thunkp ys/*0:11*/; tick us/*0:001*/ (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = tick/*1*/ ((x/*0:0101*/,y/*0:101*/):us/*0:001*/) xs/*0:011*/ ys/*0:11*/; tick us/*0:001*/ [] _/*0:1*/ = tack/*1*/ us/*0:001*/ []; tick us/*0:001*/ _/*0:01*/ [] = tack/*1*/ us/*0:001*/ []; tick us/*0:001*/ xs/*0:01*/ ys/*0:1*/ = tack/*1*/ us/*0:001*/ (zip xs/*0:01*/ ys/*0:1*/) {
  rule #0: tick us (x:xs) (y:ys) = tack ((x,y):us) (zip xs ys&) if thunkp xs||thunkp ys
  rule #1: tick us (x:xs) (y:ys) = tick ((x,y):us) xs ys
  rule #2: tick us [] _ = tack us []
  rule #3: tick us _ [] = tack us []
  rule #4: tick us xs ys = tack us (zip xs ys)
  state 0: #0 #1 #2 #3 #4
	<var> state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<app> state 5
	[] state 31
  state 2: #3 #4
	<var> state 3
	[] state 4
  state 3: #4
  state 4: #3 #4
  state 5: #0 #1 #3 #4
	<var> state 6
	<app> state 10
  state 6: #3 #4
	<var> state 7
  state 7: #3 #4
	<var> state 8
	[] state 9
  state 8: #4
  state 9: #3 #4
  state 10: #0 #1 #3 #4
	<var> state 11
	: state 16
  state 11: #3 #4
	<var> state 12
  state 12: #3 #4
	<var> state 13
  state 13: #3 #4
	<var> state 14
	[] state 15
  state 14: #4
  state 15: #3 #4
  state 16: #0 #1 #3 #4
	<var> state 17
  state 17: #0 #1 #3 #4
	<var> state 18
  state 18: #0 #1 #3 #4
	<var> state 19
	<app> state 20
	[] state 30
  state 19: #4
  state 20: #0 #1 #4
	<var> state 21
	<app> state 23
  state 21: #4
	<var> state 22
  state 22: #4
  state 23: #0 #1 #4
	<var> state 24
	: state 27
  state 24: #4
	<var> state 25
  state 25: #4
	<var> state 26
  state 26: #4
  state 27: #0 #1 #4
	<var> state 28
  state 28: #0 #1 #4
	<var> state 29
  state 29: #0 #1 #4
  state 30: #3 #4
  state 31: #2 #3 #4
	<var> state 32
	[] state 33
  state 32: #2 #4
  state 33: #2 #3 #4
}; tack (u/*0:0101*/:us/*0:011*/) vs/*0:1*/ = tack/*1*/ us/*0:011*/ (u/*0:0101*/:vs/*0:1*/); tack [] vs/*0:1*/ = vs/*0:1*/ {
  rule #0: tack (u:us) vs = tack us (u:vs)
  rule #1: tack [] vs = vs
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
zip3 [] _/*0:01*/ _/*0:1*/ = [];
zip3 _/*0:001*/ [] _/*0:1*/ = [];
zip3 _/*0:001*/ _/*0:01*/ [] = [];
zip3 xs@(_/*0:00101*/:_/*0:0011*/) ys@(_/*0:0101*/:_/*0:011*/) zs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ with tick us/*0:0001*/ (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = tack/*1*/ ((x/*0:00101*/,y/*0:0101*/,z/*0:101*/):us/*0:0001*/) (zip3 xs/*1:0011*/ ys/*1:011*/ zs/*1:11*/&) if thunkp xs/*0:0011*/||thunkp ys/*0:011*/||thunkp zs/*0:11*/; tick us/*0:0001*/ (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = tick/*1*/ ((x/*0:00101*/,y/*0:0101*/,z/*0:101*/):us/*0:0001*/) xs/*0:0011*/ ys/*0:011*/ zs/*0:11*/; tick us/*0:0001*/ [] _/*0:01*/ _/*0:1*/ = tack/*1*/ us/*0:0001*/ []; tick us/*0:0001*/ _/*0:001*/ [] _/*0:1*/ = tack/*1*/ us/*0:0001*/ []; tick us/*0:0001*/ _/*0:001*/ _/*0:01*/ [] = tack/*1*/ us/*0:0001*/ []; tick us/*0:0001*/ xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ = tack/*1*/ us/*0:0001*/ (zip3 xs/*0:001*/ ys/*0:01*/ zs/*0:1*/) {
  rule #0: tick us (x:xs) (y:ys) (z:zs) = tack ((x,y,z):us) (zip3 xs ys zs&) if thunkp xs||thunkp ys||thunkp zs
  rule #1: tick us (x:xs) (y:ys) (z:zs) = tick ((x,y,z):us) xs ys zs
  rule #2: tick us [] _ _ = tack us []
  rule #3: tick us _ [] _ = tack us []
  rule #4: tick us _ _ [] = tack us []
  rule #5: tick us xs ys zs = tack us (zip3 xs ys zs)
  state 0: #0 #1 #2 #3 #4 #5
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5
	<var> state 2
	<app> state 9
	[] state 63
  state 2: #3 #4 #5
	<var> state 3
	[] state 6
  state 3: #4 #5
	<var> state 4
	[] state 5
  state 4: #5
  state 5: #4 #5
  state 6: #3 #4 #5
	<var> state 7
	[] state 8
  state 7: #3 #5
  state 8: #3 #4 #5
  state 9: #0 #1 #3 #4 #5
	<var> state 10
	<app> state 18
  state 10: #3 #4 #5
	<var> state 11
  state 11: #3 #4 #5
	<var> state 12
	[] state 15
  state 12: #4 #5
	<var> state 13
	[] state 14
  state 13: #5
  state 14: #4 #5
  state 15: #3 #4 #5
	<var> state 16
	[] state 17
  state 16: #3 #5
  state 17: #3 #4 #5
  state 18: #0 #1 #3 #4 #5
	<var> state 19
	: state 28
  state 19: #3 #4 #5
	<var> state 20
  state 20: #3 #4 #5
	<var> state 21
  state 21: #3 #4 #5
	<var> state 22
	[] state 25
  state 22: #4 #5
	<var> state 23
	[] state 24
  state 23: #5
  state 24: #4 #5
  state 25: #3 #4 #5
	<var> state 26
	[] state 27
  state 26: #3 #5
  state 27: #3 #4 #5
  state 28: #0 #1 #3 #4 #5
	<var> state 29
  state 29: #0 #1 #3 #4 #5
	<var> state 30
  state 30: #0 #1 #3 #4 #5
	<var> state 31
	<app> state 34
	[] state 60
  state 31: #4 #5
	<var> state 32
	[] state 33
  state 32: #5
  state 33: #4 #5
  state 34: #0 #1 #4 #5
	<var> state 35
	<app> state 39
  state 35: #4 #5
	<var> state 36
  state 36: #4 #5
	<var> state 37
	[] state 38
  state 37: #5
  state 38: #4 #5
  state 39: #0 #1 #4 #5
	<var> state 40
	: state 45
  state 40: #4 #5
	<var> state 41
  state 41: #4 #5
	<var> state 42
  state 42: #4 #5
	<var> state 43
	[] state 44
  state 43: #5
  state 44: #4 #5
  state 45: #0 #1 #4 #5
	<var> state 46
  state 46: #0 #1 #4 #5
	<var> state 47
  state 47: #0 #1 #4 #5
	<var> state 48
	<app> state 49
	[] state 59
  state 48: #5
  state 49: #0 #1 #5
	<var> state 50
	<app> state 52
  state 50: #5
	<var> state 51
  state 51: #5
  state 52: #0 #1 #5
	<var> state 53
	: state 56
  state 53: #5
	<var> state 54
  state 54: #5
	<var> state 55
  state 55: #5
  state 56: #0 #1 #5
	<var> state 57
  state 57: #0 #1 #5
	<var> state 58
  state 58: #0 #1 #5
  state 59: #4 #5
  state 60: #3 #4 #5
	<var> state 61
	[] state 62
  state 61: #3 #5
  state 62: #3 #4 #5
  state 63: #2 #3 #4 #5
	<var> state 64
	[] state 67
  state 64: #2 #4 #5
	<var> state 65
	[] state 66
  state 65: #2 #5
  state 66: #2 #4 #5
  state 67: #2 #3 #4 #5
	<var> state 68
	[] state 69
  state 68: #2 #3 #5
  state 69: #2 #3 #4 #5
}; tack (u/*0:0101*/:us/*0:011*/) vs/*0:1*/ = tack/*1*/ us/*0:011*/ (u/*0:0101*/:vs/*0:1*/); tack [] vs/*0:1*/ = vs/*0:1*/ {
  rule #0: tack (u:us) vs = tack us (u:vs)
  rule #1: tack [] vs = vs
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
zipwith f/*0:001*/ [] _/*0:1*/ = [];
zipwith f/*0:001*/ _/*0:01*/ [] = [];
zipwith f/*0:001*/ xs@(_/*0:0101*/:_/*0:011*/) ys@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:01*/ ys/*0:1*/ with tick us/*0:001*/ (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = tack/*1*/ (f/*1:001*/ x/*0:0101*/ y/*0:101*/:us/*0:001*/) (zipwith f/*2:001*/ xs/*1:011*/ ys/*1:11*/&) if thunkp xs/*0:011*/||thunkp ys/*0:11*/; tick us/*0:001*/ (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = tick/*1*/ (f/*1:001*/ x/*0:0101*/ y/*0:101*/:us/*0:001*/) xs/*0:011*/ ys/*0:11*/; tick us/*0:001*/ [] _/*0:1*/ = tack/*1*/ us/*0:001*/ []; tick us/*0:001*/ _/*0:01*/ [] = tack/*1*/ us/*0:001*/ []; tick us/*0:001*/ xs/*0:01*/ ys/*0:1*/ = tack/*1*/ us/*0:001*/ (zipwith f/*1:001*/ xs/*0:01*/ ys/*0:1*/) {
  rule #0: tick us (x:xs) (y:ys) = tack (f x y:us) (zipwith f xs ys&) if thunkp xs||thunkp ys
  rule #1: tick us (x:xs) (y:ys) = tick (f x y:us) xs ys
  rule #2: tick us [] _ = tack us []
  rule #3: tick us _ [] = tack us []
  rule #4: tick us xs ys = tack us (zipwith f xs ys)
  state 0: #0 #1 #2 #3 #4
	<var> state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	<app> state 5
	[] state 31
  state 2: #3 #4
	<var> state 3
	[] state 4
  state 3: #4
  state 4: #3 #4
  state 5: #0 #1 #3 #4
	<var> state 6
	<app> state 10
  state 6: #3 #4
	<var> state 7
  state 7: #3 #4
	<var> state 8
	[] state 9
  state 8: #4
  state 9: #3 #4
  state 10: #0 #1 #3 #4
	<var> state 11
	: state 16
  state 11: #3 #4
	<var> state 12
  state 12: #3 #4
	<var> state 13
  state 13: #3 #4
	<var> state 14
	[] state 15
  state 14: #4
  state 15: #3 #4
  state 16: #0 #1 #3 #4
	<var> state 17
  state 17: #0 #1 #3 #4
	<var> state 18
  state 18: #0 #1 #3 #4
	<var> state 19
	<app> state 20
	[] state 30
  state 19: #4
  state 20: #0 #1 #4
	<var> state 21
	<app> state 23
  state 21: #4
	<var> state 22
  state 22: #4
  state 23: #0 #1 #4
	<var> state 24
	: state 27
  state 24: #4
	<var> state 25
  state 25: #4
	<var> state 26
  state 26: #4
  state 27: #0 #1 #4
	<var> state 28
  state 28: #0 #1 #4
	<var> state 29
  state 29: #0 #1 #4
  state 30: #3 #4
  state 31: #2 #3 #4
	<var> state 32
	[] state 33
  state 32: #2 #4
  state 33: #2 #3 #4
}; tack (u/*0:0101*/:us/*0:011*/) vs/*0:1*/ = tack/*1*/ us/*0:011*/ (u/*0:0101*/:vs/*0:1*/); tack [] vs/*0:1*/ = vs/*0:1*/ {
  rule #0: tack (u:us) vs = tack us (u:vs)
  rule #1: tack [] vs = vs
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
zipwith3 f/*0:0001*/ [] _/*0:01*/ _/*0:1*/ = [];
zipwith3 f/*0:0001*/ _/*0:001*/ [] _/*0:1*/ = [];
zipwith3 f/*0:0001*/ _/*0:001*/ _/*0:01*/ [] = [];
zipwith3 f/*0:0001*/ xs@(_/*0:00101*/:_/*0:0011*/) ys@(_/*0:0101*/:_/*0:011*/) zs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ with tick us/*0:0001*/ (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = tack/*1*/ (f/*1:0001*/ x/*0:00101*/ y/*0:0101*/ z/*0:101*/:us/*0:0001*/) (zipwith3 f/*2:0001*/ xs/*1:0011*/ ys/*1:011*/ zs/*1:11*/&) if thunkp xs/*0:0011*/||thunkp ys/*0:011*/||thunkp zs/*0:11*/; tick us/*0:0001*/ (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = tick/*1*/ (f/*1:0001*/ x/*0:00101*/ y/*0:0101*/ z/*0:101*/:us/*0:0001*/) xs/*0:0011*/ ys/*0:011*/ zs/*0:11*/; tick us/*0:0001*/ [] _/*0:01*/ _/*0:1*/ = tack/*1*/ us/*0:0001*/ []; tick us/*0:0001*/ _/*0:001*/ [] _/*0:1*/ = tack/*1*/ us/*0:0001*/ []; tick us/*0:0001*/ _/*0:001*/ _/*0:01*/ [] = tack/*1*/ us/*0:0001*/ []; tick us/*0:0001*/ xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ = tack/*1*/ us/*0:0001*/ (zipwith3 f/*1:0001*/ xs/*0:001*/ ys/*0:01*/ zs/*0:1*/) {
  rule #0: tick us (x:xs) (y:ys) (z:zs) = tack (f x y z:us) (zipwith3 f xs ys zs&) if thunkp xs||thunkp ys||thunkp zs
  rule #1: tick us (x:xs) (y:ys) (z:zs) = tick (f x y z:us) xs ys zs
  rule #2: tick us [] _ _ = tack us []
  rule #3: tick us _ [] _ = tack us []
  rule #4: tick us _ _ [] = tack us []
  rule #5: tick us xs ys zs = tack us (zipwith3 f xs ys zs)
  state 0: #0 #1 #2 #3 #4 #5
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5
	<var> state 2
	<app> state 9
	[] state 63
  state 2: #3 #4 #5
	<var> state 3
	[] state 6
  state 3: #4 #5
	<var> state 4
	[] state 5
  state 4: #5
  state 5: #4 #5
  state 6: #3 #4 #5
	<var> state 7
	[] state 8
  state 7: #3 #5
  state 8: #3 #4 #5
  state 9: #0 #1 #3 #4 #5
	<var> state 10
	<app> state 18
  state 10: #3 #4 #5
	<var> state 11
  state 11: #3 #4 #5
	<var> state 12
	[] state 15
  state 12: #4 #5
	<var> state 13
	[] state 14
  state 13: #5
  state 14: #4 #5
  state 15: #3 #4 #5
	<var> state 16
	[] state 17
  state 16: #3 #5
  state 17: #3 #4 #5
  state 18: #0 #1 #3 #4 #5
	<var> state 19
	: state 28
  state 19: #3 #4 #5
	<var> state 20
  state 20: #3 #4 #5
	<var> state 21
  state 21: #3 #4 #5
	<var> state 22
	[] state 25
  state 22: #4 #5
	<var> state 23
	[] state 24
  state 23: #5
  state 24: #4 #5
  state 25: #3 #4 #5
	<var> state 26
	[] state 27
  state 26: #3 #5
  state 27: #3 #4 #5
  state 28: #0 #1 #3 #4 #5
	<var> state 29
  state 29: #0 #1 #3 #4 #5
	<var> state 30
  state 30: #0 #1 #3 #4 #5
	<var> state 31
	<app> state 34
	[] state 60
  state 31: #4 #5
	<var> state 32
	[] state 33
  state 32: #5
  state 33: #4 #5
  state 34: #0 #1 #4 #5
	<var> state 35
	<app> state 39
  state 35: #4 #5
	<var> state 36
  state 36: #4 #5
	<var> state 37
	[] state 38
  state 37: #5
  state 38: #4 #5
  state 39: #0 #1 #4 #5
	<var> state 40
	: state 45
  state 40: #4 #5
	<var> state 41
  state 41: #4 #5
	<var> state 42
  state 42: #4 #5
	<var> state 43
	[] state 44
  state 43: #5
  state 44: #4 #5
  state 45: #0 #1 #4 #5
	<var> state 46
  state 46: #0 #1 #4 #5
	<var> state 47
  state 47: #0 #1 #4 #5
	<var> state 48
	<app> state 49
	[] state 59
  state 48: #5
  state 49: #0 #1 #5
	<var> state 50
	<app> state 52
  state 50: #5
	<var> state 51
  state 51: #5
  state 52: #0 #1 #5
	<var> state 53
	: state 56
  state 53: #5
	<var> state 54
  state 54: #5
	<var> state 55
  state 55: #5
  state 56: #0 #1 #5
	<var> state 57
  state 57: #0 #1 #5
	<var> state 58
  state 58: #0 #1 #5
  state 59: #4 #5
  state 60: #3 #4 #5
	<var> state 61
	[] state 62
  state 61: #3 #5
  state 62: #3 #4 #5
  state 63: #2 #3 #4 #5
	<var> state 64
	[] state 67
  state 64: #2 #4 #5
	<var> state 65
	[] state 66
  state 65: #2 #5
  state 66: #2 #4 #5
  state 67: #2 #3 #4 #5
	<var> state 68
	[] state 69
  state 68: #2 #3 #5
  state 69: #2 #3 #4 #5
}; tack (u/*0:0101*/:us/*0:011*/) vs/*0:1*/ = tack/*1*/ us/*0:011*/ (u/*0:0101*/:vs/*0:1*/); tack [] vs/*0:1*/ = vs/*0:1*/ {
  rule #0: tack (u:us) vs = tack us (u:vs)
  rule #1: tack [] vs = vs
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
dowith f/*0:001*/ (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = f/*0:001*/ x/*0:0101*/ y/*0:101*/$$dowith f/*0:001*/ xs/*0:011*/ ys/*0:11*/;
dowith f/*0:001*/ _/*0:01*/ _/*0:1*/ = ();
dowith3 f/*0:0001*/ (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = f/*0:0001*/ x/*0:00101*/ y/*0:0101*/ z/*0:101*/$$dowith3 f/*0:0001*/ xs/*0:0011*/ ys/*0:011*/ zs/*0:11*/;
dowith3 f/*0:0001*/ _/*0:001*/ _/*0:01*/ _/*0:1*/ = ();
unzip [] = [],[];
unzip us@(_/*0:101*/:_/*0:11*/) = foldr accum/*0*/ ([],[]) us/*0:1*/ with check us@(_/*0:101*/,_/*0:11*/) = us/*0:1*/; check (foldr _/*0:1001*/ _/*0:101*/ us/*0:11*/) = throw (bad_list_value us/*0:11*/); check us/*0:1*/ = throw (bad_tuple_value us/*0:1*/) {
  rule #0: check us@(_,_) = us
  rule #1: check (foldr _ _ us) = throw (bad_list_value us)
  rule #2: check us = throw (bad_tuple_value us)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	<app> state 9
	, state 18
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
	foldr state 14
  state 10: #2
	<var> state 11
  state 11: #2
	<var> state 12
  state 12: #2
	<var> state 13
  state 13: #2
  state 14: #1 #2
	<var> state 15
  state 15: #1 #2
	<var> state 16
  state 16: #1 #2
	<var> state 17
  state 17: #1 #2
  state 18: #0 #2
	<var> state 19
  state 19: #0 #2
	<var> state 20
  state 20: #0 #2
}; accum u@(x/*0:0101*/,y/*0:011*/) us/*0:1*/ = x/*0:0101*/:(xs/*0:01*/ when xs/*0:01*/,_/*0:1*/ = check/*2*/ us/*1:1*/ {
  rule #0: xs,_ = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end)&,y/*0:011*/:(ys/*0:1*/ when _/*0:01*/,ys/*0:1*/ = check/*2*/ us/*1:1*/ {
  rule #0: _,ys = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end)& if thunkp us/*0:1*/; accum u@(x/*0:0101*/,y/*0:011*/) us/*0:1*/ = x/*1:0101*/:xs/*0:01*/,y/*1:011*/:ys/*0:1*/ when xs/*0:01*/,ys/*0:1*/ = check/*1*/ us/*0:1*/ {
  rule #0: xs,ys = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end; accum u/*0:01*/ _/*0:1*/ = throw (bad_tuple_value u/*0:01*/) {
  rule #0: accum u@(x,y) us = x:(xs when xs,_ = check us end)&,y:(ys when _,ys = check us end)& if thunkp us
  rule #1: accum u@(x,y) us = x:xs,y:ys when xs,ys = check us end
  rule #2: accum u _ = throw (bad_tuple_value u)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 3
  state 1: #2
	<var> state 2
  state 2: #2
  state 3: #0 #1 #2
	<var> state 4
	<app> state 7
  state 4: #2
	<var> state 5
  state 5: #2
	<var> state 6
  state 6: #2
  state 7: #0 #1 #2
	<var> state 8
	, state 12
  state 8: #2
	<var> state 9
  state 9: #2
	<var> state 10
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #0 #1 #2
	<var> state 13
  state 13: #0 #1 #2
	<var> state 14
  state 14: #0 #1 #2
	<var> state 15
  state 15: #0 #1 #2
} end;
unzip3 [] = [],[],[];
unzip3 us@(_/*0:101*/:_/*0:11*/) = foldr accum/*0*/ ([],[],[]) us/*0:1*/ with check us@(_/*0:101*/,_/*0:1101*/,_/*0:111*/) = us/*0:1*/; check (foldr _/*0:1001*/ _/*0:101*/ us/*0:11*/) = throw (bad_list_value us/*0:11*/); check us/*0:1*/ = throw (bad_tuple_value us/*0:1*/) {
  rule #0: check us@(_,_,_) = us
  rule #1: check (foldr _ _ us) = throw (bad_list_value us)
  rule #2: check us = throw (bad_tuple_value us)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
  state 1: #2
  state 2: #0 #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #1 #2
	<var> state 6
	<app> state 9
	, state 18
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
	foldr state 14
  state 10: #2
	<var> state 11
  state 11: #2
	<var> state 12
  state 12: #2
	<var> state 13
  state 13: #2
  state 14: #1 #2
	<var> state 15
  state 15: #1 #2
	<var> state 16
  state 16: #1 #2
	<var> state 17
  state 17: #1 #2
  state 18: #0 #2
	<var> state 19
  state 19: #0 #2
	<var> state 20
	<app> state 21
  state 20: #2
  state 21: #0 #2
	<var> state 22
	<app> state 24
  state 22: #2
	<var> state 23
  state 23: #2
  state 24: #0 #2
	<var> state 25
	, state 28
  state 25: #2
	<var> state 26
  state 26: #2
	<var> state 27
  state 27: #2
  state 28: #0 #2
	<var> state 29
  state 29: #0 #2
	<var> state 30
  state 30: #0 #2
}; accum u@(x/*0:0101*/,y/*0:01101*/,z/*0:0111*/) us/*0:1*/ = x/*0:0101*/:(xs/*0:01*/ when xs/*0:01*/,_/*0:101*/,_/*0:11*/ = check/*2*/ us/*1:1*/ {
  rule #0: xs,_,_ = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<app> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	, state 7
  state 7: #0
	<var> state 8
  state 8: #0
	<var> state 9
  state 9: #0
} end)&,y/*0:01101*/:(ys/*0:101*/ when _/*0:01*/,ys/*0:101*/,_/*0:11*/ = check/*2*/ us/*1:1*/ {
  rule #0: _,ys,_ = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<app> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	, state 7
  state 7: #0
	<var> state 8
  state 8: #0
	<var> state 9
  state 9: #0
} end)&,z/*0:0111*/:(zs/*0:11*/ when _/*0:01*/,_/*0:101*/,zs/*0:11*/ = check/*2*/ us/*1:1*/ {
  rule #0: _,_,zs = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<app> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	, state 7
  state 7: #0
	<var> state 8
  state 8: #0
	<var> state 9
  state 9: #0
} end)& if thunkp us/*0:1*/; accum u@(x/*0:0101*/,y/*0:01101*/,z/*0:0111*/) us/*0:1*/ = x/*1:0101*/:xs/*0:01*/,y/*1:01101*/:ys/*0:101*/,z/*1:0111*/:zs/*0:11*/ when xs/*0:01*/,ys/*0:101*/,zs/*0:11*/ = check/*1*/ us/*0:1*/ {
  rule #0: xs,ys,zs = check us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<app> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	, state 7
  state 7: #0
	<var> state 8
  state 8: #0
	<var> state 9
  state 9: #0
} end; accum u/*0:01*/ _/*0:1*/ = throw (bad_tuple_value u/*0:01*/) {
  rule #0: accum u@(x,y,z) us = x:(xs when xs,_,_ = check us end)&,y:(ys when _,ys,_ = check us end)&,z:(zs when _,_,zs = check us end)& if thunkp us
  rule #1: accum u@(x,y,z) us = x:xs,y:ys,z:zs when xs,ys,zs = check us end
  rule #2: accum u _ = throw (bad_tuple_value u)
  state 0: #0 #1 #2
	<var> state 1
	<app> state 3
  state 1: #2
	<var> state 2
  state 2: #2
  state 3: #0 #1 #2
	<var> state 4
	<app> state 7
  state 4: #2
	<var> state 5
  state 5: #2
	<var> state 6
  state 6: #2
  state 7: #0 #1 #2
	<var> state 8
	, state 12
  state 8: #2
	<var> state 9
  state 9: #2
	<var> state 10
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #0 #1 #2
	<var> state 13
  state 13: #0 #1 #2
	<var> state 14
	<app> state 16
  state 14: #2
	<var> state 15
  state 15: #2
  state 16: #0 #1 #2
	<var> state 17
	<app> state 20
  state 17: #2
	<var> state 18
  state 18: #2
	<var> state 19
  state 19: #2
  state 20: #0 #1 #2
	<var> state 21
	, state 25
  state 21: #2
	<var> state 22
  state 22: #2
	<var> state 23
  state 23: #2
	<var> state 24
  state 24: #2
  state 25: #0 #1 #2
	<var> state 26
  state 26: #0 #1 #2
	<var> state 27
  state 27: #0 #1 #2
	<var> state 28
  state 28: #0 #1 #2
} end;
def void (catmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (listmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (rowcatmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (colcatmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (rowmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (colmap f/*0:101*/ x/*0:11*/) = __std__::__do__ f/*0:101*/ x/*0:11*/;
def void (__ifelse__ y/*0:1001*/ z/*0:101*/ []) = __ifelse__ y/*0:1001*/ (void z/*0:101*/) ();
def void (__ifelse__ y/*0:1001*/ z/*0:101*/ {}) = __ifelse__ y/*0:1001*/ (void z/*0:101*/) ();
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(listmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__ (__lambda__ [x/*0:10101*/] (void y/*0:11*/));
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(rowmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__ (__lambda__ [x/*0:10101*/] (void y/*0:11*/));
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(colmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__ (__lambda__ [x/*0:10101*/] (void y/*0:11*/));
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(catmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__ (__lambda__ [x/*0:10101*/] (void y/*0:11*/));
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(rowcatmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__ (__lambda__ [x/*0:10101*/] (void y/*0:11*/));
def __std__::__do__ (__lambda__ [x/*0:10101*/] y@(colcatmap _/*0:1101*/ _/*0:111*/)) = __std__::__do__ (__lambda__ [x/*0:10101*/] (void y/*0:11*/));
def __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ z/*0:1101*/ [])) = __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ (void z/*0:1101*/) ()));
def __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ z/*0:1101*/ {})) = __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ (void z/*0:1101*/) ()));
def __std__::__do__ (__lambda__ [x/*0:10101*/] (void y/*0:111*/)) = __std__::__do__ (__lambda__ [x/*0:10101*/] y/*0:111*/);
def __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ (void z/*0:11011*/) ())) = __std__::__do__ (__lambda__ [x/*0:10101*/] (__ifelse__ y/*0:11001*/ z/*0:11011*/ ()));
def __std__::__do__ f/*0:1*/ = do f/*0:1*/;
__C::pure_quoted_symbol s/*0:1*/::string = __C::pure_quoted_symbol id/*0:*/ if id/*0:*/>0 when id/*0:*/::int = __C::pure_getsym s/*0:1*/ {
  rule #0: id::int = __C::pure_getsym s
  state 0: #0
	<var>::int state 1
  state 1: #0
} end;
globsym pat/*0:01*/::string level/*0:1*/::int = uniq/*3*/ (catmap descr/*3*/ info/*0:*/) when res/*0:*/ = evalcmd ("show -gst"+str level/*0:1*/+" "+pat/*0:01*/); stringp res/*0:*/||throw evalcmd; info/*0:*/ = init (init (split "\n" res/*1:*/)) {
  rule #0: info = init (init (split "\n" res))
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: _ = stringp res||throw evalcmd
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: res = evalcmd ("show -gst"+str level+" "+pat)
  state 0: #0
	<var> state 1
  state 1: #0
} end with uniq (x/*0:101*/:xs@(y/*0:1101*/:_/*0:111*/)) = if x/*0:101*/===y/*0:1101*/ then uniq/*1*/ xs/*0:11*/ else x/*0:101*/:uniq/*1*/ xs/*0:11*/; uniq xs/*0:1*/ = xs/*0:1*/ {
  rule #0: uniq (x:xs@(y:_)) = if x===y then uniq xs else x:uniq xs
  rule #1: uniq xs = xs
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	: state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
  state 10: #0 #1
	<var> state 11
	<app> state 12
  state 11: #1
  state 12: #0 #1
	<var> state 13
	<app> state 15
  state 13: #1
	<var> state 14
  state 14: #1
  state 15: #0 #1
	<var> state 16
	: state 19
  state 16: #1
	<var> state 17
  state 17: #1
	<var> state 18
  state 18: #1
  state 19: #0 #1
	<var> state 20
  state 20: #0 #1
	<var> state 21
  state 21: #0 #1
}; descr s/*0:1*/::string = case filter (flip (~=) "") (split " " s/*0:1*/) of sym/*0:01*/:_/*0:1*/ = if any (flip (==) sym/*0:01*/) ["extern","private","infix","infixl","infixr","prefix","postfix","outfix","nonfix"] then [] else catmap (\x/*0:1*/ -> if symbolp x/*0:1*/ then [x/*0:1*/] else [] {
  rule #0: _ x = if symbolp x then [x] else []
  state 0: #0
	<var> state 1
  state 1: #0
}) [__C::pure_quoted_symbol sym/*0:01*/]; _/*0:*/ = [] {
  rule #0: sym:_ = if any (flip (==) sym) ["extern","private","infix","infixl","infixr","prefix","postfix","outfix","nonfix"] then [] else catmap (\x -> if symbolp x then [x] else []) [__C::pure_quoted_symbol sym]
  rule #1: _ = []
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	: state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
} end {
  rule #0: descr s::string = case filter (flip (~=) "") (split " " s) of sym:_ = if any (flip (==) sym) ["extern","private","infix","infixl","infixr","prefix","postfix","outfix","nonfix"] then [] else catmap (\x -> if symbolp x then [x] else []) [__C::pure_quoted_symbol sym]; _ = [] end
  state 0: #0
	<var>::string state 1
  state 1: #0
} end;
clearsym sym/*0:01*/::string level/*0:1*/::int = () when res/*0:*/ = evalcmd ("clear -t"+str level/*0:1*/+" "+sym/*0:01*/); stringp res/*0:*/||throw evalcmd {
  rule #0: _ = stringp res||throw evalcmd
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: res = evalcmd ("clear -t"+str level+" "+sym)
  state 0: #0
	<var> state 1
  state 1: #0
} end;
clearsym sym/*0:01*/::symbol level/*0:1*/::int = clearsym sym/*0:*/ level/*2:1*/ when sym/*0:*/ = str sym/*0:01*/; sym/*0:*/ = if sym/*0:*/!0=="(" then substr sym/*0:*/ 2 (#sym/*0:*/-2) else sym/*0:*/ {
  rule #0: sym = if sym!0=="(" then substr sym 2 (#sym-2) else sym
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: sym = str sym
  state 0: #0
	<var> state 1
  state 1: #0
} end;
