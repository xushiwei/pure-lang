// math.pure tests for exact/inexact and symbolic results

using math, system;

/* This will print out each operation, arguments and result as a single
   line. Exceptions are flagged with '__error__', evaluation failures with
   '__failed__'. Floating point values are rounded in the output to 3
   significant digits by default, to prevent 'make check' from failing due to
   rounding discrepancies. */

let double_format = "%#0.3g"; // modify as needed, to get more accuracy

test (f,x,y) = puts $ format (f,x,y,check (f,x,y) (catch __error__ (f x y)));
test (f,x) = puts $ format (f,x,check (f,x) (catch __error__ (f x)));

check _ z = z if numberp z;
check (f,x,y) (g@_ u v) = __failed__ if f===g && x===u && y===v;
check (f,x) (g@_ u) = __failed__ if f===g && x===u;
check _ z = z otherwise;

format (f,x,y,z) = str f+","+print x+","+print y+","+print z;
format (f,x,z) = str f+","+print x+","+print z;

/* Kludge: To avoid rounding discrepancies near zero, round everything to zero
   which is below a certain threshold. This also works around issues with
   negative zeros, which aren't supported on some systems and broken on
   others. */

const eps = 1e-8;
roundz x::double = if abs x < eps then 0.0 else x;

print x::double
= str x if infp x || nanp x; // Windoze compatibility
= sprintf double_format (roundz x) otherwise;

print (x+:y) = print x+"+:"+print y;
// Kludge: Normalize the argument in polar representation if the absolute
// value is near zero.
print (x::double<:y::double) = print x+"<:"+print 0.0
  if abs x ~== 0.0 && roundz x == 0.0 && ~infp y && ~nanp y;
print (x<:y) = print x+"<:"+print y otherwise;
print x = str x otherwise;

tests =
puts "*** EXACT/INEXACT ***" $$
// These should all return exact results, except +/- with polar operands, as
// well as / and ^ which always return inexact results.
do test [op,2,a|op=[(+),(-),(*),(%),(/),(^)];a=[2+:3,2<:3,2%3]] $$
do test [op,a,2|op=[(+),(-),(*),(%),(/),(^)];a=[2+:3,2<:3,2%3]] $$
puts "*** SYMBOLIC ***" $$
// If everything is all right here, these should all print __failed__.
do test [op,x,a|op=[(+),(-),(*),(%),(/),(^)];a=[2+:3,2<:3,2%3]] $$
do test [op,a,x|op=[(+),(-),(*),(%),(/),(^)];a=[2+:3,2<:3,2%3]];

tests;
