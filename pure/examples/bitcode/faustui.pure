
/* faustui.pure: Provide access to the control descriptions of a Faust dsp.
   Copyright (c) 2009-2010 by Albert Graef <Dr.Graef@t-online.de>. */

/* Note that Pure's new internal Faust interface uses the same format of UI
   description as the pure-faust module, so the code below is virtually the
   same as in pure-faust/faust.pure. */

/* Constructors for control descriptions. Such descriptions are returned by
   the 'info' function of a Faust dsp.

   There are various basic control elements, each associated with a control
   variable 'ref' and a parameter tuple 'args'. The latter are the arguments
   of the control element as given in the Faust program. Thus, e.g., 'button
   ref "Push me!"' would denote a button with label "Push me!", and 'hslider
   ref ("gain",1.0,0.0,10.0,0.1) a horizontal slider with label "gain" and the
   given initial, min, max and step size values. The control variable itself
   is implemented as a C pointer 'ref' which, depending on the dsp's sample
   format, points either to a C float or a C double value. Changing the value
   pointed to by 'ref' using 'put_double' or 'put_float' (before invoking the
   dsp's 'compute' function) assigns a new value to the corresponding control
   element in the Faust dsp. Passive control elements such as 'vbargraph' have
   their value updated during invocation of the 'compute' function, and can
   then be read using 'get_double' or 'get_float'.

   There are also three constructors for denoting groups of controls,
   'vgroup', 'hgroup' and 'tgroup'. These take a single 'args' argument, which
   is a pair (label,elems) consisting of the label of the group, as given in
   the Faust program, and the list of all control elements in that group. The
   toplevel control element is always a group (a 'vgroup' by default). */

public button checkbox vslider hslider nentry vbargraph hbargraph
  vgroup hgroup tgroup;

/* Convenience functions to retrieve the components of a control description.
   The control_type, control_ref and control_label functions return the type
   (i.e., constructor), reference (a C double* or float* pointer) and label of
   a control, respectively. control_args yields the remaining control
   parameters. */

control_type (f@_ ptr args) |
control_type (f@_ args) = f;

control_ref (_ ptr args) = ptr;

control_label (_ ptr (label,args)) |
control_label (_ (label,args)) |
control_label (_ ptr label::string) |
control_label (_ label::string) = label;

control_args (_ ptr (label,args)) |
control_args (_ (label,args)) = args;
control_args (_ ptr label::string) |
control_args (_ label::string) = ();

/* The following function returns a flat representation of a control group as
   a list of basic control descriptions, which provides a quick way to access
   all the control values of a Faust DSP. The grouping controls themselves are
   omitted. */

controls (_ (_,ctls)) = catmap controls ctls if listp ctls;
controls x = [x] otherwise;

/* The following function works like the controls function above, but also
   replaces the label of each basic control with a fully qualified path
   consisting of all control labels leading up to the given control. Thus,
   e.g., the label of a slider "gain" inside a group "voice#0" inside the
   main "faust" group will be denoted by the label "faust/voice#0/gain". */

pcontrols x = controls "" x with
  controls path x =
    case x of
      _ (label::string,ctls) = catmap (controls (join path label)) ctls
      			         if listp ctls;
      f@_ ptr (label::string,args) = [f ptr (join path label,args)];
      f@_ ptr label::string = [f ptr (join path label)];
      _ = [x]; // bad control description
    end;
  join "" s::string |
  join s::string "" = s;
  join s::string t::string = s+"/"+t otherwise;
end;

/* Convenience function to turn a control list (as returned by controls or
   pcontrols above) into a record mapping control names to the corresponding
   pointers. */

control_map ui = { control_label c => control_ref c | c = ui };

/* As of Pure 0.45, the Faust interface now also offers some rudimentary
   reflection capabilities. Currently the following functions are provided by
   the runtime:

   - faust_rtti returns runtime type information about a Faust dsp. The result
     is a pair (name,dbl) where name is the name of the Faust module and dbl
     denotes the sample format. The latter is just a flag which is true iff
     double samples and control values are used; false indicates single
     precision.

   - faust_mods builds a list of all Faust modules currently loaded; each
     element is a hash pair name=>(dbl,ns), where name is the module name, dbl
     denotes the sample format, and ns is the list of all namespaces in which
     the module is visible. This information is useful if you need to create
     and manipulate Faust dsps dynamically.

   NOTE: Since this information is maintained by the Faust bitcode loader, it
   is only available in the interpreter, not in standalone executables. Thus,
   if you plan to batch-compile your script, you should retrieve the
   information at compile time and assign it to a constant, e.g.:

     const mod_info = faust_mods;
     // Create a dummy dsp to extract the runtime data.
     const name,dbl = faust_rtti dsp when dsp = modname::newinit 0 end;

   But note that with a batch-compiled script you won't get much Faust
   "livecoding" anyway, so if you really need to recompile and reload Faust
   dsps on the fly, then you should do that in the interpreter. */

extern expr *faust_rtti(expr *dsp);
extern expr *faust_mods();
