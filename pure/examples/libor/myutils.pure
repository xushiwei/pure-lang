/* General Utilities Copyright (c) 2008 by Libor Spacek */

//General mathematical iterators over one and two indices

// namespace myutils;
// public iter1d iter2d sigma Pi fac binomial gcf 
//       rotate protate nrotate;

iter1d op i1 i2 f = foldl1 op (map f (i1..i2));

iter2d op i1 i2 j1 j2 f = 
		foldl1 op (map (uncurry f) [x,y | x = i1..i2; y = j1..j2]);
      
//Examples on how to use the mathematical iterators
sigma i1 i2 f = iter1d (+) i1 i2 f;
Pi i1 i2 f = iter2d (*) i1 i2 f;
fac n = Pi 1L n id;

//Binomial using (k, n-k) symmetry and bignum division
binomial n k = (Pi (k+1L) n id) div (Pi 2L (n-k) id) if n-k < k;
	          = (Pi (n-k+1L) n id) div (Pi 2L k id);
        
// Euclid's recursive greatest common factor algorithm for ints and bignums
gcf x 0 | gcf x 0L = x;
gcf x y = gcf y (x mod y);

//(2) List Processing
// take the head of a list and put it at the end	
ecat h::int [] = [h];
ecat h::int (h2::int:t) = h2:(ecat h t);

rotate (h:t) = ecat h t;

// take n items from the front and put them at the end (n positive 0<=n<=#n)
protate 0 l = l;
protate n::int l = (drop n l)+(take n l);

// rotate n items, cf. "rotate n bits instruction" (n can now also be negative)
// example applied to clocks: >head (nrotate (-33) (0..23)); 
// what time is 33 hrs before midnight? Answer: 15 hrs.
nrotate  n::int l 
   = if n<0  then (protate (ll + (n mod ll)) l)
             else	(protate (n mod ll) l) when ll=#l end;
             
