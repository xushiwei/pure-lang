// Basic bit manipulation facilities Libor Spacek (C) 25th June, 2009

def setbit i::int bit::int = i or (1<<bit);
def clearbit i::int bit::int = i and (not (1<<bit));
def getbit i::int bit::int = (i>>bit) and 1;

def setbit i::bigint bit::int = i or (1L<<bit);
def clearbit i::bigint bit::int = (i and (not (1L<<bit)));
def getbit i::bigint bit::int = (i>>bit) and 1;

// conversions from and to little-endian lists of integers
// any nonzero integer is interpreted as a set bit
list2n l =  if ((#l) > 32) then (ltbb l 0L) else (ltb l 0)
	with
		ltb [] j::int = j;
		ltb (0:t) 0 = ltb t 0;
		ltb (h::int:t) 0 = ltb t 1;
		ltb (0:t) j::int = ltb t (j<<1);
		ltb (h::int:t) j::int = ltb t ((j<<1)+1);

		ltbb [] j::bigint = j;
		ltbb (0:t) 0L = ltbb t 0L;
		ltbb (h::int:t) 0L = ltbb t 1L;
		ltbb (0:t) j::bigint = ltbb t (j<<1);
		ltbb (h::int:t) j::bigint = ltbb t ((j<<1)+1);
	end;

n2list i::int = itl i [] 
	with
		itl 0 l = l;
		itl j::int l = if (j and 1) then itl (j>>1) (1:l) else itl (j>>1) (0:l);
	end;

n2list i::bigint = itl i [] 
	with
		itl 0L l = l;
		itl j::bigint l = if (int (j and 1)) then itl (j>>1) (1:l) else itl (j>>1) (0:l);
	end;

// direct modifications using pointers (refs to ints and bigints)
def refsetbit r::pointer bit::int = put r ((get r) or (1<<bit));
def refclearbit r::pointer bit::int = put r ((get r) and (not (1<<bit)));
def refgetbit r::pointer bit::int = ((get r) >> bit) and 1;

def r::pointer << bitsno::int = put r ((get r) << bitsno);
def r::pointer >> bitsno::int = put r ((get r) >> bitsno);
