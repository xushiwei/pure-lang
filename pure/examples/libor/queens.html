<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Some Solutions to the N Queens Problem</title>
<meta name="author" content="Libor Spacek (C) &lt;libors&#64;gmail.com&gt;" />
<meta name="date" content="Version 2: June 2009" />
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 5196 2007-06-03 20:25:28Z wiemann $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="some-solutions-to-the-n-queens-problem">
<h1 class="title">Some Solutions to the N Queens Problem</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Libor Spacek (C) &lt;<a class="reference external" href="mailto:libors&#64;gmail.com">libors&#64;gmail.com</a>&gt;</td></tr>
<tr class="field"><th class="docinfo-name">License:</th><td class="field-body">GPL V3</td>
</tr>
<tr><th class="docinfo-name">Date:</th>
<td>Version 2: June 2009</td></tr>
</tbody>
</table>
<!--  -->
<div class="section" id="example-usage">
<h1>Example usage:</h1>
<blockquote>
<p>#pure -i queens.pure</p>
<p>&gt;fullboard (thequeens 30);</p>
</blockquote>
<!--  -->
</div>
<div class="section" id="utilities">
<h1>Utilities:</h1>
<pre class="literal-block">
nullary nosolution passed failed;
</pre>
<!--  -->
<p><strong>(diagsafe j l)</strong></p>
<blockquote>
<p>is square j in the current row safe from the diagonal attacks by
all queens in previous rows placed on other columns recorded in list l ?</p>
<pre class="literal-block">
diagsafe j::int l = rsafe 1 l
   with
      rsafe id::int [j2::int] = if id==(abs(j2-j)) then 0 else 1;
      rsafe id::int (j2::int:l) =
         if id==(abs(j2-j)) then 0 else rsafe (succ id) l
   end;
</pre>
</blockquote>
<!--  -->
<p><strong>(fullboard s)</strong></p>
<blockquote>
<p>full coordinates representation [(row,column),...] is redundant
because the first coordinate of any solution will always be 1..n.
However, it can be reconstructed with, e.g. (fullboard (thequeens n));
All solutions here are encoded as the columns permutations only,
[column, ...], leaving out (the index formed by) the ordered rows.
In all cases rows and columns are interchangeable,
i.e. reading the same numbers as [row, ....] for ordered
columns is also a valid solution.</p>
<pre class="literal-block">
fullboard s = zip (1..(#s)) s;
</pre>
</blockquote>
<!--  -->
</div>
<div class="section" id="solutions">
<h1>Solutions:</h1>
<p><strong>(allqueens n)</strong></p>
<blockquote>
<p>returns all possible solutions by constrained search, e.g.
(allqueens 8) returns a list of all 92 chessboard solutions.
There is no known method to find the number
of solutions for any n. Experimental solutions exist currently
for up to n=26 by using special purpose parallel hardware and
running for a long time. Allqueens, which is quite fast,
is quite breathless for n=15 (number of solutions = 2 279 184).
It is unwise to ask for the full list
to be printed for anything beyond n=10 (724  solutions).</p>
<p>Only half of the first row is considered for the first queen,
thus halving the total search effort,
followed by adding a reflection of all the solutions found
about the middle column.
Odd sized boards must have additionally the first midrow starting position
searched and add its solutions.
More reflections and rotations could be done but the solutions
would have to be  tested for duplicates.
All rook checking (row and column) is eliminated by using only unused
candidates list c, leaving just the bishop check, id==abs(j2-j),
(both diagonals).</p>
<pre class="literal-block">
allqueens n::int = if (n mod 2 == 0) then (hsoln+revsoln)
      else hsoln+(search (rem hsn nl) [hsn])+revsoln
   when
      sn = succ n; hsn = sn div 2;
      hnl = (1..(n div 2)); nl = (1..n);
      hsoln = cat [search (rem j nl) [j] | j = hnl];
      revsoln = map (\y -&gt; map (\z -&gt; sn-z) y) hsoln
   end
   with
      search [] p = [p]; // solved
      search c p = cat [ search (rem j c) (j:p) | j = c; diagsafe j p]
   end;
</pre>
</blockquote>
<!--  -->
<p><strong>(queens n)</strong></p>
<blockquote>
<p>now also finds all solutions. Queens is more concise than allqueens but
is also slower</p>
<pre class="literal-block">
queens n::int = search n n []
   with
   search 0 _ p = [p];     // no more rows, solved
   search _ 0 _ = []; // failed, run out of alternative js
   search i::int j::int p = search i (pred j) p if unsafe j p; // try another j
      = (search (pred i) n (j:p))+(search i (pred j) p); // depth-first
   end;
</pre>
</blockquote>
<!--  -->
<p><strong>(tailqueens n)</strong></p>
<blockquote>
<p>this concise backtracking tailrecursive version
throws a single solution  - the first one of queens' as it searches
in the same order</p>
<pre class="literal-block">
tailqueens n::int = catch id (srch n n [])
   with srch 0 _ p = throw p; // no more rows: solved
      srch _ 0 _ = []; // out of columns: failed
      srch i::int j::int p =
         (if unsafe j p then void else (srch (i-1) n (j:p)))
         $$ (srch i (j-1) p)
   end;
</pre>
</blockquote>
<!--  -->
<p><strong>(thequeens n)</strong></p>
<blockquote>
<p>Any two queens placement symmetric under a single reflection around any of
the   board's four axis of symmetry is not part of a solution by problem
definition.    It follows that any complete solution cannot be symmetric
(invariant) under a single reflection.</p>
<p>There are so called doubly symmetric solutions, invariant under any
combination of 90 degrees rotations, which have an orbit of just two
equivalent solutions, produced by a single reflection (e.g. viewing the board
from top or from underneath). A double symmetric solution has the full square
symmetry internally but its axis of symmetry do not coincide with those of
the board.</p>
<p>There always exists at least one symmetric solution invariant under 180
degrees rotation (or two orthogonal reflections), producing an orbit of four
equivalent solutions. The symmetric solutions are the ones found by
'thequeens' and possibly other regular methods.</p>
<p>All other solutions are asymmetric and thus can be rotated into four
different positions  and viewed from above or below the board, in each case
producing a different (equivalent)  solution, the total orbit
(of the dihedral group) of eight.</p>
<p>There are no other solutions.</p>
<p>'Thequeens' encodes my solution in the following few lines of code. It is to
my knowledge the simplest algorithm for the N-Queens problem. It is very fast
even for large boards, being a regular (linear) solution requiring no search.
Of course, it does not give all the solutions and thus does not solve the
hard problem described above for 'allqueens'.</p>
<p>The correct pattern is simply written down directly without any checking or
searching being necessary. It can be easily learnt to do 'by inspection',
which is probably a neat party trick to perform. The solutions had been
tested exhaustively for board sizes 0 to 5001 and individually for board size
50000x50000.</p>
<pre class="literal-block">
thequeens n::int = case n of
   1 = [1];  // trivial solution to one square board
   2 | 3 = nosolution;
   _::int = 1:(map succ (thequeens (n-1))) if (n mod 2);// odd size boards done
      = map (newsq) (0..(n-1)) // the rest is even sized boards solution
   with
      newsq x::int = (succ ((start+2*x) mod n)) if x &lt; hn;
                   = (succ ((restart+2*(x-hn)) mod n)) end
   when
      hn::int = (n div 2); // half n
      start::int = if (n mod 3) then (pred hn) else 1; //(n mod 3) special
      restart::int = (1+n-start)
   end
end; // end of case and thequeens
</pre>
</blockquote>
<!--  -->
</div>
<div class="section" id="testing">
<h1>Testing:</h1>
<p><strong>(unsafe j l)</strong></p>
<blockquote>
<p>is square j in the current row attacked (rook or bishop)
by any previously placed queen in list l?</p>
<pre class="literal-block">
unsafe j::int l = rsafe 1 l
   with
      rsafe _ [] = 0;
      rsafe id::int (j2::int:l) =
         if ((jd == 0) || ((id-jd) == 0) || ((id+jd) == 0)) then 1
         else rsafe (succ id) l
         when jd = j2-j end
   end;
</pre>
</blockquote>
<!--  -->
<p><strong>(checkqs l)</strong></p>
<blockquote>
<p>checks one solution either in 0..n-1 encoding or in 1..n
encoding. It returns 0 for a correct result, including &quot;nosolution&quot;
for sizes 2 and 3; 1 is returned if a queen attack exists anywhere
within the presented 'solution'.</p>
<pre class="literal-block">
checkqs [] = 0;
checkqs (s::int:l) = if unsafe s l then 1 else checkqs l;
checkqs (nosolution) = 0;
</pre>
</blockquote>
<!--  -->
<p><strong>(queenstest method l)</strong></p>
<blockquote>
<p>conducts exhaustive tests of solutions,
returns either 'passed' or 'failed'. Can be supplied either a
name of a method that will produce a single solution for each
listed board size, or (id) followed by a list of candidate
solutions. The latter form is useful for testing 'allqueens'.
Example usage:</p>
<pre class="literal-block">
&gt;queenstest (id) (allqueens 8);
&gt;queenstest (id) (queens 8);
&gt;queenstest tailqueens [5,6,7];
&gt;queenstest thequeens (5000:4999..100);
</pre>
<pre class="literal-block">
queenstest _ [] = passed;
queenstest method (h:l) =
      if checkqs (method h) then failed
      else (queenstest method l);
</pre>
</blockquote>
</div>
</div>
</body>
</html>
