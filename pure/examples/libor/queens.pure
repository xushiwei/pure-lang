/* .. We use docutils to produce the documentation. Docstrings are extracted
   .. with pure-doc. Please see the pure-doc documentation for details.

======================================
Some Solutions to the N Queens Problem
======================================

:Author: Libor Spacek (C) <libors@gmail.com>
:License: GPL V3
:Date: 21th May 2008  Version 2: May 2009

**Example usage:**

	# pure -i queens.pure

	>fullboard (thequeens 50); */

// using namespace queens;
// public allqueens queens tailqueens fullboard thequeens checkqs queenstest;
// private safe;

nullary failed nosolution;

/* 
**(diagsafe j l)**
	is square j in current row safe from just the diagonal attacks by previously
	placed queens in list l? id is the +ve rows difference  used for recursion */

diagsafe j::int l = rsafe 1 j l
	with
	rsafe _ _ [] = 1;
	rsafe id::int j::int (j2::int:l) = 
		if id==(abs(j2-j)) then 0 else rsafe (succ id) j l
	end;

/* remove an element from a list - used for candidates list reduction */
rem _ [] = [];
rem h1::int (h2::int:t) = if h1 == h2 then t else h2:(rem h1 t);

/* ..
**(fullboard s)**
	full coordinates representation [(row,column),...] is redundant
	because the first coordinate of any solution will always be 1..n. 
	However, it can be reconstructed with, e.g.: (fullboard (thequeens n));
	By default all solutions here are encoded as the columns permutations only, 
	[column, ...], leaving out the ordered rows.
	In all cases rows and columns are interchangeable without affecting
	the solutions, i.e. reading the same numbers as [row, ....] for ordered
	columns is also valid.
*/
fullboard s = zip (1..(#s)) s;

/* ..
**(allqueens n)**
	returns all possible solutions by constrained search.
	N.B. nobody has so far been able to find out, by any known method, the number
	of solutions for n=26 and beyond. Allqueens, which is quite fast,
	starts getting breathless beyond n=13 with #solutions = 73,712.
	Only half of the first row is considered for the first queen, 
	thus halving the total search effort, followed by a single reflection of the solutions found. Odd sized boards have additionally the middle row searched. 
	All rook checking (row and column) is eliminated by using only valid 
	candidates c (generating only valid permutations), 
	leaving just a single check to perform for the bishop (both diagonals).
	More reflections/rotations could be done but they would have to be 
	tested for duplicates.
		>allqueens 8; returns all 92 solutions, as a list of lists */

allqueens n::int = unimplemented for less than 5 if (n < 5);
	= if (n mod 2 == 0) then (hsoln+revsoln) else
		(hsoln+(list (search pn (rem hsn nl) [hsn]))+revsoln)
  when pn = pred n; sn = succ n; hsn = sn div 2;
	hnl = (1..(n div 2)); nl = (1..n);
	hsoln = list (tuple (map (\j -> search pn (rem j nl) [j]) hnl));
   revsoln = map (\y -> map (\z -> sn-z) y) hsoln
	end
	with
	search 0 c p = p;
	search i::int c p = tuple 
		(map (\j -> search (pred i) (rem j c) (j:p)) [k | k = c; diagsafe k p])
  end;

/* ..
**(queens n)**
*/

queens n::int = search n n []
  with
   search 0 _ p = [];  			// last i, solved
   search _ 0 _ = nosolution;    	// failed, run out of alternative js
   search i::int j::int p = 
     if (nosolution === solution) then search i (pred j) p else j:solution
     when solution = search (pred i) n (j:p) end if safe j p;
     = search i (pred j) p	       // also try another j when unsafe
  end;

/* ..
**(tailqueens n)**
	this concise backtracking tailrecursive version 
	throws a single solution which is the rows reflection
	of that found by "queens"  */

tailqueens n::int = catch id (srch n n []) 
  with srch 0 _ p = throw p; // no more rows: solved
		 srch _ 0 _ = nosolution; // out of columns: failed
       srch i::int j::int p = if safe j p then 
         ( if nosolution === (srch (i-1) n (j:p)) then srch i (j-1) p else [] ) 
       else srch i (j-1) p
  end;

/* ..
**(thequeens n)**
	encodes my no search regular solution in just 12 lines of code,
	which is to my knowledge the simplest and fastest known algorithm for 
	the N-Queens problem. It is very fast even for large boards.

	There always exists one symmetrical (under 180 degrees rotation) 
	solution of this form, producing an orbit of just 4 equivalent solutions, 
	instead of the usual 8. The correct pattern is generated directly without
	any checking or searching being necessary.
	The solutions had been tested exhaustively for board sizes 0 to 5000 
	and individually for board size 50000x50000. */

thequeens n::int = case n of
	1 = [1];  // trivial solution to one square board
	2 | 3 = nosolution;
	_::int = 1:(map succ (thequeens (n-1))) if (n mod 2);// odd size boards done
		= map (newsq) (0..(n-1)) // the rest is even sized boards solution
		with 
		newsq x::int = (succ ((start+2*x) mod n)) if x < hn;
						 = (succ ((restart+2*(x-hn)) mod n)) end
		when hn::int = (n div 2); // half n
			start::int = if (n mod 3) then (pred hn) else 1; //(n mod 3) special
			restart::int = (1+n-start) end 
end; // end of case and thequeens

/* The rest are test utilities

**(safe j l)**
	is square j in current row safe from any attacks by previously
	placed queens in list l? id is the +ve rows difference used for recursion 
	with rsafe */

safe j::int l = rsafe 1 j l
	with
	rsafe _ _ [] = 1;
	rsafe id::int j::int (j2::int:l) = 
		if ((j==j2) || (id==(abs(j2-j)))) then 0 else rsafe (succ id) j l
	end;

/*..
**(checkqs l)**
	checks one solution either in 0..n-1 encoding or in 1..n
	encoding. It returns 1 for a correct result, including "nosolution" 
	for sizes 2 and 3; 0 is returned if a queen attack exists anywhere 
	within the presented 'solution'.
*/

checkqs [] = 1;
checkqs (s::int:l) = if safe s l then checkqs l else 0;
checkqs (nosolution) = 1;

/*..
**(queenstest method l)**
	conducts exhaustive tests of solutions for boards of all listed sizes. Usage:
		>queenstest (id) (allqueens 8);
		
		>queenstest queens (1..10); 

		>queenstest tailqueens ([5,6,7]);

		>queenstest thequeens (5000:4999..100); */

queenstest _ [] = 1;
queenstest method (h:l) = 
		if checkqs (method h) then (queenstest method l) else 0;
