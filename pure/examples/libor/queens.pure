/* ..

======================================
Some Solutions to the N Queens Problem
======================================

:Author: Libor Spacek (C) <libors@gmail.com\>
:License: GPL V3
:Date: Version 2: June 2009

**Example usage:**

	\# pure -i queens.pure
	
	\>fullboard (thequeens 50); */

// using namespace queens;
// public allqueens queens tailqueens fullboard thequeens checkqs queenstest;
// private safe;

nullary nosolution passed failed;

/* ..

**(diagsafe j l)**

	is square j in current row safe from the diagonal attacks by previously
	placed queens in list l? id is the +ve rows difference  used in
	local recursion to check all the occupied rows */

diagsafe j::int l = rsafe 1 l
	with
	rsafe id::int [j2::int] = if id==(abs(j2-j)) then 0 else 1;
	rsafe id::int (j2::int:l) = if id==(abs(j2-j)) then 0 else rsafe (succ id) l 
	end;
	
ecat h::int [] = [h];
ecat h::int (h2::int:t) = h2:(ecat h t);
rotate (h::int:t) = ecat h t;

rot 1 l = [l];
rot i::int l = l:(rot (pred i)(rotate l));
rotations l = rot (#l) l;

iteraten n::int f x = (iterate f x)!!(0..(pred n));
lazyrotations l = iteraten (#l) rotate l;

/* work in progress
permute [i::int] = [i];
permute (h::int:t) =  (hr:(permute tr)) when (hr:tr) = (ecat h t) end;
permuten l = iteraten (foldl1 (*) (1..(#l))) permute l; */

/* remove an element from an ordered list used for candidates list reduction */
rem _ [] = [];
rem h1::int (h2::int:t) = if h1 == h2 then t else h2:(rem h1 t);

/* remove an ordered tuple from an ordered tuple of ints */
remtuple _ () = ();
remtuple () l = l;
remtuple h1::int (h2::int,t2) = (h2,t2) if h1 < h2;
remtuple h1::int (h2::int,t2) = t2 if h1 == h2;
remtuple h1::int (h2::int,t2) = h2,(remtuple h1 t2);
remtuple (h1::int,t1) (h2::int,t2) = remtuple t1 (h2,t2) if h1 < h2;
remtuple (h1::int,t1) (h2::int,t2) = remtuple t1 t2 if h1 == h2;
		= h2,(remtuple (h1,t1) t2); 

/* remove an ordered triple from a list of ordered lists 
remlists _ [] = [];
remlists (ld::int,m::int,hd::int) (h2:t2) = ((remlist (h1:t1) h2):(remlists   if h1 == 1;
remlist (h1::int:t1) (h2::int:t2) = remlist t1 (h2:t2) if h1 < h2;
remlist (h1::int:t1) (h2::int:t2) = remlist t1 t2 if h1 == h2;
		= h2:(remlist (h1:t1) t2); */
/* ..

**(fullboard s)**

	full coordinates representation [(row,column),...] is redundant
	because the first coordinate of any solution will always be 1..n. 
	However, it can be reconstructed with, e.g.\: (fullboard (thequeens n));
	By default all solutions here are encoded as the columns permutations only, 
	[column, ...], leaving out the ordered rows.
	In all cases rows and columns are interchangeable without affecting
	the solutions, i.e. reading the same numbers as [row, ....] for ordered
	columns is also valid. */
	
fullboard s = zip (1..(#s)) s;

/* ..

**(allqueens n)**

	returns all possible solutions by constrained search.
	N.B. nobody has so far been able to find out, by any known method, the number
	of solutions for n=26 and beyond. Allqueens, which is quite fast,
	starts getting breathless beyond n=13 with the total number of 
	solutions = 73,712.
	
	Only half of the first row is considered for the first queen, 
	thus halving the total search effort, 
	followed by adding a reflection of all the solutions found 
	about the middle column. 
	Odd sized boards must have additionally the first midrow starting position
	searched and add its solutions. 
	More reflections and rotations could be done but the solutions 
	would have to be 	tested for duplicates.
	All rook checking (row and column) is eliminated by using only unused 
	candidates list c (generating only valid permutations), 
	leaving just a single check, id==abs(j2-j),  
	to perform for the bishop (both diagonals).
		
		\>allqueens 8; returns all 92 solutions, as a list of lists */

allqueens n::int = unimplemented for less than 5 if (n < 5);
	= if (n mod 2 == 0) then (hsoln+revsoln) else
		hsoln+(list (search pn (rem hsn nl) [hsn]))+revsoln
  when pn = pred n; sn = succ n; hsn = sn div 2;
	hnl = (1..(n div 2)); nl = (1..n);
	hsoln = list (tuple (map (\j -> search pn (rem j nl) [j]) hnl));
   revsoln = map (\y -> map (\z -> sn-z) y) hsoln
	end
	with
	search 0 c p = p;
	search i::int c p = tuple 
		(map (\j -> search (pred i) (rem j c) (j:p)) [k | k = c; diagsafe k p])
  end;
/* work in progress
newqueens n::int = unimplemented for less than 5 if (n < 5);
	= if (n mod 2 == 0) then (hsoln+revsoln) else
		(hsoln+(list (search pn (remlist [(pred hsn),hsn,(succ hsn)] nl) [hsn]))+revsoln)
  when pn = pred n; sn = succ n; hsn = sn div 2;
	hnl = (1..(n div 2)); nnl = [(1..n)|i=1..pn];
	hsoln = list (tuple (map (\j -> search pn (rem j nl) [j]) hnl));
   revsoln = map (\y -> map (\z -> sn-z) y) hsoln
	end
	with
	search 0 c p = p;
	search i::int c p = tuple 
		(map (\j -> search (pred i) (rem j c) (j:p)) [k | k = c; diagsafe k p])
  end;
*/

/* ..

**(queens n)** */

queens n::int = search n n []
  with
   search 0 _ p = [];  			// last i, solved
   search _ 0 _ = nosolution;    // failed, run out of alternative js
   search i::int j::int p = 
     if (nosolution === solution) then search i (pred j) p else j:solution
     when solution = search (pred i) n (j:p) end if safe j p;
     = search i (pred j) p	       // also try another j when unsafe
  end;

/* ..

**(tailqueens n)**

	this concise backtracking tailrecursive version 
	throws a single solution which is the rows reflection
	of that found by "queens"  */

tailqueens n::int = catch id (srch n n []) 
  with srch 0 _ p = throw p; // no more rows: solved
		 srch _ 0 _ = nosolution; // out of columns: failed
       srch i::int j::int p = if safe j p then 
         ( if nosolution === (srch (i-1) n (j:p)) then srch i (j-1) p else [] ) 
       else srch i (j-1) p
  end;

/* ..

**(thequeens n)**

	encodes my no search regular solution in just 12 lines of code,
	which is to my knowledge the simplest and fastest known algorithm for 
	the N-Queens problem. It is very fast even for large boards.

	There always exists one symmetrical (under 180 degrees rotation) 
	solution of this form, producing an orbit of just 4 equivalent solutions, 
	instead of the usual 8. The correct pattern is generated directly without
	any checking or searching being necessary.
	The solutions had been tested exhaustively for board sizes 0 to 5000 
	and individually for board size 50000x50000. */

thequeens n::int = case n of
	1 = [1];  // trivial solution to one square board
	2 | 3 = nosolution;
	_::int = 1:(map succ (thequeens (n-1))) if (n mod 2);// odd size boards done
		= map (newsq) (0..(n-1)) // the rest is even sized boards solution
		with 
		newsq x::int = (succ ((start+2*x) mod n)) if x < hn;
						 = (succ ((restart+2*(x-hn)) mod n)) end
		when hn::int = (n div 2); // half n
			start::int = if (n mod 3) then (pred hn) else 1; //(n mod 3) special
			restart::int = (1+n-start) end 
end; // end of case and thequeens

/* .. The rest are test utilities

**(safe j l)**

	is square j in current row safe from any attacks by previously
	placed queens in list l? id is the +ve rows difference used for recursion 
	with rsafe */

safe j::int l = rsafe 1 l
	with
	rsafe _ [] = 1;
	rsafe id::int (j2::int:l) = 
		if ((jd == 0) || (jd == id)) then 0 else rsafe (succ id) l
		when jd = abs(j2-j) end
	end;

/*..

**(checkqs l)**

	checks one solution either in 0..n-1 encoding or in 1..n
	encoding. It returns 1 for a correct result, including "nosolution" 
	for sizes 2 and 3; 0 is returned if a queen attack exists anywhere 
	within the presented 'solution'. */

checkqs [] = 1;
checkqs (s::int:l) = if safe s l then checkqs l else 0;
checkqs (nosolution) = 1;

/*..

**(queenstest method l)**

	conducts exhaustive tests of solutions for boards of all listed sizes. Usage:
	
		\>queenstest (id) (allqueens 8);
		
		\>queenstest queens (1..10);
		 
		\>queenstest tailqueens ([5,6,7]);
		
		\>queenstest thequeens (5000:4999..100); */

queenstest _ [] = passed;
queenstest method (h:l) = 
		if checkqs (method h) then (queenstest method l) else failed;
