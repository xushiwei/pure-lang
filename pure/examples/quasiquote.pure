
/* An implementation of Lisp's quasiquote. 2008-10-08 AG. */

/* These rules implement a Lisp-like quasiquote which produces a quoted
   expression while evaluating embedded calls of 'unquote' and 'splice'. See
   the Pure manual for a discussion of this macro. */

def quasiquote (unquote x)	= x;
def quasiquote (splice x)	= case x of
				    x = foldl1 ($) x if listp x;
				      = throw (bad_list_value x);
				  end;
def quasiquote (f@_ (splice x))	= case x of
				    x = foldl ($) (quasiquote f) x if listp x;
				      = throw (bad_list_value x);
				  end;
def quasiquote (f@_ x)		= quasiquote f (quasiquote x);
def quasiquote x::matrix	= map qq (quote x) with
				    qq (unquote x) = eval x;
				    qq (f@_ x)     = qq f (qq x);
				    qq x::matrix   = map qq x;
				    qq x           = x;
				  end;
def quasiquote x		= quote x;

/* Some syntactic sugar for Lisp weenies. Note that we cannot have ',' for
   unquoting, so we use ',$' instead. */

prefix 9 ` ,$ ,@ ;
def `x = quasiquote x; def ,$x = unquote x; def ,@x = splice x;

/* Unquoting example. This yields 'foo 1 2 0.75 (5/6)'. */

`foo 1 2 (,$(3/4)) (5/6);

/* This also works for list, tuple and matrix values. */

`[1,2,,$(3/4),5/6];
`(1,2,,$(3/4),5/6);
`{1,2,,$(3/4),5/6};

/* Splicing allows you to insert arguments into a function application. The
   argument of 'splice' must be a list value with the arguments to be
   spliced. E.g., the following example yields 'foo 1 2 (2/3) (3/4) (5/6)'. */

`foo 1 2 (,@'[2/3,3/4]) (5/6);

/* Note that the actual splicing is done at runtime, hence splicing argument
   lists computed at runtime works ok, too. */

`foo 1 2 (,@x) (5/6) when x = '[2/3,3/4] end;

/* Our implementation also allows you to splice a list as the head of a
   function application. */

`(,@'[foo,2/3,3/4]) (5/6);
