
/* Quasiquote example. 2008-10-08 AG. */

/* These rules implement a (simplified) Lisp-like quasiquote. See the Pure
   manual for a discussion of this macro. */

apply (x:xs)     = apply x xs with
  apply x []     = x;
  apply x (y:ys) = apply (x y) ys;
  apply _ ys     = throw (bad_list_value ys);
end;
apply xs         = throw (bad_list_value xs);

def quasiquote (unquote x)	= x;
def quasiquote (splice x)	= apply x;
def quasiquote (f@_ (splice x))	= apply (quasiquote f:x);
def quasiquote (f@_ x)		= quasiquote f (quasiquote x);
def quasiquote x::matrix	= map qq (quote x) with
				    qq (unquote x) = eval x;
				    qq (f@_ x)     = qq f (qq x);
				    qq x::matrix   = map qq x;
				    qq x           = x;
				  end;
def quasiquote x		= quote x;

/* Some syntactic sugar for Lisp weenies. Note that we cannot have ',' for
   unquoting, so we use ',$' instead. */

prefix 9 ` ,$ ,@ ;
def `x = quasiquote x; def ,$x = unquote x; def ,@x = splice x;

/* Unquoting example. This yields 'foo 1 2 0.75 (5/6)'. */

`foo 1 2 (,$(3/4)) (5/6);

/* Splicing example. This yields 'foo 1 2 (2/3) (3/4) (5/6)'. */

`foo 1 2 (,@'[2/3,3/4]) (5/6);

/* Note that the actual splicing is done at runtime, hence splicing argument
   lists computed at runtime works ok, too. */

`foo 1 2 (,@x) (5/6) when x = '[2/3,3/4] end;
