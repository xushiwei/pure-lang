
/* An implementation of Lisp's quasiquote. 2009-05-26 AG. */

/* Our implementation tries to stay as close to the spirit of the original
   quasiquote (see, e.g., Guy L. Steele, Common Lisp the Language, 2nd
   Edition) as reasonably possible in Pure. Nested quasiquotes work as
   expected, but note that our implementation only strips away the outermost
   quasiquote level, in the same way as Scheme's quasiquote. (In contrast,
   Common Lisp implementations of quasiquote usually expand the entire
   expression in one go. See quasiquote2.pure for a macro implementation of
   quasiquote which does about the same in Pure.)

   Also note that, due to the differences in representing function
   applications, splicing works somewhat differently from the Lisp version:

   - `,@[a,b,c]		=> a b c

   - `(,@[a,b,c]) x y	=> a b c x y

   - `x (,@[a,b,c]) y	=> x a b c y

   Thus, in our implementation splicing essentially "curries" the argument
   list, and this will work in any context. (Also, the current implementation
   does *not* support splicing into other Pure aggregate structures such as
   lists, tuples and matrices, as these data structures already provide their
   own means to do this.) Finally note that, like in Lisp, the argument of
   'splice' must always evaluate to a proper list, otherwise 'quasiquote'
   raises an exception. */

/* Some syntactic sugar for Lisp weenies. Note that we cannot have ',' for
   unquoting, we use ',$' instead. Also note that '`', ',$' and ',@' are just
   ordinary prefix operators, applications of these must be parenthesized
   accordingly. Thus, e.g., the Lisp expression `(f ,@(a b c)) would be
   written as `f (,@[a,b,c]) in Pure. */

prefix 9 ` ,$ ,@ ;
def (`) = quasiquote; def (,$) = unquote; def (,@) = splice;

/* Quasiquote itself is implemented as a macro which simply expands to a call
   of the qq function below. Thus the evaluation of the quasiquote is actually
   done at runtime. */

def quasiquote x = qq (quote x);

/* qq x descends into x, substituting embedded instances of unquote and splice
   at "level 0" (i.e., belonging to the outermost quasiquote) only. */

qq x = qqn 0 x with
/* Note that we have to deal with both the normalized and the literal forms of
   embedded instances of quasiquote, unquote and splice here, as these forms
   may occur unevaluated inside quoted subterms. */
qqn n (`x)		|
qqn n (qq (quote x))	= quote (quasiquote y) when y = qqn (n+1) x end;
qqn 0 (,$x)		|
qqn 0 (unquote x)	= eval x;
qqn 0 (,@x)		|
qqn 0 (splice x)	= case eval x of
			    x = foldl1 ($) x if listp x;
			      = throw (bad_list_value x);
			  end;
qqn 0 (f@_ (,@x))	|
qqn 0 (f@_ (splice x))	= case eval x of
			    x = foldl ($) (qqn 0 f) x if listp x;
			      = throw (bad_list_value x);
			  end;
qqn n (,$x)		|
qqn n (unquote x)	= unquote (qqn (n-1) x);
qqn n (,@x)		|
qqn n (splice x)	= splice (qqn (n-1) x);
qqn n (f@_ (,@x))	|
qqn n (f@_ (splice x))	= qqn n f (splice (qqn (n-1) x));
qqn n (f@_ x)		= qqn n f (qqn n x);
qqn n x::matrix		= map (qqn n) x;
qqn n x			= x;
end;

/* Unquoting example. This yields 'foo 1 2 0.75 (5/6)'. */

`foo 1 2 (,$(3/4)) (5/6);

/* In fact, you can also achieve the same by just substituting a local
   variable into a normal quoted expression. This works in Pure, because in
   difference to Lisp a local variable is never quoted, rather its value is
   always substituted directly into the quoted expression without any further
   ado. */

'foo 1 2 x (5/6) when x = 3/4 end;

/* Splicing allows you to insert arguments into a function application. The
   argument of 'splice' must be a list value with the arguments to be
   inserted. The following example yields 'foo 1 2 (2/3) (3/4) (5/6)'. */

`foo 1 2 (,@'[2/3,3/4]) (5/6);

/* The following example computes the same value as above, but takes the
   spliced value from a local variable. Note again that the variable x can't
   be quoted, thus the extra quote before the spliced value is needed to
   inhibit its evaluation. */

`foo 1 2 (,@'x) (5/6) when x = '[2/3,3/4] end;

/* It's also possible to splice a list as the head of a function application.
   This example yields 'foo (2/3) (3/4) (5/6)'. */

`(,@'[foo,2/3,3/4]) (5/6);

/* A nested quasiquote. Like in Scheme, this only expands the outermost
   quasiquote, yielding 'a (quasiquote (b (unquote (1+2)) (unquote (foo 4 d))
   e)) f'. A subsequent evaluation of the resulting term then expands the
   nested quasiquote, yielding 'a (b 3 (foo 4 d) e) f'. */

let x = `(a (`(b (,$(1+2)) (,$(foo (,$(1+3)) d)) e)) f);
x; eval x;
