
pd-pure: Pd loader for Pure scripts
======== == ====== === ==== =======

Copyright (c) 2008 by Albert Graef <Dr.Graef@t-online.de>
Distributed under the GNU Public License V3, see COPYING for details.

This plugin lets you write external Pd control objects in Pure. Pure is a
functional programming language based on the term rewriting calculus, see
http://pure-lang.googlecode.com.

This is still an experimental version, please report bugs to the author.

In particular, note that the embedded Pure interpreter uses the same kind of
JIT compiler as the command line version of the interpreter, which may cause
delays during startup, since the Pure functions are compiled on demand. With
the current version of the LLVM JIT used by the Pure interpreter there's no
easy way around this, but we hope to fix this issue in a future release. Once
all Pure objects have been compiled to native code, they are executed very
efficiently.

Installation
============

Usually, 'make && sudo make install' should do the trick. This will compile
the external (you need to have both Pd and Pure installed to do that) and
install it in the lib/pd/extra/pure directory.

The Makefile tries to guess the installation prefix under which Pd is
installed. If it guesses wrong, you can tell it the right prefix with 'make
prefix=/some/path'. Or you can specify the exact path of the lib/pd/extra
directory with 'make pdextradir=/some/path' (by default the Makefile assumes
$(prefix)/lib/pd/extra).

After installation, you still have to tell Pd to load the Pure external at
startup, either with the -lib option (pd -lib pure), or by specifying 'pure'
in the File/Startup options. (The latter setting can be saved so that the Pure
loader is always available when you run Pd.)

Usage
=====

See the pure-help.pd patch for a few examples. Basically, to implement a Pd
object named 'foo', you have to supply a Pure script named 'foo.pure' which
defines the 'foo' function and anything else that it might need. Put that
script in the same directory as the Pd patch in which you want to use the
'foo' object. The 'foo' function gets evaluated at object creation time,
receiving any additional parameters the object is created with. The resulting
Pure expression (which can also just be 'foo' itself) becomes the object
executed at runtime, by passing Pd messages from the inlets as parameters, and
routing the function results to the outlets of the object.

Note that you can also define multiple objects in a single script file, say
'master.pure'. To these ends, simply create a symbolic link of the form
'foo.pure' to 'master.pure' for each object 'foo' in the script that you want
to use. (This only works on Unix systems. On Windows you'll have to use
separate scripts instead.)

Pd messages are translated to corresponding Pure expressions and vice versa in
a straighforward fashion. E.g., the Pd message 'foo a 2 3' becomes the Pure
expression 'foo a 2 3'. Pd symbols which are no valid Pure symbols become
strings in Pure. Conversely, Pure integers and floating point values become
'float' messages in Pd. Pure symbols and strings are mapped to Pd symbols.

By default, a Pure object has just one inlet and one outlet. For instance, the
following object [add5] accepts Pd 'float' messages and adds 5 to each
received value:

add5 (float x) = x+5;

You can also parameterize an object with creation arguments:

add x (float y) = x+y;

This object can then be invoked, e.g., as [add 5] in the Pd patch to supply
the needed creation argument x.

Configuring Inlets and Outlets
=========== ====== === =======

To create an object with multiple inlets and outlets, the object creation
function must return the desired numbers of inlets and outlets, along with a
second function to be applied at runtime, as a tuple n,m,foo. The input
arguments to the runtime function as well as the corresponding function
results are then encoded as pairs k,val where k denotes the inlet or outlet
index. (Note that the k index is provided only if there actually is more than
one inlet. Also, the outlet index is assumed to be zero if none is specified,
so that it can be omitted if there's only one outlet.)

For instance, the following object, invoked as [cross] in the Pd patch, has
two inlets and two outlets and routes messages from the left inlet to the
right outlet and vice versa.

cross = 2,2,cross with cross (k,x) = (1-k,x) end;

You can also emit multiple messages, possibly to different outlets, in one
go. These must be encoded as lists of values or index,value pairs, which are
emitted in the order in which they are written. E.g., the following [fan]
object implements an "n-fan" which routes its input to n outlets
simultaneously:

fan n = 1,n,fan n with fan n x = reverse [k,x | k = 0..n-1] end;

(Note that, because of the use of the 'reserve', the n outlets are served in
right-to-left order here. This is not strictly necessary, but matches the Pd
convention.)

Another example is the following [dup] object with a single inlet and outlet,
which just sends out each received message twice:

dup x = [x,x];

An object can also just "swallow" messages and generate no output at all. To
these ends, make the object return either an empty list [] or the empty tuple
(). For instance, the following object [echo] implements a sink which just
prints received messages on standard output, which is useful for debugging
purposes:

using system;
echo x = () when puts (str x) end;

You could also implement this object as follows, by just removing the
superflous outlet (in this case all return values from the function will be
ignored anyway):

using system;
echo = 1,0,puts.str;

Local State
===== =====

Local state can be kept in Pure reference values. For instance, the following
[counter] object produces the next counter value when receiving a 'bang'
message:

nullary bang;
counter = next (ref 0) with
  next r bang = put r (get r+1);
  next _ _    = () otherwise;
end;

Asynchronous Messages
============ ========

pd-pure provides a simple asynchronous messaging facility which allows a Pure
object to schedule a message to be delivered to itself later. This is useful
for implementing all kinds of delays and, more generally, any kind of object
which, once triggered, does its own sequencing of output messages.

To these ends, the object function may return a special message of the form
'delay t msg' (either by itself or as an element of a result list) to indicate
that the message 'msg' should be delivered to the object function after t
milliseconds (where t is either a machine int or a double value). After the
prescribed delay the object function will then be invoked on the given
message, and the results of this call are processed as usual (routing messages
to outlets and/or scheduling new timer events in response to further 'delay'
messages). Note that if the delay is zero or negative, the message is
scheduled to be delivered immediately.

For instance, a simple kind of delay object can be implemented in Pure as
follows:

mydelay _ (alarm msg) = msg;
mydelay t msg = delay t (alarm msg) otherwise;

The desired delay time is specified as a creation argument. The first equation
handles messages of the form 'alarm msg'; the action is to just output the
delayed message given by the 'msg' argument. All other input messages are
scheduled by the second equation, which wraps the message in an 'alarm' term
so that it gets processed by the first equation when it is delivered.

Note that pd-pure only allows you to schedule a single asynchronous event per
call of the object function. Thus, if the 'mydelay' object above receives
another message while it is still waiting for the previous one to be
delivered, the old timer is cancelled and the new one is scheduled instead;
this works like Pd's builtin 'delay' object.

Moreover, scheduling a new event at an infinite (or nan) time value cancels
any existing timer. (Note that you still have to specify the 'msg' parameter,
but it will be ignored in this case.) We can use this to equip our 'mydelay'
object with a 'stop' message as follows:

nullary stop;
mydelay _ (alarm msg) = msg;
mydelay _ stop = delay inf ();
mydelay t msg = delay t (alarm msg) otherwise;

More elaborate functionality can be built on top of the basic timer
facility. The following example shows how to maintain a timed message queue in
a Pure list, in order to implement a simple delay line similar to Pd's builtin
'pipe' object. Here we also employ the 'pd_time' function, which is provided
by the Pure loader so that Pure scripts can access the current logical Pd time
in milliseconds. This is convenient if we need to deal with absolute time
values, which we use in this example to keep track of the times at which
messages in the queue are to be delivered.

extern double pd_time();
mypipe t = process (ref []) with
  process q () = case dequeue q of
                   x,(t,_):_ = [x,delay (t-pd_time) ()];
                   x,_ = x;
                 end;
  process q x  = enqueue q x $$ delay t () if null (get q);
               = enqueue q x $$ () otherwise;
  enqueue q x  = put q $ get q+[(pd_time+t,x)];
  dequeue q    = x,put q xs when (_,x):xs = get q end;
end;

The [pure] Object
=== ====== ======

The Pure loader also provides a generic 'pure' object as a quick and dirty
means to create a Pure object from a predefined function without loading a
script file. However, since most functions in the Pure prelude are not
prepared to deal with raw Pd messages, this is most useful for special
purposes such as debugging.

For instance, [pure str] creates an object with a single inlet and outlet
which applies the prelude function 'str' to its inputs. Connecting this to
Pd's [print] object provides a quick way to print the Pure representation of
messages passed to the inlet of the [pure str] object.

The [pure] object can also be used to generate constant numbers or string
values. For instance, [pure cst (1/7)] responds to any message (such as
'bang') by producing the value 1/7 = 0.142857...


Enjoy. :)
Albert Graef <Dr.Graef@t-online.de>
