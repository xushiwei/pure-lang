/* stlstruct.pure - named field data structures using the stlvec library 

Copyright (c) 2011-2012 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stllib, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stlvec distribution package for details

defstruct and defstruct_code
----------------------------

The defstruct macro is used to define a "struct", a custom data type that
holds arbitrary Pure expressions in named fields. The macro defines a type tag
for the new type, functions to create instances of it and functions for
setting and accessing field values.

    defstruct name_spec field_spec

The name_spec is used to name the custom data structure and to specifiy
whether all of its instances are mutable or immutable. The field_spec names
each field in the structure and optionally specifies the type of the field and
whether the field is readonly or settable. If the custom data structure is
immutable, the "setter functions" generated by defstruct will
"copy-and-write".

The defstruct_code macro is the same as defstruct except that it generates
code and prints it rather than evaluating it. If you want, you can paste
the generated code in your scripts.

Example 1 - A mutable stlstruct with getter functions
-----------------------------------------------------

Set things up to avoid warnings.

   > using system, pslib::stlstruct;
   > #! --nowarn

Define a structure date type, worker. Each plumber is a mutable structure
with three fields: name, idnum, and unit. name must be a string, idnum must be
and int and unit can be anything.

   > stl::defstruct plumber {name.string, idnum.int, unit};
   ()

Construct a plumber.

   > let p = plumber {"Steve",203, "unit_11"};

Get the name.

   > name p;                       // name works on plumbers
   "Steve"

   > p!plumber_name;               // fails, getters or indexed not both
   (plumber {"Steve",203,"unit_11"}) !plumber_name

Set the idnum.

   > set_idnum p 213.0;            // fails, 213.0 is not an int
   set_idnum (plumber {"Steve",203,"unit_21"}) 213.0

   > set_idnum p 213;             // ok
   plumber {"Steve",213,"unit_21"}

   > p;                           // mutable -- p was changed
   plumber {"Steve",213,"unit_21"}


Example 2 - An immutable stlstruct accessed by (!)
--------------------------------------------------

Define the structure. The ".i" means use indexed read style. The "/immutable"
means that the structures are immutable. I.e., setter functions write on and
return a copy of structures the are asked to change.

   > stl::defstruct (worker.i/immutable) {name.string, idnum.int, unit};
   ()

Construct a worker.

   > let w = worker {"Fred", 201, "unit_10"};

   > typep worker w;
   1

The constructor parameters are type-checked:

   > catch id $ worker {"Fred", (), "unit_10"};
   bad_argument

Using [] instead of {} you can turn off type guards for constructor
parameters. This can be useful when you need a partially initialized instance
of a new structure.

   > let w_pi = worker ["Fred",(),"unit_10"]
  
   > w_pi;
   worker{"Fred",(),"unit_10"}

Fields for structs with indexed read style are accessed using (!) using the
constants generated by defstruct.

    > w!worker_name;
   "Fred"

   > w!worker_unit;
   "unit_10"

Change the worker's name. Because worker is an immutable data structure, w is
not changed. Instead an updated new worker is created and returned

   > let w1 = set_name w "Sam";
 
   > w1;                             // w1 is Sam
   worker{"Sam",201,"unit_10"}

   > w;                              // w is still Fred
   worker{"Fred",201,"unit_10"}

   
Example 3 - A mutable stlstruct with a read-only field
------------------------------------------------------

Define the struct. The "/mutable" after a struct name makes the whole
structure mutable, i.e., the setter functions return the (updated) struct
passed to them, not a new one. The "/r" after a field name means that the
field is read-only, i.e., do not create a setter fuction for tne field.

   > stl::defstruct (painter.i/mutable) {name, idnum.int/r, unit};
   ()

   > let p = painter {"Bill",202, "unit_10"};

   > p!painter_name;
   "Bill"

   > set_unit p "unit_20";
   painter{"Bill",202,"unit_20"}

   > p;
   painter{"Bill",202,"unit_20"}

Try to change idnum.

   > set_idnum p 203;            // fails
   set_idnum (painter {"Bill",202,"unit_20"}) 203

   > p;
   painter{"Bill",202,"unit_20"}
  

Parameter Syntax
----------------

   mutability ::= "/mutable" | "/immutable"

   read_style ::= ".i" | ".f"

   name_spec ::= identifier | ( read_style ] [ mutability] )

   access_tag ::= "/r" | "/s"

   typeguard ::= "." qualified_type_name

   field ::= identifier [ typeguard ] [ access_tag ]

   fields ::= field | fields, field

   field_list ::=  "{" fields "}"

   defstruct ::= "defstruct" name_spec field_list

"mutable" means change field values in place. "immutable" means copy on
write. I.e., the setter functions, if any, will make a copy before setting the
new value and return the copy rather than the original struct.  "i" is for
indexed reading (!) and "f" is for functional read_style. "r" is for read-only
and "s" is for settable.

For a name_spec, default mutability and read_style are "mutable" and "f". For
a field the default is no typeguard and "s".

Code Generated
--------------

Paste these lines in at the prompt and take a look.

  using stlstruct;
  #! --nowarn

  stl::defstruct_code plumber {name.string, idnum.int, unit};
  stl::defstruct_code (worker.i/immutable) {name.string, idnum.int, unit};
  stl::defstruct_code (painter.i/mutable) {name, idnum.int/r, unit};

Here is the code for plumber:

   ::plumber (stl::STRUCT ::plumber sv) = 
     stl::STRUCT ::plumber (stl::struct_dup sv);

   ::plumber v@{p0:: string,p1:: int,p2} = 
     stl::STRUCT ::plumber (stl::struct_sv v);

   ::plumber xs = 
     stl::STRUCT ::plumber (stl::struct_sv xs) 
     if ~vectorp xs && #xs == 3;

   ::plumber _ = throw bad_argument;

   ::name (stl::STRUCT ::plumber v) = stl::sv_get v 0;

   ::set_name (stl::STRUCT ::plumber sv) x:: string = 
      stl::STRUCT ::plumber (stl::sv_put sv 0 x $$ sv);

   ::idnum (stl::STRUCT ::plumber v) = stl::sv_get v 1;

   ::set_idnum (stl::STRUCT ::plumber sv) x:: int = 
      stl::STRUCT ::plumber (stl::sv_put sv 1 x $$ sv);

   ::unit (stl::STRUCT ::plumber v) = stl::sv_get v 2;

   ::set_unit (stl::STRUCT ::plumber sv) x = 
     stl::STRUCT ::plumber (stl::sv_

Explicit Namespaces
-------------------

Sometimes it is necessary to specify a namespace. For example, see
ut_struct.pure, in which the worker struct is defined first in the
global namespace and then in the "fo" namespace. In the second definition the
fo:: namespace qualifier is required. Note that the namespace qualifier is not
required for the "executive" struct because it was not previously defined.

It is not a bad idea to always specify the namespace in the name-spec. For one
thing you might change from the global namespace to a private namespace as you
are writing a program, and you might still intend for a particular struct
to be in the global namespace. E.g.,

    > stl::defstruct sa [fa];
    <stdin>, line 2: warning: implicit declaration of 'sa'
    <stdin>, line 2: warning: implicit declaration of 'fa'
    ()

    > stl::defstruct ::sb [::fb];

defstruct silently forces all of the field names to reside in the same
namespace as the name of the struct being defined.

*/

using system, regex;
using "lib:stlbase", "lib:stlvec";

public members bad_argument;

namespace stl;

private extern void* stl_sv_make_from_xs(expr* xs_or_sm);
private extern void* stl_sv_make_n(expr* xs, int n);
private extern void  stl_sv_delete(void* vec);
private extern void* stl_sv_dup(expr* it);
private extern expr* stl_sv_vector(expr* it);
private extern expr* stl_sv_foldr(expr* fun, expr* val, expr* it);
private extern int pure_sym(char* s);
private extern int atoi(char* s);

/* Runtime Support For stlstruct **********************************************/

nonfix STRUCT;
STRUCT = quote STRUCT;
const struct_constr = "stl::STRUCT";

type struct (STRUCT _ _ );

nonfix struct_error;

extern expr* stl_sv_get(void* vec, int pos) = sv_get;

extern void  stl_sv_put(void* vec, int pos, expr* val) = sv_put;

struct_err msg = throw (struct_error msg);

struct_sv xs = sentry stl_sv_delete (stl_sv_make_from_xs xs);

struct_dup sv = sentry stl_sv_delete (stl_sv_dup (STRUCT sv));

struct_put sv i x = sv_put sv i x $$ sv;


/* Bootstrapped stlstruct To Hold Field Info *********************************/

// stl::defstruct_code (fo::field_def) 
// {
//  fnamespace.string,
//  fname.string,
//  ftype.string,
//  faccess.string
// };

type field_def (stl::STRUCT field_def _);
field_def (stl::STRUCT field_def sv) = stl::STRUCT field_def (stl::struct_dup sv);
field_def v@{p0:: string,p1:: string,p2:: string,p3:: string} = stl::STRUCT field_def (stl::struct_sv v);
field_def xs = stl::STRUCT field_def (stl::struct_sv xs) if ~vectorp xs && #xs == 4;
field_def _ = throw ::bad_argument;
fnamespace (stl::STRUCT field_def v) = stl::sv_get v 0;
set_fnamespace (stl::STRUCT field_def sv) x:: string = stl::STRUCT field_def (stl::struct_put sv 0 x);
fname (stl::STRUCT field_def v) = stl::sv_get v 1;
set_fname (stl::STRUCT field_def sv) x:: string = stl::STRUCT field_def (stl::struct_put sv 1 x);
ftype (stl::STRUCT field_def v) = stl::sv_get v 2;
set_ftype (stl::STRUCT field_def sv) x:: string = stl::STRUCT field_def (stl::struct_put sv 2 x);
faccess (stl::STRUCT field_def v) = stl::sv_get v 3;
set_faccess (stl::STRUCT field_def sv) x:: string = stl::STRUCT field_def (stl::struct_put sv 3 x);

/* Functions To Parse defstruct And Generate Code *****************************/

private parse_field_spec parse_name_spec parse_field_specs eval_code 
        mk_struct_constructors mk_struct_accessors mk_struct ;

private readonly_tag settable_tag indexed_tag 
        functional_tag mutable_tag immutable_tag;

const readonly_tag = "r";
const settable_tag = "s";
const indexed_tag = "i";
const functional_tag = "f";
const mutable_tag = "mutable";
const immutable_tag = "immutable";

parse_field_spec default_namespace default_access spec = fdef when
  field_pat ="^[[:space:]]*([^ ./]+)(\\.[^ ./]+)?(/[^[:space:]]+)?$";
  ri = reg_info $ regex field_pat REG_EXTENDED spec 0;
  if #ri <8 then struct_err (sprintf "bad field def: %s" spec) else ();
  qname = ri!3;
  ftype = ri!5;
  faccess_str = ri!7;
  ri = reg_info $ regex "(([^ ./:]+)::)?([^ ./]+)" REG_EXTENDED qname 0;
  fnamespace, fname = ri!5,ri!7;
  fnamespace = if null fnamespace then default_namespace else fnamespace;
  ftype = if ::null ftype then ftype else substr ftype 1 1000;
  faccess = if ::null faccess_str then default_access 
            else substr faccess_str 1 1000;
  fdef = field_def {fnamespace ,fname, ftype, faccess};
end;

parse_name_spec name_spec = ns, struct_name, mutable, indexed
when
  ndef = catch err (parse_field_spec "" mutable_tag name_spec);
  ndx_tag = ftype ndef;
  indexed = if null ndx_tag then 0
            else if ndx_tag == indexed_tag then 1
            else if ndx_tag == functional_tag then 0
            else err 1;
  ns = fnamespace ndef;
  struct_name = fname ndef;
  m_tag = faccess ndef;
  mutable = if  m_tag == mutable_tag then 1
            else if m_tag == immutable_tag then 0
            else err 1;
end with
  err _ = struct_err (sprintf "bad name spec: %s" name_spec); 
end;

parse_field_specs nspace fields_spec = fdefs when
  fss = split "," (substr fields_spec 1 (#fields_spec-2));
  fdefs = map (parse_field_spec nspace settable_tag) fss;
end;

eval_code print code = () when
  if print then puts (code + ";") else eval code;
end;

mk_qname ns name = if null ns then "::" +  name else ns + "::" + name;

mk_constr ns name = struct_constr + " " + mk_qname ns name;

mk_struct_constructors print ns name fdefs = () when
  constr_name = mk_constr ns name;
  qname = mk_qname ns name;  
  ftypes = map ftype fdefs;  
  params = join "," $ zipwith mkparam ftypes (0..inf);
  eval_code print ("type " + qname + " (" + constr_name + " _)");
  cd = qname + " (" + constr_name + " sv) = " + constr_name + 
    " (stl::struct_dup sv)";
  eval_code print cd;
  cd = qname + " v@{" + params + "} = " + constr_name +
    " (stl::struct_sv v)";
  eval_code print cd;
  cd = qname + " xs = " + constr_name + 
    " (stl::struct_sv xs) if ~vectorp xs && #xs == " + str (#ftypes);
  eval_code print cd;
  cd = qname + " _ = throw ::bad_argument";
  eval_code print cd;
end with
 mkparam ftype i = sprintf "p%d%s" (i,tguard) when
    tguard = if null ftype then "" else ":: " + ftype;
  end;
end;

mk_struct_accessors print ns name mutable indexed fdefs = mk_a fdefs 0 
with
  mk_a [] _ = ();
  mk_a (fdef:rest) ndx = mk_a rest (ndx+1) when
    fldname = fname fdef;
    qfname = mk_qname ns fldname;
    pure_sym(qfname);
    cd = if indexed then
          "const " + name + "_" + fldname + " = " + str ndx 
         else
           qfname + " (" + constr_name + " v) = stl::sv_get v " + str ndx;
    eval_code print cd;
    if faccess fdef == readonly_tag then ()
    else if mutable then
      eval_code print (mk_mutable_setter fdef ndx)
    else
      eval_code print (mk_immutable_setter fdef ndx);
  end;
  mk_mutable_setter fdef ndx = setter_lhs fdef + " = " + constr_name + 
    " (stl::struct_put sv " + str ndx + " x)";
  mk_immutable_setter fdef ndx = setter_lhs fdef + " = " + constr_name + 
    " (stl::struct_put (stl::struct_dup sv) " + str ndx + " x)";
  type_guard fd = if null t then t else ":: " + t when t = ftype fd end;
  setter_lhs fdef = lhs when
    setter_name = mk_qname ns ("set_" + fname fdef);
    lhs = setter_name + " (" + constr_name + " sv) x" + type_guard fdef;
    pure_sym(setter_name);
  end;
end when
  constr_name = mk_constr ns name;
  qname = mk_qname ns name;  ftypes = map ftype fdefs;  
end;

mk_struct print name_spec field_specs = () when
  nspace, name, mutable, indexed = parse_name_spec name_spec;
  fdefs = parse_field_specs nspace field_specs;
  mk_struct_constructors print nspace name fdefs;
  mk_struct_accessors print nspace name mutable indexed fdefs;
end;

/* Public Interface *********************************************************/

def defstruct name fields = 
  stl::mk_struct 0 (str ('name)) (str ('fields));

def defstruct_code name fields = 
  stl::mk_struct 1 (str ('name)) (str ('fields));

::members (STRUCT _ sv) = stl_sv_foldr (\x xs->x:xs) [] (STRUCT sv);

struct_name (STRUCT name _) = str name; 

(::!) (STRUCT _ sv) ndx::int = stl::sv_get sv ndx;

namespace ;

__show__ s@(stl::STRUCT name sv) = str name + str (vector $ members s);


