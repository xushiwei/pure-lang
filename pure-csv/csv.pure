/* CSV library interface

   Date: July 15, 2008
   Updated: November 21,22, 2008 to use namespaces.
   Updated: December 22, 2009: changed the default dialect to a const and 
            modified lookup to take advantage of nonlinear pattern matching.
   Updated: June 11, 2010 to make use of rewritten C module and Pure's built
            in records.
   Updated: July 7, 2010 added space_before_quote_flag and trim_space_flag.
*/

namespace csv;

using "lib:csv";

private extern dialect_t *dialect_new(char *, char *, char *, char *,
	                              int, int, int);
private extern void dialect_free(dialect_t *);
private extern csv_t *csv_open(char *, char *, void *, int);
private extern void csv_close(csv_t *t);
private extern void csv_free(csv_t *t);
private extern expr *csv_write(csv_t *, expr **, int);
private extern expr *csv_read(csv_t *csv);

public
  QUOTE_MINIMAL
  QUOTE_STRING
  QUOTE_ALL
  ON
  OFF
  TRIM_LEFT
  TRIM_RIGHT
  TRIM_BOTH
  LIST
  VECTOR
  dialect
  quote
  escape
  delimiter
  terminator
  quote_flag
  quote_before_space_flag
  trim_space_flag
  default
  open
  close
  getr
  fgetr
  fgetr_lazy
  putr
  fputr;

/* Public dialect options

  delimiter:  Character used to separates fields.
              Type: string
              Default: ","

  escape:     Escape character used to embed delimiter, escape, or return
              characters. If the escape character is not null, then the
              quote character is ignored.
              Type: string
              Default: ""
              Notes:
                Reading: The escape character is dropped and the next char
                         is inserted into the field.
                Writing: The escape character is written into the output
                         stream before the delimiter, escape, or return
                         character.

  quote:      Quote character for embedding delimiters, quotes, and
              returns. The quote character is ignored if the escape
              character is defined.
              Type: string
              Default: "\""

  terminator: Value use for record termination.
              Type: One of {"\r\n", "\n"}
              Default: "\n"
	      Notes:
                Reading: "\r" are always ignored except when embedded in
                         fields.

  quote_flag: Sets whether strings or numbers should be quoted.
              Type: One of {QUOTE_ALL, QUOTE_STRING, QUOTE_MINIMAL}
              Default: QUOTE_ALL
	      Notes:
	        Reading: QUOTE_ALL     - all fields are returned as strings.
			 QUOTE_STRING  - 
                         QUOTE_MINIMAL - non quoted integer and double fields
                                         are converted.
                Writing: QUOTE_ALL     - all fields are written enclosed in
                                         quotes.
                         QUOTE_STRING  - only string fields are written
                                         enclosed in quotes.
                         QUOTE_MINIMAL - only fields containing quote, 
                                         delimiter, or return characters are
                                         written with enclosing quotes.

  space_before_quote_flag:
              Type: One of {ON, OFF}
	      Default: OFF
	      Notes:
	        Reading: ON  - allows space before a field.
                         OFF - follows RFC4180 rules.
  
  trim_space_flag:
             Type: One of {OFF, TRIM_LEFT, TRIM_RIGHT, TRIM_BOTH}
             Default: OFF
             Notes:
               Reading: OFF        - follows RFC4180 rules.
                        TRIM_LEFT,
			TRIM_RIGHT,
			TRIM_BOTH  - may allow conversion of numbers if
                                     quote_flag = QUOTE_MINIMAL since space
				     before a number is interpreted as a
                                     string.
                                      
*/

const QUOTE_MINIMAL = 1;
const QUOTE_STRING = 2;
const QUOTE_ALL = 3;

const OFF = 0;
const ON = 1;

const TRIM_RIGHT = 1;
const TRIM_LEFT  = 2;
const TRIM_BOTH  = 3;

private in;

in dict key lst = ~ member dict key || any (=== dict!key) lst;

dialect d::matrix
  = if null r then
      throw error "out of memory"
    else
      sentry dialect_free r
    when
      s = {quote=>"\"", escape=>"", delimiter=>",", terminator=>"\n",
      	   quote_flag=>QUOTE_ALL, space_before_quote_flag=>OFF,
	   trim_space_flag=>OFF};
      v = if check_dialect d then
            record {s, d}
          else
            throw error "invalid dialect"
	  with
      	    check_dialect d::matrix
              = all (\(x=>y) -> member s x) d &&
	        (~ member d terminator ||  d!terminator == "\n" || 
		 d!terminator == "\r\n") &&
                all stringp (d!![quote,escape,delimiter]) &&
                in d quote_flag [1,2,3] &&
		in d space_before_quote_flag [0,1] &&
                in d trim_space_flag [0,1,2,3];
          end;
      r = dialect_new (v!quote) (v!escape) (v!delimiter) (v!terminator)
                      (v!quote_flag) (v!space_before_quote_flag)
                      (v!trim_space_flag);
    end;

/* Predefined dialects */
const default = dialect {};
const RFC4180 = dialect {terminator=>"\r\n"};
const EXCEL = dialect {quote_flag=>QUOTE_MINIMAL, 
                       terminator=>"\r\n",
		       space_before_quote_flag=>ON,
		       trim_space_flag=>TRIM_BOTH};

const LIST = 1;
const VECTOR = 0;

/* Open a CSV file for reading, "r", writing, "w", or appending, "a",
   with dialect d */
open (fname::string, rw_flag::string, d::pointer, list_flag::int)
  = if rw_flag ~= "r" && rw_flag ~= "w" && rw_flag ~= "a" then
      throw error "bad read/write/append flag"
    else if null d || null f then
      throw error "cannot open file"    
    else
      (sentry csv_free f $$ sentry csv_close f)
    when
      f = csv_open fname rw_flag d list_flag;
    end;

/* Open a CSV file like above but with the library but output is a vector */
open (fname::string, rw_flag::string, d::pointer)
  = open (fname, rw_flag, d, 0);

/* Open a CSV file like above but with the library default dialect */
open (fname::string, rw_flag::string) = open (fname, rw_flag, default, 0);

/* Open a CSV file for reading with the library default dialect */
open fname::string = open (fname, "r", default, 0);

/* Close a CSV file. Sentries ensure files will automatically be closed
   and internal buffers will be freed when the file pointer goes out of
   scope. */
close f::pointer = clear_sentry f $$ csv_close f;

/* Write a record to a CSV file */
putr f::pointer r::matrix = csv_write f r (#r) if rowvectorp r;
putr f::pointer r@(_:_) = csv_write f m (#m) when m = matrix r; end;

/* Write a list of records to a CSV file */
fputr f::pointer xs@(_:_) = loop xs with
  loop [] = ();
  loop (x:xs) = (putr f x) $$ loop xs;
end;

/* Read a record from a CSV file */
getr f::pointer = csv_read f;

/* Read a list of records from a CSV file */
fgetr f::pointer = loop (getr f) [] with
  loop () xs = reverse xs;
  loop x xs = loop (getr f) (x:xs);
end;

/* Lazily read a list of records from a CSV file */
fgetr_lazy f::pointer = if null r then [] else r:fgetr_lazy f & when
  r = getr f;
end;