/* CSV library interface

   Date: July 15, 2008
   Updated: November 21,22, 2008 to use namespaces.
   Updated: December 22, 2009: changed the default dialect to a const and 
            modified lookup to take advantage of nonlinear pattern matching.
   Updated: June 11, 2010 to make use of rewritten C module and Pure's built
            in records.
   Updated: July 7, 2010 added space_before_quote_flag and trim_space_flag.
*/

namespace csv;

using "lib:csv";

private extern dialect_t *dialect_new(char *, char *, char *, char *,
	                              int, int, int);
private extern void dialect_free(dialect_t *);
private extern csv_t *csv_open(char *, char *, void *, int);
private extern void csv_close(csv_t *t);
private extern void csv_free(csv_t *t);
private extern expr *csv_write(csv_t *, expr **, int);
private extern expr *csv_read(csv_t *csv);

public
  QUOTE_MINIMAL
  QUOTE_STRING
  QUOTE_ALL
  ON
  OFF
  TRIM_LEFT
  TRIM_RIGHT
  TRIM_BOTH
  LIST
  VECTOR
  CRLF
  LF
  dialect
  quote
  escape
  delimiter
  terminator
  quote_flag
  quote_before_space_flag
  trim_space_flag
  default
  open
  close
  getr
  fgetr
  fgetr_lazy
  putr
  fputr;

/* Public dialect options

  delimiter:  Character used to separate fields.
              Type: string
              Default: ","

  escape:     Escape character used to embed delimiter, escape, or return
              characters. If the escape character is not null, then the
              quote character is ignored.
              Type: string
              Default: ""
              Notes:
                Reading: The escape character is dropped and the next char
                         is inserted into the field.
                Writing: The escape character is written into the output
                         stream before the delimiter, escape, or return
                         character.

  quote:      Quote character for embedding delimiters, quotes, and
              returns. The quote character is ignored if the escape
              character is defined.
              Type: string
              Default: "\""

  terminator: Value used for record termination when writing.
              Type: One of {LF, CRLF}. LF = "\n" and CRLF = "\r\n".
              Default: LF
	      Notes: 
                Reading: "\r" are always ignored except when embedded in
                         fields.

  quote_flag: Sets whether strings or numbers should be quoted.
              Type: One of {QUOTE_ALL, QUOTE_STRING, QUOTE_MINIMAL}
              Default: QUOTE_ALL
	      Notes:
	        Reading: QUOTE_ALL     - all fields are returned as strings.
			 QUOTE_STRING  - non quoted integer and double fields
                                         are converted.
                         QUOTE_MINIMAL - same as QUOTE_STRING.
                Writing: QUOTE_ALL     - all fields are written enclosed in
                                         quotes.
                         QUOTE_STRING  - only string fields are written
                                         enclosed in quotes.
                         QUOTE_MINIMAL - only fields containing quote, 
                                         delimiter, or return characters are
                                         written with enclosing quotes.

  space_before_quote_flag:
              Type: One of {ON, OFF}
	      Default: OFF
	      Notes:
	        Reading: ON  - allows space before a field.
                         OFF - follows RFC4180 rules.
  
  trim_space_flag:
             Type: One of {OFF, TRIM_LEFT, TRIM_RIGHT, TRIM_BOTH}
             Default: OFF
             Notes:
               Reading: OFF        - follows RFC4180 rules.
                        TRIM_LEFT,
			TRIM_RIGHT,
			TRIM_BOTH  - may allow conversion of numbers if
                                     quote_flag = QUOTE_MINIMAL since space
				     before a number is interpreted as a
                                     string.
                                      
*/

const terminator_opts = {LF=>1, CRLF=>2};
const quote_flag_opts = {QUOTE_MINIMAL=>1, QUOTE_STRING=>2, QUOTE_ALL=>3};
const space_before_quote_opts = {OFF=>0, ON=>1};
const trim_space_opts = {OFF=>0, TRIM_RIGHT=>1, TRIM_LEFT=>2, TRIM_BOTH=>3};

dialect d::matrix
  = if ~null opts then
      throw (error ("invalid dialect option(s) " + str opts))
    else if ~install_str quote then
      throw (error ("dialect [quote] must be a string"))
    else if ~install_str escape then
      throw (error ("dialect [escape] must be a string"))
    else if ~install_str delimiter then
      throw (error ("dialect [delimiter] must be a string"))
    else if ~install_sym terminator terminator_opts then
      throw (error ("dialect [terminator] must be one of " +
                    str (keys terminator_opts)))
    else if ~install_sym quote_flag quote_flag_opts then
      throw (error ("dialect [quote_flag] must be one of " +
                    str (keys quote_flag_opts)))
    else if ~install_sym space_before_quote_flag space_before_quote_opts then
      throw (error ("dialect [space_before_quote_flag] must be one of " +
                    str (keys space_before_quote_opts)))
    else if ~install_sym trim_space_flag trim_space_opts then
      throw (error ("dialect [trim_space_flag] must be one of " +
                    str (keys trim_space_opts)))
    else 
      sentry dialect_free (dialect_new (m!quote) (m!escape) (m!delimiter)
                                       (m!terminator) (m!quote_flag)
                                       (m!space_before_quote_flag)
                                       (m!trim_space_flag)
                           when m = get df end)
    with 
      install_str k
        = if ~member d k then
            1
          else if stringp (d!k) then
            put df (update (get df) k (d!k)) $$ 1
          else
            0;
      install_sym k sd
        = if ~member d k then
            1
          else if member sd (d!k) then
            put df (update (get df) k (sd!(d!k))) $$ 1
          else
            0;
    end when
      df = ref {quote=>"\"", escape=>"", delimiter=>",", terminator=>"\n",
                quote_flag=>3, space_before_quote_flag=>0, 
                trim_space_flag=>0};
      opts = filter (\(x=>y) -> ~member m x) d when m = get df end;
    end;

/* Predefined dialects */
let default = dialect {};
let RFC4180 = dialect {terminator=>CRLF};
let EXCEL = dialect {quote_flag=>QUOTE_MINIMAL, 
                     terminator=>CRLF,
                     space_before_quote_flag=>ON,
                     trim_space_flag=>TRIM_BOTH};

const LIST = 1;
const VECTOR = 0;

/* Open a CSV file for reading, "r", writing, "w", or appending, "a",
   with dialect d, and if list_flag ~= 0 then a list is returned when
   reading */
open (fname::string, rw_flag::string, d::pointer, list_flag::int)
  = if rw_flag ~= "r" && rw_flag ~= "w" && rw_flag ~= "a" then
      throw error "bad read/write/append flag"
    else if null d || null f then
      throw error "cannot open file"    
    else
      (sentry csv_free f $$ sentry csv_close f)
    when
      f = csv_open fname rw_flag d list_flag;
    end;

/* Open a CSV file like above but with the library but output is a vector */
open (fname::string, rw_flag::string, d::pointer)
  = open (fname, rw_flag, d, 0);

/* Open a CSV file like above but with the library default dialect */
open (fname::string, rw_flag::string) = open (fname, rw_flag, default, 0);

/* Open a CSV file for reading with the library default dialect */
open fname::string = open (fname, "r", default, 0);

/* Close a CSV file. Sentries ensure files will automatically be closed
   and internal buffers will be freed when the file pointer goes out of
   scope. */
close f::pointer = clear_sentry f $$ csv_close f;

/* Write a record to a CSV file */
putr f::pointer r::matrix = csv_write f r (#r) if rowvectorp r;
putr f::pointer r@(_:_) = csv_write f m (#m) when m = matrix r; end;

/* Write a list of records to a CSV file */
fputr f::pointer xs@(_:_) = loop xs with
  loop [] = ();
  loop (x:xs) = (putr f x) $$ loop xs;
end;

/* Read a record from a CSV file */
getr f::pointer = csv_read f;

/* Read a list of records from a CSV file */
fgetr f::pointer = loop (getr f) [] with
  loop () xs = reverse xs;
  loop x xs = loop (getr f) (x:xs);
end;

/* Lazily read a list of records from a CSV file */
fgetr_lazy f::pointer = if null r then [] else r:fgetr_lazy f & when
  r = getr f;
end;