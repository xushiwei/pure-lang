/* This file is part of the Pure programming system.

   The Pure programming system is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option) any
   later version.

   The Pure programming system is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/

/* The CSV library provides an interface to read and write comma separated
   value files. The reading and writing functions are loosely based on
   Python's csv module (http://docs.python.org/lib/module-csv.html)

   Author: Robert E. Rucker
   Email: erucker@bmc.edu
   Date: July 15, 2008
   Updated: November 21,22, 2008 to use namespaces.
*/

namespace C;
using "lib:csv";
/* Read a string with embedded '\n's within quotes. No error checking! */
extern expr *csv_fgets(FILE *fp, char *quote);

/* Convert a CSV string to a list (record).
   s: CSV formated string to be converted to a list of fields.
   Dialect: CSV format specification. Unless specified, defaults to RFC4180
            for Windows and UNIX for all other OSs.
   NOTE: Rec must contain strings, integers, and floating point numbers. If a
         field is some other type, the 'csv::error msg' rule is invoked.
*/
extern expr *csvstr_to_list(char *str, expr *dialect);

/* Convert a list (record) to a CSV string.
   Rec: List of fields to be converted to CSV format.
   Dialect: CSV format specification. Unless specified, defaults to RFC4180
            for Windows and UNIX for all other OSs.
   NOTE: Rec must contain strings, integers, and floating point numbers. If a
         field is some other type, the 'csv::error msg' rule is invoked.
*/
extern expr *list_to_csvstr(expr *list, expr *dialect);

extern int fputs(char *s, FILE *fp);

namespace csv;

public
/* Public dialect options
  DELIMITER:      Field delimiter.
                  Type: string
                  Default: ","

  ESCAPE:         Embedded escape character.
                  Type: string
                  Defaults: "\""
                  Notes:
                    Reading: The escape character is dropped and the next char
                    is inserted into the field.
                    Writing: The escape character is written into the output
                             stream.

  QUOTE:          Quote character.
                  Type: string
                  Default: "\""
                  Note:
                    If embedded quotes are doubled, ESCAPE must equal the value
                    of QUOTE. The dialect function will automatically set the
                    ESCAPE value to that of QUOTE if ESCAPE is not specified.

  QUOTING_STYLE:  Sets whether strings or numbers should be quoted.
                  Type: One of {QUOTE_ALL, QUOTE_STRINGS, QUOTE_EMBEDDED}
                  Default: QUOTE_STRINGS

  LINETERMINATOR: Value use for record termination.
                  Type: string
                  Default: "\r\n"

  SKIPSPACE:      Skip white space flag.
                  Type: boolean {1=true, 0=false}
                  Default: true
                  Note:
                    If true, white spaces before fields are removed. However,
                    quoted fields always retain white space.
*/
  DELIMITER
  ESCAPE
  QUOTE
  QUOTING_STYLE
  LINETERMINATOR
  SKIPSPACE

/* Public quote style constants */
  QUOTE_ALL
  QUOTE_STRINGS
  QUOTE_EMBEDDED

/* Public CSV dialects */
  RFC4180
  UNIX
  EXCEL
  DEFAULTS

/* Public equations */
  error
  dialect
  str
  list
  fgets
  fputs
  fget
  fput;

/* Define error for custom error handling. */
error msg;

const DELIMITER = 0;
const ESCAPE = 1;
const QUOTE = 2;
const QUOTING_STYLE = 3;
const LINETERMINATOR = 4;
const SKIPSPACE = 5;

const QUOTE_ALL = 0;
const QUOTE_STRINGS = 1;
const QUOTE_EMBEDDED = 2;

/* Defaults are set to RFC 4180 (http://www.ietf.org/rfc/rfc4180.txt) except
   for the \r\n pair */
private defaults;
let defaults = [",", "\"", "\"", 1, "\n", 1];

/* Creates a dialect base on the list of dialect options given above.
   For examples, see RFC4180, UNIX, and EXCEL constants below.
*/
dialect opts
  = zipwith ((lookup) opts2) (0..5) defaults
    when
      opts2
        = if any (\(x=>y) -> x == ESCAPE) opts then
            opts
          else
            opts + [ESCAPE=>(lookup opts QUOTE "\"")];
    end
    with
      lookup [] k::int v = v;
      lookup ((x=>y):xs) k::int _ = y if k == x;
      lookup ((x=>y):xs) k::int v = lookup xs k v;
    end;

const RFC4180 = dialect [LINETERMINATOR=>"\r\n"];
const UNIX = defaults;
const EXCEL = dialect [QUOTING_STYLE=>QUOTE_EMBEDDED];
const DEFAULTS
  = if (substr sysinfo 0 5) == "mingw" then
      RFC4180
    else
      UNIX;

/* List to CSV string conversion */
  str record@[]
| str record@(_:_)
  = C::list_to_csvstr record DEFAULTS;

  str (recordc@[], dialect@(_:_))
| str (record@(_:_), dialect@(_:_))
  = C::list_to_csvstr record dialect;

/* Write a record to a file */
  fputs record@[] f::pointer
| fputs record@(_:_) f::pointer
  = C::fputs (str (record, DEFAULTS)) f;

  fputs record@[] (f::pointer, dialect@(_:_))
| fputs record@(_:_) (f::pointer, dialect@(_:_))
  = C::fputs (str (record, dialect)) f;

/* CSV string to list conversion */
list s::string
  = C::csvstr_to_list s DEFAULTS;
list (s::string, dialect@(_:_))
  = C::csvstr_to_list s dialect;
list (C::csv_fgets s _,_)
  = s;

/* Read a record from a file */
fgets (f::pointer, dialect@(_:_))
  = list (C::csv_fgets f (dialect!QUOTE), dialect);
fgets f::pointer
  = fgets (f, DEFAULTS);

/* Read a whole file at one time */
fget (f::pointer, dialect@(_:_))
  = read (fgets (f, dialect)) []
    with
      read x acc = reverse acc if ~listp x;
      read x acc = read (fgets (f, dialect)) (x:acc);
    end;
fget f::pointer
  = fget (f, DEFAULTS);

/* Write a whole file at one time */
fput records@(_:_) (f::pointer, dialect@(_:_))
  = write records f
    with
      write [] f = ();
      write (x:xs) f = fputs x (f, dialect) $$ write xs f;
    end;

fput records@(_:_) f::pointer
  = fput records (f, DEFAULTS);
