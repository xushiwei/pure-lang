
============================================================================
Pure-CSV - Comma Separated Value Interface for the Pure Programming Language
============================================================================

:Author: Eddie Rucker <erucker@bmc.edu>
:Date: |date|
:Copyright: 2008, 2009, 2010 by Eddie Rucker
:License: 3-clause BSD license, see the accompanying COPYING file for details

.. |date| date::

The CSV library provides an interface for reading and writing comma 
separated value files. The module is very loosely based on Python's CSV
module (http://docs.python.org/lib/module-csv.html).

.. contents::
.. sectnum::

Installation
------------

Run ``make`` to compile the module and ``make install`` (as root) to 
install it in the Pure library directory. This requires GNU make. The 
``make install`` step is only necessary for system-wide installation.

The ``make`` utility tries to guess your Pure installation directory 
and platform-specific setup. If it gets this wrong, you can set some 
variables manually. In particular, ``make install prefix=/usr`` sets 
the installation prefix, and ``make PIC=-fPIC`` or some similar flag 
might be needed for compilation on 64 bit systems. Please see the 
Makefile for details.

Usage
-----

Data records are represented as vectors or lists of any Pure values. Values
are converted as necessary and written as a group of strings, integers, or
doubles separated by a delimiter. Three predefined dialects are provided; 
``default`` (record terminator="\n"), ``RFC4180``(record terminator="\r\n"),
and ``Excel``. Procedures are provided to create other CSV dialects. See 
(http://www.ietf.org/rfc/rfc4180.txt) for more details about the RFC4180
standard.

Handling Errors
~~~~~~~~~~~~~~~

.. _error:

``error msg``
  is an error handling term. Operations producing parse errors, memory 
  errors, or read/write errors produce a special ``csv::error msg`` term,
  where ``msg`` is a string describing the particular error. Your 
  application should either check for these or have ``csv::error`` defined
  to directly handle errors in some way (e.g., provide a default value, or
  raise an exception).

Creating Dialects
~~~~~~~~~~~~~~~~~

.. _dialect:

``dialect record``
  creates a dialect from a record of dialect option pairs. The dialect
  object is freed automatically when exiting the pure script. The list of
  possible options and option values are presented below.

  - ``delimiter`` - Field delimiter.

    * Value - any string.
    * Default - ``","``.

  - ``escape`` - Embedded escape character used to embed a delimiter, 
    escape, or terminator into unquoted fields.

    * Value - any string.
    * Default - ``""``.
    * Notes - When defined, the quote value is ignored.
  
  - ``quote`` - Quotes are used to embed delimiters, quotes, or
    terminators into a field.
  
    * Value - any string.
    * Default - ``"\""``.
    * Notes - If embedded quotes are doubled, ``escape`` must be the 
      null string.

  - ``terminator`` - Record termination string.

    * Value - One of {``"\r\n"'', ``"\n"``}.
    * Default: ``"\n"``.

  - ``quote_flag`` - Sets the quoting style of strings and/or numbers.

    * Value - One of {``QUOTE_ALL``, ``QUOTE_STRINGS``, ``QUOTE_MINIMAL``}.
    * Default - ``ALL``.
    * Notes -

      1. ``QUOTE_ALL`` - every field is read/written as a string.

      2. ``QUOTE_STRING`` - When reading, fields within quotes are read as
         strings. Also fields that are not integers or doubles are converted
         to strings. When writing, only fields that are of type ``string`` 
         are quoted when written to the file.

      3. ``QUOTE_MINIMAL`` - When reading, acts like the ``STRING`` flag. 
         When writing, only fields containing embedded quotes, terminators,
         or delimiters are written with quotes.

  - ``space_before_quote_flag`` - Determines if space is acceptable before a
    quoted field.
    * Value - One of {``On``, ``Off``}.
    * Default - ``Off``.
  
  - ``trim_space_flag`` - trim space before or after field contents.

    * Value - One of {OFF, TRIM_LEFT, TRIM_RIGHT, TRIM_BOTH}
    * Default - ``OFF``.
    * Notes -
    
      1. When the flag is ``OFF``, reading and writing follows RFC4180 rules.

      2. When the flag is one of ``TRIM_LEFT``, ``TRIM_RIGHT``, or 
         ``TRIM_BOTH`` - the field is trimed accordingly. Use *caution* when
         reading because trimming may allow conversion of numbers if the
         ``quote_flag`` is set to ``QUOTE_MINIMAL``. Also, when writing, 
         trimming space is probably a bad idea since leading or trailing 
         space may be significant for another application.

  The following example illustrates the construction of a dialect for 
  reading tab delimited files without quoted strings.

.. _example_dialect:

Example

::
    
  > using csv;
  > using namespace csv;
  > let d = dialect {delimiter=>"\t", quote_flag=>QUOTE_STRING};
  > d;
  #<pointer 0x9d75280>
  > 

Opening CSV Files
~~~~~~~~~~~~~~~~~

.. _open:

``open name::string``
  opens a CSV file for reading using the default dialect. If the file does
  not exist, the ``error msg`` rule is invoked.

``open (name::string, rw_flag::string)``
  opens a CSV file for reading, writing, or appending using the default
  dialect. Valid "rw_flag" values are ``"r"`` for reading, ``"w"`` for
  writing, and ``"a"`` for appending. If the file does not exits when
  opened for reading, the ``error msg`` rule is invoked. When a file is
  opened for writing and the file exists, the old file is overwritten. If
  the file does not exist, a new empty file is created. When a file is
  opened for appending and the file exists, new records are appended to
  the end of the file, otherwise a new empty file is created.

``open (name::string, rw_flag::string, d::pointer)``
  exactly as above except according to a user defined dialect ``d``.

``open (name::string, rw_flag::string, d::pointer, list_flag::int)``
  exactly as above except if ``list_flag`` is set to ``1`` or ``LIST``, the
  output of ``putr``, ``fputr``, and ``fputr_lazy`` is a list instead of a
  vector.

.. _examples_open:

Example

::
  
  > using csv;
  > using namespace csv;
  > let d = dialect {delimiter=>"\t"};
  > let f = open ("junk.csv", "w", d);
  > putr f {"hello",123,"",3+:4,world};
  ()
  > close f;
  ()
  > let f = open ("junk.csv", "r", d);
  > getr f;
  {"hello","123","","3+:4","world"}
  >

File Reading Functions
~~~~~~~~~~~~~~~~~~~~~~

.. _getr:

``getr csv_file::pointer``
  reads from a ``csv_file`` opened by ``csv::open`` and returns a record
  represented as a row matrix. Reading from a file opened for writing or
  appending invokes the ``error msg`` rule.

.. _fgetr:

``fgetr csv_file::pointer``
  reads a whole file and returns a list of records. This procedure 
  should only be used on data files that are small enough to fit in the 
  computer's primary memory. Reading from a file opened for writing or
  appending invokes the ``error msg`` rule.

``fgetr_lazy csv_file::pointer``
  Lazy version of ``fgetr``.

File Writing Functions
~~~~~~~~~~~~~~~~~~~~~~

When modifying CSV files that will be imported into Microsoft Excel,
fields with significant leading 0s should be written using a 
``"=""0..."""`` formatting scheme. This same technique will work for
preserving leading space too. Again, this quirk should only be
necessary for files to be imported into MS Excel. 

.. _putr:

``putr csv_file::pointer rec::matrix``
  writes a record in row matrix format to ``csv_file``. Writing to a file
  opened for reading invokes the ``error msg`` rule.

.. _fputr:

``fputr csv_file::pointer l@(_:_)``
  writes a list of records where each record is a row matrix to ``csv_file``.
  Writing to a file opened for reading invokes the ``error msg`` rule.

.. _examples:

Examples
~~~~~~~~

The first example shows how to write and read a default CSV file.

::
  
  > using csv;
  > using namespace csv;
  > let f = open ("testing.csv","w");
  > fputr f [{"bob",3.9,"",-2},{"fred",-11.8,"",0},{"mary",2.3,"$",11}];
  ()
  > close f;
  ()
  > let f = open "testing.csv";
  > fgetr f;
  [{"bob","3.9","","-2"},{"fred","-11.8","","0"},{"mary","2.3","$","11"}]
  > close f;

The second example illustrates how to write and read a CSV file using
automatic conversions.

::

  > using csv;
  > using namespace csv;
  > let d = dialect {quote_flag => QUOTE_MINIMAL};
  > let f = open ("test.csv","w",d);
  > putr f {"I","",-4,1.2,2%4,like};
  ()
  > putr f {"playing","the",0,-0.2,1+:4,drums};
  ()
  > close f;
  ()
  > let f = open ("test.csv","r",d);
  > fgetr f;
  [{"I","",-4,1.2,"2%4","like"},{"playing","the",0,-0.2,"1+:4","drums"}]
  > close f;
  ()

Records containing quotes, delimiters, and line breaks are also properly
handled.

::

  > using csv;
  > using namespace csv;
  > let d = dialect {quote_flag=>QUOTE_STRING};
  > let f = open ("test.csv","w",d);
  > fputr f [{"this\nis\n",1},{"a \"test\"",2}];
  ()
  > close f;
  ()
  > let f = open ("test.csv","r",d);
  > fgetr f;
  [{"this\nis\n",1},{"a \"test\"",2}]
  > close f;
  ()

If we look at the file, we see the files are properly written.

::

  erucker:$ more test.csv
  "this
  is
  ",1
  "a ""test""",2

Consider the following hand written CSV file. According to RFC4180, this is
not a valid CSV file. By turning the ``space_before_quote_flag`` on, the file
can still be read.

::
  
  erucker:$ more test.csv
    "this",   "is",  "not", "valid"

::
  > using csv;
  > using namespace csv;
  > let f = open "test.csv";
  > getr f;
  csv::error "parse error at line 1"
  > let d = dialect {space_before_quote_flag=>ON};
  > let f = open ("test.csv", "r", d);
  > getr f;
  {"this","is","not","valid"}

The ``trim_space_flag`` should be used with caution. A field with space in
font of a number should be interpreted as a string. For instance, consider
the following file.

::
  
  erucker:$ more test.csv
  "  this   ", 45 ,23,  hello

Now consider what happens for the two dialects below.

::
  
  > using csv;
  > using namespace csv;
  > let d = dialect {trim_space_flag=>TRIM_BOTH};
  > let f = open ("test.csv","r",d);
  > getr f;
  {"this","45","23","hello"}
  > let d = dialect {trim_space_flag=>TRIM_BOTH, quote_flag=>QUOTE_MINIMAL};
  > let f = open ("test.csv", "r", d);
  > getr f;
  {"this",45,23,"hello"}

The ``trim_space_flag`` also affects writing.

::
  
  > using csv;
  > using namespace csv;
  > let d = dialect {trim_space_flag=>TRIM_BOTH};
  > let f = open ("test.csv", "w", d);
  > putr f {"   this   ","   45 "};
  ()
  > close f;
  ()
  > quit
  
  erucker:$ more test.csv
  "this","45"

For the last example a tab delimiter is used, automatic conversions is on,
and records are represented as lists. Note that files are automatically 
closed when the script is finished.

::

  > using csv;
  > using namespace csv;
  > let d = dialect {quote_flag=>QUOTE_MINIMAL, delimiter=>"\t"};
  > let f = open ("test.csv","w",d,LIST);
  > fputr f [["a","b",-4.5,""],["c","d",2.3,"-"]];
  ()
  > close f;
  ()
  > let f = open ("test.csv","r",d,LIST);
  > fgetr f;                             
  [["a","b",-4.5,""],["c","d",2.3,"-"]]
  > quit
