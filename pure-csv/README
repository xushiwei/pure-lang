
============================================================================
Pure-CSV - Comma Separated Value Interface for the Pure Programming Language
============================================================================

:Author: Eddie Rucker <erucker@bmc.edu>
:Date: |date|
:Copyright: 2008, 2009, 2010 by Eddie Rucker
:License: 3-clause BSD license, see the accompanying COPYING file for details

.. |date| date::

The CSV library provides an interface for reading and writing comma 
separated value files. The module is very loosely based on Python's CSV
module (http://docs.python.org/lib/module-csv.html).

.. contents::
.. sectnum::

Installation
------------

Run ``make`` to compile the module and ``make install`` (as root) to 
install it in the Pure library directory. This requires GNU make. The 
``make install`` step is only necessary for system-wide installation.

The ``make`` utility tries to guess your Pure installation directory 
and platform-specific setup. If it gets this wrong, you can set some 
variables manually. In particular, ``make install prefix=/usr`` sets 
the installation prefix, and ``make PIC=-fPIC`` or some similar flag 
might be needed for compilation on 64 bit systems. Please see the 
Makefile for details.

Usage
-----

Data records are represented as matrices of strings, integers, and 
doubles. Two predefined dialects are provided; default (record 
terminator="\n") and RFC4180 (record terminator="\r\n"); and
procedures are provided to create other CSV dialects. See
(http://www.ietf.org/rfc/rfc4180.txt) for more details about the 
RFC4180 standard.

Handling Errors
~~~~~~~~~~~~~~~

.. _error:

``error msg``
  is an error handling term. Input that does not abide by dialect 
  rules or records containing field types other than strings, integers, 
  and doubles produce a special ``csv::error msg`` term, where ``msg`` 
  is a string describing the particular error. Your application should 
  either check for these or have ``csv::error`` defined to directly 
  handle errors in some way (e.g., provide a default value, or raise an 
  exception).

Creating Dialects
~~~~~~~~~~~~~~~~~

.. _dialect:

``dialect record``
  creates a dialect from a record of dialect option pairs. The dialect
  object is freed automatically when exiting the pure script. The list of
  possible options and option values are presented below.

  - ``delimiter`` - Field delimiter.

    * Value - any string.
    * Default - ``","``.

  - ``escape`` - Embedded escape character used to embed a delimiter, 
    escape, or terminator into unquoted fields.

    * Value - any string.
    * Default - ``""``.
    * Notes - When defined, the quote value is ignored.
  
  - ``quote`` - Quotes are used to embed delimiters, quotes, or
    terminators into a field.
  
    * Value - any string.
    * Default - ``"\""``.
    * Notes - If embedded quotes are doubled, ``escape`` must be the 
      null string.
  
  - ``quote_flag`` - Sets the quoting style of strings and/or numbers.

    * Value - One of {``ALL``, ``STRINGS``, ``MINIMAL``}.
    * Default - ``ALL``.

  - ``terminator`` - Record termination string.

    * Value - One of {``"\r\n"'', ``"\n"``}.
    * Default: ``"\n"``.

  The following example illustrates the construction of a dialect for 
  reading tab delimited files without quoted strings.

.. _example_dialect:

Examples

::
    
  > using csv;
  > using namespace csv;
  > let d = dialect {delimiter=>"\t"};
  > d;
  #<pointer 0x9d75280>
  > 

Opening CSV Files
~~~~~~~~~~~~~~~~~

.. _open:

``open name::string``
  opens a CSV file for reading using the default dialect. If the file does
  not exist, the ``error msg`` rule is invoked.

``open (name::string, rw_flag::string)``
  opens a CSV file for reading, writing, or appending using the default
  dialect. Valid "rw_flag" values are ``"r"`` for reading, ``"w"`` for
  writing, and ``"a"`` for appending. If the file does not exits when
  opened for reading, the ``error msg`` rule is invoked. When a file is
  opened for writing and the file exists, the old file is overwritten. If
  the file does not exist, a new empty file is created. When a file is
  opened for appending and the file exists, new records are appended to
  the end of the file, otherwise a new empty file is created.

``open (name::string, rw_flag::string, d::pointer)``
  exactly as above except according to a user defined dialect ``d``.

.. _examples_open:

Example

::
  
  > using csv;
  > using namespace csv;
  > let d = dialect {delimiter=>"\t"};
  > let f = open ("junk.csv", "w", d);
  > putr f {"hello",123,"",3+:4,world};
  ()
  > close f;
  ()
  > let f = open ("junk.csv", "r", d);
  > getr f;
  {"hello","123","","3+:4","world"}
  >

File Reading Functions
~~~~~~~~~~~~~~~~~~~~~~

.. _getr:

``getr csv_file::pointer``
  reads from a ``csv_file`` opened by ``csv::open`` and returns a record
  represented as a row matrix. Reading from a file opened for writing or
  appending invokes the ``error msg`` rule.

.. _fgetr:

``fget csv_file::pointer``
  reads a whole file and returns a list of records. This procedure 
  should only be used on data files that are small enough to fit in the 
  computer's primary memory. Reading from a file opened for writing or
  appending invokes the ``error msg`` rule.

File Writing Functions
~~~~~~~~~~~~~~~~~~~~~~

When modifying CSV files that will be imported into Microsoft Excel,
fields with significant leading 0s should be written using a 
``"=""0..."""`` formatting scheme. This same technique will work for
preserving leading space too. Again, this quirk should only be
necessary for files to be imported into MS Excel. 

.. _putr:

``putr csv_file::pointer rec::matrix``
  writes a record in row matrix format to ``csv_file``. Writing to a file
  opened for reading invokes the ``error msg`` rule.

.. _fputr:

``fputr csv_file::pointer l@(_:_)``
  writes a list of records where each record is a row matrix to ``csv_file``.
  Writing to a file opened for reading invokes the ``error msg`` rule.

.. _examples:

Examples
~~~~~~~~

::
  
  > using csv;
  > using namespace csv;
  > let f = open ("testing.csv","w");
  > fputr f [{"bob",3.9,"",-2},{"fred",-11.8,"",0},{"mary",2.3,"$",11}];
  ()
  > close f;
  ()
  > let f = open "testing.csv";
  > fgetr f;
  [{"bob","3.9","","-2"},{"fred","-11.8","","0"},{"mary","2.3","$","11"}]
  > close f;
  >
