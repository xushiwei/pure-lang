
========
pd-faust
========

Version @version@, |today|

Albert Graef <Dr.Graef@t-online.de>

pd-faust is a dynamic environment for running Faust dsps in Pd. It is based on
the author's :doc:`faust2pd<faust2pd>` script, but offers many improvements
and additional features:

* Faust dsps are implemented using two Pd objects, ``fsynth~`` and ``fdsp~``,
  which provide the necessary infrastructure to run Faust synthesizer and
  effect units in Pd, respectively.

* In contrast to faust2pd, the Pd GUI of Faust units is generated dynamically,
  inside Pd. pd-faust supports the same global GUI layout options as faust2pd.
  In addition, it also provides various options to adjust the layout of
  individual control items.

* pd-faust recognizes the ``midi`` and ``osc`` controller attributes in the
  Faust source and automatically provides corresponding MIDI and OSC
  controller mappings. It also features facilities for synchronizing MIDI
  playback and OSC-based controller automation.

* Perhaps most importantly, Faust dsps can be reloaded at any time (even while
  the Pd patch is running), in which case the GUI and the controller mappings
  are regenerated automatically and on the fly as needed.

.. _faust2pd: faust2pd

Copying
=======

Copyright (c) 2011 by Albert Graef

pd-faust is distributed under the GNU LGPL v3+. Please see the included
COPYING and COPYING.LESSER files for details.

This package also includes the faust-stk instruments which are distributed
under an MIT-style license, please check the examples/synths/README-STK file
and the dsp files for authorship information and licensing details pertaining
to these. The original faust-stk sources can be found in the Faust
distribution, cf. http://faust.grame.fr/.

Installation
============

You'll need Faust_ and Pd_, obviously. The pd-faust objects are written in the
Pure_ programming language, so you'll also need an installation of the Pure
interpreter (0.50 or later), along with the following packages:
:doc:`pd-pure<pd-pure>` (0.15 or later), :doc:`pure-faust<pure-faust>` (0.6 or
later) and :doc:`pure-stldict<pure-stldict>` (any version). Finally, gcc and
GNU make (or compatible) are required to compile the helper dsps and the
example instruments; please check the Makefile for details.

.. _Faust: http://faust.grame.fr/
.. _Pd: http://puredata.info/
.. _Pure: http://pure-lang.googlecode.com/

For a basic installation run ``make``, then ``sudo make install``. This will
install the pd-faust objects in your Pd lib/extra/faust folder. Add this
directory to your Pd library search path (``--path`` option or
``Preferences/Path`` in Pd) and you should be set.

Some further build options are described in the Makefile. In particular, it is
possible to compile the Faust dsps to LLVM bitcode which can be loaded
directly by the Pure interpreter, but for that you'll need an LLVM-capable
C/C++ compiler such as clang or gcc with the dragonegg plugin. Please check
the LLVM_ website for details.

.. _LLVM: http://llvm.org/

Usage
=====

Working with pd-faust basically involves adding a bunch of ``fsynth~`` and
``fdsp~`` objects to a Pd patch along with the corresponding GUI subpatches,
and wiring up the Faust units in some variation of a synth-effects chain which
typically takes input from Pd's MIDI interface (``notein``, ``ctlin``, etc.)
and outputs the signals produced by the Faust units to Pd's audio interface
(``dac~``). For your convenience, the included ``midiosc`` object can be used
to handle the MIDI input and OSC controller automation.

The ``fdsp~`` object is invoked as follows::

  fdsp~ dspname instname channel

* ``dspname`` denotes the name of the Faust dsp (usually this is just the name
  of the .dsp file with the extension stripped off).

* ``instname`` denotes the name of the instance of the Faust unit. Multiple
  instances of the same Faust dsp can be used in a Pd patch, which must all
  have different instance names. In addition, the instance name is also used
  to identify the GUI subpatch of the unit (see below) and to generate unique
  OSC addresses for the unit's control elements.

* ``channel`` is the number of the MIDI channel the unit responds to. This can
  be 1..16, or 0 to specify "omni" operation (listen to MIDI messages on all
  channels).

The ``fdsp~`` object requires a Faust dsp which can work as an effect unit,
processing audio input and producing audio output. (Only stereo units are
fully supported in the present version.)

The ``fsynth~`` object works in a similar fashion, but has an additional
creation argument specifying the desired number of voices::

  fsynth~ dspname instname channel numvoices

The ``fsynth~`` object requires a Faust dsp which can work as a monophonic
synthesizer (having zero audio inputs and two audio outputs). To these ends,
pd-faust assumes that the Faust unit provides three so-called "voice controls"
which indicate which note to play:

* ``freq`` is the fundamental frequency of the note in Hz.

* ``gain`` is the velocity of the note, as a normalized value between 0 and 1.
  This usually controls the volume of the output signal.

* ``gate`` indicates whether a note is currently playing. This value is either
  0 (no note to play) or 1 (play a note), and usually triggers the envelop
  function (ADSR or similar).

pd-faust doesn't care at which path inside the Faust dsp these controls are
located, but they must all be there, and the basenames of the controls must be
unique throughout the entire dsp.

Like :doc:`faust2pd<faust2pd>`, pd-faust implements the necessary logic to
drive the given number of voices of an ``fsynth~`` object. That is, it will
actually create a separate instance of the Faust dsp for each voice and handle
polyphony by allocating voices from this pool in a round-robin fashion,
performing the usual voice stealing if the number of simultaneous notes to
play exceeds the number of voices. Also note that an ``fsynth~`` operated in
omni mode (``channel = 0``) automatically filters out messages on channel 10
which is reserved for percussion in the General MIDI standard.

For each ``fdsp~`` and ``fsynth~`` object, the Pd patch should also contain an
(initially empty) "one-off" graph-on-parent subpatch with the same name as the
instance name of the Faust unit::

  pd instname

You don't have to insert anything into this subpatch, the contents (a bunch of
Pd GUI elements corresponding to the control elements of the Faust unit) will
be generated automatically by pd-faust when the corresponding ``fdsp~`` or
``fsynth~`` object is created (and whenever the unit gets reloaded at
runtime).

The ``fdsp~`` and ``fsynth~`` objects respond to the following messages:

* ``bang`` outputs the current control settings on the control outlet in OSC
  format.

* ``write`` outputs the current control settings to external MIDI and/or OSC
  devices. This message can also be invoked with a numeric argument to toggle
  the "write mode" of the unit; please see `External MIDI and OSC
  Controllers`_ below for details.

* ``reload`` reloads the Faust unit. This also reloads the shared library or
  bitcode file if the unit was recompiled since the object was last loaded.

* ``addr value`` changes the control indicated by the OSC address ``addr``.
  This is also used internally for communication with the Pd GUI and for
  controller automation.

In addition, the ``fdsp~`` and ``fsynth~`` objects respond to MIDI controller
messages of the form ``ctl val num chan``, and the ``fsynth~`` object also
understands note-related messages of the form ``note num vel chan`` (note
on/off) and ``bend val chan`` (pitch bend). In either case, pd-faust provides
the necessary logic to map controller and note-related messages to the
corresponding control changes in the Faust unit.

.. note:: Like pd-pure, pd-faust also remaps Pd's ``menu-open`` command so
   that it lets you edit the Faust source of an ``fdsp~`` or ``fsynth~``
   object by right-clicking on the object and choosing ``Open`` from the
   context menu.

Examples
--------

The examples folder contains a few example patches which illustrate how this
all works. Having installed pd-faust as described above, you can run these
from the examples directory, e.g.: ``pd test.pd``. You can also run the
examples without actually installing pd-faust, if you add the ``-path ..``
option when running Pd from the examples directory.

The following examples are currently available:

* test.pd: Simple patch running a single Faust instrument.

* synth.pd: Slightly more elaborate patch featuring a synth-effects chain.

* bouree.pd: Full-featured example running various instruments.

For your convenience, related MIDI and OSC files as well as the Faust sources
of the instruments and effects are contained in corresponding subdirectories
(midi, osc, synths) of the examples directory. A slightly modified version of
the faust-stk instruments from the Faust distribution is also included, please
check the examples/synths/README-STK file for more information about these.

The MIDI files are in standard MIDI file format and come from various sources
on the web; I believe that they are all in the public domain and can thus be
distributed freely. The OSC files used by pd-faust for controller automation
are plain ASCII files suitable for hand-editing if you know what you are
doing; the format should be fairly self-explanatory.

Please note that in the present version the patch directory layout (MIDI, OSC
and Faust source files can be found in the midi, osc and synths subfolders,
respectively) is hardwired, so you should follow this layout for your own
pd-faust patches as well.

Operating the Patches
---------------------

The generated Pd GUI elements for the Faust dsps are pretty much the same as
with :doc:`faust2pd<faust2pd>` (which see). The only obvious change is the
addition of a "record" button (gray toggle in the upper right corner) which
enables recording of OSC automation data. As with faust2pd, the default GUI
layout can be adjusted in various ways; see `Tweaking the GUI Layout`_ below
for details.

In case the operation of the ``midiosc`` abstraction in the provided examples
is not immediately obvious, here is a brief rundown of the available controls:

* The creation argument of ``midiosc`` is the name of the MIDI file, either as
  a Pd symbol (in this case the .mid filename extension is supplied
  automatically) or as a double-quoted string. This argument can also be
  omitted if you don't need MIDI file playback.

* The abstraction has a single control outlet through which it feeds the
  generated MIDI and other messages to the connected ``fsynth~`` and ``fdsp~``
  objects. In addition, live MIDI input is also accepted and forwarded to the
  control outlet, after being translated to the format understood by
  ``fsynth~`` and ``fdsp~`` objects.

* The ``start``, ``stop`` and ``cont`` controls in the *first* row of control
  elements start, stop and continue MIDI and OSC playback, respectively. The
  ``echo`` toggle in this row causes played MIDI events to be printed in the
  Pd main window.

* The gray "record" toggle in the upper right corner of the abstraction
  enables recording of OSC controller automation data from any of the Faust
  units which have their "record" toggle switched on. Once ``midiosc``\ 's
  "record" toggle is switched on, recording will be started and stopped with
  the ``start``, ``stop`` and ``cont`` controls in the first row.

* There are some additional controls related to OSC recording in the *second*
  row: ``save`` saves the currently recorded data in an OSC file for later use
  (this file will be located in the osc subdirectory, and have the same name
  as the MIDI file with new extension .osc); ``abort`` is like ``stop`` in
  that it stops recording and playback, but also throws away the data recorded
  in this run (while ``stop`` keeps it for later playback); and ``clear``
  clears the entire recorded OSC sequence so that you can start a new one.

* Once some automation data has been recorded, it will be played back along
  with the MIDI file. You can then just listen to it, or go on to record more
  automation data, etc., ad lib. Use the ``echo`` toggle in the second row to
  print the OSC messages as they are played back. If you save the automation
  data with the ``save`` button, it will be reloaded from its OSC file next
  time the patch is opened.

* The controls in the *third* row provide some additional ways to configure
  the playback process. The ``loop`` button can be used to enable looping,
  which repeats the playback of the MIDI (and OSC) sequence ad infinitum. The
  ``thru`` button, when switched on, routes the MIDI data during playback
  through Pd's MIDI output so that it can be used to drive an external MIDI
  device in addition to the Faust instruments. The ``write`` button does the
  same with MIDI and OSC controller data generated either through automation
  data or by manually operating the control elements in the Pd GUI, see
  `External MIDI and OSC Controllers`_ below for details.

Note that ``midiosc`` is merely an example. Your own patches may well be
constructed without it, if you don't need all the fancy functionality it
provides, and simply feed control messages in the recognized format directly
into ``fdsp~`` and ``fsynth~`` objects instead. Or you may need even more
elaborate input/output interfacing, in which case ``midiosc`` can be used as a
starting point for your own MIDI/OSC input/output abstraction driving the
``fdsp~`` and ``fsynth~`` objects in your patch.

External MIDI and OSC Controllers
---------------------------------

The ``fsynth~`` object has built-in (and hard-wired) support for MIDI notes,
pitch bend and MIDI controller 123 (all notes off).

Other MIDI and OSC controller data can be handled as well, by configuring the
controls in your Faust units accordingly. pd-faust's treatment of such
controller data depends on the *mode* the ``fdsp~`` or ``fsynth~`` object is
in.

The default mode is *read mode*, in which controller data received from
external MIDI and OSC devices is interpreted according to the controller
mappings defined in the Faust source (this is explained below), by updating
the corresponding GUI elements and the control variables of the Faust dsp.
For obvious reasons, this only works with *active* Faust controls.

An ``fdsp~`` or ``fsynth~`` object can also be put in *write mode* by feeding
a message of the form ``write 1`` into its control inlet. For convenience, the
``write`` toggle in the ``midiosc`` abstraction allows you to do this
simultaneously for all Faust units connected to ``midiosc``\ 's control
outlet.

Once an object is in write mode, it does not interpret incoming MIDI and OSC
controller data any more, but rather *outputs* MIDI and OSC controller data in
response to both automation data and the manual operation of the Pd GUI
elements, again according to the controller mappings defined in the Faust
source. Note that this works with both *active* and *passive* Faust controls.

To configure MIDI controller assignments, the labels of the Faust control
elements have to be marked up with the special ``midi`` attribute in the Faust
source. For instance, a pan control (MIDI controller 10) may be implemented in
the Faust source as follows::

  pan = hslider("pan [midi:ctrl 10]", 0, -1, 1, 0.01);

In read mode, pd-faust will then provide the necessary logic to handle MIDI
input from controller 10 by changing the pan control in the Faust unit
accordingly, mapping the controller values 0..127 to the range and step size
given in the Faust source. Conversely, in write mode corresponding MIDI
controller data will be generated and sent to Pd's MIDI output, on the MIDI
channel specified in the creation arguments of the Faust unit (0 meaning
"omni", i.e., output on all MIDI channels), so that it can drive an external
MIDI device such as a keyboard or a faderbox.

In principle, the same functionality is also available for external OSC
devices, employing explicit OSC controller assignments in the Faust source by
means of the ``osc`` attribute. E.g., the following enables input and output
of OSC messages for the OSC ``/pan`` address::

  pan = hslider("pan [osc:/pan]", 0, -1, 1, 0.01);

The necessary infrastructure is already provided by pd-faust, but the OSC
input and output facilities needed to make this actually work are not
implemented in the ``midiosc`` abstraction right now. That's because Pd
doesn't provide any built-in objects for OSC input and output, although a few
different solutions exist and are included in Hans-Christoph Steiner's
Pd-extended_ distribution, such as Martin Peach's `OSC externals`_. Thus,
you'll have to edit the ``midiosc`` abstraction and add OSC input/output
yourself if you need this.

.. _Pd-extended: http://puredata.info/community/projects/software/pd-extended
.. _OSC externals: http://puredata.info/Members/martinrp/OSCobjects

Tweaking the GUI Layout
-----------------------

As already mentioned, pd-faust provides the same global GUI layout options as
:doc:`faust2pd<faust2pd>`. Here is a brief rundown of the available options:

* ``width=wd``, ``height=ht``: Specify the maximum horizontal and/or vertical
  dimensions of the layout area. If one or both of these values are nonzero,
  pd-faust will try to make the GUI fit within this area.

* ``font-size=sz``: Specify the font size (default is 10).

* ``fake-buttons``: Render ``button`` controls as Pd toggles rather than
  bangs.

* ``radio-sliders=max``: Render zero-based sliders with stepsize 1 and up to
  ``max`` different values as Pd radio controls rather than Pd sliders.

* ``slider-nums``: Add a number box to each slider control. This is actually
  the default in pd-faust, which can be disabled with the ``no-slider-nums``
  option.

* ``exclude=pat,...``: Exclude the controls whose labels match the given glob
  patterns from the Pd GUI.

Please check the faust2pd documentation for a detailed description of these
options. The only notable difference to faust2pd here is that the
``slider-nums`` option is always the default in pd-faust, so you'll have to
specify ``no-slider-nums`` if you want to *disable* this option.

With pd-faust there is no way to specify the above options on the command
line, so you'll have to put them as ``pd`` attributes on the *main* group of
your Faust program, as described in the faust2pd documentation. For instance::

  process = vgroup("[pd:no-slider-nums][pd:font-size=12]", ...);

In addition, the following options can be used to tweak the appearance of
individual control items. If present, these options override the corresponding
built-in or user-specified defaults. Each option can be prefixed with ``no-``
to negate the option value. (Thus, e.g., ``no-hidden`` makes items visible
which would otherwise, by means of the global ``exclude`` option, be removed
from the GUI.)

* ``hidden``: Removes the corresponding control from the Pd GUI. This is the
  only option which can also be used for group controls, in which case *all*
  controls in the group will become invisible in the Pd GUI.

* ``fake-button``, ``radio-slider``, ``slider-num``: These have the same
  meaning as the corresponding global ``fake-buttons``, ``radio-sliders`` and
  ``slider-nums`` options, but apply to individual control items. Also note
  that pd-faust allows the ``radio-slider`` option to be placed not only on
  sliders, but also on numeric entries, i.e., ``nentry`` in the Faust source.
  (However, as with the ``radio-sliders`` option, this option is only
  applicable if the control is zero-based and has a stepsize of 1.)

Again, these options are specified with the ``pd`` attribute in the label of
the corresponding Faust control. For instance, the following definitions make
the ``pan`` control invisible in the Pd GUI and render the ``mode`` item as a
Pd radio control::

  pan = hslider("pan [pd:hidden]", 0, -1, 1, 0.01);
  mode = nentry("mode [pd:radio-slider]", 0, 0, 4, 1);

Remote Control
--------------

Also included in the sources is a helper abstraction faust-remote.pd and an
accompanying elisp file faust-remote.el. These work pretty much like
pure-remote.pd and pure-remote.el in the :doc:`pd-pure<pd-pure>` distribution,
but are tailored for the remote control of Faust dsps in a Pd patch. In
particular, they enable you to quickly reload the Faust dsps in Pd using a
simple keyboard command (``C-C C-X`` by default) from Emacs. The
faust-remote.el program was designed to be used with Juan Romero's Emacs
`Faust mode`_; please see etc/pure-remote.el for usage instructions.

.. _Faust mode:  https://github.com/rukano/emacs-faust-mode

Caveats and Bugs
================

Some parts of this software might still be experimental, under construction
and/or bug-ridden. Bug reports, patches and suggestions are welcome. Please
send these directly to the author, or post them either to the Faust or the
Pure mailing list.

In particular, please note the following known limitations in the current
implementation:

* Only stereo dsps are fully supported right now. This will hopefully be fixed
  soon.

* Passive Faust controls are only supported in ``fdsp~`` objects.

* The names of the voice controls in the ``fsynth~`` object (``freq``,
  ``gain``, ``gate``) are currently hard-coded.

* Polyphonic aftertouch and channel pressure messages are not supported in the
  MIDI interface right now, so you'll have to use ordinary MIDI controllers
  for these parameters instead. Coarse/fine pairs of MIDI controllers aren't
  directly supported either, so you'll have to implement these yourself as two
  separate Faust controls.

* With the present :doc:`pure-faust<pure-faust>` version, dynamic reloading of
  a Faust module only works if there is only a single instance of the module
  in the patch. This is actually a limitation of pure-faust, so it doesn't
  affect the reloading of Faust bitcode modules which are handled directly by
  the Pure interpreter. Our expectation is that pure-faust will eventually be
  phased out in favour of Pure's native Faust interface, but Faust bitcode
  modules often don't perform quite as well as Faust modules compiled to
  native code using gcc yet, so using Pure's native Faust interface isn't the
  default right now. This might change in the future.

Also, please check the TODO file included in the distribution for other issues
which we are already aware of and which will hopefully be addressed in future
pd-faust versions.
