
/* Load a sequence from a (type 0 or 1) MIDI file. All tracks are mixed down
   to a single sequence, meta events are removed, and timestamps are converted
   to milliseconds, according to the division and the tempo map of the file. */

using midifile;

public note polytouch ctl pgm touch bend;
nonfix start stop continue;
public loop;

namespace midiseq;

load name::string = filter not_meta $ convert $
  foldl mix [] $ midifile::get_tracks mf
with
  // Check for meta events.
  not_meta (_,msg) = msg!0~=0xff;
  // Convert to msec timestamps. NOTE: We assume a default tempo of 120 BPM
  // (500000 msecs per quarter note) here.
  convert = convert_smpte (division*resolution) if division > 0;
  	  = convert_ppqn resolution (500000,0,0);
  // Convert SMPTE timestamps.
  convert_smpte 1000 xs = xs; // timestamps are msecs already
  convert_smpte f xs = [int (round (t/f*1000)),msg | t,msg = xs];
  // Convert musical time.
  convert_ppqn _ _ [] = [];
  convert_ppqn ppqn (tempo,t0,ms0) ((t,msg):xs)
    = (ms,msg) : convert_ppqn ppqn (tempo,t,ms) xs when
        ms = int $ round (ms0+tempo/ppqn*(t-t0)/1000);
	tempo = (msg!2<<16)+(msg!3<<8)+msg!4; // new tempo
      end if msg!0 == 0xff && msg!1 == 0x51; // tempo message?
    = (ms,msg) : convert_ppqn ppqn (tempo,t,ms) xs when
        ms = int $ round (ms0+tempo/ppqn*(t-t0)/1000);
      end;
  // Mix two tracks.
  mix xs [] = xs;
  mix [] ys = ys;
  mix xs@(x1@(t1,msg1):xs1) ys@(y2@(t2,msg2):ys2)
    = x1 : mix xs1 ys if t1<=t2;
    = y2 : mix xs ys2 otherwise;
end when
  ty,division,resolution,ntracks = midifile::info mf;
end if ~null mf when
  mf::pointer = midifile::load name;
end;

/* Convert the sequence to a format more suitable for playback. Absolute
   timestamps are converted to relative ones and MIDI voice messages are
   converted to a symbolic format, using message selectors familiar from the
   Pd midi objects. System messages are discarded. */

decode xs = convert $ filter valid xs with
  valid (t,msg) = (msg!0 and 0xf0) ~= 0xf0;
  convert [] = [];
  convert ((t,msg):xs) = (0,decode msg):convert t xs with
    convert t1 [] = [];
    convert t1 ((t2,msg):xs) = (t2-t1,decode msg):convert t2 xs;
    decode {status,num,val,_} = case status of
      0x80 | 0x90 = note num val chan; // note on/off
      0xa0 = polytouch num val chan; // key pressure aka polyphonic aftertouch
      0xb0 = ctl val num chan; // control change
      0xc0 = pgm (num+1) chan; // program change
      0xd0 = touch num chan; // channel pressure
      0xe0 = bend (num+val<<7) chan; // pitch bend (num=lsb, val=msb)
    end when
      chan = status and 0xf + 1;
      status = status and 0xf0;
      val = if status == 0x80 then 0 else val;
    end;
  end;
end;

namespace;

using pdfaust;
using namespace pdfaust, midiseq;

/* midiseq object: Play a MIDI file. The name of the midi file is specified as
   a creation argument. The object understands the following messages:

   - start starts the playback
   - stop stops the playback
   - continue resumes playback at last position
   - loop 0 and loop 1 disable and enable looping, respectively
   - 0 and 1 are equivalent to stop and continue, respectively

   Notes are output on the outlet, using the format 'note num vel chan'. In
   addition, controller messages of the form 'ctl 123 0 chan' for each MIDI
   channel are output when a stop message is received. */

#! --required midiseq
midiseq name = catch (\msg->pd_error_s msg $$ cst ()) (seq with
  seq 0.0 = seq stop;
  seq 1.0 = seq continue;
  seq start | seq continue = () if get running;
  seq start = seq continue when
    // rewind to beginning
    put act s; put last s;
  end;
  seq stop = {stopmsgs, pd_delay inf ()} when
    put act (get last); put running false;
  end;
  seq continue = case nextmsgs of
    () = put running false $$ ();
    dt,msgs = put running true $$ pd_delay 0 msgs when
      // calculate the timebase
      m = #get act;
      t = foldl (\t (dt,_) -> t+dt) 0.0 $ take (n-m) s;
      pd_send "offset" t;
    end;
  end;
  seq (loop val) = () when
    put looping (val~=0.0);
  end;
  seq _ = () if ~get running;
  // process pending messages
  seq msgs::list = case nextmsgs of
    () = {smatrix msgs,loopmsg} when
      put running false;
      loopmsg = if get looping then pd_delay 500 start else {};
    end;
    dt,newmsgs = {smatrix msgs,pd_delay dt newmsgs};
  end;
  seq _ = ();
  // grab the next chunk of messages
  nextmsgs = case get act of
    [] = ();
    (dt,msg):xs = dt,msg:ys when
      ys = map (!1) $ takewhile (\(dt,msg) -> dt == 0) xs;
      xs = dropwhile (\(dt,msg) -> dt == 0) xs;
      put act xs;
    end;
  end when
    put last (get act);
  end;
end when
  name = if symbolp name then str name+".mid" else name;
  fname = libsearch "midi" name;
  loaded,s = if stringp fname && ~null fname then true,load fname else false,[];
  listp s || throw ("midiseq: error loading "+name);
  s = decode s; n = #s;
  act = ref s; last = ref s;
  running = ref false;
  looping = ref false;
  stopmsgs = { ctl 0 123 chan | chan = 1..16 };
  ~loaded || pd_post $ "midiseq: loaded "+pfile fname;
end);
