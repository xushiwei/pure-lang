
/* This one is in the liblo headers, but not wrapped automatically as it's an
   array constant. Define it as a Pure vector which can readily be passed to
   liblo functions expecting a timestamp value. */

const lo::TT_IMMEDIATE = {0,0};

/* These are varargs functions in the liblo interface, so we massage them
   somewhat to make them callable from Pure. */

extern int Pure_lo_message_add(void*, char*, expr*) = message_add;
extern int Pure_lo_send(void*, char*, char*, expr*) = send;
extern int Pure_lo_send_timestamped(void*, lo_timetag*, char*, char*, expr*)
 = send_timestamped;
extern int Pure_lo_send_from(void*, void*, lo_timetag*, char*, char*, expr*)
 = send_from;

/* liblo allows these to be invoked also with NULL pointers as strings, so we
   emulate this behaviour here. */

private extern void *lo_address_new(void*,void*);
address_new host::pointer port::pointer =
  lo_address_new host port if host==NULL && port==NULL;
address_new host::pointer port::string =
  lo_address_new host (cooked $ byte_cstring port) if host==NULL;
address_new host::string port::pointer =
  lo_address_new (cooked $ byte_cstring host) port if port==NULL;

private extern void *lo_server_add_method(void*,void*,void*,void*,void*);
server_add_method s::pointer path::pointer types::pointer h::pointer data::pointer =
  lo_server_add_method s path types h data if path==NULL && types==NULL;
server_add_method s::pointer path::pointer types::string h::pointer data::pointer =
  lo_server_add_method s path (cooked $ byte_cstring types) h data if path==NULL;
server_add_method s::pointer path::string types::pointer h::pointer data::pointer =
  lo_server_add_method s (cooked $ byte_cstring path) types h data if types==NULL;

private extern void lo_server_del_method(void*,void*,void*);
server_del_method s::pointer path::pointer types::string =
  lo_server_del_method s path types if path==NULL && types==NULL;
server_del_method s::pointer path::pointer types::string =
  lo_server_del_method s path (cooked $ byte_cstring types) if path==NULL;
server_del_method s::pointer path::string types::string =
  lo_server_del_method s (cooked $ byte_cstring path) types if types==NULL;

private extern void *lo_server_thread_add_method(void*,void*,void*,void*,void*);
server_thread_add_method s::pointer path::pointer types::pointer h::pointer data::pointer =
  lo_server_thread_add_method s path types h data if path==NULL && types==NULL;
server_thread_add_method s::pointer path::pointer types::string h::pointer data::pointer =
  lo_server_thread_add_method s path (cooked $ byte_cstring types) h data if path==NULL;
server_thread_add_method s::pointer path::string types::pointer h::pointer data::pointer =
  lo_server_thread_add_method s (cooked $ byte_cstring path) types h data if types==NULL;

private extern void lo_server_thread_del_method(void*,void*,void*);
server_thread_del_method s::pointer path::pointer types::string =
  lo_server_thread_del_method s path types if path==NULL && types==NULL;
server_thread_del_method s::pointer path::pointer types::string =
  lo_server_thread_del_method s path (cooked $ byte_cstring types) if path==NULL;
server_thread_del_method s::pointer path::string types::string =
  lo_server_thread_del_method s (cooked $ byte_cstring path) types if types==NULL;

/* Convenience functions to decode liblo OSC messages and addresses. */

public decode_arg decode_argv;

decode_arg "i" p::pointer = get_int p;
decode_arg "h" p::pointer = get_int64 p;
decode_arg "c" p::pointer = get_byte p;
decode_arg "f" p::pointer = get_float p;
decode_arg "d" p::pointer = get_double p;
decode_arg "b" p::pointer = p;
decode_arg "s" p::pointer = cstring_dup p;
decode_arg "S" p::pointer = cstring_dup p;
decode_arg "t" p::pointer = int_matrix 2 p;
decode_arg "m" p::pointer = map ubyte $ byte_matrix 4 p;
decode_arg "T" p::pointer = ();
decode_arg "F" p::pointer = ();
decode_arg "N" p::pointer = ();
decode_arg "I" p::pointer = ();
decode_arg _   p::pointer = p; // unknown

decode_argv types::string p::pointer n::int = tuple $
  zipwith decode_arg (chars types)
  [get_pointer (p+i*SIZEOF_POINTER) | i = 0..n-1];

/* This returns a triple host, port, protocol. */

public decode_address;

decode_adress a::pointer =
  address_get_hostname a, address_get_port a, address_get_protocol a;

public message_args message_source message_timestamp;

message_args m::pointer =
  decode_argv (message_get_types m) (message_get_argv m);

message_source m::pointer = decode_address (message_get_source m);

/* This one will only work in liblo 0.26 and later. To work around this, you
   can explicitly include a timestamp in outgoing messages instead. */

message_timestamp m::pointer = int_matrix 2 p if pointerp p
  when p = message_get_timestamp m end;

/* A convenience function to create an OSC timetag at a given (nonnegative)
   offset in seconds (a double) from another timetag, which can be either a
   lo_timetag pointer or a Pure int vector. If the given timetag is NULL, the
   current time is assumed (as given by lo::timetag_now). The return value is
   always a Pure int vector which can readily be passed to liblo functions
   expecting a timestamp value. */

public timetag;

timetag p::pointer offs = {ts!0+secs,ts!1+ticks} when
  ts = int_matrix 2 p; if null p then timetag_now ts else ();
  secs = int (trunc offs); ticks = int (frac offs*4294967296.0);
end if offs>=0;

timetag ts::matrix offs = {ts!0+secs,ts!1+ticks} when
  secs = int (trunc offs); ticks = int (frac offs*4294967296.0);
end if imatrixp ts && offs>=0;
