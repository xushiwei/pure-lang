<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>Pure-XML - XML/XSLT interface</title>
<meta name="author" content="Albert Graef &lt;Dr.Graef&#64;t-online.de&gt;" />
<meta name="date" content="Mar 10 2009" />
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2005-12-18 01:56:14 +0100 (Sun, 18 Dec 2005) $
:Revision: $Revision: 4224 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="pure-xml-xml-xslt-interface">
<h1 class="title">Pure-XML - XML/XSLT interface</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Albert Graef &lt;<a class="reference" href="mailto:Dr.Graef&#64;t-online.de">Dr.Graef&#64;t-online.de</a>&gt;</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>Mar 10 2009</td></tr>
</tbody>
</table>
<p><a class="reference" href="http://www.w3.org/TR/xml">XML</a>, the Extensible Markup Language, facilitates the exchange of complex
structured data between applications and systems. <a class="reference" href="http://www.w3.org/TR/xslt">XSLT</a> allows you to
transform XML documents to other XML-based formats such as HTML. Together, XML
and XSLT let you create dynamic web content with ease. Both XML and XSLT are
open standards by the W3C consortium (<a class="reference" href="http://www.w3.org">http://www.w3.org</a>).</p>
<p>Pure's XML interface is based on the libxml2 and libxslt libraries from the
GNOME project. If you have a Linux system then you most likely have these
libraries, otherwise you can get them from <a class="reference" href="http://xmlsoft.org">http://xmlsoft.org</a>. For Windows
users, the required dlls are available from the GnuWin32 project
(<a class="reference" href="http://gnuwin32.sourceforge.net">http://gnuwin32.sourceforge.net</a>) and are already included in the Pure MSI
package.</p>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#installation" id="id1" name="id1">1&nbsp;&nbsp;&nbsp;Installation</a></li>
<li><a class="reference" href="#usage" id="id2" name="id2">2&nbsp;&nbsp;&nbsp;Usage</a></li>
<li><a class="reference" href="#data-structures" id="id3" name="id3">3&nbsp;&nbsp;&nbsp;Data Structures</a><ul class="auto-toc">
<li><a class="reference" href="#the-document-tree" id="id4" name="id4">3.1&nbsp;&nbsp;&nbsp;The Document Tree</a></li>
<li><a class="reference" href="#document-types" id="id5" name="id5">3.2&nbsp;&nbsp;&nbsp;Document Types</a></li>
</ul>
</li>
<li><a class="reference" href="#operations" id="id6" name="id6">4&nbsp;&nbsp;&nbsp;Operations</a><ul class="auto-toc">
<li><a class="reference" href="#document-operations" id="id7" name="id7">4.1&nbsp;&nbsp;&nbsp;Document Operations</a></li>
<li><a class="reference" href="#traversing-documents" id="id8" name="id8">4.2&nbsp;&nbsp;&nbsp;Traversing Documents</a></li>
<li><a class="reference" href="#node-information" id="id9" name="id9">4.3&nbsp;&nbsp;&nbsp;Node Information</a></li>
<li><a class="reference" href="#node-manipulation" id="id10" name="id10">4.4&nbsp;&nbsp;&nbsp;Node Manipulation</a></li>
<li><a class="reference" href="#transformations" id="id11" name="id11">4.5&nbsp;&nbsp;&nbsp;Transformations</a></li>
</ul>
</li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id1" id="installation" name="installation">1&nbsp;&nbsp;&nbsp;Installation</a></h1>
<p>Run <tt class="docutils literal"><span class="pre">make</span></tt> and then <tt class="docutils literal"><span class="pre">sudo</span> <span class="pre">make</span> <span class="pre">install</span></tt> to compile and install this module
from source. This requires libxml2, libxslt and Pure.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id2" id="usage" name="usage">2&nbsp;&nbsp;&nbsp;Usage</a></h1>
<p>Use the following declaration to make the operations of this module available
in your programs:</p>
<pre class="literal-block">
using xml;
</pre>
<p>The module defines two namespaces <tt class="docutils literal"><span class="pre">xml</span></tt> and <tt class="docutils literal"><span class="pre">xslt</span></tt> for the XML and the
XSLT operations, respectively. For convenience, you can open these in your
program as follows:</p>
<pre class="literal-block">
using namespace xml, xslt;
</pre>
<p>A number of complete examples illustrating the use of this module can be found
in the examples directory in the source distribution.
..</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id3" id="data-structures" name="data-structures">3&nbsp;&nbsp;&nbsp;Data Structures</a></h1>
<p>XML documents are represented using pointers to the <tt class="docutils literal"><span class="pre">xmlDoc</span></tt> and
<tt class="docutils literal"><span class="pre">xmlNode</span></tt> structures provides by the libxml2 library. Similarly,
stylesheets are pointers to the xmlStylesheet structure from libxslt
(cf. <a class="reference" href="#transformations">Transformations</a>). These are all &quot;cooked&quot; pointers which take care of
freeing themselves automatically when they are no longer needed. You can
also check for these types of pointers using the following predicates:</p>
<ul class="simple" id="docp">
<li><tt class="docutils literal"><span class="pre">xml::docp</span> <span class="pre">x</span></tt> checks whether <tt class="docutils literal"><span class="pre">x</span></tt> is an XML document.</li>
</ul>
<ul class="simple" id="nodep">
<li><tt class="docutils literal"><span class="pre">xml::nodep</span> <span class="pre">x</span></tt> checks whether <tt class="docutils literal"><span class="pre">x</span></tt> is a node in an XML document.</li>
</ul>
<ul class="simple" id="stylesheetp">
<li><tt class="docutils literal"><span class="pre">xslt::stylesheetp</span> <span class="pre">x</span></tt> checks whether <tt class="docutils literal"><span class="pre">x</span></tt> is a stylesheet pointer.</li>
</ul>
<!--  -->
<div class="section">
<h2><a class="toc-backref" href="#id4" id="the-document-tree" name="the-document-tree">3.1&nbsp;&nbsp;&nbsp;The Document Tree</a></h2>
<p>An XML document is a rooted tree which can be created, traversed and
manipulated using the operations of this module. There are different types
of nodes in the tree, each carrying their own type of data. In Pure land,
the node data is described using the <cite>node info</cite> constructors described
below. The following document node types are currently recognized:</p>
<ul id="nodes">
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::element</span> <span class="pre">tag</span> <span class="pre">ns</span> <span class="pre">attrs</span></tt></p>
<p>An XML element with given (possibly qualified) name <tt class="docutils literal"><span class="pre">tag</span></tt>, a (possibly
empty) list of namespace declarations <tt class="docutils literal"><span class="pre">ns</span></tt> and a (possibly empty) list
of attributes (<tt class="docutils literal"><span class="pre">key=&gt;value</span></tt> pairs of strings) <tt class="docutils literal"><span class="pre">attrs</span></tt>. Namespace
declarations normally take the form of a pair of strings
<tt class="docutils literal"><span class="pre">(prefix,href)</span></tt>, where <tt class="docutils literal"><span class="pre">prefix</span></tt> is the prefix associated with the
namespace and <tt class="docutils literal"><span class="pre">href</span></tt> the corresponding URI (the name of the
namespace). They can also be just a string <tt class="docutils literal"><span class="pre">href</span></tt> if the namespace
prefix is missing.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::element_text</span> <span class="pre">tag</span> <span class="pre">ns</span> <span class="pre">attrs</span> <span class="pre">content</span></tt></p>
<p>A convenience function which denotes a combination of an element node
with a text child; this is only used when creating a new node, and
indicates that a text node child is to be added to the node
automatically.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::attr</span> <span class="pre">key</span> <span class="pre">val</span></tt></p>
<p>An attribute node. These only occur as results of the <a class="reference" href="#select">select</a> and <a class="reference" href="#attrs">attrs</a>
functions, and cannot be inserted directly into a document.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::text</span> <span class="pre">content</span></tt></p>
<p>A text node with given content (a string).</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::cdata</span> <span class="pre">content</span></tt></p>
<p>Like <tt class="docutils literal"><span class="pre">xml::text</span></tt>, but contains unparsed character data.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::comment</span> <span class="pre">content</span></tt></p>
<p>A comment.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::entity_ref</span> <span class="pre">name</span></tt></p>
<p>An entity reference (<tt class="docutils literal"><span class="pre">&amp;name;</span></tt>).</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::pi</span> <span class="pre">name</span> <span class="pre">content</span></tt></p>
<p>Processing instructions. <tt class="docutils literal"><span class="pre">name</span></tt> is the application name, <tt class="docutils literal"><span class="pre">content</span></tt>
the text of the processing instructions.</p>
</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id5" id="document-types" name="document-types">3.2&nbsp;&nbsp;&nbsp;Document Types</a></h2>
<p id="dtd">Besides the node types described above, there are some additional node
types only used in the <a class="reference" href="http://www.w3.org/TR/REC-xml/#dt-doctype">document type definition</a> (DTD), which can be
extracted from a document using the <a class="reference" href="#int-subset">int_subset</a> and <a class="reference" href="#ext-subset">ext_subset</a>
functions. These are for inspection purposes only; it is not possible to
change the DTD of a document in-place. (However, you can create a new
document, and attach a DTD to it, using the <a class="reference" href="#new-doc">new_doc</a> function.)</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::doctype</span> <span class="pre">name</span> <span class="pre">extid</span></tt></p>
<p>DTDs are represented using this special type of node, where <tt class="docutils literal"><span class="pre">name</span></tt> is
the name of the root element, and <tt class="docutils literal"><span class="pre">extid</span></tt> is a pair consisting of the
external identifier and the URI of the DTD (or just the URI if there is
no external identifier). The <tt class="docutils literal"><span class="pre">xml::doctype</span></tt> node has as its children
zero or more of the following kinds of DTD declaration nodes (these are
just straightforward abstract syntax for the !ELEMENT, !ATTLIST and
!ENTITY declarations inside a DTD declaration; see the <a class="reference" href="http://www.w3.org/TR/xml">XML</a> specification
for details).</p>
</li>
</ul>
<p id="element-declaration">Element declarations:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">xml::undefined_element</span> <span class="pre">name</span></tt></li>
<li><tt class="docutils literal"><span class="pre">xml::empty_element</span> <span class="pre">name</span></tt></li>
<li><tt class="docutils literal"><span class="pre">xml::any_element</span> <span class="pre">name</span></tt></li>
<li><tt class="docutils literal"><span class="pre">xml::mixed_element</span> <span class="pre">name</span> <span class="pre">content</span></tt></li>
<li><tt class="docutils literal"><span class="pre">xml::std_element</span> <span class="pre">name</span> <span class="pre">content</span></tt></li>
</ul>
<p id="attribute-declaration">Attribute declarations:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">xml::cdata_attr</span> <span class="pre">elem_name</span> <span class="pre">name</span> <span class="pre">default</span></tt></li>
<li><tt class="docutils literal"><span class="pre">xml::id_attr</span> <span class="pre">elem_name</span> <span class="pre">name</span> <span class="pre">default</span></tt></li>
<li><tt class="docutils literal"><span class="pre">xml::idref_attr</span> <span class="pre">elem_name</span> <span class="pre">name</span> <span class="pre">default</span></tt></li>
<li><tt class="docutils literal"><span class="pre">xml::idrefs_attr</span> <span class="pre">elem_name</span> <span class="pre">name</span> <span class="pre">default</span></tt></li>
<li><tt class="docutils literal"><span class="pre">xml::entity_attr</span> <span class="pre">elem_name</span> <span class="pre">name</span> <span class="pre">default</span></tt></li>
<li><tt class="docutils literal"><span class="pre">xml::entities_attr</span> <span class="pre">elem_name</span> <span class="pre">name</span> <span class="pre">default</span></tt></li>
<li><tt class="docutils literal"><span class="pre">xml::nmtoken_attr</span> <span class="pre">elem_name</span> <span class="pre">name</span> <span class="pre">default</span></tt></li>
<li><tt class="docutils literal"><span class="pre">xml::nmtokens_attr</span> <span class="pre">elem_name</span> <span class="pre">name</span> <span class="pre">default</span></tt></li>
<li><tt class="docutils literal"><span class="pre">xml::enum_attr</span> <span class="pre">elem_name</span> <span class="pre">name</span> <span class="pre">vals</span> <span class="pre">default</span></tt></li>
<li><tt class="docutils literal"><span class="pre">xml::notation_attr</span> <span class="pre">elem_name</span> <span class="pre">name</span> <span class="pre">vals</span> <span class="pre">default</span></tt></li>
</ul>
<p id="entity-declaration">Entity declarations:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">xml::int_entity</span> <span class="pre">name</span> <span class="pre">content</span></tt></li>
<li><tt class="docutils literal"><span class="pre">xml::int_param_entity</span> <span class="pre">name</span> <span class="pre">content</span></tt></li>
<li><tt class="docutils literal"><span class="pre">xml::ext_entity</span> <span class="pre">name</span> <span class="pre">extid</span> <span class="pre">content</span></tt></li>
<li><tt class="docutils literal"><span class="pre">xml::ext_param_entity</span> <span class="pre">name</span> <span class="pre">extid</span> <span class="pre">content</span></tt></li>
</ul>
<!--  -->
<p>The element content type (<tt class="docutils literal"><span class="pre">content</span></tt> argument of the <a class="reference" href="#element-declaration">element
declaration</a> nodes) is a kind of regular expression formed with tags
(specified as strings) and the following constructors:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">xml::pcdata</span></tt>: text data (<tt class="docutils literal"><span class="pre">#PCDATA</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">xml::sequence</span> <span class="pre">xs</span></tt>: concatenation (<tt class="docutils literal"><span class="pre">x,y,z</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">xml::union</span> <span class="pre">xs</span></tt>: alternatives (<tt class="docutils literal"><span class="pre">x|y|z</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">xml::opt</span> <span class="pre">x</span></tt>: optional element (<tt class="docutils literal"><span class="pre">x?</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">xml::mult</span> <span class="pre">x</span></tt>: repeated element (<tt class="docutils literal"><span class="pre">x*</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">xml::plus</span> <span class="pre">x</span></tt>: non-optional repeated element (<tt class="docutils literal"><span class="pre">x+</span></tt>)</li>
</ul>
<!--  -->
<p>Attribute defaults (the <tt class="docutils literal"><span class="pre">default</span></tt> argument of <a class="reference" href="#attribute-declaration">attribute declaration</a>
nodes) are represented using the following constructor symbols:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">xml::required</span></tt>: a required attribute, i.e., the user must specify this</li>
<li><tt class="docutils literal"><span class="pre">xml::implied</span></tt>: an implied attribute, i.e., the user does not have to
specify this</li>
<li><tt class="docutils literal"><span class="pre">xml::default</span> <span class="pre">val</span></tt>: an attribute with the given default value <tt class="docutils literal"><span class="pre">val</span></tt></li>
<li><tt class="docutils literal"><span class="pre">xml::fixed</span> <span class="pre">val</span></tt>: an attribute with the given fixed value <tt class="docutils literal"><span class="pre">val</span></tt></li>
</ul>
<!--  -->
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id6" id="operations" name="operations">4&nbsp;&nbsp;&nbsp;Operations</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id7" id="document-operations" name="document-operations">4.1&nbsp;&nbsp;&nbsp;Document Operations</a></h2>
<p>The following functions allow you to create new XML documents, load them
from or save them to a file or a string, and provide general information
about a document.</p>
<ul id="new-doc">
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::new_doc</span> <span class="pre">version</span> <span class="pre">dtd</span> <span class="pre">info</span></tt></p>
<p>This function creates a new XML document. It returns a pointer to the new
document. <tt class="docutils literal"><span class="pre">version</span></tt> is a string denoting the XML version (or <tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt> to
indicate the default). <tt class="docutils literal"><span class="pre">info</span></tt> is the data of the root node (which
should denote an element node). <tt class="docutils literal"><span class="pre">dtd</span></tt> denotes the document type which
can be <tt class="docutils literal"><span class="pre">()</span></tt> to denote an empty DTD, a string (the URI/filename of the
DTD), or a pair <tt class="docutils literal"><span class="pre">(pubid,sysid)</span></tt> where <tt class="docutils literal"><span class="pre">pubid</span></tt> denotes the public
identifier of the DTD and <tt class="docutils literal"><span class="pre">sysid</span></tt> its system identifier (URI).</p>
<p>Note that only simple kinds of documents with an internal DTD can be
created this way. Use the <a class="reference" href="#load-file">load_file</a> or <a class="reference" href="#load-string">load_string</a> function below to
create a skeleton document if a more elaborate prolog is required.</p>
</li>
</ul>
<ul id="load-string">
<span id="load-file"></span><li><p class="first"><tt class="docutils literal"><span class="pre">xml::load_file</span> <span class="pre">name</span> <span class="pre">flags</span></tt>, <tt class="docutils literal"><span class="pre">xml::load_string</span> <span class="pre">s</span> <span class="pre">flags</span></tt></p>
<p>Load an XML document from a file or a string. <tt class="docutils literal"><span class="pre">flags</span></tt> denotes the
parser flags (a bitwise disjunction of any of the following: constants,
or 0 for the default):</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">xml::DTDLOAD</span></tt>: load DTD</li>
<li><tt class="docutils literal"><span class="pre">xml::DTDVALID</span></tt>: validate</li>
<li><tt class="docutils literal"><span class="pre">xml::PEDANTIC</span></tt>: pedantic parse</li>
<li><tt class="docutils literal"><span class="pre">xml::SUBENT</span></tt>: substitute entities</li>
<li><tt class="docutils literal"><span class="pre">xml::NOBLANKS</span></tt>: suppress blank nodes</li>
</ul>
<p>The return value is the document pointer. These operations may also fail
if there is a fatal error parsing the document.</p>
</li>
</ul>
<ul id="save-string">
<span id="save-file"></span><li><p class="first"><tt class="docutils literal"><span class="pre">xml::save_file</span> <span class="pre">name</span> <span class="pre">doc</span> <span class="pre">encoding</span> <span class="pre">compression</span></tt>,
<tt class="docutils literal"><span class="pre">xml::save_string</span> <span class="pre">doc</span></tt></p>
<p>Save an XML document <tt class="docutils literal"><span class="pre">doc</span></tt> to a file or a string. When saving to a
file, <tt class="docutils literal"><span class="pre">encoding</span></tt> denotes the desired encoding (or <tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt> for the
default), <tt class="docutils literal"><span class="pre">compression</span></tt> the desired level of zlib compression (0 means
none, 9 is maximum, -1 indicates the default). Note that with
<tt class="docutils literal"><span class="pre">xml::save_string</span></tt>, the result is always encoded as UTF-8.</p>
</li>
</ul>
<ul id="doc-info">
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::doc_info</span> <span class="pre">doc</span></tt></p>
<p>Retrieve general information about a document. Returns a tuple
<tt class="docutils literal"><span class="pre">(version,encoding,url,compression,standalone)</span></tt>, where <tt class="docutils literal"><span class="pre">version</span></tt> is
the XML version of the document, <tt class="docutils literal"><span class="pre">encoding</span></tt> the external encoding (if
any), <tt class="docutils literal"><span class="pre">url</span></tt> the name/location of the document (if any), <tt class="docutils literal"><span class="pre">compression</span></tt>
the level of zlib compression, and <tt class="docutils literal"><span class="pre">standalone</span></tt> is a flag indicating
whether the document contains any external references (see the libxml2
documentation for details).</p>
</li>
</ul>
<ul id="ext-subset">
<span id="int-subset"></span><li><p class="first"><tt class="docutils literal"><span class="pre">xml::int_subset</span> <span class="pre">doc</span></tt>, <tt class="docutils literal"><span class="pre">xml::ext_subset</span> <span class="pre">doc</span></tt></p>
<p>Retrieve the internal and external DTD subset of a document. Returns a
<tt class="docutils literal"><span class="pre">doctype</span></tt> node (fails if there's no corresponding DTD).</p>
</li>
</ul>
<p><strong>Example</strong></p>
<p>Read the sample.xml document distributed with the sources (ignoring blank
nodes) and retrieve the document info:</p>
<pre class="literal-block">
&gt; using xml;
&gt; let sample = xml::load_file &quot;sample.xml&quot; xml::NOBLANKS;
&gt; xml::doc_info sample;
&quot;1.0&quot;,&quot;&quot;,&quot;sample.xml&quot;,0,-2
</pre>
<!--  -->
</div>
<div class="section">
<h2><a class="toc-backref" href="#id8" id="traversing-documents" name="traversing-documents">4.2&nbsp;&nbsp;&nbsp;Traversing Documents</a></h2>
<p>These operations are used to traverse the document tree, i.e., the nodes of
the document. They take either a document pointer <tt class="docutils literal"><span class="pre">doc</span></tt> or a node pointer
<tt class="docutils literal"><span class="pre">node</span></tt> as argument, and yield a corresponding node pointer (or a document
pointer, in the case of <tt class="docutils literal"><span class="pre">xml::doc</span></tt>). The node pointers can then be used
with the <a class="reference" href="#node-information">Node Information</a> and <a class="reference" href="#node-manipulation">Node Manipulation</a> operations described
below.</p>
<ul class="simple" id="root">
<li><tt class="docutils literal"><span class="pre">xml::root</span> <span class="pre">doc</span></tt>: the root node of <tt class="docutils literal"><span class="pre">doc</span></tt></li>
</ul>
<ul class="simple" id="doc">
<li><tt class="docutils literal"><span class="pre">xml::doc</span> <span class="pre">node</span></tt>: the document <tt class="docutils literal"><span class="pre">node</span></tt> belongs to</li>
</ul>
<ul class="simple" id="parent">
<li><tt class="docutils literal"><span class="pre">xml::parent</span> <span class="pre">node</span></tt>: the parent of <tt class="docutils literal"><span class="pre">node</span></tt></li>
</ul>
<ul class="simple" id="last">
<span id="first"></span><li><tt class="docutils literal"><span class="pre">xml::first</span> <span class="pre">node</span></tt>, <tt class="docutils literal"><span class="pre">xml::last</span> <span class="pre">node</span></tt>: first and last child node</li>
</ul>
<ul class="simple" id="prev">
<span id="next"></span><li><tt class="docutils literal"><span class="pre">xml::next</span> <span class="pre">node</span></tt>, <tt class="docutils literal"><span class="pre">xml::prev</span> <span class="pre">node</span></tt>: next and previous sibling</li>
</ul>
<ul class="simple" id="last-attr">
<span id="first-attr"></span><li><tt class="docutils literal"><span class="pre">xml::first_attr</span> <span class="pre">node</span></tt>, <tt class="docutils literal"><span class="pre">xml::last_attr</span> <span class="pre">node</span></tt>: first and last
attribute node</li>
</ul>
<p>All these operations fail if the corresponding target node does not exist,
or if the type of the given node is not supported by this implementation.</p>
<!--  -->
<p>There are also two convenience functions to retrieve the children and
attribute nodes of a node:</p>
<ul class="simple" id="children">
<li><tt class="docutils literal"><span class="pre">xml::children</span> <span class="pre">node</span></tt>: returns the list of all child nodes of <tt class="docutils literal"><span class="pre">node</span></tt></li>
</ul>
<ul class="simple" id="attrs">
<li><tt class="docutils literal"><span class="pre">xml::attrs</span> <span class="pre">node</span></tt>: returns the list of all attribute nodes of <tt class="docutils literal"><span class="pre">node</span></tt></li>
</ul>
<p>Moreover, given a node pointer <tt class="docutils literal"><span class="pre">node</span></tt>, <tt class="docutils literal"><span class="pre">node!i</span></tt> can be used to retrieve
the <tt class="docutils literal"><span class="pre">i</span></tt>th child of <tt class="docutils literal"><span class="pre">node</span></tt>.</p>
<p><strong>Example</strong></p>
<p>Peek at the root node of the sample document and its children:</p>
<pre class="literal-block">
&gt; let r = xml::root sample; r;
#&lt;pointer 0xe15e10&gt;
&gt; xml::node_info r;
xml::element &quot;story&quot; [] []
&gt; #xml::children r;
5
&gt; xml::node_info (r!0);
xml::cdata &quot;&lt;greeting&gt;Hello, world!&lt;/greeting&gt;&quot;
</pre>
<!--  -->
</div>
<div class="section">
<h2><a class="toc-backref" href="#id9" id="node-information" name="node-information">4.3&nbsp;&nbsp;&nbsp;Node Information</a></h2>
<p>These operations retrieve information about the nodes of an XML document.</p>
<ul id="select">
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::select</span> <span class="pre">doc</span> <span class="pre">xpath</span></tt></p>
<p>Retrieve nodes using an <a class="reference" href="http://www.w3.org/TR/xpath">XPath</a> specification. Given an XPath (a string)
<tt class="docutils literal"><span class="pre">xpath</span></tt>, this operation returns the list of all matching nodes in the
given document <tt class="docutils literal"><span class="pre">doc</span></tt>.</p>
</li>
</ul>
<ul id="node-info">
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::node_info</span> <span class="pre">node</span></tt></p>
<p>Retrieve the node data from <tt class="docutils literal"><span class="pre">node</span></tt>. Returns a <cite>node info</cite> value as
described in <a class="reference" href="#data-structures">Data Structures</a>. Fails if the node does not belong to one
of the supported node types.</p>
</li>
</ul>
<!--  -->
<ul id="is-blank-node">
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::is_blank_node</span></tt></p>
<p>Checks whether a node is a blank node (empty or whitespace only) and thus
possibly ignorable.</p>
</li>
</ul>
<ul id="node-base">
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::node_base</span> <span class="pre">node</span></tt></p>
<p>Returns the base URI of the given node.</p>
</li>
</ul>
<ul id="node-path">
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::node_path</span> <span class="pre">node</span></tt></p>
<p>Returns the path of a node in the document, in the format accepted by
<a class="reference" href="#select">select</a>.</p>
</li>
</ul>
<ul id="node-content">
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::node_content</span> <span class="pre">node</span></tt></p>
<p>Returns the text carried by the node, if any (after entity substitution).</p>
</li>
</ul>
<p>In addition, you can retrieve and change attributes of element nodes with
the following operations:</p>
<ul id="node-attr">
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::node_attr</span> <span class="pre">node</span> <span class="pre">name</span></tt></p>
<p>Retrieves the value of the attribute with the given <tt class="docutils literal"><span class="pre">name</span></tt> (after
entity substitution).</p>
</li>
</ul>
<ul id="unset-node-attr">
<span id="set-node-attr"></span><li><p class="first"><tt class="docutils literal"><span class="pre">xml::set_node_attr</span> <span class="pre">node</span> <span class="pre">name</span> <span class="pre">value</span></tt>, <tt class="docutils literal"><span class="pre">xml::unset_node_attr</span> <span class="pre">node</span> <span class="pre">name</span></tt></p>
<p>Sets or unsets an attribute value.</p>
</li>
</ul>
<p><strong>Examples</strong></p>
<p>Set and unset a node attribute:</p>
<pre class="literal-block">
&gt; xml::set_node_attr r &quot;foo&quot; &quot;4711&quot;;
()
&gt; xml::node_info r;
xml::element &quot;story&quot; [] [&quot;foo&quot;=&gt;&quot;4711&quot;]
&gt; xml::node_attr r &quot;foo&quot;;
&quot;4711&quot;
&gt; xml::unset_node_attr r &quot;foo&quot;;
()
&gt; xml::node_info r;
xml::element &quot;story&quot; [] []
</pre>
<p>The <a class="reference" href="#select">select</a> function is <em>very</em> powerful, and probably the single most
important operation of this module if you want to extract information from
an existing XML document without traversing the entire structure. Here is a
very simple example of its use:</p>
<pre class="literal-block">
&gt; map xml::node_content (xml::select sample &quot;//author&quot;);
[&quot;John Fleck&quot;]
</pre>
<!--  -->
</div>
<div class="section">
<h2><a class="toc-backref" href="#id10" id="node-manipulation" name="node-manipulation">4.4&nbsp;&nbsp;&nbsp;Node Manipulation</a></h2>
<p>These operations enable you to manipulate the document structure by adding
a new node to the document tree, and by removing (unlinking) existing nodes
from the tree.</p>
<ul id="replace">
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::replace</span> <span class="pre">node</span> <span class="pre">info</span></tt></p>
<p>Add the new node specified by <tt class="docutils literal"><span class="pre">info</span></tt> in place of the given node
<tt class="docutils literal"><span class="pre">node</span></tt>.</p>
</li>
</ul>
<ul id="add-last">
<span id="add-first"></span><li><p class="first"><tt class="docutils literal"><span class="pre">xml::add_first</span> <span class="pre">node</span> <span class="pre">info</span></tt>, <tt class="docutils literal"><span class="pre">xml::add_last</span> <span class="pre">node</span> <span class="pre">info</span></tt></p>
<p>Add the new node as the first or last child of <tt class="docutils literal"><span class="pre">node</span></tt>, respectively.</p>
</li>
</ul>
<ul id="add-prev">
<span id="add-next"></span><li><p class="first"><tt class="docutils literal"><span class="pre">xml::add_next</span> <span class="pre">node</span> <span class="pre">info</span></tt>, <tt class="docutils literal"><span class="pre">xml::add_prev</span> <span class="pre">node</span> <span class="pre">info</span></tt></p>
<p>Add the new node as the next or previous sibling of <tt class="docutils literal"><span class="pre">node</span></tt>,
respectively.</p>
</li>
</ul>
<p>The operations above all return a pointer to the new XML node object.</p>
<ul id="unlink">
<li><p class="first"><tt class="docutils literal"><span class="pre">xml::unlink</span> <span class="pre">node</span></tt></p>
<p>Deletes an existing node from the document tree.</p>
</li>
</ul>
<p><strong>Examples</strong></p>
<p>Replace the first child of the root node in the sample document:</p>
<pre class="literal-block">
&gt; xml::node_info (r!0);
xml::cdata &quot;&lt;greeting&gt;Hello, world!&lt;/greeting&gt;&quot;
&gt; xml::replace (r!0) (xml::text &quot;bla bla&quot;);
#&lt;pointer 0xd40d80&gt;
&gt; xml::node_info (r!0);
xml::text &quot;bla bla&quot;
</pre>
<p>Delete that node:</p>
<pre class="literal-block">
&gt; xml::unlink (r!0);
()
&gt; xml::node_info (r!0);
xml::comment &quot;This is a sample document for testing the xml interface.&quot;
</pre>
<!--  -->
</div>
<div class="section">
<h2><a class="toc-backref" href="#id11" id="transformations" name="transformations">4.5&nbsp;&nbsp;&nbsp;Transformations</a></h2>
<p>The following operations provide basic XSLT support. As already mentioned,
stylesheets are represented as pointers to the xsltStylesheet structure
provided by libxslt. Note that, in difference to XML document pointers,
this is an opaque type, i.e., there is no direct means to inspect and
manipulate parsed stylesheets in memory using the operations of this
module. However, a stylesheet is just a special kind of XML document and
thus can be manipulated after reading the stylesheet as an ordinary XML
document. The <a class="reference" href="#load-stylesheet">load_stylesheet</a> function then allows you to convert the
document pointer to an XSLT Stylesheet object.</p>
<p>Applying a stylesheet to an XML document generally involves the following
steps:</p>
<ol class="arabic simple">
<li>Load and parse the stylesheet using <a class="reference" href="#load-stylesheet">load_stylesheet</a>. The parameter to
<a class="reference" href="#load-stylesheet">load_stylesheet</a> can be either the name of a stylesheet file or a
corresponding document pointer. The function returns a pointer to the
stylesheet object which is used in the subsequent processing.</li>
<li>Invoke <a class="reference" href="#apply-stylesheet">apply_stylesheet</a> on the stylesheet and the target document.
This returns a new document pointer containing the transformed XML
document.</li>
<li>Run <a class="reference" href="#save-result-file">save_result_file</a> or <a class="reference" href="#save-result-string">save_result_string</a> on the result and the
stylesheet to save the transformed document in a file or a string.</li>
</ol>
<p>Here is a brief summary of the XSLT operations provided by this module.
Please check the <a class="reference" href="http://www.w3.org/TR/xslt">XSLT</a> documentation for details of the transformation
process.</p>
<ul id="load-stylesheet">
<li><p class="first"><tt class="docutils literal"><span class="pre">xslt::load_stylesheet</span> <span class="pre">x</span></tt></p>
<p>Load a stylesheet. <tt class="docutils literal"><span class="pre">x`</span> <span class="pre">can</span> <span class="pre">be</span> <span class="pre">either</span> <span class="pre">an</span> <span class="pre">XML</span> <span class="pre">document</span> <span class="pre">pointer,</span> <span class="pre">or</span> <span class="pre">a</span>
<span class="pre">string</span> <span class="pre">denoting</span> <span class="pre">the</span> <span class="pre">desired</span> <span class="pre">``.xsl</span></tt> file.</p>
</li>
</ul>
<ul id="apply-stylesheet">
<li><p class="first"><tt class="docutils literal"><span class="pre">xslt::apply_stylesheet</span> <span class="pre">style</span> <span class="pre">doc</span> <span class="pre">params</span></tt></p>
<p>Apply the stylesheet <tt class="docutils literal"><span class="pre">style</span></tt> to the given document <tt class="docutils literal"><span class="pre">doc</span></tt> with the
given parameters <tt class="docutils literal"><span class="pre">params</span></tt>. The third argument is a (possibly empty)
list of <tt class="docutils literal"><span class="pre">key=&gt;value</span></tt> string pairs which allows you to pass additional
parameters to the stylesheet.</p>
</li>
</ul>
<ul id="save-result-string">
<span id="save-result-file"></span><li><p class="first"><tt class="docutils literal"><span class="pre">xslt::save_result_file</span> <span class="pre">name</span> <span class="pre">doc</span> <span class="pre">style</span> <span class="pre">compression</span></tt>,
<tt class="docutils literal"><span class="pre">xslt::save_result_string</span> <span class="pre">doc</span> <span class="pre">style</span></tt></p>
<p>Save the transformation result <tt class="docutils literal"><span class="pre">doc</span></tt> obtained with the stylesheet
<tt class="docutils literal"><span class="pre">style</span></tt> to a file or a string. This works pretty much like <a class="reference" href="#save-file">save_file</a>
or <a class="reference" href="#save-string">save_string</a>, but also keeps track of some output-related information
contained in the stylesheet.</p>
</li>
</ul>
<p><strong>Example</strong></p>
<p>Load the recipes.xml document and the recipes.xsl stylesheet distributed
with the sources:</p>
<pre class="literal-block">
&gt; let recipes = xml::load_file &quot;recipes.xml&quot; xml::DTDVALID;
&gt; let style = xslt::load_stylesheet &quot;recipes.xsl&quot;;
</pre>
<p>Apply the stylesheet to the document and save the result in a html file:</p>
<pre class="literal-block">
&gt; let res = xslt::apply_stylesheet style recipes [];
&gt; xslt::save_result_file &quot;recipes.html&quot; res style 0;
()
</pre>
<p>That's all. You can now have a look at recipes.html in your favourite web
browser.</p>
</div>
</div>
</div>
</body>
</html>
