
/* xml.pure: Basic XML/XSLT interface using libxml2 and libxslt. */

/* Copyright (c) 2009 by Albert Graef <Dr.Graef@t-online.de>.

   This file is part of the Pure programming language and system.

   Pure is free software: you can redistribute it and/or modify it under the
   terms of the GNU General Public License as published by the Free Software
   Foundation, either version 3 of the License, or (at your option) any later
   version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
   details.

   You should have received a copy of the GNU General Public License along
   with this program.  If not, see <http://www.gnu.org/licenses/>. */

using "lib:xml";

namespace xml;

// Sentries. These are for internal use only.
private extern void xml_free_doc(void *p, expr *x) = free_doc;
private extern void xml_free_node(void *p, expr *x) = free_node;

/* Manifest constants (parser flags). */

const xml::DTDLOAD  = 0x01; // load DTD
const xml::DTDVALID = 0x02; // validate
const xml::PEDANTIC = 0x04; // pedantic parse
const xml::SUBENT   = 0x08; // substitute entities
const xml::NOBLANKS = 0x10; // suppress blank nodes

/* Predicates to check for XML documents and nodes. */

extern int xml_docp(expr *x) = docp;
extern int xml_nodep(expr *x) = nodep;

/* An XML document is a rooted tree which can be created, traversed and
   manipulated using the operations of this module. There are different types
   of nodes in the tree, each carrying their own type of data. In Pure land,
   the node data is described using the node info constructors described
   below. The following document node types are currently recognized:

   - element tag ns attrs: an XML element with given (possibly qualified) name
     (tag), namespace declarations (list of (prefix,href) pairs, or just href
     if the namespace prefix is missing) and attributes (list of (key=>value)
     pairs)

   - element_text tag ns attrs content: a convenience function which denotes a
     combination of an element node with a text child; this is only used when
     creating a new node, and indicates that a text node child is to be added
     to the node automatically

   - attr key val: an attribute node; these only occur as results of
     xml::select and xml::attrs, and cannot be inserted directly into a
     document

   - text content: text node with given content (a string)

   - cdata content: like text, but contains unparsed character data

   - comment content: a comment

   - entity_ref name: entity reference (&name;)

   - pi name content: processing instructions (name is the application name,
     content the text of the processing instructions)

   Besides these, there is a number of different node types only used in the
   document type definition (DTD), which can be extracted from a document
   using the xml_int_subset and xml_ext_subset functions. These are for
   inspection purposes only; it is not possible to change the DTD of a
   document in-place. (However, you can create a new document, and attach a
   DTD to it, using the xml_new_doc function.) */

public
  // document nodes
  element // tag ns attrs
  element_text // tag ns attrs content
  attr // name val
  text // content
  cdata // content
  comment // comment
  entity_ref // name
  pi // name instructions

  // dtd nodes
  doctype // name extid

  // element declarations
  undefined_element // name
  empty_element // name
  any_element // name
  mixed_element // name content
  std_element // name content

  // attribute declarations
  cdata_attr // elem_name name default
  id_attr // elem_name name default
  idref_attr // elem_name name default
  idrefs_attr // elem_name name default
  entity_attr // elem_name name default
  entities_attr // elem_name name default
  nmtoken_attr // elem_name name default
  nmtokens_attr // elem_name name default
  enum_attr // elem_name name vals default
  notation_attr // elem_name name vals default

  // entity declarations
  int_entity // name content
  int_param_entity // name content
  ext_entity // name extid content
  ext_param_entity // name extid content
;

/* Element content type (content argument of *_element). */

nullary pcdata;
public
  sequence // xs
  union    // xs
  opt      // x
  mult     // x
  plus     // x
;

/* Attribute defaults (default argument of *_attr). */

nullary required implied;
public
  default // val
  fixed   // val
;

/* Internal helper ops. */

private mksequence mkunion;

mksequence (sequence xs) (sequence ys)	= sequence (xs+ys);
mksequence (sequence xs) y		= sequence (xs+[y]);
mksequence x (sequence ys)		= sequence (x:ys);
mksequence x y				= sequence [x,y] otherwise;

mkunion (union xs) (union ys)		= union (xs+ys);
mkunion (union xs) y			= union (xs+[y]);
mkunion x (union ys)			= union (x:ys);
mkunion x y				= union [x,y] otherwise;

/* Create a new XML document. Returns a pointer to the document. version is a
   string denoting the XML version (or "" to indicate the default). info is
   the data of the root node (which should denote an element node). dtd
   denotes the document type which can be () to denote an empty DTD, a string
   (the URI/ filename of the DTD), or a pair (pubid,sysid) where pubid denotes
   the public identifier of the DTD and sysid its system identifier (URI). */

/* Note that only simple kinds of documents with an internal DTD can be
   created this way. Use the xml_load_file or xml_load_string function below
   to create a skeleton document if a more elaborate prolog is required. */

extern expr *xml_new_doc(char *version, expr *dtd, expr *info) = new_doc;

/* Load an XML document from a file or a string. flags denotes the parser
   flags (a bitwise disjunction of any of the constants defined at the
   beginning of this module, or 0 for the default). Returns the document
   pointer (fails if there is a fatal error parsing the document). */

extern expr *xml_load_file(char *name, int flags) = load_file;
extern expr *xml_load_string(char *s, int flags) = load_string;

/* Save an XML document doc to a file or a string. When saving to a file,
   encoding denotes the desired encoding (or "" for the default), compression
   the desired level of zlib compression (0 means none, 9 is maximum, -1
   indicates the default). Note that with xml_save_string, the result is
   always encoded as UTF-8. */

extern expr *xml_save_file(char *name, expr *doc,
			   char *encoding, int compression) = save_file;
extern expr *xml_save_string(expr *doc) = save_string;

/* Retrieve general information about a document. Returns a tuple (version,
   encoding,url,compression,standalone), where version is the XML version of
   the document, encoding the external encoding (if any), url the
   name/location of the document (if any), compression the level of zlib
   compression, and standalone is a truth value which corresponds to the
   "standalone" attribute in the XML document header. */

extern expr *xml_doc_info(expr *doc) = doc_info;

/* Retrieve the internal and external DTD subset of a document. Returns a
   doctype node (fails if there's no corresponding DTD). */

extern expr *xml_int_subset(expr *doc) = int_subset;
extern expr *xml_ext_subset(expr *doc) = ext_subset;

/* Traverse the document tree, i.e., the nodes of the document. The root node
   can be retrieved from an XML document pointer doc with xml::root, which
   returns a pointer to an XML node object. Given an XML node pointer node,
   you can then obtain the document it belongs to with xml::doc, its parent
   node with xml::parent, its first and last child node with xml::first and
   xml::last, the next and previous sibling of the node with xml::next and
   xml::prev, and the first and last attribute node with xml::first_attr and
   xml::last_attr respectively. All these operations fail if the corresponding
   target node does not exist, or if the type of the given node is not
   supported by this implementation. */

extern expr *xml_root(expr *doc) = root;
extern expr *xml_doc(expr *node) = doc;
extern expr *xml_parent(expr *node) = parent;
extern expr *xml_first(expr *node) = first;
extern expr *xml_last(expr *node) = last;
extern expr *xml_next(expr *node) = next;
extern expr *xml_prev(expr *node) = prev;
extern expr *xml_first_attr(expr *node) = first_attr;
extern expr *xml_last_attr(expr *node) = last_attr;

/* Convenience functions to retrieve the children and attribute nodes of a
   node. */

public children attrs;

children node	= while nodep next (first node) if nodep node;
attrs node	= while nodep next (first_attr node) if nodep node;

node!i::int	= children node!i if nodep node;

/* Retrieve nodes using an XPath specification. Given an XPath (a string)
   xpath, this operation returns the list of all matching nodes in the given
   document doc. */

extern expr *xml_select(expr *doc, expr *xpath) = select;

/* Retrieve the node data. Returns a node info value. Fails if node does not
   belong to one of the supported node types. */

extern expr *xml_node_info(expr *node) = node_info;

/* Additional node operations. The xml::is_blank_node function checks whether
   a node is a blank node (empty or whitespace only) and thus possibly
   ignorable. The xml::node_base function returns the base URI of the given
   node, xml::node_path its path (in the format accepted by xml::select), and
   xml::node_content returns the text carried by the node, if any (after
   entity substitution). For an element node, xml::node_attr can be used to
   retrieve the value of the given attribute (after entity substitution),
   xml::set_node_attr and xml::unset_node_attr to set and unset an attribute
   value. */

extern expr *xml_is_blank_node(expr *node) = is_blank_node;
extern expr *xml_node_base(expr *node) = node_base;
extern expr *xml_node_path(expr *node) = node_path;
extern expr *xml_node_content(expr *node) = node_content;

extern expr *xml_node_attr(expr *node, expr *name) = node_attr;
extern expr *xml_set_node_attr(expr *node, expr *name, expr *val)
  = set_node_attr;
extern expr *xml_unset_node_attr(expr *node, expr *name) = unset_node_attr;

/* Add a new node to the document tree, given the node data (node info value)
   info. The new node can be added either in place of a given node node
   (xml::replace), as node's first or last child (xml::add_first,
   xml::add_last), or as its next or previous sibling (xml::add_next,
   xml::add_prev). Returns a pointer to the new XML node object. */

extern expr *xml_replace(expr *node, expr *info) = replace;
extern expr *xml_add_first(expr *node, expr *info) = add_first;
extern expr *xml_add_last(expr *node, expr *info) = add_last;
extern expr *xml_add_next(expr *node, expr *info) = add_next;
extern expr *xml_add_prev(expr *node, expr *info) = add_prev;

/* Delete an existing node from the document tree. */

extern expr *xml_unlink(expr *node) = unlink;

/* Basic XSLT support. Stylesheets are represented as XSLT stylesheet
   pointers. Note that, in difference to XML document pointers, this is an
   opaque type, i.e., there is no direct means to inspect and manipulate
   parsed stylesheets in memory. However, you can achieve this by reading the
   stylesheets as XML documents. This is possible because a stylesheet is just
   a special kind of XML document. The xslt::load_stylesheet function then
   allows you to convert the document pointer to an XSLTStylesheet object.

   Applying a stylesheet to an XML document generally involves the following
   steps:

   1. Load and parse the stylesheet using xslt::load_stylesheet. The parameter
      to xslt::load_stylesheet can be either the name of a stylesheet file or
      a corresponding document pointer. The function returns a pointer to the
      stylesheet object which is used in the subsequent processing.

   2. Invoke xslt::apply_stylesheet on the stylesheet and the target
      document. This returns a new document pointer containing the transformed
      XML document. The third argument of xslt::apply_stylesheet is a list of
      (key=>value) string pairs which allows you to pass additional parameters
      to the stylesheet.

   3. Run xslt::save_result_file or xslt::save_result_string on the result and
      the stylesheet to save the transformed document in a file or a string.
      (You could also save the result using one of the XML output operations,
      but then some output-related information contained in the stylesheet
      might be lost.) */

namespace xslt;

private extern void xslt_free_stylesheet(void *p, expr *x) = free_stylesheet;

extern int xslt_stylesheetp(expr *x) = stylesheetp;

extern expr *xslt_load_stylesheet(expr *doc) = load_stylesheet;

extern expr *xslt_apply_stylesheet(expr *style, expr *doc, expr *params)
  = apply_stylesheet;

extern expr *xslt_save_result_file(char *name, expr *doc, expr *style,
				   int compression) = save_result_file;
extern expr *xslt_save_result_string(expr *doc, expr *style)
  = save_result_string;
