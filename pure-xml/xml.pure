
/* xml.pure: Basic XML/XSLT interface using libxml2 and libxslt. */

/* Copyright (c) 2009 by Albert Graef <Dr.Graef@t-online.de>.

   pure-xml is free software: you can redistribute it and/or modify it under
   the terms of the GNU Lesser General Public License as published by the Free
   Software Foundation, either version 3 of the License, or (at your option)
   any later version.

   pure-xml is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
   License for more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

using "lib:xml";

namespace xml;

// Sentries. These are for internal use only.
private extern void xml_free_doc(void *p, expr *x) = free_doc;
private extern void xml_free_node(void *p, expr *x) = free_node;

/* Manifest constants (parser flags). */

const xml::DTDLOAD  = 0x01; // load DTD
const xml::DTDVALID = 0x02; // validate
const xml::PEDANTIC = 0x04; // pedantic parse
const xml::SUBENT   = 0x08; // substitute entities
const xml::NOBLANKS = 0x10; // suppress blank nodes

/* ..

   Data Structure
   ==============

   This module represents XML documents using pointers to the ``xmlDoc`` and
   ``xmlNode`` structures provides by the libxml2 library. Similarly,
   stylesheets are simply pointers to the xmlStylesheet structure from libxslt
   (cf. Transformations_). This makes it possible to use these objects
   directly with the operations of the libxml2 and libsxslt libraries (via
   Pure's C interface) if necessary. Note, however, that these are all
   "cooked" pointers which take care of freeing themselves automatically when
   they are no longer needed, therefore you shouldn't free them manually.

   You can also check for these types of pointers using the following
   predicates:

   .. _docp:

   * ``xml::docp x`` checks whether ``x`` is an XML document pointer.

   .. _nodep:

   * ``xml::nodep x`` checks whether ``x`` is a pointer to a node in an XML
     document.

   .. _stylesheetp:

   * ``xslt::stylesheetp x`` checks whether ``x`` is an XSLT stylesheet
     pointer. */

extern int xml_docp(expr *x) = docp;
extern int xml_nodep(expr *x) = nodep;

/* ..

   The Document Tree
   -----------------

   An XML document is a rooted tree which can be created, traversed and
   manipulated using the operations of this module. There are different types
   of nodes in the tree, each carrying their own type of data. In Pure land,
   the node data is described using the following "node info" constructors.

   .. _node info:

   * ``xml::element tag ns attrs``

     An XML element with given (possibly qualified) name ``tag``, a (possibly
     empty) list of namespace declarations ``ns`` and a (possibly empty) list
     of attributes ``attrs``. Namespace declarations normally take the form of
     a pair of strings ``(prefix,href)``, where ``prefix`` is the prefix
     associated with the namespace and ``href`` the corresponding URI (the
     name of the namespace), but they can also be just a string ``href`` if
     the namespace prefix is missing. Attributes are encoded as ``key=>value``
     pairs, where ``key`` is the attribute name and ``value`` the associated
     value; both ``key`` and ``value`` are strings.

   * ``xml::element_text tag ns attrs content``

     A convenience function which denotes a combination of an element node
     with a text child. This is only used when creating a new node, and
     indicates that a text node child is to be added to the node
     automatically.

   * ``xml::attr key val``

     An attribute node. These only occur as results of the select_ and attrs_
     functions, and cannot be inserted directly into a document.

   * ``xml::text content``

     A text node with the given content (a string).

   * ``xml::cdata content``

     Like ``xml::text``, but contains unparsed character data.

   * ``xml::comment content``

     A comment.

   * ``xml::entity_ref name``

     An entity reference (``&name;``).

   * ``xml::pi name content``

     Processing instructions. ``name`` is the application name, ``content``
     the text of the processing instructions.

   Document Types
   --------------

   .. _dtd:

   Besides the node types described above, there are some additional node
   types used in the `document type definition`_ (DTD), which can be extracted
   from a document using the int_subset_ and ext_subset_ functions. These are
   for inspection purposes only; it is not possible to change the DTD of a
   document in-place. (However, you can create a new document and attach a DTD
   to it, using the new_doc_ function.)

   .. _document type definition: http://www.w3.org/TR/REC-xml/#dt-doctype

   * ``xml::doctype name extid``

     DTDs are represented using this special type of node, where ``name`` is
     the name of the root element, and ``extid`` is a pair consisting of the
     external identifier and the URI of the DTD (or just the URI if there is
     no external identifier). The ``xml::doctype`` node has as its children
     zero or more of the following kinds of DTD declaration nodes (these are
     just straightforward abstract syntax for the !ELEMENT, !ATTLIST and
     !ENTITY declarations inside a DTD declaration; see the XML specification
     for details).

   .. _element declaration:

   *Element declarations:* Here, ``name`` is the element tag and ``content``
   the definition of the element structure, see `element content`_ below. XML
   supports various kinds of element types, please refer to `document type
   definition`_ in the XML specification for details.

   * ``xml::undefined_element name``

     An undefined element. This is in libxml2, but not in the XML
     specification, you shouldn't see this in normal operation.

   * ``xml::empty_element name``

     An element without any content.

   * ``xml::any_element name``

     An element with unrestricted content.

   * ``xml::mixed_element name content``

     A "mixed" element which can contain character data, optionally
     interspersed with child elements, as given in the ``content``
     specification.

   * ``xml::std_element name content``

     A standard element consisting *only* of child elements, as given in the
     ``content`` specification.

   .. _attribute declaration:

   *Attribute declarations:* These are used to declare the attributes of an
   element. ``elem_name`` is the name of an element which describes the
   attribute type, ``name`` is the name of the attribute itself, and
   ``default`` specifies the default value of the attribute, see `attribute
   defaults`_ below. XML supports a bunch of different attribute types, please
   refer to `document type definition`_ in the XML specification for details.

   * ``xml::cdata_attr elem_name name default``
   * ``xml::id_attr elem_name name default``
   * ``xml::idref_attr elem_name name default``
   * ``xml::idrefs_attr elem_name name default``
   * ``xml::entity_attr elem_name name default``
   * ``xml::entities_attr elem_name name default``
   * ``xml::nmtoken_attr elem_name name default``
   * ``xml::nmtokens_attr elem_name name default``
   * ``xml::enum_attr elem_name name vals default``
   * ``xml::notation_attr elem_name name vals default``

   .. _entity declaration:

   *Entity declarations:* These are used for internal and external entity
   declarations. ``name`` is the entity name and ``content`` its
   definition. External entities also have an ``extid`` (external
   identifier/URI pair) identifying the entity.

   * ``xml::int_entity name content``
   * ``xml::int_param_entity name content``
   * ``xml::ext_entity name extid content``
   * ``xml::ext_param_entity name extid content``

*/

public
  // document nodes
  element element_text attr text cdata comment entity_ref pi

  // dtd nodes
  doctype

  // element declarations
  undefined_element empty_element any_element mixed_element std_element

  // attribute declarations
  cdata_attr id_attr idref_attr idrefs_attr entity_attr entities_attr
  nmtoken_attr nmtokens_attr enum_attr notation_attr

  // entity declarations
  int_entity int_param_entity ext_entity ext_param_entity;

/* .. _element content:

   The element content type (``content`` argument of the `element
   declaration`_ nodes) is a kind of regular expression formed with tags
   (specified as strings) and the following constructors:

   * ``xml::pcdata``: text data (``#PCDATA``)
   * ``xml::sequence xs``: concatenation (``x,y,z``)
   * ``xml::union xs``: alternatives (``x|y|z``)
   * ``xml::opt x``: optional element (``x?``)
   * ``xml::mult x``: repeated element (``x*``)
   * ``xml::plus x``: non-optional repeated element (``x+``)

*/

nonfix pcdata;
public sequence union opt mult plus;

/* .. _attribute defaults:

   Attribute defaults (the ``default`` argument of `attribute declaration`_
   nodes) are represented using the following constructor symbols:

   * ``xml::required``: a required attribute, i.e., the user must specify this
   * ``xml::implied``: an implied attribute, i.e., the user does not have to
     specify this
   * ``xml::default val``: an attribute with the given default value ``val``
   * ``xml::fixed val``: an attribute with the given fixed value ``val``

*/

nonfix required implied;
public default fixed;

/* Internal helper ops to construct element content types. */

private mksequence mkunion;

mksequence (sequence xs) (sequence ys)	= sequence (xs+ys);
mksequence (sequence xs) y		= sequence (xs+[y]);
mksequence x (sequence ys)		= sequence (x:ys);
mksequence x y				= sequence [x,y] otherwise;

mkunion (union xs) (union ys)		= union (xs+ys);
mkunion (union xs) y			= union (xs+[y]);
mkunion x (union ys)			= union (x:ys);
mkunion x y				= union [x,y] otherwise;

/* ..

   Operations
   ==========

   This module provides all operations necessary to create, inspect and
   manipulate XML documents residing either in memory or on disk. Operations
   for formatting XML documents using XSLT stylesheets are also available.

   Document Operations
   -------------------

   The following functions allow you to create new XML documents, load them
   from or save them to a file or a string, and provide general information
   about a document.

   .. _new_doc:

   * ``xml::new_doc version dtd info``

     This function creates an XML document. It returns a pointer to the new
     document. ``version`` is a string denoting the XML version (or ``""`` to
     indicate the default). ``info`` is the `node info`_ of the root node
     (which should denote an element node). ``dtd`` denotes the document type
     which can be ``()`` to denote an empty DTD, a string (the URI/filename of
     the DTD), or a pair ``(pubid,sysid)`` where ``pubid`` denotes the public
     identifier of the DTD and ``sysid`` its system identifier (URI).

     Note that only simple kinds of documents with an internal DTD can be
     created this way. Use the load_file_ or load_string_ function below to
     create a skeleton document if a more elaborate prolog is required. */

extern expr *xml_new_doc(char *version, expr *dtd, expr *info) = new_doc;

/* .. _load_file:
   .. _load_string:

   * ``xml::load_file name flags``, ``xml::load_string s flags``

     Load an XML document from a file ``name`` or a string ``s``. ``flags``
     denotes the parser flags, a bitwise disjunction of any of the following
     constants, or 0 for the default:

     - ``xml::DTDLOAD``: load DTD
     - ``xml::DTDVALID``: validate
     - ``xml::PEDANTIC``: pedantic parse
     - ``xml::SUBENT``: substitute entities
     - ``xml::NOBLANKS``: suppress blank nodes

     The return value is the document pointer. These operations may also fail
     if there is a fatal error parsing the document. */

extern expr *xml_load_file(char *name, int flags) = load_file;
extern expr *xml_load_string(char *s, int flags) = load_string;

/* .. _save_file:
   .. _save_string:

   * ``xml::save_file name doc encoding compression``,
     ``xml::save_string doc``

     Save an XML document ``doc`` to a file or a string. When saving to a
     file, ``encoding`` denotes the desired encoding (or ``""`` for the
     default), ``compression`` the desired level of zlib compression (0 means
     none, 9 is maximum, -1 indicates the default). Note that with
     ``xml::save_string``, the result is always encoded as UTF-8. */

extern expr *xml_save_file(char *name, expr *doc,
			   char *encoding, int compression) = save_file;
extern expr *xml_save_string(expr *doc) = save_string;

/* .. _doc_info:

   * ``xml::doc_info doc``

     Retrieve general information about a document. Returns a tuple
     ``(version,encoding,url,compression,standalone)``, where ``version`` is
     the XML version of the document, ``encoding`` the external encoding (if
     any), ``url`` the name/location of the document (if any), ``compression``
     the level of zlib compression, and ``standalone`` is a flag indicating
     whether the document contains any external markup declarations "which
     affect the information passed from the XML processor to the application",
     see the section on the `standalone document declaration`_ in the XML spec
     for details. (Apparently, in libxml2 ``standalone`` is either a truth
     value or one of the special values -1, indicating that there's no XML
     declaration in the prolog, or -2, indicating that there's an XML
     declaration but no ``standalone`` attribute.)

   .. _standalone document declaration: http://www.w3.org/TR/REC-xml/#sec-rmd

*/

extern expr *xml_doc_info(expr *doc) = doc_info;

/* .. _int_subset:
   .. _ext_subset:

   * ``xml::int_subset doc``, ``xml::ext_subset doc``

     Retrieve the internal and external DTD subset of a document. Returns a
     ``doctype`` node (fails if there's no corresponding DTD).

   **Example**

   Read the sample.xml document distributed with the sources (ignoring blank
   nodes) and retrieve the document info::

     > using xml;
     > let sample = xml::load_file "sample.xml" xml::NOBLANKS;
     > xml::doc_info sample;
     "1.0","","sample.xml",0,-2

*/

extern expr *xml_int_subset(expr *doc) = int_subset;
extern expr *xml_ext_subset(expr *doc) = ext_subset;

/* ..

   Traversing Documents
   --------------------

   These operations are used to traverse the document tree, i.e., the nodes of
   the document. They take either a document pointer ``doc`` or a node pointer
   ``node`` as argument, and yield a corresponding node pointer (or a document
   pointer, in the case of ``xml::doc``). The node pointers can then be used
   with the `Node Information`_ and `Node Manipulation`_ operations described
   below.

   .. _root:

   * ``xml::root doc``: the root node of ``doc``

   .. _doc:

   * ``xml::doc node``: the document ``node`` belongs to

   .. _parent:

   * ``xml::parent node``: the parent of ``node``

   .. _first:
   .. _last:

   * ``xml::first node``, ``xml::last node``: first and last child node

   .. _next:
   .. _prev:

   * ``xml::next node``, ``xml::prev node``: next and previous sibling

   .. _first_attr:
   .. _last_attr:

   * ``xml::first_attr node``, ``xml::last_attr node``: first and last
     attribute node
     
   All these operations fail if the corresponding target node does not exist,
   or if the type of the given node is not supported by this implementation. */

extern expr *xml_root(expr *doc) = root;
extern expr *xml_doc(expr *node) = doc;
extern expr *xml_parent(expr *node) = parent;
extern expr *xml_first(expr *node) = first;
extern expr *xml_last(expr *node) = last;
extern expr *xml_next(expr *node) = next;
extern expr *xml_prev(expr *node) = prev;
extern expr *xml_first_attr(expr *node) = first_attr;
extern expr *xml_last_attr(expr *node) = last_attr;

/* ..

   There are also two convenience functions to retrieve the children and
   attribute nodes of a node:

   .. _children:

   * ``xml::children node``: returns the list of all child nodes of ``node``

   .. _attrs:

   * ``xml::attrs node``: returns the list of all attribute nodes of ``node``

   Moreover, given a node pointer ``node``, ``node!i`` can be used to retrieve
   the ``i``\ th child of ``node``.

   **Example**

   Peek at the root node of the sample document and its children::

     > let r = xml::root sample; r;
     #<pointer 0xe15e10>
     > xml::node_info r;
     xml::element "story" [] []
     > #xml::children r;
     5
     > xml::node_info (r!0);
     xml::cdata "<greeting>Hello, world!</greeting>"

*/

public children attrs;

children node	= iterwhile nodep next (first node) if nodep node;
attrs node	= iterwhile nodep next (first_attr node) if nodep node;

node!i::int	= children node!i if nodep node;

/* ..

   Node Information
   ----------------

   These operations retrieve information about the nodes of an XML document.

   .. _select:

   * ``xml::select doc xpath``

     Retrieve nodes using an XPath_ specification. Given an XPath (a string)
     ``xpath``, this operation returns the list of all matching nodes in the
     given document ``doc``.

     .. _XPath: http://www.w3.org/TR/xpath */

extern expr *xml_select(expr *doc, expr *xpath) = select;

/* .. _node_info:

   * ``xml::node_info node``

     Retrieve the node data from ``node``. Returns a `node info`_ value, as
     described in `Data Structure`_ above. Fails if the node does not belong
     to one of the supported node types. */

extern expr *xml_node_info(expr *node) = node_info;

/* ..

   .. _is_blank_node:

   * ``xml::is_blank_node``

     Checks whether a node is a blank node (empty or whitespace only) and thus
     possibly ignorable.

   .. _node_base:

   * ``xml::node_base node``

     Returns the base URI of the given node.

   .. _node_path:

   * ``xml::node_path node``

     Returns the path of a node in the document, in the format accepted by
     select_.

   .. _node_content:

   * ``xml::node_content node``

     Returns the text carried by the node, if any (after entity substitution).

   In addition, you can retrieve and change attributes of element nodes with
   the following operations:

   .. _node_attr:

   * ``xml::node_attr node name``

     Retrieves the value of the attribute with the given ``name`` (after
     entity substitution).

   .. _set_node_attr:
   .. _unset_node_attr:

   * ``xml::set_node_attr node name value``, ``xml::unset_node_attr node name``

     Sets or unsets an attribute value.

   **Examples**

   Set and unset a node attribute::

     > xml::set_node_attr r "foo" "4711";
     ()
     > xml::node_info r;
     xml::element "story" [] ["foo"=>"4711"]
     > xml::node_attr r "foo";
     "4711"
     > xml::unset_node_attr r "foo";
     ()
     > xml::node_info r;
     xml::element "story" [] []

   The select_ function is *very* powerful, and probably the single most
   important operation of this module if you want to extract information from
   an existing XML document without traversing the entire structure. Here is a
   very simple example of its use::

     > [xml::node_content n, xml::node_path n | n = xml::select sample "//author"];
     [("John Fleck","/story/storyinfo/author")]

*/

extern expr *xml_is_blank_node(expr *node) = is_blank_node;
extern expr *xml_node_base(expr *node) = node_base;
extern expr *xml_node_path(expr *node) = node_path;
extern expr *xml_node_content(expr *node) = node_content;

extern expr *xml_node_attr(expr *node, expr *name) = node_attr;
extern expr *xml_set_node_attr(expr *node, expr *name, expr *val)
  = set_node_attr;
extern expr *xml_unset_node_attr(expr *node, expr *name) = unset_node_attr;

/* ..

   Node Manipulation
   -----------------

   These operations enable you to manipulate the document structure by adding
   a new node to the document tree (specified through its `node info`_), and
   by removing (unlinking) existing nodes from the tree.

   .. _replace:

   * ``xml::replace node info``

     Add the new node specified by ``info`` in place of the given node
     ``node``.

   .. _add_first:
   .. _add_last:

   * ``xml::add_first node info``, ``xml::add_last node info``

     Add the new node as the first or last child of ``node``, respectively.

   .. _add_next:
   .. _add_prev:

   * ``xml::add_next node info``, ``xml::add_prev node info``

     Add the new node as the next or previous sibling of ``node``,
     respectively.

   The operations above all return a pointer to the new XML node object. */

extern expr *xml_replace(expr *node, expr *info) = replace;
extern expr *xml_add_first(expr *node, expr *info) = add_first;
extern expr *xml_add_last(expr *node, expr *info) = add_last;
extern expr *xml_add_next(expr *node, expr *info) = add_next;
extern expr *xml_add_prev(expr *node, expr *info) = add_prev;

/* .. _unlink:

   * ``xml::unlink node``

     Deletes an existing node from the document tree. Returns ``()``.

   **Examples**

   Replace the first child of the root node in the sample document::

     > xml::node_info (r!0);
     xml::cdata "<greeting>Hello, world!</greeting>"
     > xml::replace (r!0) (xml::text "bla bla");
     #<pointer 0xd40d80>
     > xml::node_info (r!0);
     xml::text "bla bla"

   Delete that node::

     > xml::unlink (r!0);
     ()
     > xml::node_info (r!0);
     xml::comment "This is a sample document for testing the xml interface."

*/

extern expr *xml_unlink(expr *node) = unlink;

/* ..

   Transformations
   ---------------

   The following operations provide basic XSLT support. As already mentioned,
   stylesheets are represented as pointers to the xsltStylesheet structure
   provided by libxslt. Note that, in difference to XML document pointers,
   this is an opaque type, i.e., there is no direct means to inspect and
   manipulate parsed stylesheets in memory using the operations of this
   module. However, a stylesheet is just a special kind of XML document and
   thus can be manipulated after reading the stylesheet as an ordinary XML
   document. The load_stylesheet_ function then allows you to convert the
   document pointer to an XSLT Stylesheet object.

   Applying a stylesheet to an XML document generally involves the following
   steps:

   1. Load and parse the stylesheet using load_stylesheet_. The parameter to
      load_stylesheet_ can be either the name of a stylesheet file or a
      corresponding document pointer. The function returns a pointer to the
      stylesheet object which is used in the subsequent processing.

   2. Invoke apply_stylesheet_ on the stylesheet and the target document.
      This returns a new document containing the transformed XML document.

   3. Run save_result_file_ or save_result_string_ on the result and the
      stylesheet to save the transformed document in a file or a string.

   Here is a brief summary of the XSLT operations. Please check the XSLT_
   documentation for details of the transformation process.

   .. _load_stylesheet:

   * ``xslt::load_stylesheet x``

     Load a stylesheet. ``x`` can be either an XML document pointer, or a
     string denoting the desired ``.xsl`` file.

   .. _apply_stylesheet:

   * ``xslt::apply_stylesheet style doc params``

     Apply the stylesheet ``style`` to the given document ``doc`` with the
     given parameters ``params``. The third argument is a (possibly empty)
     list of ``key=>value`` string pairs which allows you to pass additional
     parameters to the stylesheet.

   .. _save_result_file:
   .. _save_result_string:

   * ``xslt::save_result_file name doc style compression``,
     ``xslt::save_result_string doc style``

     Save the transformation result ``doc`` obtained with the stylesheet
     ``style`` to a file or a string. This works pretty much like save_file_
     or save_string_, but also keeps track of some output-related information
     contained in the stylesheet.

   **Example**

   Load the recipes.xml document and the recipes.xsl stylesheet distributed
   with the sources::

     > let recipes = xml::load_file "recipes.xml" xml::DTDVALID;
     > let style = xslt::load_stylesheet "recipes.xsl";

   Apply the stylesheet to the document and save the result in a html file::

     > let res = xslt::apply_stylesheet style recipes [];
     > xslt::save_result_file "recipes.html" res style 0;
     ()

   That's all. You can now have a look at recipes.html in your favourite web
   browser. */

namespace xslt;

private extern void xslt_free_stylesheet(void *p, expr *x) = free_stylesheet;

extern int xslt_stylesheetp(expr *x) = stylesheetp;

extern expr *xslt_load_stylesheet(expr *doc) = load_stylesheet;

extern expr *xslt_apply_stylesheet(expr *style, expr *doc, expr *params)
  = apply_stylesheet;

extern expr *xslt_save_result_file(char *name, expr *doc, expr *style,
				   int compression) = save_result_file;
extern expr *xslt_save_result_string(expr *doc, expr *style)
  = save_result_string;

/* ..

   Index
   =====

   .. makeindex:: */
