/* pure-stlmap-funs.pure - dump "grouped" function signatures of functions
   provided by pure-stlmap.

   pure -x pure-stlmap-funs [x|d]

   d - csv data set
   x - csv cross-tabbed by module

   This is a throw-away script meant solely to be used for generating an
   overall summary of all the public functions in stlmap, stlmmap and
   stlhmap. Functions in stlvec are also included to help ensure that the
   function names used in pure-stlmap are consistent with those used in 
   pure-stlvec.

*/

using system, regex, stlvec, stlhmap, lib::textrec;

const fname_pos = 0;     // must be 0
const stlmap_pos = 1;
const stlmmap_pos = 2;
const stlhmap_pos = 3;
const stlvec_pos = 4;

/* Global Variables *****************************************************/

let crosstab_titles = 
  ["group_ord","group","generic_name","stlmap","stlmmap","stlhmap","stlvec"];

fun_group_list = 
[
  "(^)"=>"access",
  "(!)"=>"access",
  "(#)"=>"info",
  "(<)"=>"compare",
  "(<=)"=>"compare",
  "(==)"=>"compare",
  "(>)"=>"compare",
  "(>=)"=>"compare",
  "(~=)"=>"compare",
  "allpairs"=>"compare",
  "append"=>"modify",
  "bad_selfwrite"=>"x_internal",
  "begin"=>"iter",
  "beginp"=>"iter",
  "bounding_keys"=>"info",
  "bounds"=>"info",
  "bucket_size"=>"info",
  "capacity"=>"info",
  "catmap"=>"functional",
  "colcatmap"=>"functional",
  "colmap"=>"functional",
  "compatible"=>"x_internal",
  "compatible_ranges"=>"x_internal",
  "const_stlvec"=>"constructor",
  "container_info"=>"info",
  "count"=>"info",
  "dec"=>"iter",
  "distance"=>"info",
  "do"=>"functional",
  "empty"=>"info",
  "emptystlhmap"=>"constructor",
  "emptystlhset"=>"constructor",
  "emptystlmap"=>"constructor",
  "emptystlmmap"=>"constructor",
  "emptystlmset"=>"constructor",
  "emptystlset"=>"constructor",
  "emptystlvec"=>"constructor",
  "endp"=>"iter",
  "ensure_beg"=>"x_internal",
  "ensure_end"=>"x_internal",
  "erase"=>"modify",
  "filter"=>"functional",
  "find"=>"iter",
  "first"=>"access",
  "foldl"=>"functional",
  "foldl1"=>"functional",
  "foldr"=>"functional",
  "foldr1"=>"functional",
  "get"=>"access",
  "get_info"=>"iter",
  "get_key"=>"iter",
  "get_sv"=>"x_internal",
  "get_val"=>"iter",
  "hmap_reserve"=>"info",
  "inc"=>"iter",
  "insert"=>"modify",
  "insert_elm"=>"iter",
  "insert_or_replace"=>"modify",
  "iterator"=>"iter",
  "keys"=>"access",
  "l_bound"=>"iter",
  "last"=>"access",
  "list"=>"conversion",
  "listmap"=>"functional",
  "lu_bounds"=>"iter",
  "map"=>"functional",
  "map_difference"=>"set_operation",
  "map_equal"=>"compare",
  "map_includes"=>"set_operation",
  "map_intersection"=>"set_operation",
  "map_merge"=>"set_operation",
  "map_symmetric_difference"=>"set_operation",
  "map_union"=>"set_operation",
  "member"=>"info",
  "members"=>"conversion",
  "mkstlmap"=>"constructor",
  "mkstlmmap"=>"constructor",
  "mkstlmset"=>"constructor",
  "mkstlset"=>"constructor",
  "mkstlvec"=>"constructor",
  "move"=>"iter",
  "next_key"=>"info",
  "null"=>"info",
  "p_find"=>"x_temp",
  "p_member"=>"x_temp",
  "pastend"=>"iter",
  "prev_key"=>"info",
  "put"=>"iter",
  "range_info"=>"iter",
  "replace"=>"modify",
  "replace_with"=>"modify",
  "reserve"=>"info",
  "rmfirst"=>"modify",
  "rmlast"=>"modify",
  "rowcatmap"=>"functional",
  "rowmap"=>"functional",
  "stlhmap"=>"constructor",
  "stlhset"=>"constructor",
  "stlmap"=>"constructor",
  "stlmmap"=>"constructor",
  "stlmset"=>"constructor",
  "stlset"=>"constructor",
  "stlvec"=>"constructor",
  "stream"=>"functional",
  "swap"=>"modify",
  "u_bound"=>"iter",
  "update"=>"modify",
  "update_elm"=>"modify",
  "update_elm_with"=>"modify",
  "vals"=>"access",
  "vector"=>"conversion",
  "w_find"=>"x_temp",
  "w_member"=>"x_temp",
  "wrap"=>"x_temp"
];

let group_order_list =
[
 "constructor"=>1,
 "modify"=>2,
 "access"=>3,
 "conversion"=>4,
 "functional"=>5,
 "compare"=>6,
 "set_operation"=>7,
 "info"=>8,
 "iter"=>9,

 "x_internal"=>101,
 "x_temp"=>102
];

let group_order_map = stlhmap group_order_list;

let fun_group_map = stlhmap fun_group_list;

let non_functions = stlhset ["let","const","type","extern"];

let fun_sig_recs = emptystlhmap;

/* Functions *****************************************************************/

get_group fn = if member fun_group_map fn then fun_group_map!fn else "??";

parse_line modname line = res when
  is_comment = regex comment_pat REG_NOSUB line 0;
  ri = reg_info $ regex line_pat REG_EXTENDED line 0;
  ns_f_params =  drop 1 $ filter stringp (list ri);
  res = if ~is_comment && #ns_f_params == 3 then 
          get_row (modname:ns_f_params) 
        else [];
end with
  get_row x@[modname, ns, fname, params] = 
    if ~member non_functions fname then get_row_aux x else [];
  get_row_aux x@[modname, ns, fname, params] = res when
    ns, fname = if regex "^(::"  REG_NOSUB fname 0 then
                  "::", regsub (cst "(") "^(::" 0 fname 0
                else ns, fname;
    ns_prefix = if null ns then "stl::" else "";
    xparams = strip_type params;
    xparams = strip_at xparams;
    xparams = strip_STLVEC_3 xparams;
    xparams = strip_STLVEC_2 xparams;
    xparams = strip_STLVEC xparams;
    xparams = strip_CONST_STLVEC xparams;
    fsignature = ns_prefix + fname + xparams;
    res = [modname, fname, fsignature];
  end; 
  strip_type s = regsub sub_type qs_pat REG_EXTENDED s 0;
  strip_STLVEC s = regsub sub_sv sv_pat REG_EXTENDED s 0;
  strip_STLVEC_2 s = regsub sub_sv2 sv2_pat REG_EXTENDED s 0;
  strip_STLVEC_3 s = regsub sub_sv3 sv3_pat REG_EXTENDED s 0;
  strip_CONST_STLVEC s = regsub sub_csv csv_pat REG_EXTENDED s 0;
  strip_at s = regsub sub_at at_pat REG_EXTENDED s 0;
  sub_type info = head (drop 3 (list info));
  sub_sv x = "sv";
  sub_sv2 x = sprintf "(sv, %s)" (last (list x));
  sub_sv3 x = sprintf "(sv, %s, %s)" (head xs, last xs) when
    xs = drop 5 (list x); 
  end;
  sub_csv x = "csv";
  sub_at (_,_,_,x) = x;
end when
  comment_pat = "^\\s*//";
  line_pat = "^(::)?([^ ]+)([^=]*)=";
  qs_pat = "([^ :]+)::[^,) ]+";
  at_pat = "([[:alpha:]]+)@\\([^)]+\\)";
  sv_pat = "\\(STLVEC [^)]+\\)";
  sv2_pat = "\\(STLVEC ([^, ]+), ([^)]+)\\)";
  sv3_pat = "\\(STLVEC ([^, ]+), ([^, ]+), ([^)]+)\\)";
  csv_pat = "\\(CONST_STLVEC [[:alpha:]]+\\)";
end if stringp line;

parse_line modname line = [];

add_fun_info modname fp rows = loop rows with
  loop rows = fclose fp $$ rows if feof fp;
  loop rows = loop rows1 when
    row = parse_line modname (fgets fp);
    rows1 = if null row then rows else row:rows;
  end;
end;

get_fun_info_rows = rows when
  rows = add_fun_info "stlmap" (fopen "../stlmap.pure" "r") [];
  rows = add_fun_info "stlmmap" (fopen "../stlmmap.pure" "r") rows;
  rows = add_fun_info "stlhmap" (fopen "../stlhmap.pure" "r") rows;
  rows = add_fun_info "stlvec" (fopen "../../pure-stlvec/stlvec.pure" "r") rows;
end;

add_fsignature [modname, fname, fsignature] = () when
  rr, new = if member fun_sig_recs fname then fun_sig_recs!fname, false
            else stlvec {fname, [], [], [],  [], [], [], []}, true; 
  if new then insert fun_sig_recs (fname=>rr) else ();
  pos = case modname of
    "stlmap" = stlmap_pos;
    "stlmmap" = stlmmap_pos;
    "stlhmap" = stlhmap_pos;
    "stlvec" = stlvec_pos;
    _ = throw ("unrecognized module name: " + modname);
  end;
  replace rr pos (fsignature:(rr!pos));  
end;

add_fsignature _ = puts "bad row";

print_fun_sig_rec rec = pfsrs (has_multi_sigs mod_sigs) mod_sigs
with
  pfsrs n mod_sigs = () if  ~max_sigs mod_sigs;
  pfsrs n mod_sigs = pfsrs n1 (map tail_sigs mod_sigs) when
    n1 = if n then n+1 else n;
    xgroup = get_group fname;
    xgroup_ord = if member group_order_map xgroup then 
                   group_order_map!xgroup
                 else
                   "1000";
    xfname = if n then fname + "_" + str n else fname;
    xrec = xgroup_ord : xgroup : xfname : (map head_sigs mod_sigs);
    textrec::putrec ",\"" xrec;
  end;
  has_multi_sigs rec = max_sigs rec > 1;
  max_sigs mod_sigs = foldl (\mx sigs->max mx (#sigs)) 0 mod_sigs;
  head_sigs [] = "";
  head_sigs (x:xs) = x;
  tail_sigs [] = [];
  tail_sigs (x:xs) = xs;
end when
  fname = rec!fname_pos;
  mod_sigs = members (rec,1,stl::svend);
end;

print_cross_tab_info rows = () when
  textrec::putrec ",\"" crosstab_titles;
  do add_fsignature rows;
  do print_fun_sig_rec (vals fun_sig_recs);
end;

print_data rows = do put_row rows with
  put_row row@[modname, fname, fsignature] = () when
    xgroup = get_group fname;
    textrec::putrec ",\"" (xgroup:row);
  end;
end;

main fmt = () when
  rows = get_fun_info_rows;
  if fmt == "x" then print_cross_tab_info rows 
  else print_data rows;
end;

if compiling || argc == 0 then 
  () 
else 
  if argc == 2 then main (argv!1) 
  else puts "Usage: fun_info mode (x for crosstab, d for data)";


