/* time_dispatch.pure -- access times for stlhmap with different function
   signatures.

   Usage: > run time_dispatch.pure
          > main num_words_in_hash_table

  This requires that the DISPATCH_EXPERIMENT compilation flag is on in 
  in stlhmap.pure.

   A lookup is a sequence like "if member set x then set!x else ()". 

   There are five tests, one for each function signature used to call the
   underlying C functions: "fast", "plain", "wrapped", "w", "p", and "q". 
 
   The fast test calls the underlying C functions (stl::sh_member and
   stl::sth_val) directly with no type checking other than the "marshalling"
   check based on the pointer type.

   The plain test uses the Pure member and (!) functions. 

   The wrapped test uses versions of member and (!) specialized on (STLHMAP x)
   as opposed to the stlhmap type (a pointer tag). 

   The w test is the same as the wrapped test except that it uses a unique
   names, e.g., w_member instead of member.

   The p test is like the w test except that it uses the stlhmap
   type (a pointer tag) as opposed to a data type (STLHMAP x). 

   The q test is like the p test with no type checking at all (except for
   the marshalling check in sh_member and sh_val).

*/

using system, stlhmap, stlvec, stlvec::algorithms;
//using system, hashdict, stlhmap, stlvec, stlvec::algorithms;

const repeats = 10000;
const lookups = 100;

time_fast_stlhmap words keys = () when
  tm = clock;
  insert ss words;
  tm = (clock - tm) / 1000.0;
  // printf "fill      fast stlhmap: %8.1f msecs, %d words\n"  (tm,#ss);
  tm = clock;
  spin repeats;
  tm = (clock - tm) / 1000.0;
  printf "lookup    fast stlhmap: %8.1f msecs\n" tm;
  puts (get val);
end with
  spin 0 = ();
  spin n = lookup keys $ spin (n-1);
  lookup [] = ();
  lookup (k:ks) = stl::sh_member ss k $$ stl::sh_val ss k $$ lookup ks;
end when 
  ss = emptystlhset;
end;

time_plain_stlhmap words keys = () when
  tm = clock;
  insert ss words;
  tm = (clock - tm) / 1000.0;
  // printf "fill     plain stlhmap: %8.1f msecs, %d words\n"  (tm,#ss);
  tm = clock;
  spin repeats;
  tm = (clock - tm) / 1000.0;
  printf "lookup   plain stlhmap: %8.1f msecs\n" tm;
  puts (get val);
end with
  spin 0 = ();
  spin n = lookup keys $ spin (n-1);
  lookup [] = ();
  lookup (k:ks) = member ss k $$ ss!k $$ lookup ks;
end when 
  ss = emptystlhset;
end;

time_wrapped_stlhmap words keys = () when
  tm = clock;
  insert ss words;
  tm = (clock - tm) / 1000.0;
  // printf "fill   wrapped stlhmap: %8.1f msecs, %d words\n"  (tm,#ss);
  tm = clock;
  spin repeats;
  tm = (clock - tm) / 1000.0;
  printf "lookup wrapped stlhmap: %8.1f msecs\n" tm;
  puts (get val);
end with
  spin 0 = ();
  spin n = lookup keys $ spin (n-1);
  lookup [] = ();
  lookup (k:ks) = member wss k $$ wss!k $$ lookup ks;
end when 
  ss = emptystlhset;
  wss = wrap ss;
end;

time_w_stlhmap words keys = () when
  tm = clock;
  insert ss words;
  tm = (clock - tm) / 1000.0;
  // printf "fill         w stlhmap: %8.1f msecs, %d words\n"  (tm,#ss);
  tm = clock;
  spin repeats;
  tm = (clock - tm) / 1000.0;
  printf "lookup       w stlhmap: %8.1f msecs\n" tm;
  puts (get val);
end with
  spin 0 = ();
  spin n = lookup keys $ spin (n-1);
  lookup [] = ();
  lookup (k:ks) = w_member wss k $$ w_find wss k $$ lookup ks;
end when 
  ss = emptystlhset;
  wss = wrap ss;
end;

time_p_stlhmap words keys = () when
  tm = clock;
  insert ss words;
  tm = (clock - tm) / 1000.0;
  // printf "fill         p stlhmap: %8.1f msecs, %d words\n"  (tm,#ss);
  tm = clock;
  spin repeats;
  tm = (clock - tm) / 1000.0;
  printf "lookup       p stlhmap: %8.1f msecs\n" tm;
  puts (get val);
end with
  spin 0 = ();
  spin n = lookup keys $ spin (n-1);
  lookup [] = ();
  lookup (k:ks) = p_member ss k $$ p_find ss k $$ lookup ks;
end when 
  ss = emptystlhset;
end;

time_q_stlhmap words keys = () when
  tm = clock;
  insert ss words;
  tm = (clock - tm) / 1000.0;
  // printf "fill         q stlhmap: %8.1f msecs, %d words\n"  (tm,#ss);
  tm = clock;
  spin repeats;
  tm = (clock - tm) / 1000.0;
  printf "lookup       q stlhmap: %8.1f msecs\n" tm;
  puts (get val);
end with
  spin 0 = ();
  spin n = lookup keys $ spin (n-1);
  lookup [] = ();
  lookup (k:ks) = q_member ss k $$ q_find ss k $$ lookup ks;
end when 
  ss = emptystlhset;
  //wss = wrap ss;
end;


/*** Harness ********************************************************/

// returns a stlvec of shuffled words and a list of keys
get_words num_words filename = words, keys when
  fp = case fopen filename  "r" of 
    fopen _ _ = pointer 0;
    fp = fp;
  end;
  all_words = if null fp then
                puts "Can't open word file" $$ emptystlvec
              else
                stlvec $ drop 200 (split "\n" (fget fp));
  fclose fp;
  num_words = min (#all_words) num_words;
  num_keys = min num_words lookups; 
  stl::random_shuffle all_words;
  words = stlvec (all_words,stl::svbeg,num_words);
  allkeys = stlvec words;
  stl::random_shuffle allkeys;
  keys = members (allkeys,0,num_keys);
end;

main num_words = () when
  sep = "--------------------------------------";
  words, keys = get_words num_words "../examples/anagram_groups_dict.txt";
  num_words = min num_words (#words);
  printf "\nstlhmap dispatch comparisons %d lookups, %d repeats\n"
  (lookups,repeats);
  puts sep;
  time_fast_stlhmap words keys;
  time_plain_stlhmap words keys;
  time_wrapped_stlhmap words keys;
  time_w_stlhmap words keys;
  time_p_stlhmap words keys;
  time_q_stlhmap words keys;
end;
    
/* Sample **************************************************************

> main 100;

stlhmap dispatch comparisons 100 lookups, 10000 repeats
--------------------------------------
lookup    fast stlhmap:    550.0 msecs
lookup   plain stlhmap:   1560.0 msecs
--------------------------------------
lookup wrapped stlhmap:   1000.0 msecs
lookup       w stlhmap:   1000.0 msecs
lookup       p stlhmap:   1550.0 msecs
lookup       q stlhmap:    990.0 msecs

*/

/* Comment *************************************************************

     q vrs. fast shows the cost of an indirect call with no type checks.
 
     w vrs. q shows the (very low) cost of a (STLHMAP x) type check

     p vrs. q shows the (higher) cost of a x::stlhmap type check

     plain vrs. p shows the (very low) cost of using a overloaded name (! and
                  member) as opposed to not names. This might go up if the
                  names were overloaded by other modules.

     wrapped vrs. w shows the cost of using overloaded functions (! and
                  member) It is zero here, even though these are indeed
                  overloaded. Note that loading the hashdict module before
                  before the stlhmap module makes wrapped and plain much
                  slower. See below.

*/

/* Sample with hashdict loaded before stlhmap ******************************


stlhmap dispatch comparisons 100 lookups, 10000 repeats
--------------------------------------
lookup    fast stlhmap:    550.0 msecs
lookup   plain stlhmap:   2800.0 msecs
lookup wrapped stlhmap:   2630.0 msecs
lookup       w stlhmap:   1000.0 msecs
lookup       p stlhmap:   1540.0 msecs
lookup       q stlhmap:    990.0 msecs

*/
