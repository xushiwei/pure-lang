/* stlhmap.pure: Pure interface to C++ STL unordered_map
    
--- DRAFT - FOR DISCUSSON PURPOSES ONLY ---

Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stlmap, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stlmap distribution package for details.

*/
 
using stlbase;
using "lib:stlassoc";

namespace stl;

/*** C++ support ***********************************************************/

private extern expr* sh_type_tags();
private extern expr* sh_make_empty(int ko);
private extern expr* sh_copy(expr* pxshp);
private extern void  sh_delete(void* shmapp);
private extern void  sh_reserve(expr* pxshp, double mlf, int size);
private extern expr* sh_info(expr* pxshp);
private extern int   sh_bucket_size(expr* pxshp, int bucket_pos);
private extern int   sh_size(expr* pxshp);
private extern bool  sh_empty(expr* pxshp);
private extern int   sh_equal(expr* pxshp1, expr* pxshp2);
private extern int   sh_count(expr* pxshp, expr* key);
private extern expr* sh_find(expr* pxshp, expr* key, int what);
private extern int   sh_insert(expr* pxshp, expr* src, bool replace);
private extern expr* sh_insert_stlhmap(expr* pxshp, bool replace);
private extern int   sh_insert_stlvec(expr* map, void* svp, bool replace);
private extern expr* sh_replace(expr* pxshp, expr* key, expr* val);
private extern void  sh_swap(expr* pxshp1, expr* pxshp2);
private extern int   sh_erase(expr* pxshp, expr* key);
private extern int   sh_clear(expr* pxshp);
private extern expr* sh_make_vector(expr* pxshp);
private extern void* sh_fill_stlvec(expr* rng, void* v);
private extern expr* sh_listmap(expr* fun, expr* pxshp, int what);
private extern expr* sh_listcatmap(expr* fun, expr* pxshp, int what);
private extern expr* sh_foldl(expr* fun, expr* val, expr* pxshp);
private extern expr* sh_foldl1(expr* fun, expr* pxshp);
private extern void  sh_do(expr* fun, expr* pxshp);

extern bool  sh_is_set(expr* pxshp) = setp;
extern int   sh_member(stlhmap* pmap, expr* key) = sh_member;
extern expr* sh_find_val(stlhmap* pmap, expr* key) = sh_val;

let stlhmap_t = stl::sh_type_tags;

/*** Global Definitions **************************************************/

namespace ;

public emptystlhmap emptystlhset members erase insert_or_replace replace;

type stlhmap x::pointer = check_ptrtag stl::stlhmap_t x;
type stlhset x::pointer = check_ptrtag stl::stlhmap_t x && stl::setp x;

namespace stl;

// /*** Experiment *********************************************************/

namespace ;

nonfix STLHMAP;

wrap x = STLHMAP x;

(!) (STLHMAP hm) key = stl::sh_val hm key;

member (STLHMAP hm) key = stl::sh_member hm key;

w_find (STLHMAP hm) key = stl::sh_val hm key;

w_member (STLHMAP hm) key = stl::sh_member hm key;

p_find hm::stlhmap key = stl::sh_val hm key;

p_member hm::stlhmap key = stl::sh_member hm key;

q_find hm key = stl::sh_val hm key;

q_member hm key = stl::sh_member hm key;

namespace stl;

// /*** End experiment

/*** Helpers **************************************************************/

private sh_key_flg sh_val_flg sh_elm_flg sh_compatible;

const sh_key_flg = 1;
const sh_val_flg = 2;
const sh_elm_flg = 3;

sh_compatible hm1 hm2 = if setp hm1 then setp hm2 else ~setp hm2; 

/***  Constructors *********************************************************/

::emptystlhmap = sh_make_empty 0;

::stlhmap xs = hm when
  hm = ::emptystlhmap;
  sh_insert hm xs 0;
end if listp xs || matrixp xs;

::stlhmap (STLVEC svp) = hm when
  hm = ::emptystlhmap;
  sh_insert_stlvec hm svp 0;
end;

::stlhmap hm::stlhmap = sh_copy hm if ~setp hm;

::emptystlhset = sh_make_empty 1;

::stlhset xs = hs when
  hs = ::emptystlhset;
  sh_insert hs xs 0;
end if listp xs || matrixp xs;

::stlhset (STLVEC svp) = hs when
  hs = ::emptystlhset;
  sh_insert_stlvec hs svp 0;
end;

::stlhset hm::stlhset = sh_copy hm;

hmap_reserve hm::stlhmap mlf::double size::int = sh_reserve hm mlf size;

/*** Info ***************************************************************/

(::#) hm::stlhmap = sh_size hm;

empty hm::stlhmap = sh_empty hm;

container_info hm::stlhmap = sh_info hm;

bucket_size hm::stlhmap i::int = sh_bucket_size hm i;

count hm::stlhmap key = sh_count hm key;

::member hm::stlhmap key = sh_member hm key;

/*** Access *************************************************************/

(::!) hm::stlhmap key = sh_val hm key;

::get (hm::stlhmap,key) = sh_find hm key sh_elm_flg; 

::members hm::stlhmap = sh_listmap 0 hm sh_elm_flg;

::keys hm::stlhmap = sh_listmap 0 hm sh_key_flg;

::vals hm::stlhmap = sh_listmap 0 hm sh_val_flg;

vector hm::stlhmap = sh_make_vector hm;

::stlvec hm::stlhmap = sv if ok when
  sv = emptystlvec;
  ok = case sv of  
    STLVEC v = sh_fill_stlvec hm v $$ 1;
    _ = 0;
  end;
end;

/*** Modifiers *********************************************************/

::insert hm::stlhmap (STLVEC svp) = sh_insert_stlvec hm svp 0;

::insert hm::stlhmap src::stlhmap = 
  sh_insert_stlhmap hm src 0 if sh_compatible hm src;

::insert hm::stlhmap src = sh_insert hm src 0;

::insert_or_replace hm::stlhmap (STLVEC svp) = 
  sh_insert_stlvec hm svp 1 if ~setp hm;

::insert_or_replace hm::stlhmap src::stlhmap = 
  sh_insert_stlhmap hm src 1 if ~setp hm && ~setp src;

::insert_or_replace hm::stlhmap src = sh_insert hm src 1 if ~setp hm;

::replace hm::stlhmap key val = sh_replace hm key val;

::erase hm::stlhmap = sh_clear hm;

::erase (hm::stlhmap,key) = sh_erase hm key;

swap hm1::stlhmap hm2::stlhmap = sh_swap hm1 hm2 if sh_compatible hm1 hm2;

/*** Equality **********************************************************/

(::==) hm1::stlhmap hm2::stlhmap = sh_equal hm1 hm2 if sh_compatible hm1 hm2;

(::~=) hm1::stlhmap hm2::stlhmap = ~sh_equal hm1 hm2 if sh_compatible hm1 hm2;

/*** Mapping and Folding ************************************************/

::map f hm::stlhmap = sh_listmap f hm sh_elm_flg;

::foldl f x hm::stlhmap = sh_foldl f x hm;

::foldl1 f hm::stlhmap = sh_foldl1 f hm;

::do f hm::stlhmap = sh_do f hm;

::filter p hm::stlhmap = sh_listcatmap f hm sh_elm_flg with
  f x = res when
    res = case p x of
      1 = [x];
      0 = [];
      y = throw failed_cond;
    end;
  end;
end;

::listmap f hm::stlhmap = sh_listmap f hm sh_elm_flg;

::catmap f hm::stlhmap = sh_listcatmap f hm sh_elm_flg;

::rowmap f hm::stlhmap = rowcat (sh_listmap f hm sh_elm_flg);

::rowcatmap f hm::stlhmap = rowcat (sh_listmap f hm sh_elm_flg);

::colmap f hm::stlhmap = colcat (sh_listmap f hm sh_elm_flg);

::colcatmap f hm::stlhmap = colcat (sh_listmap f hm sh_elm_flg);

