/* stlhmap.pure: Pure interface to C++ STL hmap
    
--- DRAFT - FOR DISCUSSON PURPOSES ONLY ---

Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stlmap, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stlmap distribution package for details.

*/
 
using stlbase;
using "lib:stlhmap";

namespace stl;

/*** C++ support **********************************************************/

extern expr* shm_type_tags();
private extern expr* shm_make_empty(expr* hash, expr* eql,
                                    expr* default_val, int ko);
private extern expr* shm_copy(expr* pxshmp);
private extern void  shm_delete(void* shmp);
private extern void  shm_reserve(expr* shmp, double mlf, int size);
private extern expr* shm_hash_info(expr* shmp);

private extern int   shm_size(expr* shmp);
private extern int   shm_count(expr* pxshmp, expr* key);
private extern bool  shm_empty(expr* shmp);
private extern bool  shm_is_set(expr* shmp);
private extern expr* shm_find(expr* pxshmp, expr* key, int what);

extern expr* shm_copy_iter(expr* pxshmip);
extern expr* shm_begin(expr* pxshmp);
extern expr* shm_end(expr* pxshmp); 
extern expr* shm_get_elm_at_inc(expr* pxshmip);
private extern expr* shm_equal_iter(expr* pxshmip1, expr* pxshmip2);

private extern expr* shm_insert_elm(expr* pxshmp, expr* kv);
private extern int   shm_insert_elms_xs(expr* pxshmp, expr* src);
private extern int   shm_insert_elms_stlvec(expr* pxshmp, expr* svrng);
private extern void  shm_swap(expr* pxshmp1, expr* pxshmp2);
private extern int   shm_erase(expr* pxshmp, expr* key);
private extern int   shm_clear(expr* pxshmp);

private extern int   shm_equal(expr* shmp1, expr* shmp2);

private extern expr* shm_make_vector(expr* shmp);
private extern void* shm_fill_stlvec(expr* shmp, void* v);

private extern expr* shm_listmap(expr* fun, expr* shmp, int what);
private extern expr* shm_listcatmap(expr* fun, expr* shmp, int what);
private extern expr* shm_foldl(expr* fun, expr* val, expr* shmp);
private extern expr* shm_foldl1(expr* fun, expr* shmp);

private extern int   shm_member(expr* pxshmp, expr* key);
private extern expr* shm_update(expr* pxshmp, expr* key, expr* val);
private extern expr* shm_update_with(expr* pxshmp, expr* key, expr* unaryfun);

extern void stl_set_shm_trace(bool enable) = set_shm_trace;
extern bool stl_shm_trace_enabled() = shm_trace_enabled;

/*** global type definitions ********************************************/

namespace ;

let stlhmap_t, stlhmap_iter_t, stlhset_t, stlhset_iter_t = stl::shm_type_tags;

type stlhmap x = check_ptrtag stlhmap_t x;
type stlhset x = check_ptrtag stlhset_t x;
type stlhac x::stlhmap | stlhac x::stlhset;

stlhmapp x = check_ptrtag stlhmap_t x;
stlhsetp x = check_ptrtag stlhset_t x;
stlhacp x = stlhmapp x || stlhsetp x;

stlhac_range_p x = case x of x::shmrng = 1; x = 0 end; 

namespace stl;

/*** Helpers **************************************************************/

private 
  shm_update_with
  shm_iter shm_key shm_val shm_elm 
  shm_wrap_sv shm_less shm_equal compatible_ranges lazy_map_aux;

const shm_key = 1;
const shm_val = 2;
const shm_elm = 3;
const shm_iter = 4;
const shm_iter_dflt = 5;

const shm_at_beginning = 1;
const shm_at_pastend = 2;

compatible_ranges shm1 shm2 = 
  if shm_is_set shm1 then shm_is_set shm2 else ~shm_is_set shm2;

// function of k=>v
lazy_map_aux fun first last = gen first with
  gen i = if shm_equal_iter i last then [] 
          else fun (shm_get_elm_at_inc i):(gen i &);
end;

lazy_elms_aux first last = gen first with
  gen i = if shm_equal_iter i last then [] 
          else shm_get_elm_at_inc i : (gen i &);
end;

/***  Constructors *********************************************************/

emptystlhmap ()                = shm_make_empty hash (==) [] 0;
emptystlhmap (khash,keql,dflt) = shm_make_empty khash keql dflt 0;
emptystlhmap (khash,keql)      = shm_make_empty khash keql [] 0;
emptystlhmap  khash            = shm_make_empty khash (==) []  0;

stlhmap xs = shm when
  shm = emptystlhmap hash;
  shm_insert_elms_xs shm xs;
end if listp xs || matrixp xs;

stlhmap rng::svrng = shm when
  shm = emptystlhmap hash;
  shm_insert_elms_stlvec shm rng;
end;

stlhset hm::stlhmap = shm_copy hm;

emptystlhset ()                   = shm_make_empty hash (==) [] 1;
emptystlhset (khash,keql)         = shm_make_empty khash keql [] 1;
emptystlhset  khash               = shm_make_empty khash (==) [] 1;

stlhset xs = ss when
  ss = emptystlhset ();
  shm_insert_elms_xs ss xs;
end if listp xs || matrixp xs;

stlhset rng::svrng = ss when
  ss = emptystlhset ();
  shm_insert_elms_stlvec ss rng;
end;

stlhset hs::stlhset = shm_copy hs;

reserve shm::stlhac mlf::double size::int = shm_reserve shm mlf size;

/*** Range Content ****************************************************/

lazy_map f shm::stlhac = lazy_map_aux f first last when 
  first = shm_copy_iter $ shm_begin shm;
  last = shm_end shm;
end;

lazy_elms shm::stlhac = lazy_elms_aux first last when 
  first = shm_copy_iter $ shm_begin shm;
  last = shm_end shm;
end;

lazy_keys shm::stlhac = lazy_map (\(k=>v)->k) shm if ~shm_is_set shm;

lazy_keys shm::stlhac = lazy_elms shm;

lazy_vals shm::stlhac = lazy_map (\(k=>v)->v) shm if ~shm_is_set shm;

lazy_vals shm::stlhac = lazy_elms shm;

elms shm::stlhac = shm_listmap 0 shm shm_elm;

keys shm::stlhac = shm_listmap 0 shm shm_key;// if ~shm_is_set shm;

vals shm::stlhac = shm_listmap 0 shm shm_val;// if ~shm_is_set shm;

vector shm::stlhac = shm_make_vector shm;

stlvec shm::stlhac = sv if ok when
  sv = emptystlvec;
  ok = case sv of  
    STLVEC v = shm_fill_stlvec shm v $$ 1;
    _ = 0;
  end;
end;

/*** Info ***************************************************************/

(::#) shm::stlhac = shm_size shm;

size shm::stlhac = shm_size shm;

empty shm::stlhac = shm_empty shm;

is_set shm::stlhac = shm_is_set shm;

count shm::stlhac key = shm_count shm key;

hash_info shm::stlhac = shm_hash_info shm;

/*** Modifiers *********************************************************/

insert shm::stlhac xs::list = shm_insert_elms_xs shm xs;

insert shm::stlhac xs::matrix = shm_insert_elms_xs shm xs;

insert shm::stlhac svr::svrng = shm_insert_elms_stlvec shm svr;

insert shm::stlhmap val@(k=>v) = shm_insert_elm shm val;

insert shm::stlhset key = shm_insert_elm shm key;

insert_elm shm::stlhset key = shm_insert_elm shm key; // to get xs, etc into set

clear shm::stlhac = shm_clear shm;

erase shm::stlhac key = shm_erase shm key;

swap shm1::stlhmap shm2::stlhmap = shm_swap shm1 shm2;

swap ss1::stlhset ss2::stlhset = shm_swap ss1 ss2;

/*** Equality and Lexicographical Comparison ***************************/

equal shm1::stlhac shm2::stlhac = shm_equal shm1 shm2
  if compatible_ranges shm1 shm2;

(::==) hac1::stlhac hac2::stlhac = shm_equal hac1 hac2
  if compatible_ranges hac1 hac2;

(::~=) hac1::stlhac hac2::stlhac = ~shm_equal hac1 hac2
  if compatible_ranges hac1 hac2;

/*** Mapping and Folding ********************************************/

::map f shm::stlhac = shm_listmap f shm shm_elm; // => shm_key for sets

::foldl f x shm::stlhac = shm_foldl f x shm;

::foldl1 f shm::stlhac = shm_foldl1 f shm;

::do f shm::stlhac = shm_foldl (\_ x->f x) () shm $$ ();

// ::filter p shm::stlhac = shm_foldl f [] shm with
//   f x xs = res when
//     res = case p x of
//       1 = x:xs;
//       0 = xs;
//       y = throw failed_cond;
//     end;
//   end;
// end;

::listmap f shm::stlhac = shm_listmap f shm shm_elm;

::catmap f shm::stlhac = shm_listcatmap f shm shm_elm;

/*** Vector functions ****************************************************/

::rowmap f shm::stlhac = rowcat (shm_listmap f shm shm_elm);

::rowcatmap f shm::stlhac = rowcat (shm_listmap f shm shm_elm);

::colmap f shm::stlhac = colcat (shm_listmap f shm shm_elm);

::colcatmap f shm::stlhac = colcat (shm_listmap f shm shm_elm);

/*** Key oriented interface functions *********************************/

(::!) shm::stlhac key = shm_find shm key shm_val;

has_key shm::stlhac key = shm_member shm key;

update shm::stlhmap k v = shm_update shm k v $$ shm;

update_elm shm::stlhmap (k=>v) = shm_update shm k v $$ shm;

update_with f shm::stlhmap key x = shm_update_with shm key (f x) $$ shm;

