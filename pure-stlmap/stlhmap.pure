/* stlhmap.pure: Pure interface to C++ STL unordered_map
    
--- DRAFT - FOR DISCUSSON PURPOSES ONLY ---

Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stlmap, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stlmap distribution package for details.

*/
 
using stlbase;
using "lib:stlhmap";

namespace stl;

/*** C++ support **********************************************************/

extern expr* shm_type_tags();
private extern expr* shm_make_empty(expr* hash, expr* keql, expr* veql, int ko);
private extern expr* shm_copy(expr* pxshmp);
private extern void  shm_delete(void* shmp);
private extern void  shm_reserve(expr* shmp, double mlf, int size);
private extern expr* shm_hash_info(expr* shmp);
private extern expr* shm_begin(expr* pxshmp);
private extern expr* shm_end(expr* pxshmp); 
private extern expr* shm_get_elm_at_inc(expr* pxshmip);
private extern expr* shm_equal_iter(expr* pxshmip1, expr* pxshmip2);
private extern int   shm_size(expr* shmp);
private extern bool  shm_empty(expr* shmp);
private extern bool  shm_is_set(expr* shmp);
private extern int   shm_equal(expr* shmp1, expr* shmp2);
private extern int   shm_count(expr* pxshmp, expr* key);
private extern int   shm_member(expr* pxshmp, expr* key);
private extern expr* shm_find(expr* pxshmp, expr* key, int what);
private extern expr* shm_insert_elm(expr* pxshmp, expr* kv);
private extern int   shm_insert_elms_xs(expr* pxshmp, expr* src);
private extern int   shm_insert_elms_stlvec(expr* pxshmp, expr* svrng);
private extern expr* shm_update(expr* pxshmp, expr* key, expr* val);
private extern void  shm_swap(expr* pxshmp1, expr* pxshmp2);
private extern int   shm_erase(expr* pxshmp, expr* key);
private extern int   shm_clear(expr* pxshmp);
private extern expr* shm_make_vector(expr* shmp);
private extern void* shm_fill_stlvec(expr* shmp, void* v);
private extern expr* shm_listmap(expr* fun, expr* shmp, int what);
private extern expr* shm_listcatmap(expr* fun, expr* shmp, int what);
private extern expr* shm_foldl(expr* fun, expr* val, expr* shmp);
private extern expr* shm_foldl1(expr* fun, expr* shmp);

/*** global type definitions ********************************************/

namespace ;

let stlhmap_t, stlhmap_iter_t, stlhset_t, stlhset_iter_t = stl::shm_type_tags;

type stlhmap x = check_ptrtag stlhmap_t x;        //hash map
type stlhset x = check_ptrtag stlhset_t x;        //hash set     
type stlhacon x::stlhmap | stlhacon x::stlhset;   //hash associative container

namespace stl;

/*** Helpers **************************************************************/

private shm_key shm_val shm_elm shm_equal compatible_ranges;

const shm_key = 1;
const shm_val = 2;
const shm_elm = 3;

/***  Constructors *********************************************************/

emptystlhmap                = shm_make_empty hash (==) (==) 0;

mkstlhmap (khash,keql,veql) = shm_make_empty khash keql veql 0;
mkstlhmap (khash,keql)      = shm_make_empty khash keql (==) 0;
mkstlhmap  khash            = shm_make_empty khash (==) (==) 0;

stlhmap xs = shm when
  shm = emptystlhmap;
  shm_insert_elms_xs shm xs;
end if listp xs || matrixp xs;

stlhmap rng::svrng = shm when
  shm = emptystlhmap;
  shm_insert_elms_stlvec shm rng;
end;

stlhmap shm::stlhmap = shm_copy shm;

emptystlhset                   = shm_make_empty hash (==) (==) 1;

mkstlhset (khash,keql,veql)    = shm_make_empty khash keql veql 1;
mkstlhset (khash,keql)         = shm_make_empty khash keql (==) 1;
mkstlhset  khash               = shm_make_empty khash (==) 1;

stlhset xs = ss when
  ss = emptystlhset;
  shm_insert_elms_xs ss xs;
end if listp xs || matrixp xs;

stlhset rng::svrng = ss when
  ss = emptystlhset;
  shm_insert_elms_stlvec ss rng;
end;

stlhset shs::stlhset = shm_copy shs;

hash_reserve shm::stlhacon mlf::double size::int = shm_reserve shm mlf size;

/*** Info ***************************************************************/

(::#) shm::stlhacon = shm_size shm;

empty shm::stlhacon = shm_empty shm;

container_info shm::stlhacon = shm_hash_info shm;

count shm::stlhacon key = shm_count shm key;

has_key shm::stlhacon key = shm_member shm key;

distance shm::stlhacon = shm_size shm;

/*** Access *************************************************************/

(::!) shm::stlhacon key = shm_find shm key shm_val;

get (shm::stlhacon,key) = shm_find shm key shm_elm;

stream shm::stlhacon = gen first with
  gen i = if shm_equal_iter i last then [] 
          else shm_get_elm_at_inc i : (gen i &);
end when 
  first = shm_begin shm;
  last = shm_end shm;
end;

elms shm::stlhacon = shm_listmap 0 shm shm_elm;

keys shm::stlhacon = shm_listmap 0 shm shm_key;

vals shm::stlhacon = shm_listmap 0 shm shm_val;

vector shm::stlhacon = shm_make_vector shm;

stlvec shm::stlhacon = sv if ok when
  sv = emptystlvec;
  ok = case sv of  
    STLVEC v = shm_fill_stlvec shm v $$ 1;
    _ = 0;
  end;
end;

/*** Modifiers *********************************************************/

put (shm::stlhmap,key) v = shm_update shm key v;

insert shm::stlhacon xs::list = shm_insert_elms_xs shm xs;

insert shm::stlhacon xs::matrix = shm_insert_elms_xs shm xs;

insert shm::stlhacon svr::svrng = shm_insert_elms_stlvec shm svr;

insert shm::stlhacon val@(k=>v) = shm_insert_elm shm val;

insert_or_update shm::stlhmap (k=>v) = shm_update shm k v $$ shm;

insert_or_update shm::stlhset k = shm_insert_elm shm k $$ shm;

insert_or_update_key_val shm::stlhmap k v = shm_update shm k v;

insert shm::stlhset elm = shm_insert_elm shm elm; 

erase shm::stlhacon = shm_clear shm;

erase (shm::stlhacon,key) = shm_erase shm key;

swap shm1::stlhmap shm2::stlhmap = shm_swap shm1 shm2;

swap ss1::stlhset ss2::stlhset = shm_swap ss1 ss2;

/*** Equality **********************************************************/

(::==) hac1::stlhmap hac2::stlhmap = shm_equal hac1 hac2;

(::==) hac1::stlhset hac2::stlhset = shm_equal hac1 hac2;

(::~=) hac1::stlhmap hac2::stlhmap = ~shm_equal hac1 hac2;

(::~=) hac1::stlhset hac2::stlhset = ~shm_equal hac1 hac2;

/*** Mapping and Folding ***********************************************/

::map f shm::stlhacon = shm_listmap f shm shm_elm;

::foldl f x shm::stlhacon = shm_foldl f x shm;

::foldl1 f shm::stlhacon = shm_foldl1 f shm;

::do f shm::stlhacon = shm_foldl (\_ x->f x) () shm $$ ();

::listmap f shm::stlhacon = shm_listmap f shm shm_elm;

::catmap f shm::stlhacon = shm_listcatmap f shm shm_elm;

::rowmap f shm::stlhacon = rowcat (shm_listmap f shm shm_elm);

::rowcatmap f shm::stlhacon = rowcat (shm_listmap f shm shm_elm);

::colmap f shm::stlhacon = colcat (shm_listmap f shm shm_elm);

::colcatmap f shm::stlhacon = colcat (shm_listmap f shm shm_elm);

