/* stlhmap.pure: Pure interface to C++ STL hmap
    
--- DRAFT - FOR DISCUSSON PURPOSES ONLY ---

Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stlmap, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stlmap distribution package for details.

*/
 
using stlbase;
using "lib:stlhmap";

namespace stl;

/*** C++ support **********************************************************/

extern expr* shm_type_tags();
private extern expr* shm_make_empty(expr* hash, expr* eql,
                                    expr* default_val, int ko);
private extern void  shm_delete(void* shmp);
private extern expr* shm_parameters(expr* shmp);
private extern int   shm_size(expr* shmp);
private extern int   shm_count(expr* pxshmp, expr* key);
private extern bool  shm_empty(expr* shmp);
private extern bool  shm_is_set(expr* shmp);
private extern expr* shm_find(expr* pxshmp, expr* key, int what);

extern expr* shm_copy_iter(expr* pxshmip);
extern expr* shm_begin(expr* pxshmp);
extern expr* shm_end(expr* pxshmp); 
extern expr* shm_get_elm_at_inc(expr* pxshmip);
private extern expr* shm_equal_iter(expr* pxshmip1, expr* pxshmip2);

private extern expr* shm_insert_elm(expr* hmap, expr* kv);
private extern int   shm_insert_elms_xs(expr* hmap, expr* src);
private extern int   shm_insert_elms_stlvec(expr* hmap, expr* svrng);
private extern int   shm_insert_elms_stlhmap(expr* hmap, expr* shmp);
private extern void  shm_swap(expr* hac1, expr* hac2);
private extern int   shm_erase(expr* hac, expr* key);
private extern int   shm_clear(expr* hmap);

private extern int   shm_equal(expr* shmp1, expr* shmp2);

private extern expr* shm_make_vector(expr* shmp);
private extern void* shm_fill_stlvec(expr* shmp, void* v);

private extern expr* shm_listmap(expr* fun, expr* shmp, int what);
private extern expr* shm_listcatmap(expr* fun, expr* shmp, int what);
private extern expr* shm_foldl(expr* fun, expr* val, expr* shmp);
private extern expr* shm_foldl1(expr* fun, expr* shmp);

private extern int   shm_member(expr* hmap, expr* key);
private extern expr* shm_update(expr* hmap, expr* key, expr* val);
private extern expr* shm_update_with(expr* hmap, expr* key, expr* unaryfun);

extern void stl_set_shm_trace(bool enable) = set_shm_trace;
extern bool stl_shm_trace_enabled() = shm_trace_enabled;

/*** global type definitions ********************************************/

namespace ;

let stlhmap_t, stlhmap_iter_t, stlhset_t, stlhset_iter_t = stl::shm_type_tags;

type stlhmap x = check_ptrtag stlhmap_t x;
type stlhset x = check_ptrtag stlhset_t x;
type stlhac x::stlhmap | stlhac x::stlhset;

stlhmapp x = check_ptrtag stlhmap_t x;
stlhsetp x = check_ptrtag stlhset_t x;
stlhacp x = stlhmapp x || stlhsetp x;

stlhac_range_p x = case x of x::shmrng = 1; x = 0 end; 

namespace stl;

/*** Helpers **************************************************************/

private 
  shm_update_with
  shm_iter shm_key shm_val shm_elm 
  shm_wrap_sv shm_less shm_equal shm_compatible_ranges lazy_map_aux;

const shm_key = 1;
const shm_val = 2;
const shm_elm = 3;
const shm_iter = 4;
const shm_iter_dflt = 5;

const shm_at_beginning = 1;
const shm_at_pastend = 2;

compatible_ranges shm1 shm2 = 
  if shm_is_set shm1 then shm_is_set shm2 else ~shm_is_set shm2;

// function of k=>v
lazy_map_aux fun first last = gen first with
  gen i = if shm_equal_iter i last then [] 
          else fun (shm_get_elm_at_inc i):(gen i &);
end;

lazy_elms_aux first last = gen first with
  gen i = if shm_equal_iter i last then [] 
          else shm_get_elm_at_inc i : (gen i &);
end;

/***  Constructors *********************************************************/

emptystlhmap ()                = shm_make_empty hash (==) [] 0;
emptystlhmap (khash,keql,dflt) = shm_make_empty khash keql dflt 0;
emptystlhmap (khash,keql)      = shm_make_empty khash keql [] 0;
emptystlhmap  khash            = shm_make_empty khash (==) []  0;

stlhmap xs = shm when
  shm = emptystlhmap hash;
  shm_insert_elms_xs shm xs;
end if listp xs || matrixp xs;

stlhmap rng::svrng = shm when
  shm = emptystlhmap hash;
  shm_insert_elms_stlvec shm rng;
end;

stlhmap shm::stlhmap = shm when
  _,params = shm_parameters shm;
  shm = emptystlhmap params;
  shm_insert_elms_stlhmap shm shm;
end if ~shm_is_set shm;

emptystlhset ()                   = shm_make_empty hash (==) [] 0;
emptystlhset (khash,keql,buckets) = shm_make_empty khash keql buckets 0;
emptystlhset (khash,keql)         = shm_make_empty khash keql 0 0;
emptystlhset  khash               = shm_make_empty khash (==) 0  0;

stlhset xs = ss when
  ss = emptystlhset (<);
  shm_insert_elms_xs ss xs;
end if listp xs || matrixp xs;

stlhset rng::svrng = ss when
  ss = emptystlhset (<);
  shm_insert_elms_stlvec ss rng;
end;

stlhset shm::stlhmap = ss when
  _,kc,_ = shm_parameters shm;
  ss = emptystlhset kc;
  shm_insert_elms_stlhmap ss shm;
end if shm_is_set shm;

/*** Range Content ****************************************************/

lazy_map f shm::stlhmap = lazy_map_aux f first last when 
  first = shm_copy_iter $ shm_begin shm;
  last = shm_end shm;
end;

lazy_elms shm::stlhmap = lazy_elms_aux first last when 
  first = shm_copy_iter $ shm_begin shm;
  last = shm_end shm;
end;

lazy_keys shm::stlhmap = lazy_map (\(k=>v)->k) shm if ~shm_is_set shm;

lazy_keys shm::stlhmap = lazy_elms shm;

lazy_vals shm::stlhmap = lazy_map (\(k=>v)->v) shm if ~shm_is_set shm;

lazy_vals shm::stlhmap = lazy_elms shm;

elms shm::stlhmap = shm_listmap 0 shm shm_elm; 

keys shm::stlhmap = shm_listmap 0 shm shm_key;// if ~shm_is_set shm;

vals shm::stlhmap = shm_listmap 0 shm shm_val;// if ~shm_is_set shm;

vector shm::stlhmap = shm_make_vector shm;

stlvec shm::stlhmap = sv if ok when
  sv = emptystlvec;
  ok = case sv of  
    STLVEC v = shm_fill_stlvec shm v $$ 1;
    _ = 0;
  end;
end;

/*** Info ***************************************************************/

(::#) shm::stlhmap = shm_size shm;

size shm::stlhmap = shm_size shm;

empty shm::stlhmap = shm_empty shm;

is_set shm::stlhmap = shm_is_set shm;

count shm::stlhmap key = shm_count shm key;

parameters shm::stlhmap = shm_parameters shm;

/*** Modifiers *********************************************************/

insert shm::stlhmap xs::list = shm_insert_elms_xs shm xs;

insert shm::stlhmap xs::matrix = shm_insert_elms_xs shm xs;

insert shm::stlhmap shm::stlhmap = shm_insert_elms_stlhmap shm shm;

insert shm::stlhmap svr::svrng = shm_insert_elms_stlvec shm svr;

insert shm::stlhmap val@(k=>v) = shm_insert_elm shm val;

insert shm::stlhset key = shm_insert_elm shm key;

insert_elm shm::stlhset key = shm_insert_elm shm key; // to get xs, etc into set

clear shm::stlhmap = shm_clear shm;

erase shm::stlhmap key = shm_erase shm key;

swap shm1::stlhmap shm2::stlhmap = shm_swap shm1 shm2;

swap ss1::stlhset ss2::stlhset = shm_swap ss1 ss2;

/*** Equality and Lexicographical Comparison ***************************/

equal shm1::stlhmap shm2::stlhmap = shm_equal shm1 shm2
  if compatible_ranges shm1 shm2;

(::==) hac1::stlhmap hac2::stlhmap = shm_equal hac1 hac2
  if compatible_ranges hac1 hac2;

(::~=) hac1::stlhmap hac2::stlhmap = ~shm_equal hac1 hac2
  if compatible_ranges hac1 hac2;

/*** Mapping and Folding ********************************************/

::map f shm::stlhmap = shm_listmap f shm shm_elm; // => shm_key for sets

::foldl f x shm::stlhmap = shm_foldl f x shm;

::foldl1 f shm::stlhmap = shm_foldl1 f shm;

::do f shm::stlhmap = shm_foldl (\_ x->f x) () shm $$ ();

// ::filter p shm::stlhmap = shm_foldl f [] shm with
//   f x xs = res when
//     res = case p x of
//       1 = x:xs;
//       0 = xs;
//       y = throw failed_cond;
//     end;
//   end;
// end;

::listmap f shm::stlhmap = shm_listmap f shm shm_elm;

::catmap f shm::stlhmap = shm_listcatmap f shm shm_elm;

/*** Vector functions ****************************************************/

::rowmap f shm::stlhmap = rowcat (shm_listmap f shm shm_elm);

::rowcatmap f shm::stlhmap = rowcat (shm_listmap f shm shm_elm);

::colmap f shm::stlhmap = colcat (shm_listmap f shm shm_elm);

::colcatmap f shm::stlhmap = colcat (shm_listmap f shm shm_elm);

/*** Key oriented interface functions *********************************/

(::!) shm::stlhmap key = shm_find shm key shm_val;

has_key shm::stlhmap key = shm_member shm key;

update shm::stlhmap k v = shm_update shm k v $$ shm;

update_elm shm::stlhmap (k=>v) = shm_update shm k v $$ shm;

update_with f shm::stlhmap key x = shm_update_with shm key (f x) $$ shm;

