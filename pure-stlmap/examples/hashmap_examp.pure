
/* Some basic examples for the hashmap module. This is intended to be fed to
   the interpreter in a piecemeal fashion (best done using "Send Current Line"
   in Emacs). To see the results, you can also run the script from the command
   line as follows: pure < hashmap_examp.pure

   NOTE: In this directory you'll also find a log file generated by running
   this script through Pure. You can run the script yourself and compare the
   results with the log to see whether the hashmap module works ok on your
   system. The Makefile has a target which automatizes this; simply run 'make
   check' in the main source directory. However, note that 'make check' may in
   some cases detect some slight differences even if the module is working
   properly, depending on which compiler, STL and Pure version you use.
   (Harmless differences manifest themselves in different hashmap element
   orders, since these aren't defined by the STL.) */

using hashmap;

public foo bar baz; // free symbols used below

/* Create a hashmap and populate it with some Pure data. Both keys and values
   may be arbitrary Pure expressions. Note that in general the elements may be
   stored in an apparently random order (not necessarily the order in which
   they were inserted). */

let m = hashmap [foo=>99, bar=>bar 4711L, baz=>1..5]; m;

/* Note that hashmaps are printed using the format 'hashmap [key=>val,...]' by
   default, which reconstructs the value when used as a literal in Pure code.
   It is also possible to define a custom pretty-printing, using your own
   preferred symbol in place of 'hashmap'. In particular, the symbol may also
   be an outfix symbol so that hashmaps can be printed and entered in a
   bracketed format analogous to list and matrix notation. The following code
   shows how to make this work. To these ends, we introduce a nonfix symbol
   {$$} denoting the empty hashmap (note that this must be written as is, with
   no spaces between the "brackets"), and a corresponding pair of outfix
   symbols {$ $} which will be used to denote non-empty hashes. */

nonfix {$$};  // empty hashmap
outfix {$ $}; // hashmap brackets

// Define the above as macros which expand to proper hashmap values.
// NOTE: This uses the new built-in __list__ macro from Pure 0.49 or later.

def {$$} = hashmap [];
def {$ xs@(_,_) $} = hashmap (__list__ xs);
def {$ x $} = hashmap [x];

/* Now we can use the notation {$ key=>val, ... $} to enter hashmap literals
   in Pure code, and a call to the hashmap_symbol function also makes the
   hashmap pretty-printer use this notation. */

hashmap_symbol ({$ $});

let m = {$ foo=>99, bar=>bar 4711L, baz=>1..5 $}; m;

/* The pretty-printing can be changed at any time. E.g., to revert to the
   default: */

hashmap_symbol hashmap;
m;

// Query the map.
m!bar;  // => bar 4711L
keys m; // => [foo,bar,baz]
vals m; // => [99,bar 4711L,[1,2,3,4,5]]
list m; // => [foo=>99,bar=>bar 4711L,baz=>[1,2,3,4,5]]

// Membership test.
member m foo, member m bar;

// Delete an element. Note that hashmaps are mutable, so you need to take a
// copy if you want to preserve the original value.
let m1 = copy m;
delete m foo; m1;
m!foo;  // => out_of_bounds exception
keys m; // => [bar,baz]
vals m; // => [bar 4711L,[1,2,3,4,5]]
list m; // => [bar=>bar 4711L,baz=>[1,2,3,4,5]]

member m foo, member m bar;

// Hashmaps can also be used in list and matrix comprehensions.
[x,y | x=>y = m1];
{x,y | x=>y = m1; listp y};

/* You can check two hashmaps for syntactic equality, which holds if and only
   if they contain the same elements, in the same order. But note that this is
   somewhat flaky because the order of elements in a hashmap may depend on how
   it is constructed. */

m===m, m===m1, m === copy m,
hashmap [97=>98,"a"=>"b"] === hashmap ["a"=>"b",97=>98]; // => 1,0,1,0

/* So the above isn't useful if you want to verify that two hashmaps contain
   the same elements, irrespective of the particular order in which the
   members are listed. This can be done using the semantic equality
   operation. */

m==m, m==m1, m == copy m,
hashmap [97=>98,"a"=>"b"] == hashmap ["a"=>"b",97=>98]; // => 1,0,1,1

/* Note that the hashmap module provides no submap comparisons. If you need
   them, here's one way to define them in Pure instead. A hashmap x is
   considered a submap of a hashmap y iff all key=>val pairs of x are also
   contained in y. */

x::hashmap <= y::hashmap = x===y ||
  (all (member y) xks && vals x === [y!k | k = xks] when xks = keys x end);
x::hashmap >= y::hashmap = x===y ||
  (all (member x) yks && vals y === [x!k | k = yks] when yks = keys y end);
x::hashmap <  y::hashmap = x<=y && #x<#y;
x::hashmap >  y::hashmap = x>=y && #x>#y;

m<=m1, m<m1, m>=m, m>m; // => 1,1,1,0

/* Hashmaps can also serve as a hashed set data structure which contains only
   keys but no values. In this case the value associated with a key defaults
   to the key itself. */

let m = hashmap [99, bar 4711L, 1..5]; m;

member m 99;
m!99;
delete m 99;
member m 99;
m!99;
insert m 99;

// You can also mix singleton elements with ordinary key-value associations.
delete m (bar 4711L);
insert m (bar=>bar 4711L);
m!99;
m!bar;

/* Basic set-like operations like union, intersection etc. aren't provided by
   the module either, but you can easily implement them yourself as follows.
   Note that we take a copy of the first operand here in order to preserve
   value semantics. */

x::hashmap + y::hashmap = foldl insert (copy x) (list y);
x::hashmap - y::hashmap = foldl delete (copy x) (keys y);
x::hashmap * y::hashmap = x-(x-y);

let m1 = hashmap [5,1,3,11,3];
let m2 = hashmap (3..6);

m1;m2;
m1+m2; // => hashmap [11,1,3,4,5,6]
m1-m2; // => hashmap [11,1]
m1*m2; // => hashmap [3,5]

// These operations also work with general hashmaps, of course.
hashmap [foo=>99,baz=>1..5] + hashmap [bar=>bar 4711L];

/* Multimaps are supported, too. These differ from the ordinary hashmaps in
   that they may contain multiple key-value associations for each key. They
   are implemented by the hashmmap type, which provides pretty much the same
   API as the hashmap type. */

x::hashmmap + y::hashmmap = foldl insert (copy x) (list y);
x::hashmmap - y::hashmmap = foldl delete (copy x) (keys y);
x::hashmmap * y::hashmmap = x-(x-y);

let m1 = hashmmap [5,1,3,11,3];
let m2 = hashmmap (3..6);

m1;m2;
m1+m2; // => hashmmap [11,1,3,3,3,4,5,5,6]
m1-m2; // => hashmmap [11,1,3]
m1*m2; // => hashmmap [3,5]

let m = hashmmap [foo=>99,baz=>1..5] + hashmmap [baz=>bar 4711L]; m;

/* Note that indexing works a bit differently from ordinary hashmaps in that
   the list of *all* associations for a given key is returned (which may be
   empty if the key is not in the map). */

m!![foo,bar,baz];
