
/* Some basic examples for the ordmap module. This is intended to be fed to
   the interpreter in a piecemeal fashion (best done using "Send Current Line"
   in Emacs). To see the results, you can also run the script from the command
   line as follows: pure < ordmap_examp.pure

   NOTE: In this directory you'll also find a log file generated by running
   this script through Pure. You can run the script yourself and compare the
   results with the log to see whether the ordmap module works ok on your
   system. The Makefile has a target which automatizes this; simply run 'make
   check' in the main source directory. */

using ordmap;

public bar; // free symbol used below

/* Create an ordmap and populate it with some Pure data. Both keys and values
   may be arbitrary Pure expressions. The key values in a map must all be
   ordered using the standard '<' predicate. This is also the order that will
   be used when printing an ordmap or extracting its members. In the following
   examples, the predefined orders on strings and numbers will be used, but of
   course you can also use your own custom data types if you define '<' on
   them. */

let m = ordmap ["foo"=>99, "bar"=>bar 4711L, "baz"=>1..5]; m;

/* Note that ordmaps are printed using the format 'ordmap [key=>val,...]' by
   default, which reconstructs the value when used as a literal in Pure code.
   It is also possible to define a custom pretty-printing, using your own
   preferred symbol in place of 'ordmap'. In particular, the symbol may also
   be an outfix symbol so that ordmaps can be printed and entered in a
   bracketed format analogous to list and matrix notation. The following code
   shows how to make this work. To these ends, we introduce a nonfix symbol
   {$$} denoting the empty ordmap (note that this must be written as is, with
   no spaces between the "brackets"), and a corresponding pair of outfix
   symbols {$ $} which will be used to denote non-empty maps. */

nonfix {$$};  // empty ordmap
outfix {$ $}; // ordmap brackets

// Define the above as macros which expand to proper ordmap values.
// NOTE: This uses the new built-in __list__ macro from Pure 0.49 or later.

def {$$} = ordmap [];
def {$ xs@(_,_) $} = ordmap (__list__ xs);
def {$ x $} = ordmap [x];

/* Now we can use the notation {$ key=>val, ... $} to enter ordmap literals
   in Pure code, and a call to the ordmap_symbol function also makes the
   ordmap pretty-printer use this notation. */

ordmap_symbol ({$ $});

let m = {$ "foo"=>99, "bar"=>bar 4711L, "baz"=>1..5 $}; m;

/* The pretty-printing can be changed at any time. E.g., to revert to the
   default: */

ordmap_symbol ordmap;
m;

// Query the map.
m!"bar";  // => bar 4711L
keys m;   // => ["bar","baz","foo"]
vals m;   // => [bar 4711L,[1,2,3,4,5],99]
list m;   // => ["bar"=>bar 4711L,"baz"=>[1,2,3,4,5],"foo"=>99]

// Membership test.
member m "foo", member m "bar";

// Delete an element. Note that ordmaps are mutable, so you need to take a
// copy if you want to preserve the original value.
let m1 = copy m;
delete m "foo"; m1;
m!"foo";  // => out_of_bounds exception
keys m; // => ["bar","baz"]
vals m; // => [bar 4711L,[1,2,3,4,5]]
list m; // => ["bar"=>bar 4711L,"baz"=>[1,2,3,4,5]]

member m "foo", member m "bar";

// Ordmaps can also be used in list and matrix comprehensions.
[x,y | x=>y = m1];
{x,y | x=>y = m1; listp y};

/* You can check two ordmaps for syntactic equality, which holds if and only
   if they contain exactly the same elements, in the same order. */

m===m, m===m1, m === copy m,
ordmap [97=>98] === ordmap [97.0=>98]; // => 1,0,1,0

/* Note that the above checks both keys and values for syntactic equality,
   which is why ordmap [97=>98] and ordmap [97.0=>98] are considered unequal,
   even though 97 == 97.0 in Pure and thus the two keys will be considered
   equal by ordmap. */

member (ordmap [97=>98]) 97.0; // => 1

/* If this bothers you, you can also check for semantic equality, which is
   somewhat less efficient, but takes into account the key order and properly
   deals with the multimap case (see below). */

m==m, m==m1, m == copy m,
ordmap [97=>98] == ordmap [97.0=>98]; // => 1,0,1,1

/* Note that the ordmap module provides no submap comparisons. If you need
   them, here's one way to define them in Pure instead. An ordmap x is
   considered a submap of an ordmap y iff all key=>val pairs of x are also
   contained in y. */

x::ordmap <= y::ordmap = x===y ||
  (all (member y) xks && vals x === [y!k | k = xks] when xks = keys x end);
x::ordmap >= y::ordmap = x===y ||
  (all (member x) yks && vals y === [x!k | k = yks] when yks = keys y end);
x::ordmap <  y::ordmap = x<=y && #x<#y;
x::ordmap >  y::ordmap = x>=y && #x>#y;

m<=m1, m<m1, m>=m, m>m; // => 1,1,1,0

/* Ordmaps can also serve as an ordered set data structure which contains only
   keys but no values. In this case the value associated with a key defaults
   to the key itself. */

let m = ordmap [99, 4711L, 1.0]; m;

member m 99;
m!99;
delete m 99;
member m 99;
m!99;
insert m 99;

// You can also mix singleton elements with ordinary key-value associations.
delete m 4711L;
insert m (88=>bar 4711L);
m!99;
m!88;

/* Basic set-like operations like union, intersection etc. aren't provided by
   the module either, but you can easily implement them yourself as follows.
   Note that we take a copy of the first operand here in order to preserve
   value semantics. */

x::ordmap + y::ordmap = foldl insert (copy x) (list y);
x::ordmap - y::ordmap = foldl delete (copy x) (keys y);
x::ordmap * y::ordmap = x-(x-y);

let m1 = ordmap [5,1,3,11,3];
let m2 = ordmap (3..6);

m1;m2;
m1+m2; // => ordmap [1,3,4,5,6,11]
m1-m2; // => ordmap [1,11]
m1*m2; // => ordmap [3,5]

// These operations also work with general ordmaps, of course.
ordmap ["foo"=>99,"baz"=>1..5] + ordmap ["bar"=>bar 4711L];

/* Multimaps are supported, too. These differ from the ordinary ordmaps in
   that they may contain multiple key-value associations for each key. They
   are implemented by the ordmmap type, which provides pretty much the same
   API as the ordmap type. */

x::ordmmap + y::ordmmap = foldl insert (copy x) (list y);
x::ordmmap - y::ordmmap = foldl delete (copy x) (keys y);
x::ordmmap * y::ordmmap = x-(x-y);

let m1 = ordmmap [5,1,3,11,3];
let m2 = ordmmap (3..6);

m1;m2;
m1+m2; // => ordmmap [1,3,3,3,4,5,5,6,11]
m1-m2; // => ordmmap [1,3,11]
m1*m2; // => ordmmap [3,5]

let m = ordmmap ["foo"=>99,"baz"=>1..5] + ordmmap ["baz"=>bar 4711L]; m;

/* Note that indexing works a bit differently from ordinary ordmaps in that
   the list of *all* associations for a given key is returned (which may be
   empty if the key is not in the map). */

m!!["foo","bar","baz"];

/* Like ordmaps, ordmmaps can be compared for syntactic and semantic equality.
   The latter also properly deals with the case that equal keys may be listed
   in any order. (This may become slow in degenerate cases where the ordmmap
   contains much more members than distinct keys.) */

ordmmap [97=>98,97.0=>99] === ordmmap [97.0=>98,97=>99]; // => 0
ordmmap [97=>98,97.0=>99] == ordmmap [97.0=>98,97=>99]; // => 1
