/* stlmap.pure: Pure interface to C++ STL map
    
--- DRAFT - FOR DISCUSSON PURPOSES ONLY ---

Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stldict, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stldict distribution package for details.

*/
 
using stlbase;
using "lib:stlmap";

// stlmap constuctors
nonfix STLMAP;
STLMAP = 'STLMAP;

// stlmap types
type stlset (STLMAP _);
type stlmap (STLMAP _);
type smrng (STLMAP _);
type smrng (STLMAP _, _);

namespace stl;

/*** C++ support ************************************************************/

private extern expr* sm_make_empty(expr* kcmp, expr* vcmp, expr* veql, int ko);
private extern void  sm_delete(void* map);
private extern bool  sm_is_set(expr* tpl);
private extern expr* sm_set_default(void* map, expr* val);
private extern expr* sm_get_default(void* map);
private extern expr* sm_get_elm(void* map, expr* key, int what);
private extern int   sm_equal(expr* tpl1, expr* tpl2);
private extern int   sm_less(expr* tpl1, expr* tpl2);
private extern bool  sm_includes(expr* rng1, expr* rng2);
private extern expr* sm_setop(int op, expr* rng1, expr* rng2);
private extern expr* sm_make_vector(expr* tpl);
private extern void* sm_make_stlvec(expr* tpl);
private extern int   sm_size(expr* tpl);
private extern expr* sm_bounds(expr* tpl);
private extern int   sm_member(void* map, expr* key);
private extern expr* sm_next_key(void* map, expr* key);
private extern expr* sm_prev_key(void* map, expr* key);
private extern expr* sm_update(void* map, expr* key, expr* val);
private extern expr* sm_update_with(void* map, expr* key, expr* unaryfun);
private extern int   sm_insert_elm(void* map, expr* kv);
private extern int   sm_insert_elms_xs(void* map, expr* src);
private extern int   sm_insert_elms_stlvec(void* map, expr* tpl);
private extern int   sm_insert_elms_stlmap(void* map, expr* tpl);
private extern int   sm_erase(expr* rng);
private extern int   sm_erase_if (expr* pred, expr* rng);
private extern int   sm_clear(void* map);
private extern expr* sm_listmap(expr* fun, expr* rng, int what);
private extern expr* sm_listcatmap(expr* fun, expr* rng, int what);
private extern expr* sm_foldl(expr* fun, expr* val, expr* rng);
private extern expr* sm_foldl1(expr* fun, expr* rng);
private extern expr* sm_foldr(expr* fun, expr* val, expr* rng);
private extern expr* sm_foldr1(expr* fun, expr* rng);

extern void stl_set_sm_trace(bool enable) = set_sm_trace;
extern bool stl_sm_trace_enabled() = sm_trace_enabled;

/*** Helpers **************************************************************/

private sm_key sm_val sm_elm 
  sm_union sm_difference sm_intersection sm_symmetric_difference 
  sm_wrap sm_wrap_sv sm_less sm_equal;

const sm_key = 1;
const sm_val = 2;
const sm_elm = 3;

const sm_merge = 1;
const sm_union = 2;
const sm_difference = 3;
const sm_intersection = 4;
const sm_symmetric_difference = 5;

sm_wrap m = STLMAP (sentry sm_delete m);

sm_wrap_sv m = STLVEC (sentry sm_delete m);

both_sets rng1 rng2 = sm_is_set rng1 && sm_is_set rng2;

both_maps rng1 rng2 = ~sm_is_set rng1 && ~sm_is_set rng2;

/*** Accessors, modifiers and observers ********************************/

size rng::smrng = sm_size rng;

set_default sm@(STLMAP m) val = sm_set_default m val if ~sm_is_set sm;

get_default sm@(STLMAP m) = sm_get_default m; // returns (bool, default)

empty rng::smrng = sm_size rng == 0;

bounds (STLMAP m) = (STLMAP m), stlbeg, stlend;

bounds rng@(STLMAP m, _) = (STLMAP m), sm_bounds rng;

::next_key sm@(STLMAP m) key = sm_next_key m key;

::prev_key sm@(STLMAP m) key = sm_prev_key m key;

::member (STLMAP m) key = sm_member m key;

::find_elm what (STLMAP m) key = sm_get_elm m key what;

::stlvec rng::smrng = sm_wrap_sv $ sm_make_stlvec rng;

::insert_elm sm@(STLMAP m) rk = sm_insert_elm m rk;

::insert_elms sm@(STLMAP m) xs::list = sm_insert_elms_xs m xs;

::insert_elms sm@(STLMAP m) xs::matrix = sm_insert_elms_xs m xs;

::insert_elms sm@(STLMAP m) rng::smrng = sm_insert_elms_stlmap m rng;

::insert_elms sm@(STLMAP m) rng::svrng = sm_insert_elms_stlvec m rng;

::erase sm@(STLMAP m) = sm_clear m;

::erase rng::smrng = sm_erase rng;

::erase_if pred rng::smrng = sm_erase_if pred rng;

::update sm@(STLMAP m) key x = sm_update m key x $$ sm if ~sm_is_set sm;

::update_with f sm@(STLMAP m) key x = 
  sm_update_with m key (f x) if ~sm_is_set sm;

/***  Constructors *********************************************************/

::emptystlmap = sm_wrap $ sm_make_empty (<) (<) (==) 0;

::emptystlmap_with kcmp vcmp veql = sm_wrap $ sm_make_empty kcmp vcmp veql 0;

::stlmap xs = sm when
  sm = ::emptystlmap;
  insert_elms sm xs;
end if listp xs || matrixp xs;

::stlmap rng::svrng = sm when
  sm = ::emptystlmap;
  insert_elms sm rng;
end;

::stlmap rng::smrng = sm when
  sm = ::emptystlmap;
  insert_elms sm rng;
end;

::mkstlmap y ks::list = do add ks $$ sm with
  add k = ::update sm k y;
end when
  sm = emptystlmap;  
end;

::emptystlset = sm_wrap $ sm_make_empty (<) (<) (==) 1;

::emptystlset_with kcmp vcmp veql = sm_wrap $ sm_make_empty kcmp vcmp veql 1;

::stlset xs = sm when
  sm = ::emptystlset;
  insert_elms sm xs;
end if listp xs || matrixp xs;

::stlset rng::svrng = sm when
  sm = ::emptystlset;
  insert_elms sm rng;
end;

::stlset rng::smrng = sm when
  sm = ::emptystlset;
  insert_elms sm rng;
end;

/*** Operators *************************************************************/

(::!) (STLMAP m) key = sm_get_elm m key sm_val;

(::#) sm::stlmap = sm_size sm;

(::==) sm1::stlmap sm2::stlmap = sm_equal sm1 sm2;

(::~=) sm1::stlmap sm2::stlmap = ~sm_equal sm1 sm2;

(::<) rng1::smrng rng2::smrng = sm_less rng1 rng2;

(::<=) rng1::smrng rng2::smrng = ~sm_less rng2 rng1;

(::>) rng1::smrng rng2::smrng = sm_less rng2 rng1;

(::>=) rng1::smrng rng2::smrng = ~sm_less rng1 rng2;

sm_equal rng1::smrng rng2::smrng = sm_equal rng1 rng2 
  if both_maps rng1 rng2 || both_sets rng1 rng2;

sm_less rng1::smrng rng2::smrng = sm_less rng1 rng2 
  if both_maps rng1 rng2 || both_sets rng1 rng2;

/** STL algorithms **********************************************************/

merge rng1::smrng rng2::smrng = 
  sm_wrap $ sm_setop sm_merge rng1 rng2
  if both_sets rng1 rng2 || both_maps rng1 rng2;

set_union rng1::smrng rng2::smrng = 
  sm_wrap $ sm_setop sm_union rng1 rng2
  if both_sets rng1 rng2 || both_maps rng1 rng2;

set_difference rng1::smrng rng2::smrng = 
  sm_wrap $ sm_setop sm_difference rng1 rng2
  if both_sets rng1 rng2 || both_maps rng1 rng2;

set_intersection rng1::smrng rng2::smrng = 
  sm_wrap $ sm_setop sm_intersection rng1 rng2
  if both_sets rng1 rng2 || both_maps rng1 rng2;

set_symmetric_difference rng1::smrng rng2::smrng = 
  sm_wrap $ sm_setop sm_symmetric_difference rng1 rng2
  if both_sets rng1 rng2 || both_maps rng1 rng2;

set_includes rng1::smrng rng2::smrng = sm_includes rng1 rng2 
  if both_sets rng1 rng2 || both_maps rng1 rng2;

// add find adj ?? some others ??05

/*** List interface functions *********************************************/

::members rng::smrng = sm_listmap 0 rng sm_elm; 

::map f rng::smrng = sm_listmap f rng sm_elm; // => sm_key for sets

::listmap f rng::smrng = sm_listmap f rng sm_elm;

::catmap f rng::smrng = sm_listcatmap f rng sm_elm;

::foldl f x rng::smrng = sm_foldl f x rng;

::foldl1 f rng::smrng = sm_foldl1 f rng;

::foldr f x rng::smrng = sm_foldr f x rng;

::foldr1 f rng::smrng = sm_foldr1 f rng;

::do f rng::smrng = sm_foldl (\_ x->f x) () rng $$ ();

::filter p rng::smrng = sm_foldr f [] rng with
  f x xs = res when
    res = case p x of
      1 = x:xs;
      0 = xs;
      y = throw failed_cond;
    end;
  end;
end;

::keys rng::smrng = sm_listmap 0 rng sm_key if ~sm_is_set rng;

::vals rng::smrng = sm_listmap 0 rng sm_val if ~sm_is_set rng;

::map_keys f rng::smrng = sm_listmap f rng sm_key if ~sm_is_set rng;

::map_vals f rng::smrng = sm_listmap f rng sm_val if ~sm_is_set rng;

::catmap_keys f rng::smrng = sm_listcatmap f rng sm_key if ~sm_is_set rng;;

::catmap_vals f rng::smrng = sm_listcatmap f rng sm_val if ~sm_is_set rng;

/*** Vector interface functions ****************************************/

vector rng::smrng = sm_make_vector rng;

::rowmap f rng::smrng = rowcat (sm_listmap f rng sm_elm);

::rowcatmap f rng::smrng = rowcat (sm_listmap f rng sm_elm);

::colmap f rng::smrng = colcat (sm_listmap f rng sm_elm);

::colcatmap f rng::smrng = colcat (sm_listmap f rng sm_elm);

/*** Pure dict and set emulation *****************************************/

null rng::smrng = sm_size rng == 0; // use empty, erroneous for smrng

::first rng::smrng = sm_get_elm m b sm_elm when STLMAP m,b,e = bounds rng end;

::last rng::smrng = sm_get_elm m (sm_prev_key m e) sm_elm 
when STLMAP m,b,e = bounds rng; end;

//::list sm::stlmap = members sm;  // use members

::insert sm@(STLMAP m) rng::smrng = sm_insert_elms_stlmap m rng $$ sm;

::rmfirst rng::smrng = sm_erase (sm,b) when sm,b,e = bounds rng end;

::rmlast rng::smrng = sm_erase (sm, ::prev_key sm e) when sm,b,e = bounds rng end;

::delete sm::stlmap k = sm_erase (sm,k);

::delete_all sm::stlmap k = sm_erase (sm,k);

::delete_if pred sm::stlmap k = sm_erase_if pred (sm,k);

::delete_val sm::stlmap (k=>v) = 
  sm_erase_if (\(_=>x)->x==v) (sm,k) if ~sm_is_set sm;

(::+) rng1::smrng rng2::smrng = res when
  res = ::stlmap rng1;
  ::insert_elms res rng2;
end if both_maps rng1 rng2;

(::+) rng1::smrng rng2::smrng = set_union rng1 rng2 if both_sets rng1 rng2;

(::-) rng1::smrng rng2::smrng = res when
  res = stlmap rng1;
  do (::delete_val res) rng2 
end if both_maps rng1 rng2;

(::-) rng1::smrng rng2::smrng = set_difference rng1 rng2 if both_sets rng1 rng2;

(::*) rng1::smrng rng2::smrng = 
  if size rng1 < size rng2 then rng1 - (rng1 -rng2) else rng2 - (rng2 -rng1)
  if both_sets rng1 rng2 || both_maps rng1 rng2;

(::/) rng1::smrng rng2::smrng = (rng1 - rng2) +  (rng2 -rng1)
  if both_sets rng1 rng2 || both_maps rng1 rng2;


