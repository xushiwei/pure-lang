
--- DRAFT - FOR DISCUSSON PURPOSES ONLY ---

===========
pure-stlmap
===========

.. default-domain:: pure
.. module:: stlmap

Version @version@, |today|

| Peter Summerland <p.summerland@gmail.com>

pure-stlmap is a Pure interface to six associative containers provided by a
part of `C++'s Standard Library`_ that is often refered to as the Standard
Template Library ("STL"). The interface provides access to the STL's four
ordered associative containers, map, set, multimap and multiset, and two of
its unordered associative containers, unordered_map and unordered_set,
specialized to hold pointers to arbitrary Pure expressions.

.. _Pure: http://pure-lang.googlecode.com

.. contents::
.. sectnum::


Copying
=======

| Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved. 

pure-stlmap is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. 

pure-stlmap is distributed under a BSD-style license, see the COPYING file
for details.

Installation
============

pure-stlmap-@version@ requires at least Pure 0.48. The latest version of Pure
is available at http://code.google.com/p/pure-lang/downloads/list.

The latest version of the source code for pure-stlmap can be downloaded from
http://pure-lang.googlecode.com/files/pure-stlmap-@version@.tar.gz.
 
To install pure-stlmap (on Linux), extract the source code (e.g., tar -xzf
pure-stlmap-@version@.tar.gz), cd to the pure-stlmap-@version@ directory, and
run ``make``. After this you can (and should) also run ``make test`` to run a
few unit tests to make sure that pure-stlmap works properly on your system. If
``make test`` works, run ``sudo make install`` to install pure-stlmap on your
system.  ``make`` tries to guess your Pure installation directory and
platform-specific setup. If it gets this wrong, you can set some variables
manually. In particular, ``make install prefix=/usr`` sets the installation
prefix. Please see the Makefile for details.

Introduction
============

A part of the Standard C++ Library`_ that is often refered to as the standard
template library ("STL") provides templates for generic containers and generic
algorithms. pure-stlmap provides an interface to the STL's associative
containers: map, set, multimap and multiset and two of its unordered
associative containers: unordered_map and unordered_set, specialized to hold
arbitrary Pure expressions.

.. _C++ standard library documentation: http://en.cppreference.com/w/cpp

Containers Supported
--------------------

pure-stlmap provides six mutable containers "stlmap", "stlset", "stlmmap",
"stlmset", "stlhmap" and "stlhset" that are thin wrappers around the
corresponding associative containers provided by the STL. pure-stlmap does not
provide wrappers for unordered_multimap and unordered_multiset. In addition,
the interfaces for stlhmap and stlhset are limited compared to those provided
for the other four (ordered) associative containers.

It is sometimes convenient to discuss the supported containers in terms of
certain defining characteristics:

  * associative container - stlmap, stlset, stlmmap, stlmmset, stlhmap or
                            stlhset

  * ordered container - stlmap, stlset, stlmmap, stlmmset

  * unique-keyed container - stlmap, stlset, stlhmap, stlhset

  * multi-keyed container - stlmmap, stlmset

  * unordered container - stlhmap, stlhset

  * map - stlmap, stlmmap, stlhmap

  * ordered map - stlmap, stlmmap

  * unique-keyed map - stlmap, stlhmap

  * multi-keyed map - stlmmap

  * unordered map - stlhmap
  
  * set - stlset, stlmset, stlhset

  * ordered set - stlset, stlmset

  * unique-keyed set - stlset, stlhset

  * multi-keyed set - stlmset

  * unordered set - stlhset

Hopefully these names are intuitive enough that defining them here was not
really necessay. On the other hand, the groupings are a nice summary of what
is available in this package.

Keys, Values and Elements
-------------------------

The maps provided by pure-stlmap, stlmap, stlmmap and stlhmap, associate
values with keys. If v is associated with k in an map, m, then we say that
(k=>v) is an element of m and that k is stored in m. The sets provided by
pure-stlmap, stlset, stlmset and stlhset simply hold elements. If e is
contained a set, s, we say that e is an element of s, that e is stored in s,
that s has key e and that s has value e. In other words, we sometimes speak of
a set container as if it were a map whose elements, keys and values are all
the same object.

Each ordered container has a less-than function that is used to order its
elements by key. The default less-than function, (<) generally works well, but
a customized less-than function can be specified when the ordered container is
constructed. Two elements of a given ordered container are considered to have
unique keys if their keys are not "equivalent", i.e., one key is is not
less-than the other key. For purposes of lexicographical comparisons one
element, e1, is less than another, e2, if (a) their e1's key is less-than e2's
key and (b) e1's value is less than e2's value. Also, e1 and e2 are considered
to be equal if (a) their keys are equivalent and (b) their values are
equal. The default "value-less-than" and "value-equal" functions (<) and (==),
but these also can be customized.

The unordered containers do not have less-than functions. They have a hash
function, a key-equal function and a value-equal function. These default to
'hash', '(==)' and '(==)' but customized functions can be specified when the
container is constructed. 

Correspondence with the Native Interface
----------------------------------------

The core functions provided by pure-stlmap, such as the constructors,
equivalence and comparison operators, insert and erase operations, and the set
operations are just thin wrappers around the the corresponding C++ functions.

One advantage of this approach is that users can consult the STL documentation
to understand the performance characteristics and corner case behavior of any
pure-stlmap function that has a corresponding function in the STL. In addition
calling underlying STL functions such the set operations, swap, or copy on a
one to one basis preserves O(n) time complexity behavior that is difficult to
guarantee if the operations are reimplemented by hand in order to conform to
Pure standard library behavior.

Unfortunately, often the STL functions do not have the same semantics as
similar functions standard Pure library. 

Examples
--------

The code snippets that appear in the rest of this document assume that
something similar to the following has been entered at the prompt. ::

    pure-stlmap$> pure -q
    > using stlmap, stlhmap, stlmmap;
    > using namespace stl;

    > let sm  = stlmap  ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5];
    > let shm = stlhmap ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5];
    > let smm = stlmmap ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5];

    > let ss  = stlset  ["a","b","c","d","e"];
    > let shs = stlhset ["a","b","c","d","e"];
    > let sms = stlmset ["a","b","c","c","d"];

    > let sm_rng  = sm,"b","d";
    > let shm_rng = shm,"b","d";
    > let smm_rng = smm,"b","d";

    > let ss_rng  = ss,"b","d";
    > let shs_rng = sm,"b","d";
    > let sms_rng = sm,"b","d";

The value (or values for a multi-key container) associated with a key can be
accssed using the (!) operator. ::

    > sm!"a";
    1

    > shm!"b";
    2

    > smm!"c";
    [31,32]

As expected, the elments of the ordered containers are indeed ordered and those
in the unordered (or "hashed") containers are not. ::

    > elms ss;
    ["a","b","c","d","e"]   

    > elms shs;
    ["d","e","a","b","c"]

Note that the last element in the range specification is not included in the
range. Also, ranges are not supported for stlhmap and stlhset.

    > elms ss_rng;        // ranges supported for stlsets
    ["b","c"]

    > elms (shm,"b","d"); // fails - ranges not supported for stlhmaps
    stl::elms (#<pointer 0x83b4908>,"b","d")

Iterators
---------

The native STL interface is based on "iterators" that point to elements in
containers. pure-stlmap provides support for iterators defined on its ordered
containters, stlmap, stlmmap, stlset and stlmset.

Given a valid iterator you can access, modify or erase the element it points
to.  Given two iterators, i and j, pointing into a ordered container oc, the
range (i,j), denotes oc's elements starting with "oc[i]" the element pointed
to by i up to but not including oc[j]. In pure-stlmap, this range is denoted
by the tuple (i,j). ::

   > elms sm;
   ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

   > let i = stl::find sm1 "b"; // get the iterator

   > let j = stl::find sm1 "e";

   > elms (i,j);               // get the elements in the range
   ["b"=>2,"c"=>3,"d"=>4]

It is also possible to define a range using keys. Given an ordered container,
oc, and keys k and l, the range (oc,k,l) consists of all of the elements in
aoc starting with the first element that is not less than k up to but
not including the first element that is greater or equal to l. Note that k and
l do not have to be stored in oc. ::

   > elms (sm,"b","e");
   ["b"=>2,"c"=>3,"d"=>4]

   > elms (sm,"c1",stlend);
   ["d"=>4,"e"=>5]

When a range is required, the keys can be dropped, in which case the range
consists of all of the container's elements.

   > elms sm;
   ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

Please note that support for iterators and ranges is not provided for the
unordered containers, stlhmap and stlhset. Most pure-stlmap functions that act
on ranges can, however, operate on stlhmaps or stlhsets as well, except that,
for stlhmaps and stlhsets, they always operate on all of the container's
elements. Accordingly, whenever the documentation of a function refers to a
range, and the container in question is a a stlhmap or stlhset, the range
simply refers to the container itself.

Usage
=====

After installation of pure-stlmap (and pure-stlvec), you can use the operations
of this package by placing one or more the following import declarations in
your Pure programs::

  using stlmap;
  using stlmmap;
  using stlhmap;

Relationship with pure-stlvec
-----------------------------

pure-stlvec and pure-stlmap are linked into a common shared library
(libstlcontainer.so on Linux) that is installed when pure-stlvec is
installed. Accordingly pure-stlvec must be installed before you can use
pure-stlvec.

That said, you do not need to import stlvec (i.e., with a using statement) to
use stlmap, stlmmap or stlhmap. And pure-stlmap does not itself import
stlvec. Also, if you import stlmap, stlmmap or stlhmap but not stlvec, you
will be able to produce a stlvec that contains the elements of a given stlmap,
but you will not be able to access the stlvec's members.

   > let sv = stlvec sm;  // make a stlvec

   > sv!3;                // fails, (!) not defined for stlvecs
   STLVEC #<pointer 0xa546978>!3

   > using stlvec;        // now (!) is defined for stlvecs
   > sv!3;
   "d"=>4

Suggested Uses
--------------

Consider using stlmap or stlset unless there is some compelling reason to use
one of the others. The time complexity is guaranteed and having ordered
elements is often very useful. E.g., sparse arrays. In pure-stlmap, these two
containers support ranges and the key oriented functions cache iterators to
speed up key based lookups. Finally, if you are using set operations, these
two are unsurpassed for ease of use and efficiency.

If all you want is quick lookup, stlhmap or stlhset might be a slightly
faster. Set operations, ranges and iterator caching are not available for
these containers,

If you really need a multi-keyed container then, in pure-stlmap, stlmmap and
stlmset are your only choices. Set operations and ranges are supported, but
the semmantics are much more complicated than is the case for stlmap and
stlset. Iterator caching by key oriented functions is not provided because the
keys are not unique. For the same reason, the key oriented functions might are
less than ideal when dealing with multi-keyed containers. Using the
pure-stlmap iterator interface might be your best choice.

Types
=====

Importing the stlmap module introduces types to describe stlmap and stlset,
their iterators and ranges defined on them.
 
.. type:: stlmap /type
          stlset /type
          stlacon /type

  Types for stlmap and stlset. stlacon includes stlmap and stlset.

.. type stlmap_iter /type
        stlset_iter /type
        stlacon_iter /type

  Types for iterators on a stlmap or stlset. stlacon_iter includes stlmap_iter
  and stlset_iter.

.. type stlacon_rng /type

  A range of elements defined on a stlmap or stlset.

Importing the stlmmap module introduces types to describe stlmmap and stlmset,
along with their iterators and ranges defined on them.

.. type:: stlmmap /type
          stlmset /type
          stlmacon /type

  Types for stlmmap and stlmset. stlmacon includes stlmmap and stlmset.

 .. type stlmmap_iter /type
        stlmset_iter /type
        stlmacon_iter /type

  Types for iterators on stlmmap and stlmset. stlacon_iter includes
  stlmmap_iter and stlmset_iter.

.. type stlmacon_rng /type

  Type for a range of elements defined on a stlmmap or stlmset.

Importing the stlmap module introduces types to describe stlhmap and
stlhset.

.. type:: stlhmap /type
          stlhset /type
          stlhacon /type

Container Operations
====================

Required Container Operations
-----------------------------

New empty containers can be constructed using optional parameters that allow
you to specifiy customized less-than functions, hash functions and equality
functions. 

.. function:: mkstlmap (kcmp,dflt,vcmp,veql)
              mkstlmmap (kcmp,vcmp,veql)
              mkstlset kcmp
              mkstlmset kcmp
              mkstlhmap (khash,keql,veql)
              mkstlhset (khash,keql,veql)

   Create a new associative container. The key comparison and hash functions,
   kcmp and khash, are required, the other parameters are optional. The
   functions vcmp and veql are used to determine if one value is less than
   another or equal to another, respectively. The function keql is used to
   determine if one key is equal to another. The object dflt is a the
   containers default value. The default values for dflt, vcmp, veql and keql
   are [], (<) (==) and (==) respectively. E.g., ::

   > let xx = mkstlhmap hash;
   > container_info xx;
   0,2,0.0,1.0,hash,(==),(==)

   > let xx = mkstlmap (>);
   > container_info xx;
   0,(>),[],(<),(==)

Convenience functions are provided to construct empty containers using default
values.

.. function:: emptystlmap
              emptystlmmap
              emptystlset
              emptystlmset
              emptystlhmap
              emptystlhset

   Create a new associative container using default values.

Convenience functions are also provided to construct an empty container and
insert elements into it in one go. The source of the elements can be a list,
vector, a range defined on a stlvec, or another container of the same type as
the new container.

.. function:: stlmap /stlmap src
              stlmmap /stlmmap src
              stlset /stlmap src
              stlmset /stlmmap src
              stlhmap /stlhmap src
              stlhset /stlhmap src

   Create an associative constructor using default values and insert elements
   from src. src can be a list, vector, stlvec range or container of the same
   type as the new container. If the new container is one of the three maps,
   the elements of src must (k=>v) hash-rocket pairs.

After a stlhmap or stlhset is created, it is possible to adjust its maximum
load factor and bucket count.

.. function:: hash_reserve hacon mlf size

   Sets hacon's max_load_factor to mlf, sets the number of buckets to size/mlf
   and rehashes hacon.

.. function:: container_info /stlmmap acon

   If acon is an ordered associative container, returns (is_set, kcmp, dflt,
   vcmp, veql). If is set is true, dflt, vcmp, and veql will be random values
   that should not be used. If acon is unordered, returns (is_set,
   bucket_count, load_factor, max_load_factor, khash, keql, veql).

..function:: swap /stlmap acon1 acon2

  Swap the elements of the two containers of the same type.

.. function:: prefix # /stlmap acon

  Return the number of elements in acon.

.. function:: empty /stlmap acon

  Return true if acon is empty, else false.

Equality and Comparison
-----------------------

Two associative containers of the same type are considered to be equal if they
contain the same number of elements and if each pair of their corresponding
elements are equal.

.. function:: infix == /stlmap rng1 rng2
              infix ~= /stlmap rng1 rng2

  Test rng1 and rng2 for equality or nonequality where rng1 and rng2 are
  ranges defined over containers of the same type.
 
   > let xx = stlset ss;
   > xx == ss;
   1

   > (xx,"a","c") == (ss,"a","c");
   1

   > (xx,"a","c") == (ss,"b","c");
   0

.. function:: infix <  /stlmap rng1 rng2

   Traverse the ranges comparing pairs of elements e1 and e2. If e1 is less
   than e2, stop and return true; if e2 is less than e1 then stop and return
   false. If rng1 is exhaused but rng2 is not, return true, else return false. 
   The two ranges must be defined on ordered associative containers of the
   same type.

.. function:: infix >  /stlmap rng1 rng2
              infix <= /stlmap rng1 rng2
              infix >= /stlmap rng1 rng2

  The these three operators are the same as rng2 < rng2, ~(rng1>rng2) and
  ~(rng1<rng2).

Care must be taken when using equivalence and comparison operators with
stlmmaps because elements with the same key and different values are not
necessarily ordered by values. ::

    > let smm2 = stlmmap ["a"=>1,"b"=>2,"c"=>32,"c"=>31,"d"=>4];

    > elms smm;
    ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4]

    > elms smm2;
    ["a"=>1,"b"=>2,"c"=>32,"c"=>31,"d"=>4]

    > smm == smm2; // probably not what you want
    0 

For stlmap, stlset and stlmmset, the equivalence and comparison operators can
be thought of as set operators, e.g., if ac1 <= ac2 then ac2 contains
ac1. This is also true for stlmmap, provided that elements with equivalent
keys are stored in order. Check your implementation to see if it is even
possible to control the order (C++11 is ok). Please note that the comparison
operators are not provided for unordered containers.

Key Oriented Functions
----------------------

Most of the following functions are basically convenience functions that are
easier to use than iterators. They use cached iterators for faster lookup time
for some commonly occuring sequences of operations.

.. function:: count /stlmap acon k
              has_key /stlmap acon k

   Returns the number of elements that has k as their key.

.. function:: has_key /stlmap acon k

   Returns true if acon contains an element that has k as its key.    

.. function infix ! /stlmap acon k

  If acon is not a stlmmap: if acon has an element with key k return its value
  (or matching key if acon is a set), otherwise throw an out_of_bounds
  exception. If acon is a stlmmap: if acon has as least one element with key k
  return a list of values of all the elements with key k, otherwise return an
  empty list. E.g.::

    > sm!"c";
    3

    > catch id $ sm!"f";
    out_of_bounds

    > smm!"c";
    [31,32]

    > smm!"f";  // does not throw exception -- returns empty list
    []

.. function:: get /stlmap (acon,k)

   Same as get except that it returns a key value(s) pair.

   > get (sm,stlbeg);
   "a"=>1

   > get (smm,"c");
   "c"=>[31,32]

   > get (smm,stlbeg);
   "a"=>[1]

.. function:: put /stlmap (um,k) v
              put /stlmap (mm,k) src

   Associate v with k (i.e., insert (k=>v)) in um where um is is a stlmap or
   stlhmsp, or the elments of src with k in a stlmmap, mm. src can be a list
   or a vector. FIX should allow stlvec.

   > elms smm;
   ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

   > put (smm,"c") [31,33,35,36];
   4

   > elms smm;
   ["a"=>1,"b"=>2,"c"=>31,"c"=>33,"c"=>35,"c"=>36,"d"=>4,"e"=>5]

   > put (smm,"c") [];
   0

   > elms smm;
   ["a"=>1,"b"=>2,"d"=>4,"e"=>5]

.. function:: bounding_keys /stlmap rng

   Return a pair of keys, first and last, such that first <= k < last for each
   k, where k is the key of an element in rng. If there is no such last, the
   second member of the returned pair will be stl::stlend. If first is the key
   of the first element of rng's container, the first member of the returned
   pair will stl::stlbeg. E.g.,

   > elms sm;
   ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

   > bounding_keys sm;
   stl::stlbeg,stl::stlend

  > bounding_keys (sm,"a1","e");
   "b","e"

   > elms (sm,ans);
   ["b"=>2,"c"=>3,"d"=>4]

   > bounding_keys (smm,"a","d");
   stl::stlbeg,"d"

   > elms (smm,ans);
   ["a"=>1,"b"=>2,"c"=>31,"c"=>32]

.. function:: next_key /stlmap oc k
              prev_key /stlmap oc k

   next_key returns the key of the first element in oc, an oredered container,
   that has a key that is greater than k. If no such element exists or if k is
   stl::stlend, return stl::stlend. prev_key returns the last element in acon
   that has a key that is less that k, or, if no such element exists, throws
   an out_of_bounds execption. If k is not an element of oc, stlbeg or stlend
   throw an out_of_bound exception.

Iterator Cache
--------------

stlmaps and stlsets maintain a cache of iterators that are contructed by all
of the key oriented functions described in the previous section. In addition,
insert (of a single element), insert_or_update, and insert_or_update_with also
cache iterators.

Here are some examples produced by compiling pure-stlmap with a trace function
that shows when caching eliminates a key lookup.

   > has_key sm "a";
   1

   > sm!"a";
   found iterator for: "a"
   1

   > put (sm,"a") 10;
   found iterator for: "a"
   10

   > let k = next_key sm "a";
   found iterator for: "a"

   > let k = next_key sm k;
   found iterator for: "b"

   > put (sm,k) 30;
   found iterator for: "c"
   30

   > elms sm;
   ["a"=>10,"b"=>2,"c"=>30,"d"=>4,"e"=>5]

In particular, using has_key followed by a get or put only requires one
lookup. Also, traversing a range with next_key (or prev_key) followed by gets
and puts can be accomplished in linear time (i.e., next_key requires constant
time, assuming the current key is cached, as do put or get after next_key
caches its result). Currently the four most recently accessed iterators are
cached.

Range Access
------------

These functions access ranges defined on ordered containers. The work on
the unordered containers assuming that "range" is the entire container.

.. function:: elms /stlmap rng
              keys /stlmap rng
              vals /stlmap rng

  Return a list of the elms, keys or vals of rng. E.g.,::

    > elms shm;   // cannot do (shm,k1,k2)
   ["d"=>4,"e"=>5,"a"=>1,"b"=>2,"c"=>3]

   > keys (sm,"b","e");
   ["b","c","d"]

   > vals (sm,"b","e");
   [2,3,4]

.. function:: vector /stlmap rng
              stlvec /stlmap rng

  Return a vector or stlvec containing the elments of rng. E.g., ::

.. function:: stream /stlmap rng
              lazy_map f 

  Lazy versions of (elms rng) and (map f rng). E.g., ::

   > take 3 $ stream smm;
   ("a"=>1):#<thunk 0xb70f438c>

   > list ans;
   ["a"=>1,"b"=>2,"c"=>31]

.. function range_info /stlmap rng

   Returns a tuple (ok, sac, first, last) where ok is true if the range is
   valid, sac is the container that the range points into, and first and last
   iterators that define the range. E.g., ::

   > let ok, smx, f, l = stl::range_info (sm1,"b","e");

   > ok, smx === sm1, stl::elms (f,l);
   1,1,["b"=>2,"c"=>3,"d"=>4]

.. function:: distance /stlmap rng

   Returns the number of elements contained in rng where rng is a range
   defined on an associative container.

Insertion, Erasure and Updating
-------------------------------

Elements can be inserted into associative containers en mass from another
container or individually. In either case, if an item is about to be inserted
in a unique key associative container (stlmap, stlset, stlhmap, stlhset), the
element will not be inserted if the its key is already stored in the target
container. Please note that this behavior is the opposite to that the Pure
standard library's insert which would update the old element to match the
element being inserted.

Of course elements are always inserted into multi key associative
containers. Note also that keys can be equivalent for these purposes even if
they are not equal in other respects. E.g., a set's less than function might
only depend on a particular field of records that are inserted into it.

..function:: insert /stlmap acon src

  Tries to insert elements in a valid "insert source" into an associative
  container, and then returns the number of elements inserted. A valid "insert
  source" is a list, vector, range over a stlvec, or a range over an
  associative container of the same type as acon. If acon is an associative
  map (stlmap, stlmmap or stlhmap), the elements of src must be key value
  pairs of the form (k=>v).

..function:: insert /stlmap acon elm

  If acon is an associative map and elm is a key value pair, (k=>v), attempts
  to insert (k=>v) into acon.  If acon is an associative set, and elm is not a
  valid insert source, attempts to insert elm into acon. If acon is a
  multi-keyed container, returns an iterator pointing to the element with key
  k that was just inserted. If acon is uniquely keyed, returns a pair, the
  first of which is an iterator pointing to the element with key k that was
  just inserted (or the pre-existing element that blocked the insertion). The
  second element in the pair is a boolean value that is true if a new element
  was inserted.

..function:: insert /stlmap acon (elm,p)

  This is the same as the previous function except that (a) p is passed in as
  a hint to where the new element should be inserted and (b) a single iterator
  is returned rather than a iterator,boolean pair. If the new element is
  inserted just after p, the insertion can have constant time complexity.

..function:: insert_elm s elm

  s must be an associative set. This is the same as insert s elm, except that
  insert_elm will attempt to insert elm into s even if it is a valid insert
  source (i.e., lists, vectors, etc., can be inserted in s).

Here are some insert examples::

   > let smx  = emptystlmap;
   > insert smx {"a"=>1,"b"=>2}; elms smx;
   2
   ["a"=>1,"b"=>2]

   > let p, ok = insert smx ("a"=>2); get p,ok; // will not update "a"
   "a"=>1,0

   > put p 2 $ elms smx;  // used iterator p to update "a"'s value to 2
   ["a"=>2,"b"=>2]

   > let smmx = emptystlmmap;
   > insert smmx {"a"=>1,"b"=>2};
     2

   > let p = insert smmx ("a"=>2); get p; // returns iterator only
   "a"=>2

   > elms smmx;
   ["a"=>1,"a"=>2,"b"=>2]

The next two functions can be used to insert new items and update existing
items in an associative map. They return the map rather than the number of
elements inserted so that they can be used with foldl or foldr to insert
elements from another container. 

..function:: insert_or_update acon elm

  If acon is a map, elm must be a key value pair, (k=>v). If acon is
  multi-keyed, a stlmmap, or stlmset, insert elm. If acon is a stlmap/stlhmp,
  insert (k=>v) unless there is an element in acon with key equivalent/equal
  to k. If there is such an element, change its value to v. If acon is a
  stlset/stlhset, insert elm only if acon does not already have an elm that is
  equivalent/equal to elm. Returns acon. E.g.,::

   > let src = ["a"=>1,"b"=>2,"c"=>3,"c"=>4,"c"=>5];

   > elms $ foldl insert_or_update emptystlmmap src;
   ["a"=>1,"b"=>2,"c"=>3,"c"=>4,"c"=>5]

   > elms $ foldl insert_or_update emptystlmap src;
   ["a"=>1,"b"=>2,"c"=>5]

..function:: insert_or_update_with f m (k=>x)

  This function only applies to stlmaps. The effect of this function is as
  follows: (a) if k is not already stored in m, insert (k=>dflt) in m where
  dflt is m's dflt value. (b) put (m,k) nv when nv = f x v end. Returns
  m. E.g.,

   > let src = ["a"=>1,"b"=>2,"c"=>3,"c"=>4,"c"=>5];

   > let lists = foldl (insert_or_update_with (:)) emptystlmap src;
   > elms lists;
   ["a"=>[1],"b"=>[2],"c"=>[5,4,3]]

   > let sums = foldl (insert_or_update_with (+)) (mkstlmap ((<),0)) src;
   > elms sums;
   ["a"=>1,"b"=>2,"c"=>12]

..function:: erase /stlmap acon
             erase /stlmap (acon,k)
             erase /stlmap (acon,i)
             erase /stlmap (acon,k1,k2)
             erase /stlmap (acon,i,j)

  The first form erases all elements in acon. The second erases all elements
  with key equivalent to k. The third erases the element pointed by the
  iterator i. The fourth erases the elements in the range (acon,k1,k2). The
  fifth form erases the elements in the range (i,j), assuming i and j are
  iterators on acon. Note that the fourth and fifth forms only apply to the
  ordered containers, not stlhmap or stlhset. E.g.,::

   > elms smm;
   ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]
   > erase (sm,"z");
   0
   > erase (smm,"c");
   2
   > elms smm;
   ["a"=>1,"b"=>2,"d"=>4,"e"=>5]

   > erase (smm,"b","e");
   2
   > elms smm;;
   ["a"=>1,"e"=>5]

   > elms ss;
   ["a","b","c","d","e"]
   > let _,_,i,j = range_info (ss,"b","e");
   > erase (ss,i,j);
   3
   > elms ss;
   ["a","e"]

List-Like Operations
====================

pure-stlmap provides list like operations that act directly on the underlying
data structures. Additional list like operations, such as scanl, can be
simulated by using elms (or stream) to produce a list of elements and then
applying the operation to the list.

The first two rows of "standard" list-like operations are applicable all six
associative contaners while the last row is applicable only to the ordered
containers.

   * do, map, listmap, catmap, foldl, foldl1

   * rowmap, rowcatmap, colmap, colcatmap

   * foldr, foldr1, filter

Except for their domain, ranges defined on associative containers, these
functions are the same as the corresponding list functions in the Pure
standard Library. E.g.,

   > elms sm;
   ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

   > map (\(k=>v)->k+str v) (sm,"b","e");
   ["b2","c3","d4"]

   > foldr1 (\(k=>v) (ks=>sum)-> (k+ks=>v+sum)) (sm,"b","e");
   "bcd"=>9

   > filter (\(k=>v)->v mod 2) sm;
   ["a"=>1,"c"=>3,"e"=>5]

The list functions provided are sufficient to support list and matrix
comprehensions. ::

   > [ k + str v | (k=>v) = (sm,"b","e")];
   ["b2","c3","d4"]

   > [ k=>v | (k=>v) = sm; v mod 2];
   ["a"=>1,"c"=>3,"e"=>5]

   > { {k;v} |  (k=>v) = sm; v mod 2};
   {"a","c","e";1,3,5}


Set Algorithms
==============

pure-stlmap provides wrappers for the STL set algorithms that apply to ranges
defined on the four ordered associative containers. These algorithms are very
efficient, with linear time complexity, but they do require that the elements
of the two ranges are ordered. Accordingly, the set algorithms are not
applicable to stlhmap or stlhset. Also, when dealing with stlmmaps care must
be taken to ensure that items with the same key are ordered by their
values. If this is not possible, it might be better to use a stlmap with
buckets for values (with appropriately customized less-than and equal
operators).

When applied to the multi-keyed containers, stlmmap and stlmset, these
operations do not necessarily produce the same results as their Pure standard
library counter parts. In particular, when applied to multi-keyed contaners,
set_union is multiset union while (+) in the Pure standard library is the
multiset sum. If you want the multiset sum of a stlmmap or stlhmap, use merge.

..function:: merge /stlmap rng1 rng2

  Construct a new ordered container from rng1 and then insert rng2 and return
  it. rng1 and rng2 must be defined on the same type of ordered container.

..function:: set_union /stlmap rng1 rng2
             set_difference /stlmap rng1 rng2
             set_intersection /stlmap rng1 rng2
             set difference of rng1 and rng2
             set_symmetric_difference /stlmap rng1 rng2
             set difference of rng1 and rng2 as a new sac
             set_includes /stlmap rng1 rng2

   Returns a new ordered associative container of the same type as the ordered
   containers underlying rng1 and rng2. If the ranges are defined over a
   stlmap or stlmmap elements of rng1 have priority over the elments of rng2.

Here are some examples that show how these operations differ from those in the
Pure standard library. ::

   > let smm1 = stlmmap ["a"=>1,"b"=>2,"c"=>31,"c"=>32];
   > let smm2 = stlmmap ["c"=>32,"c"=>32,"c"=>33,"d"=>4,"e"=>5];

   > elms $ merge smm1 smm2; // three "c"=>32
   ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"c"=>32,"c"=>32,"c"=>33,"d"=>4,"e"=>5]

   > elms $ set_union smm1 smm2;  // two "c"=>32
   ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"c"=>32,"c"=>33,"d"=>4,"e"=>5]

   > let sm1 = stlmap ["a"=>1,"b"=>2,"c"=>31];
   > let sm2 = stlmap ["c"=>32,"d"=>4,"e"=>5];

   > elms $ set_union sm1 sm2; // "c"=>31 from sm1, not "c"=>32 from sm2
   ["a"=>1,"b"=>2,"c"=>31,"d"=>4,"e"=>5]

   > elms $ set_intersection sm1 sm2; // "c"=>31 from sm1
   ["c"=>31]


Iterator Interface
==================

Iterator support is provided only for the ordered associative containers,
stlmap, stlset, stlmmap and stlmset. 

Exceptions
----------

Theses functions throw a bad_argument exception if called with an invalid
iterator. An iterator remains valid until the element it was pointing to has
been erased. The also attempt to throw bad argument exceptions for bad uses
that would otherwise result in undefined behavior. E.g., ::


   > let i,j = find sm "a", find sm "d";

   > get i, get j;
   "a"=>1,"d"=>4

   > elms (i,j);
   ["a"=>1,"b"=>2,"c"=>3]

   > catch id $ elms (j,i); // j and i transposed, C++ would segfault
   bad_argument

   > erase (sm,"b");  // erase "b"=>2, leaving i and j valid
   1

   > get i; // still valid
   "a"=>1

   > erase (sm,"a");  // erase "a"=>1 - invalidating i
   1

   > catch id $ get i; // bad iterator exception
   bad_argument


Functions
---------

The functions in this section never cache iterators, on the assumption that if
you call them you are not using the key-oriented functions.

..function:: iterator /stlmap i
             begin acon /stlmap
             pastend acon /stlmap

  Return a new iterator that points to the same element as i, or return
  acon's begin or past-end iterator.

..function:: find acon /stlmap k
 
  Create a new iterator that points to the element with key equivalent to k or
  acon's past-end iterator if none exists.

..function:: lower_bound acon /stlmap k

  Return a new iterator that points to the first element in acon that is not
  less than k, or acon's past-end iterator if none exists.
 
..function:: upper_bound acon /stlmap k

  Return a new iterator that points to the first element in acon that is
  greater than k, or acon's past-end iterator if none exists.
 
..function:: equal_range acon /stlmap k

  Return the pair lower_bound acon k, upper_bound acon k.

..function:: inc /stlmap iter
             dec /stlmap iter
             move /stlmap iter n
  
  Move iter forward one, back one or forward n elements respectively, where n
  can be negative.  The iterator us mutated by these operations, provided the
  move is successful. An attempt to move to a position before the first
  element's position causes a out-of-bounds exception. Moves past the last
  element return the acon's past-end iterator

..function:: get i
             get_key i
             get_val i

  Return the element pointed to by the iterator i, or the element's key or
  value. For maps the element is returned as a key=>value hash rocket
  pair. For sets, get_elem, get_key and get_val all return the element (which
  is the same as its key).

..function:: put_val i newvalue

  Change the value of the element pointed to by i to newvalue. The elements
  key cannot be changed. The iterator must point into a map, not a set.

..function:: is_begin /stlmap i
             is_pastend /stlmap i

  Returns true if the iterator i is it's acon's begin iterator or its pastend
  iterator.

..function:: get_info /stlmap i

  Returns a tuple (is_valid,acon,key,val) where is_valid is true if the
  iterator i is valid or false if not, acon is the acon that i points into,
  and key, val are the key and value of the element i points to, if any. If i
  is the past-end iterator, key and value are FIX.

.. function:: infix == /stlmap i j
   
   Returns true if the iterators i and j point to the same element.

 .. function:: infixr ^ /stlmap m k

   Returns an iterator pointing to the element in m, a stlmap, with key k. If
   no such element existed before the call, one is created using map's default
   value.

Here are some examples using iterators. 

   > let b,e = begin smm, pastend smm;

   > elms (b,e);
   ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

   > let i,j = equal_range smm "c";

   > elms (b,i);
   ["a"=>1,"b"=>2]

   > elms (i,j);
   ["c"=>31,"c"=>32]

   > elms (j,e);
   ["d"=>4,"e"=>5]

   > get i;
   "c"=>31

   > get (inc i);
   "c"=>32

   > put i 132;
   132

   > map (\(k=>_)->k=>ord k) (b,i);
   ["a"=>97,"b"=>98,"c"=>99]

   > let is_set, smm1, k, v = get_info i; is_set, elms smm1, k, v;
   1,["a"=>1,"b"=>2,"c"=>31,"c"=>132,"d"=>4,"e"=>5],"c",132

   > get (dec j);
   "c"=>132

   > inc j $$ inc j $$ get j;
   "e"=>5

   > inc j $$ is_pastend j;
   1


 
