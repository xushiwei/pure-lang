
--- DRAFT - FOR DISCUSSON PURPOSES ONLY ---

===========
pure-stlmap
===========

.. default-domain:: pure
.. module:: stlmap

Version @version@, |today|

| Peter Summerland <p.summerland@gmail.com>

pure-stlmap is a Pure interface to six associative containers provided by a
part of `C++'s Standard Library`_ that is often refered to as the Standard
Template Library ("STL"). The interface provides access to the STL's four
ordered associative containers, map, set, multimap and multiset, and two of
its unordered associative containers, unordered_map and unordered_set,
specialized to hold pointers to arbitrary Pure expressions.

.. _Pure: http://pure-lang.googlecode.com

.. contents::
.. sectnum::


Copying
=======

| Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved. 

pure-stlmap is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. 

pure-stlmap is distributed under a BSD-style license, see the COPYING file
for details.

Installation
============

pure-stlmap-@version@ requires at least Pure 0.48. The latest version of Pure
is available at http://code.google.com/p/pure-lang/downloads/list.

The latest version of the source code for pure-stlmap can be downloaded from
http://pure-lang.googlecode.com/files/pure-stlmap-@version@.tar.gz.
 
To install pure-stlmap (on Linux), extract the source code (e.g., tar -xzf
pure-stlmap-@version@.tar.gz), cd to the pure-stlmap-@version@ directory, and
run ``make``. After this you can (and should) also run ``make test`` to run a
few unit tests to make sure that pure-stlmap works properly on your system. If
``make test`` works, run ``sudo make install`` to install pure-stlmap on your
system.  ``make`` tries to guess your Pure installation directory and
platform-specific setup. If it gets this wrong, you can set some variables
manually. In particular, ``make install prefix=/usr`` sets the installation
prefix. Please see the Makefile for details.

Introduction
============

Part of the Standard C++ Library`_ that is often refered to as the standard
template library ("STL") provides templates for generic containers and generic
algorithms. pure-stlmap provides an interface to the STL's associative
containers: map, set, multimap and multiset and two of its unordered
associative containers: unordered_map and unordered_set, specialized to
hold arbitrary Pure expressions.

.. _C++ standard library documentation: http://en.cppreference.com/w/cpp

pure-stlmap provides six containers "stlmap", "stlset", "stlmmap", "stlmset",
"stlhmap" and "stlhset" that are thin wrappers around the corresponding
associative containers provided by the STL, specialized to hold keys and
values that are arbitrary Pure expressions. pure-stlmap does not provide
wrappers for unordered_multimap and unordered_multiset. In addition, the
interfaces for stlhmap and stlhset are limited compared to those provided for
the other four (ordered) associative containers. 

Correspondence with the Native Interface
----------------------------------------

Most of the functions provided by the STL for maps, multimaps, sets and
multisets, and some of the functions for unordered_maps and unordered_sets,
have corresponding functions in pure-stlmap. When provided, the corresponding
functions provided by pure-stlmap have *exactly the same semantics* as the STL
functions, which in some cases is different than that of similar functions
provided by the standard Pure library for similar containers. In addition, the
STL set algorithm functions are provided, including merge and includes, all
with STL semmantics, which again, have different semmantics than corresponding
functions provided by similar Pure library containers.

One advantage of this approach is that users can consult the STL documentation
and many books and articles to understand the performance characteritics and
corner case behavior of any pure-stlmap function that has a corresponding
function in the STL. In addition calling underlying STL functions such the set
operations, swap, or copy on a one to one basis preserves O(n) time complexity
behavior that are difficult to match if the operations are reimplemented by
hand in order to conform to Pure standard library behavior. A disadvantage is
that the behavior of some of the pure-stlmap functions including "insert" and
the set operations will sometimes (depending on the container) be different
than the corresponding functions applicable to containers in the Pure standard
library.

Functional Programming Interface
--------------------------------

pure-stlmap provides functions to extract lists of a container's elements,
keys or values or extract its elements as a lazy list. Functions that map,
filter or fold elements are also provided. These functions *directly* on the
underlying STL container. Except for the unordered associative containers,
stlhmap and stlhset, these functions can act on a subsequence or "range" of
elements instead of all of the elments. Conversion functions are provided for
copying ranges to and from lists, vectors, other pure-stlmap containers, and
stlvecs.

Keys Values and Elements
------------------------

The three map containers associate values with keys. If v is associated with k
in a map contianer, m, then we say that (k=>v) is an element of m that k is
stored in m. The three set containers only have elements. If e is contained a
set container, s, we say that e is and element of s, that e is stored in s and
that s has key e. In other words, we sometimes spead of a set container as if
it were a map whose elements are the same as its keys. All six of the
containers are mutable. map, set, unordered_map and unordered_set all have
unique keys. multimap and multiset can have multiple element with the same
key.

Iterators and Ranges
--------------------

The native STL interface is based on "iterators" that point to elements in the
container. Given a valid iterator you can access, modify or erase the element
it points to.  Given two iterators pointing into a container aoc, i and j, the
range (i,j), denoted aoc's elements starting with "aoc[i]" the element pointed
to by j up to but not including the aoc[j]. In pure-stlmap, this range is
denoted by the tuple (i,j).

In pure-stlmap it is also possible to define a range using keys. Given an
ordered associative container, aoc, and keys k and l, the range (aoc,k,l)
consists of all of the elements in aoc starting with the first element that is
greater or equal to k up to but not including the first element that is
greater or equal to l. Note that k and l do not have to be stored in aoc. Here
are some examples::

   > let sm1 = stlmap {"a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5};

   > elms sm1;
   ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

   > elms (sm1,"b","e");
   ["b"=>2,"c"=>3,"d"=>4]

   > let i = stl::find sm1 "b";

   > let j = stl::find sm1 "e";

   > elms (i,j);
   ["b"=>2,"c"=>3,"d"=>4]

Please note that pure-stlmap provides iteraters and support for ranges only
for the four ordered associative containe.  Support for ranges is not provided
for the unordered associtiave containers, stlhmap and stlhset.

Usage
=====

After installation of pure-stlmap (and pure-stlvec), you can use the operations
of this package by placing one or more the following import declarations in
your Pure programs::

  using stlmap;
  using stlmmap;
  using stlhmap;

Types
=====

The stlmap module introduces the two ordered uniquely-keyed associatice
containers along with their corresponding iterators and ranges:
 
.. type:: stlmap /type
          stlset /type
          stlacon /type

  Ordered associative containers corresponding to the STL's map and set. stlacon
  includes stlmap and stlset.

Please note that in general, "acon" means (ordered) associative container
(with unique keys), "macon" means multi-key ordered container and "hacon"
means hashed associative container (i.e., unordered with unique keys).

.. type stlmap_iter /type
        stlset_iter /type
        stlacon_iter /type

  Iterators on stlmap and stlse. stlacon_iter includes stlmap_iter and
  stlset_iter.

.. type stlacon_rng /type

  A range of elements in an ordered associative container.

The stlmap module also introduces the multi-keyed ordered associative
containers along with their corresponding iterators and ranges

.. type:: stlmmap /type
          stlmset /type
          stlmacon /type

  Ordered associative containers corresponding to the STL's map and set. stlacon
  includes stlmmap and stlmset.

.. type stlmmap_iter /type
        stlmset_iter /type
        stlmacon_iter /type

  Iterators on stlmmap and stlmset. stlacon_iter includes stlmmap_iter and
  stlmset_iter.

.. type stlmacon_rng /type

  A range of elements in a multi-keyed ordered associative container.

Finally, the stlhmap module also introduces the "hashed" or unordered
associative containers. Note that no iterators or ranges are provided.

.. type:: stlhmap /type
          stlhset /type
          stlhacon /type

  Ordered associative containers corresponding to the STL's map and set. stlacon
  includes stlmap and stlset.

Container Operations
====================

Please note that ranges and iterators are not implemented in pure-stlmap for
the unordered containers. Accordingly whenever the documentation of a function
refers to a range, and the container in question is a a stlhmap or stlhset,
the range simply refers to the container itself.

Required Container Operations
-----------------------------

Empty containers can be constructed using the full range of constructor
parameters. Containers constructed from directly from lists, vectors or other
sources use the default values. 

The constructors for the four ordered associative containers, stlmap, stlset,
stlmmap and stlmset all have a required parameter, kcmp, that is used to
determine if one key is less than another. kcmp is sometimes used to determine
if two keys are "equivalent", i.e., neither key is less than the other. The
constructors for the two unordered associative constructors have a required
parameter, khash, that is used to hash the key for hash table lookup. The
remaining parameters, vcmp, veql and keql are optional. vcmp and veql are used
to determine if one value is less than another or equal to another,
respectively. keql is used to determine if one key is equal to another.

The constructor for stlmap has an optional parameter that is a default value
for v in (k=>v). The constuctors for stlmap and stlmmap have 

.. function:: emptystlmap (kcmp,dflt,vcmp,veql)
              emptystlmmap (kcmp,vcmp,veql)
              emptystlset kcmp
              emptystlmset kcmp
              emptystlhmap (khash,keql,veql)
              emptystlhset (khash,keql,veql)

   create a new SAC. The key comparison and hash functions, kcmp and khash are
   required, the other parameters are optional. The default values for dflt,
   vcmp, veql and keql are [], (<) (==) and (==) respectively.

.. function:: stlmap /stlmap src
              stlmmap /stlmmap src
              stlset /stlmap src
              stlmset /stlmmap src
              stlhmap /stlhmap src
              stlhset /stlhmap src

   create an associative constuctor with (<) as kcmp and hash as khash (with
   standard default values) [] (<) and insert elements from src. src can be a
   list, vector, stlvec range or container of the same type as the new
   container. If the new container is one of the three maps, the elements of
   src must (k=>v) hash-rocket pairs.

After a stlhmap or stlhset is created, it is possible to adjust the
max_load_factor and number of buckets.

.. function:: hash_reserve hacon mlf size

   Sets hacon's max_load_factor to mlf, sets the number of buckets to size/mlf
   and rehashes hacon.

.. function:: container_info /stlmmap acon

   If acon is an ordered associative container, returns (is_set, kcmp, dflt,
   vcmp, veql). If is set is true, dflt, vcmp, and veql will be random values
   that should not be used. If acon is unordered, returns (is_set,
   bucket_count, load_factor, max_load_factor, khash, keql, veql).

..function:: swap /stlmap acon1 acon2

  swap the elements of the two containers of the same type

.. function:: prefix # /stlmap acon

   Returns the number of elements in acon.

.. function:: empty /stlmap acon

   returns true if acon is empty, else 0.

.. function:: infix == /stlmap acon1 acon2
              infix ~= /stlmap acon1 acon2

  returns true if the two associative containers are equal (or not equal),
  else 0. acon1 and acon2 must be the same type of container or the operatons
  will fail. They are considered equal all of their elements are equal, i.e.,
  their keys are equal and their values, if any are equal. For the ordered
  containers, two keys are considered equal if they are equivalent (i.e.,
  neither is less than the other).

.. function:: infix <  /stlmap rng1 rng2
              infix >  /stlmap rng1 rng2
              infix <= /stlmap rng1 rng2
              infix >= /stlmap rng1 rng2

  The first operator, <, returns true if the first range, rng1, is
  lexicographically less than the second rng2. The other three operators
  are the same as rng2 < rng2, ~(rng1>rng2) and ~(rng1<rng2). The ranges
  must be on the same type of ordered container.

Key Oriented Functions
----------------------

.. function:: count /stlmmap acon k
              has_key /stlmmap acon k

   Return the number of elements that have k as key; or 1 if there is such a
   key or 0 if not, respectively.

.. function infix ! /stlmap acon k

   If acon is not a stlmmap, then if acon has an element with key k return its
   value (or matching key if acon is a set), otherwise throw an out_of_bounds
   exception. If acon is a stlmmap, if acon has as least one element with key
   k return a list of values of all the elements with key k, otherwise return
   an empty list.

.. function:: get (acon,k)

   Same as (!).

.. function:: put (acon,k) v

   Associate v with k in acon wher acon is a stlmap, stlmmap or stlhmsp.
   If (k=>v) is not an element of acon, or if acon is a stlmmap, insert (k=>v).
   Otherwise update the value associated with k in acon to v. 

.. function:: bounding_keys rng

   Assume that acon the container that contains rng.  Return a pair of keys,
   first and last, such that for k where k is the key of and element in rng
   first <= k < last. If there is no such last, the second member of the
   returned pair will be stl::stlend. If first is the key of the first element
   of acon, the first member of the returned pair will stl::stlbeg.

.. function:: next_key acon k
              prev_key acon k

   next_key returns the key of the first element in acon that has a key that
   is greater than k. If no such element exists or if k is stl::stlend, return
   stl::stlend. prev_key returns the last element in acon that has a key that
   is less that k, or, if no such element exists, throws an out_of_bounds
   execption.

Range Access
------------

.. function:: elms rng
              keys rng
              vals rng

  Return a list of the elms, keys or vals of rng.

.. function:: vector rng
              stlvec rng

  Return a vector or stlvec containing the elments of rng.

.. function:: stream rng
              lazy_map f 

  Lazy versions of (elms rng) and (map f rng). 

.. function range_info /stlmap rng

   Returns a tuple (ok, sac, first, last) where ok is true if the range is
   valid, sac is the container that the range points into, and first and last
   iterators that define the range. E.g., ::

   > let ok, smx, f, l = stl::range_info (sm1,"b","e");

   > ok, smx === sm1, stl::elms (f,l);
   1,1,["b"=>2,"c"=>3,"d"=>4]

.. function:: distance /stlmap rng

   Returns the number of elements contained in rng where rng is a range
   defined on an ordered associative container. 

Insertion, Erasure and Updating
-------------------------------

Elements can be inserted into associative containers en mass from another
container or individually. In either case, if an item is about to be inserted
in a unique key associative container (stlmap, stlset, stlhmap, stlhset), the
element will not be inserted if the its key is already stored in the target
container. Please note that this behavior is the opposite to that the Pure
standard library's insert which would update the old element to match the
element being inserted. (Sorry -- TTWGPI). But all is not lost -- see
insert_or_update.

Of course elements are always inserted into multi key associative
containers. Note also that keys can be equivalent for these purposes even if
they are not equal in other respects. E.g., a set's less than function might
only depend on a particular field of records that are inserted into it.

..function:: insert /stlmap acon src
             insert /stlmap acon elm
             insert /stlmap acon (elm,p)

  Inserts elements into an associative container and return the number of
  elements inserted. If src is a list, vector, range over a stlvec, or a range
  over an associative container of the same type as acon. If acon is an
  associative map (stlmap, stlmmap or stlhmap), the elements of src must be
  key value pairs of the form (k=>v). If m is an associative map insert (k=>v)
  into m. If acon is an associative set and k is not an an object treated as
  src (i.e., list, vector ...) insert k into s. If p is added it is an
  interator that hints where the element should be inserted.
  
..function:: insert_elm s k

  Inserts k into associative set s, provided k is not already stored in s.

The next two functions can be used to insert new items and update existing
items in an associative map. They return the map rather than the number of
elements inserted so that they can be used with foldl or foldr to insert
elements from another container. 

..function:: insert_or_update m (k=>v)

  Inserts (k=>v) into m, an associative map. If m is a stlmap or stlhmap, and
  m contains an element with key equivalent to k, updates the elements value
  to v. Returns m. I.e., this function is the same as Pure standard library's
  insert function.

E.g., use foldl to insert elements from a stlhmap into stlmap.

..function:: insert_or_update_with f m (k=>x)

  This function only applies to stlmaps. The effect of this function is as
  follows: (a) if k is not already stored in m, insert (k=>dflt) in m where
  dflt is m's dflt value. (b) put (m,k) nv when nv = f x v end. Returns m.

E.g., use (+) to count words.

..function:: clear /stlmap acon

..function:: erase /stlmap (acon,k)
             erase /stlmap (acon,i)
             erase /stlmap (acon,k1,k2)
             erase /stlmap (acon,i,j)

  The first form erases all elements with key equivalent to k. The second form
  erases the element pointed by the iterator i. The third form erases the
  elements in the range (acon,k1,k2). The forth form erases the elements in
  the range (i,j), assuming i and j are iterators on acon. Note that the third
  and forth forms only apply to the ordered associative containers, not
  stlhmap or stlhset.

List-Like Operations
====================

The operations described in this section are like their list
counterparts. They apply to ranges defined the ordered associative containers
(but not to stlhmap or stlhset). The functions in the first list operate
directly on the underlying data structure while those in the second list
operate on an intermediate list produced by listmap.

   * do, map, listmap, catmap, foldl, foldl1, foldr, foldr1, filter

   * rowmap, rowcatmap, colmap, colcatmap

The functions in the second row, and listmap, make it possible to stlmap,
stlset, stlmmap and stlmset as generators in list and matrix comprehensions.

Set Algorithms
==============

The set algorithms apply to ranges defined on the four ordered associative
containers. They assume that the elements of the two ranges are ordered. Thus,
when dealing with stlmmaps care must be taken to ensure that items with the
same key are ordered by their values. These functions are thin wrappers around
the corresponding STL functions which ensures that they have linear time
complexity.

..function:: merge /stlmap rng1 rng2

  construct a new sac from rng1 and then insert rng2 and return it

..function:: set_union /stlmap rng1 rng2
             set_difference /stlmap rng1 rng2
             set_intersection /stlmap rng1 rng2
             set difference of rng1 and rng2
             set_symmetric_difference /stlmap rng1 rng2
             set difference of rng1 and rng2 as a new sac
             set_includes /stlmap rng1 rng2

   Returns a new ordered associative container of the same type as rng1 and
   rng2. The for stlmaps and stlmmaps elements of rng1 have priority over the
   elments of rng2.

Iterators
=========

Iterator support is provided only for ordered associative containers, stlmap,
stlset, stlmmap and stlmset. An iterator remains valid until the element it
was pointing to has been erased. The iterators are mutable in the sense that
there are functions available to move them around the container.


..function:: iterator /stlmap i
             begin acon /stlmap
             pastend acon /stlmap

  Return a new iterator that points to the same element as i, or return
  acon's begin or past-end iterator.

..function:: find acon /stlmap k
 
  Create a new iterator that points to the element with key equivalent to k or
  acon's past-end iterator if none exists.

..function:: lower_bound acon /stlmap k

  Return a new iterator that points to the first element in acon that is not
  less than k, or acon's past-end iterator if none exists.
 
..function:: upper_bound acon /stlmap k

  Return a new iterator that points to the first element in acon that is
  greater than k, or acon's past-end iterator if none exists.
 
..function:: equal_range acon /stlmap k

  Return the pair lower_bound acon k, upper_bound acon k.

..function:: inc /stlmap iter
             dec /stlmap iter
             move /stlmap iter n
  
  Move iter forward one, back one or forward n elements respectively, where n
  can be negative.  The iterator us mutated by these operations, provided the
  move is successful. An attempt to move to a position before the first
  element's position causes a out-of-bounds exception. Moves past the last
  element return the acon's past-end iterator

..function:: get i
             get_key i
             get_val i

  Return the element pointed to by the iterator i, or the element's key or
  value. For maps the element is returned as a key=>value hash rocket
  pair. For sets, get_elem, get_key and get_val all return the element (which
  is the same as its key).

..function:: put_val i newvalue

  Change the value of the element pointed to by i to newvalue. The elements
  key cannot be changed. The iterator must point into a map, not a set.

..function:: is_begin /stlmap i
             is_pastend /stlmap i

  Returns true if the iterator i is it's acon's begin iterator or its pastend
  iterator.

..function:: get_info /stlmap i

  Returns a tuple (is_valid,acon,key,val) where is_valid is true if the
  iterator i is valid or false if not, acon is the acon that i points into,
  and key, val are the key and value of the element i points to, if any. If i
  is the past-end iterator, key and value are FIX.

.. function:: infix == /stlmap i j
   
   Returns true if the iterators i and j point to the same element.

 .. function:: infixr ^ /stlmap m k

   Returns an iterator pointing to the element in m, a stlmap, with key k. If
   no such element existed before the call, one is created using map's default
   value.
