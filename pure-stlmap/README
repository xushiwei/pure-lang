
--- DRAFT - FOR DISCUSSON PURPOSES ONLY ---

===========
pure-stlmap
===========

.. default-domain:: pure
.. module:: stlmap

Version @version@, |today|

| Peter Summerland <p.summerland@gmail.com>

Pure's interface to C++ vectors, specialized to hold pointers to arbitrary
Pure expressions, and the C++ Standard Template Library algorithms that act on
them.

.. _Pure: http://pure-lang.googlecode.com

.. contents::
.. sectnum::

Copying
=======

| Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved. 

pure-stlmap is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. 

pure-stlmap is distributed under a BSD-style license, see the COPYING file
for details.

Installation
============

pure-stlmap-@version@ requires at least Pure 0.48. The latest version of Pure
is available at http://code.google.com/p/pure-lang/downloads/list.

The latest version of the source code for pure-stlmap can be downloaded from
http://pure-lang.googlecode.com/files/pure-stlmap-@version@.tar.gz.
 
To install pure-stlmap (on Linux), extract the source code (e.g., tar -xzf
pure-stlmap-@version@.tar.gz), cd to the pure-stlmap-@version@ directory, and
run ``make``. After this you can (and should) also run ``make test`` to run a
few unit tests to make sure that pure-stlmap works properly on your system. If
``make test`` works, run ``sudo make install`` to install pure-stlmap on your
system.  ``make`` tries to guess your Pure installation directory and
platform-specific setup. If it gets this wrong, you can set some variables
manually. In particular, ``make install prefix=/usr`` sets the installation
prefix. Please see the Makefile for details.

Overview
========

The C++ Standard Template Library ("STL") is a library of generic containers
(data structures designed for storing other objects) and a rich set of generic
algorithms that operate on them. pure-stlmap provides an interface to the
STL's "sorted associative" containers: map, set, multimap and multiset. These
containers associate keys with values. Map and multimap associate keys with
values and provide fast insertion, removal and retrieval of elements based on
keys. Set and mulitset provide fast insertion and removal of elements and very
fast set operations. 

In the following, maps and multimaps contain elements, each of which has a key
and value. The element is sometimes denoted by (k=>v). Set and multisets
really only have elements, but it is convenient to treat them as if they had
keys, where an element's key is just the element itself.

Maps and sets have unique keys while multimaps and multisets can have elements
with duplicate keys. All four of the containers keep their elements sorted by
key. 

pure-stlmap provides four containers "stlmap", "stlset", "stlmmap" and
"stlmset" that are thin wrappers around the corresponding sorted associative
containers provided by the STL, specialized to hold keys and values that are
arbitrary Pure expressions. 

All of the member functions provided by the STL for maps, multimaps, sets and
multisets have corresponding functions in pure-stlmap. The corresponding
functions provided by pure-stlmap have *exactly the same semantics* as the STL
functions, which in some cases is different than that of similar functions
provided by the standard Pure library for similar containers. In addition, the
STL set algorithm functions are provided, including merge and includes, all
with STL semmantics, which again, have different semmantics than corresponding
functions provided by similar Pure library containers. Thus users can consult
the STL documentation and many books and articles to understand the
performance characteritics and corner case behavior of any pure-stlmap
function that has a corresponding function in the STL.

Pure-to-STL "bridge" functions such as elms, keys, vals, map, filter, and fold
functions are provided to convert container contents to lists or lazy
lists. These functions work with ranges and act *directly* on the underlying
STL container. Conversion functions are provided for copying ranges to and
from lists, vectors, other pure-stlmap containers, and stlvecs.

Iterator and Key-Based Interfaces
=================================

The native STL interface is based on "iterators" that point to elements in the
container. As mentioned, pure-stlmap provides functions faithfully replicate
the functions provided by the native STL interface, assuming that the result
is defined. Rather than just letting such situations run their course,
pure-stlmap attempts to detect them and throw a "bad_argument"
exception. I.e., pure-stlmap will throw a bad_argument exception when
confronted with invalid iterators or invalid ranges that would have
undefined results if passed on to the underlying STL functions.

The native STL interface is very compact; only a handful of functions are
required to work effectively with the container.. Given a key, one can obtain
an iterator that points to the first element with this key or the element
following the last element with this key and so on. After obtaining an
interator one can retrieve, erase the element or modify its value (for maps
and multimaps). 

Given a pair of iterators, one can access, erase or modify all of the elements
in the "range" defined by the pair, namely elements starting with the element
pointed to by the first iterator up to but not including the element pointed
to by the last iterator. In this regard, there is a "pastend" iterator allows
one to designate arange that includes the last element in the
container. Sometimes we refer to a container's past-end element, which is not
really a member of the container, which would appear after all of the
container's elments if it were added to the container. Iterators can be moved
forward or backward through the sorted elements one step at a time. One
advantage of using iterators is that

In addition to the iterator based interface, pure-stlmap provides a higher
level key-based interface which is well suited for stlmap, stlset,
stlmset. For stlmmaps, where non-equivalent elements can have the same key, it
is often easier to use the STL iterator-based interface. Also, the iterator
based interface may be preferred by programmers that are already familiar with
the STL.

Modules
=======

using stlmap, stlmmap;
stlvec must be installed
STL namespace


Mini Tutorial
=============

Here are some examples that use the basic operations on a stlmap ::

   > using stlmap; using namespace stl;

Make stlmap from a vector::

   > let sm1 = stlmap {"a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5};

Get value associated with "a" ::

   > sm1!"a";
   1

List all elements in sm1 ::

   > elms (sm1,stlbeg,stlend);
   ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

Make a lazy list of elements and take 3 of its elements

   > lazy_elms sm1;
   ("a"=>1):#<thunk 0xb7087918>

   // take some elements from the lazy list
   > list $ take 3 (lazy_elms sm1);
   ["a"=>1,"b"=>2,"c"=>3]

Update ("a"=>1) to ("a"=>10) using update and update_elm, pure-stlmap's
"update or insert" functions. Note that update_elm the same as update except
that the key and value are designated as hash rocket pair. The corresponding
functions applicable to Pure standard library containers are update and
insert. pure-stlmap uses "update_elm" instead of "insert" so that insert, when
applied to a pure-stlmap container, can reflect STL semantics. In particular,
when applied to a stlmap, sm, insert sm (k=>v) will NOT change the stlmap in
any way if sm already contains and element with key k.  

   > update sm1 "a" 10 $$ elms sm1;
   ["a"=>10,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

   > update_elm sm1 ("f"=>6) $$ elms sm1;
   ["a"=>10,"b"=>2,"c"=>3,"d"=>4,"e"=>5,"f"=>6]

Insert from a list. Note that the value associated with "b" is not changed
because "b" is already stored in sm1. "g"=>7 is inserted. 

   > insert sm1 ["b"=>12,"g"=>7] $$ elms sm1;
   ["a"=>10,"b"=>2,"c"=>3,"d"=>4,"e"=>5,"f"=>6,"g"=>7]

A number of mapping, filtering, and folding operations are provided. They act
on the underlying STL structure as opposed to operating on a tempory list.
These examples map, lazy_map and foldr over ranges in sm1. The map and
lazy_map are over a the range in sm1 consisting of all elements with keys
stored in sm1 beginning with "b" and ending with the last key less than "e". ::

   // map over range in sm1
   > map (\(k=>v)->k=>2*v) (sm1,"b","e");
   ["b"=>4,"c"=>6,"d"=>8]

   > lazy_map (\(k=>v)->k=>2*v) (sm1,"b","e");
   ("b"=>4):#<thunk 0xb707f434>

   > foldr (\(k=>v) (ks,sum)-> (k+ks,v+sum)) ("",0) sm1;
   "abcdefg",38

   > filter (\(k=>v)->v mod 2) sm1;
   ["a"=>11,"c"=>3,"e"=>5,"g"=>7]

Erase erase all elements with key == "a" and then erase all elements in the 
range defined by a pair of iterators.

   > erase sm1 "a" $$ elms sm1;
   ["b"=>2,"c"=>3,"d"=>4,"e"=>5]

   > let i_c, i_d, i_end = equal_range sm1 "c", pastend sm1;
 
   > get_elm i_c, get_elm i_d, is_pastend i_end;
   "c"=>3,"d"=>4,1

   > elms (i_d, i_end);
   ["d"=>4,"e"=>5]
   
   > erase sm1 (i_d, i_end); elms sm1;
   ["b"=>2,"c"=>3]

Note that the erasure renders i_d invalid (but i_c and i_end remain valid).

   > let ok_d, _ = get_info i_d; ok_d;
   0

   > catch id $ get_elm i_d;
   bad_argument

   > let ok_c, _ = get_info i_c; ok_c;
   1

   > get_elm i_c;
   "c"=>3

All of the basic set operations are provided by calls to the STL set
algorithms all of which have O(n+m) complexity.

   > let sm1 = stlmap {"a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5};

   > let sm2 = stlmap {"c"=>13,"d"=>14,"e"=>15,"f"=>16};

   > elms $ set_union sm1 sm2;
   ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5,"f"=>16]

   > elms $ set_union sm2 sm1;
   ["a"=>1,"b"=>2,"c"=>13,"d"=>14,"e"=>15,"f"=>16]

   > elms $ set_intersection sm2 sm1;
   ["c"=>13,"d"=>14,"e"=>15]

   > elms $ set_difference sm2 sm1;
   ["f"=>16]

   > elms $ set_difference sm1 sm2;
   ["a"=>1,"b"=>2]

Note the difference between set_union sm1 sm2 and set_union sm2 sm1. This
difference reflects the fact the elements of the map on the left are inserted
into the resulting union before elements with the same key from the map on the
right. 

======================
Container Construction
======================

stlmaps and stlmmaps can be constructed as empty containers or from sequences
of key-value pairs, (k=>v). Empty containers can be constructed using the full
range of contructor parameter: a key-less-than function that orders the map's
keys, a default value, a value-less-than function that orders the maps values
and a value-equal function that determines if two values are equal. Containers
constructed from directly from lists, vectors or other sources use the default
values.

Please note that there is no function to determine if two keys are equal. All
the STL functions care about is if one key is less than another or if two keys
are "equivalent". Two keys, k1 and k2, are equivalent for these purposes if
~(k1<k2) && ~(k2<k1), where < is the container's key-less-than function.

emptystlmap (kcmp,dflt,vcmp,veql)
emptystlmap (kcmp,dflt,vcmp)
emptystlmap (kcmp,dflt)
emptystlmap kcmp

emptystlmmap (kcmp,dflt,vcmp,veql)
emptystlmmap (kcmp,dflt,vcmp)
emptystlmmap (kcmp,dflt)
emptystlmmap kcmp

Create a new stlmap or stlmmap with the indicated parameters. The default
values for dflt, vcmp and veql are (<), (==) and [].

stlmap xs
stlmap svrng
stlmap smrng

stlmmap xs
stlmmap svrng
stlmmap smmrng

Create a new stlmap or stlmmap using (<) emptystlmap (<) and insert elements
from xs, svrng, smrng or smmrng. See insert.

emptystlset kcmp
emptystlmset kcmp

Create a new stlset or stlmset using kcmp to order the elements.

stlset xs
stlset svrng
stlset smrng

stlmset xs
stlmset svrng
stlmset smmrng

=========
Iterators
=========

Iterators are constructed by the following functions. A fresh iterator is
returned.

iterator i
begin sac k
pastend sac k
find sac k
lower_bound sac k
upper_bound sac k
equal_range sac k

iterator constructs a new iterator that points to the same postion as
iter. begin returns an iterator pointing to the first element in sac. pastend
returns the past-end iterator. find returns an iterator pointng to an element
in sac with key equivalent to k. lower_bound returns an iterator pointing to
the first sac element with key not less than k. upperbound returns an iterator
pointing to the first sac element with key greater than k. equal_range returns
lower_bound and upper_bound as a pair. All of the functions that depend on k,
if no sac element satisfies the condition sac's past-end iterator is returned
in lieu of the desired iterator.

Iterators can be moved through the sequence consisting of a sac's
elements. The iterators are mutated by these operations, provided move is
successful. An attempt to move to a position before the first element's
position causes a out-of-bounds exception. Moves past the last element
return the sac's past-end iterator.

inc iter
dec iter
move iter n

The element pointed to by an iterator can be accessed or modified. For sets,
get_elm, get_key and get_val all return the same value. Only the value can be
changed; put_val will fail if called on a set iterator.

get_elm i
get_key i
get_val i
put_val i

It is useful to know if an iterator is pointing at the first element of a SAC,
the the past-end position or if the iterator is valid. An iterator is invalid
if the element it was pointing to has been erased.

is_begin i
is_pastend i
get_info i

get_info returns (true,sac,key,val) if i is valid and (false,_,_,_) if it is
not.

Two operators are provided. The first, (==) applies to all SACs. The second,
(^) only applies to stlmaps. The (^) operator based on the C++ [] operator. In
C++ sac[k] creates a reference to an element in sac with key k. If k is not
stored in sac before the call, a new element (k=>T()) is inserted, where T()
is the default value for values associated with keys in sac.

 i == j
 m^k

The first is true if i and j point to the same element in sac, where i and j
are iterators with the same underlying sac. The second returns an iterator
pointing to the an element in m, a stlmap, with key k. If no such element
existed before the call, one is created using sac's default value.

======
Ranges
======

Many of the functions that operate on SACs operate on ranges. Ranges are
designated by a pair of iterators, (first, last) where first points to an
element that is not greater than the element pointed to by last. The range is
the sequence of elements that begins with the element pointed to by first and
ends with the last element that is less than the element pointed to by
last. For these purposes the past-end iterator can be thought of as pointing
to a "past-end element" that is greater than all elements that can be inserted
in the container.

Eg.  -- with iterators


Range Info
----------

parameters sac
range_info rng

parameters returns a tuple (is_set, kcmp, dflt, vcmp, veql) where kcmp, dflt,
vcmp, veql are the parameters used to set up the sac (see Container
Construction). range_info returns a tuple (ok, sac, first, last) where ok is
true if the range is valid, sac is the container that the range points into,
and first and last iterators that define the range. E.g.,

   let sm1 = stl::stlmap ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5];
   //- ()

   stl::parameters sm1;
   //- 0,(<),[],(<),(==)

   let ok, smx, f, l = stl::range_info (sm1,"b","e"); ok;
   //- 1

   ok, stl::elms (f,l);
   1, ["b"=>2,"c"=>3,"d"=>4]

size rng
empty rng
is_set rng
count sac key

These functions return the size of range, whether a range is empty, if the
range is a stlset or stlmset, and the number elements in a container have a
given key.

====================
Container Operations
====================

Very simple: constructors, access through iterators. Then insert, erase,
clear, swap.

===============================
Using Keys in lieu of Iterators
===============================

Often it is convenient to work with containers using keys, as opposed to
iterators, to designate elements and ranges. This is especially likely to be
the case for stlmaps and stlsets where there is a one-to-one correspondence
between iterators and keys.


 For stlmmaps and stlmsets, it is
sometimes necessary to use iterators to locate and work with specific
elements.

Accessing and Updating Elements
-------------------------------

In the native STL interface, one uses a key to obtain an iterator that points
to a key, value pair associated with the key. The pair's value (but not key)
can be changed and the key and value can be accessed. In pure-stlmap, these
operations can be performed in one step using the ! operator and the update
functions. Note that the update functions all return the updated container,
not a new container as would be the case for dict.

sm ! key

If sm is a stlmap, returns the value associated with key, if any. If key is
not stored in sm an out_of_bounds exception is thrown. If sm is a stlmmap,
returns a list of values associated with key, if any. If there are no elements
with k as key, an empty list is returned.

update sm k v

If sm is a stlmap and if k is already stored in sm, change its associated
value to v. If not, add (k=>v) to sm. If sm is a stlmmap, add (k=>v) to sm.

update_elm sm (k=>v)

This function is the same as update sm k v.

update_elm ss elm

If ss is a stlset and elm is not already stored in ss, insert elm in ss,
otherwise do nothing. If ss is a stlmset, insert elm in ss.

update_with f sm k x

This function only applies to stlmaps. It is the same as update sm k (f x v)
where v is the value associated with k. If k is not stored in sm, then v is
sm's default value.

update_elms smm k xs

This function only applies to stlmmaps. ...

Accessor and Update Examples
----------------------------

let sm1 = stl::stlmap ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5];
//- ()

sm1!stl::stlbeg, sm1!"a", sm1!"d", sm1!"e"
//- 1,1,4,5


let sm2 = stl::emptystlmap (<);

stl::update_with (:) sm2 "a" 1; ()

stl::update_with (:) sm2 "a" 2; ()

stl::elms sm2;
//- ["a"=>[2,1]]

Using Keys to Designate Ranges
------------------------------

In pure-stlmap, ranges can be specified in terms of keys. If first_key and
last_key are to keys of elements in sac, the range designated by the tuple
(sac,first_key,last_key) begins with the first element with key equal to
first_key and ends with the last key whose key is less than last_key.  If
first_key is not an element of sac, the sequence begins with the first element
whose key is greater than key. The symbols stl::stlbeg and stl::stlend can be
used to designate a SAC's first element or past-end element.  If first_key is
not greater than last_key, the range is empty.

E.g.,


Functions for Using Keys in Lieu of Iterators
---------------------------------------------

The following functions are useful when using keys to access elements or
traverse ranges.

   has_key sm key
   bounding_keys rng
   next_key sm k
   prev_key sm k

has_key is can be used to test before using the ! operator in order to avoid
an out_of_bounds exception. When used this way, only one O(log n) lookup is
required because pure-stlmap caches the iterator used to carry out the has_key
operation and reuses it for the (!) lookup. Similarly, next_key sm k and
prev_key sm k are constant time operations (after the first lookup) when
applied sequentially.

E.g., mulitmap as well as map.

=============
Range Content
=============

Elements in a range can be retrieved as a list, vector, stlvec or lazy lists.

elms rng
vector rng
stlvec rng

Values and keys can be retrieved as a list.

vals rng
keys rng

Elements, values and keys can be retrieved as lazy lists.

lazy_elms rng
lazy_keys rng
lazy_vals rng

=======================================
Equality and Lexicographical Comparison
=======================================

equal rng1 rng2

(::==) sac1::stlmsac sac2::stlmsac

(::~=) sac1::stlmsac sac2::stlmsac

(::<) rng1 rng2

(::<=) rng1 rng2

(::>) rng1 rng2

(::>=) rng1 rng2

==============
Set Algorithms
==============

merge rng1 rng2

set_union rng1 rng2

set_difference rng1 rng2

set_intersection rng1 rng2

set_symmetric_difference rng1 rng2

set_includes rng1 rng2

====================
Mapping, Folding Etc
====================

Now for the Pure oriented functions. 

------
Basics
------

::map f rng

::do f rng

::foldl f rng

::foldl1 f rng

::foldr f x rng

::foldr1 f rng

::filter p rng

-----------------------------
List and Vector Comprhensions
-----------------------------

::listmap f rng

::catmap f rng

::rowmap f rng

::rowcatmap f rng

::colmap f rng

::colcatmap f rng

