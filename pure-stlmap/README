
===========
pure-stlmap
===========

.. default-domain:: pure

Version @version@, |today|

Albert Graef <Dr.Graef@t-online.de>

This package provides a light-weight, no frills interface to the C++ ``map``
and ``unordered_map`` containers, see the `C++ standard library
documentation`_ for details. (The C++ containers were originally based on the
`Standard Template Library`_, so they are also sometimes referred to as "STL
containers"; hence the name of this package.)

The package includes the ``hashmap`` and ``ordmap`` modules which make these
data structures available in Pure land and equip them with a (more or less)
idiomatic Pure container interface.

.. _C++ standard library documentation: http://en.cppreference.com/w/cpp
.. _Standard Template Library: http://www.sgi.com/tech/stl/

Copying
=======

Copyright (c) 2011 by Albert Graef.

pure-stlmap is free software: you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option) any
later version.

pure-stlmap is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
details.

You should have received a copy of the GNU Lesser General Public License along
with this program.  If not, see <http://www.gnu.org/licenses/>.

Installation
============

Get the latest source from
http://pure-lang.googlecode.com/files/pure-stlmap-@version@.tar.gz.

Run ``make`` to compile the modules and ``make install`` (as root) to install
them in the Pure library directory. This requires GNU make, and of course you
need to have Pure (and a C++ library which includes the STL) installed.

``make`` tries to guess your Pure installation directory and platform-specific
setup. If it gets this wrong, you can set some variables manually, please
check the Makefile for details.

.. note:: This module requires Pure 0.49 or later and a recent version of the
   C++ library (GNU libstdc++ v3 has been tested). All proper C++11 libraries
   should work out of the box, while (recent) C++0x implementations may
   require some fiddling with the sources and/or the compilation options. Pre
   C++0x library versions surely require considerably more work, especially in
   the hashmap module.

Usage
=====

After installation, you can use the operations of this package by placing one
or both of the following import declarations in your Pure programs::

  using hashmap;
  using ordmap;

In Pure land, the C++ ``map`` and ``unordered_map`` containers are made
available as a collection of four data structures:

* ``hashmap``, ``hashmmap``: Hashed (unordered) map and multimap data
  structures based on C++ ``unordered_map``. These work with arbitrary key
  (and value) types, like the hashed dictionary and set data structures in the
  standard library, and can be found in the ``hashmap.pure`` module.

* ``ordmap``, ``ordmmap``: Ordered map and multimap data structures based on
  C++ ``map``. These require the keys to be ordered by the standard ``<``
  predicate, like the ordered dictionary and set data structures in the
  standard library, and can be found in the ``ordmap.pure`` module.

All data structures offer most of the usual Pure container interface and can
be used either as dictionaries (holding key => value pairs) or sets (holding
only keys, without associated values). The data structures are very thin
wrappers around the C++ container types; in fact, they are just pointers to
the C++ objects. A reparsable and customizable pretty-printing is defined for
these values.

The most important difference to the dictionary and set types in the standard
library is that the hashmap and ordmap containers are *mutable* data
structures; inserting and deleting members really modifies the underlying C++
containers. (However, it is possible to take copies of the containers in
situations where it's necessary to preserve value semantics.)

Also note that not the full standard dictionary and set interface is provided;
in particular, submap comparisons and set union/difference/intersection
operations are missing right now (the C++ library doesn't have these either),
but it's easy to define them yourself if needed (please see the included
examples).

Documentation of the types and functions provided by the modules is still to
be written, so for the time being please refer to the module sources and the
included examples instead.

Examples
--------

Some basic examples showing hashmaps in action::

  > using hashmap;
  > let m = hashmap [foo=>99, bar=>bar 4711L, baz=>1..5]; m;
  hashmap [foo=>99,bar=>bar 4711L,baz=>[1,2,3,4,5]]
  > m!bar;
  bar 4711L
  > keys m;
  [foo,bar,baz]
  > vals m;
  [99,bar 4711L,[1,2,3,4,5]]
  > list m;
  [foo=>99,bar=>bar 4711L,baz=>[1,2,3,4,5]]
  > member m foo, member m bar;
  1,1
  > [x,y | x=>y = m];
  [(foo,99),(bar,bar 4711L),(baz,[1,2,3,4,5])]

This example shows how to employ ordered maps as a set data structure::

  > using ordmap;
  > x::ordmap + y::ordmap = foldl insert (copy x) (list y);
  > x::ordmap - y::ordmap = foldl delete (copy x) (list y);
  > x::ordmap * y::ordmap = x-(x-y);
  > let m1 = ordmap [5,1,3,11,3];
  > let m2 = ordmap (3..6);
  > m1;m2;
  ordmap [1,3,5,11]
  ordmap [3,4,5,6]
  > m1+m2;
  ordmap [1,3,4,5,6,11]
  > m1-m2;
  ordmap [1,11]
  > m1*m2;
  ordmap [3,5]

Using ``ordmmap`` instead of ``ordmap``, we also get ordered multisets
("bags")::

  > x::ordmmap + y::ordmmap = foldl insert (copy x) (list y);
  > x::ordmmap - y::ordmmap = foldl delete (copy x) (list y);
  > x::ordmmap * y::ordmmap = x-(x-y);
  > let m1 = ordmmap [5,1,3,11,3];
  > let m2 = ordmmap (3..6);
  > m1;m2;
  ordmmap [1,3,3,5,11]
  ordmmap [3,4,5,6]
  > m1+m2;
  ordmmap [1,3,3,3,4,5,5,6,11]
  > m1-m2;
  ordmmap [1,3,11]
  > m1*m2;
  ordmmap [3,5]
