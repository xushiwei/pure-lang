/* stlhash.pure: Pure interface to C++ STL unordered_map
    
--- DRAFT - FOR DISCUSSON PURPOSES ONLY ---

Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stlmap, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stlmap distribution package for details.

*/
 
using stlbase;
using "lib:stlassoc";

namespace stl;

/*** C++ support **********************************************************/

extern expr* sh_type_tags();
private extern expr* sh_make_empty(int ko);
private extern expr* sh_copy(expr* pxshp);
private extern void  sh_delete(void* shashp);

// These are the fastest way to access
extern void  sh_reserve(expr* pxshp, double mlf, int size);
extern expr* sh_info(expr* pxshp);
extern int   sh_bucket_size(expr* pxshp, int bucket_pos);
extern int   sh_size(expr* pxshp);
extern bool  sh_empty(expr* pxshp);
extern bool  sh_is_set(expr* pxshp);
extern int   sh_equal(expr* pxshp1, expr* pxshp2);
extern int   sh_count(expr* pxshp, expr* key);
extern int   sh_member(expr* pxshp, expr* key);
extern expr* sh_find(expr* pxshp, expr* key);
extern expr* sh_insert_elm(expr* pxshp, expr* kv);
extern int   sh_insert_elms_xs(expr* pxshp, expr* src);
extern expr* sh_update(expr* pxshp, expr* key, expr* val);
extern void  sh_swap(expr* pxshp1, expr* pxshp2);
extern int   sh_erase(expr* pxshp, expr* key);
extern int   sh_clear(expr* pxshp);
extern expr* sh_make_vector(expr* pxshp);

extern expr* sh_listmap(expr* fun, expr* pxshp, int what);
extern expr* sh_listcatmap(expr* fun, expr* pxshp, int what);

/*** Global Definitions **************************************************/

namespace ;

public emptystlhash emptystlhashset member members erase
  update_elm stlhashset; 

let stlhash_t = stl::sh_type_tags;

type stlhash x::pointer = check_ptrtag stlhash_t x; //hashed assoc container

namespace stl;

/*** Helpers **************************************************************/

private sh_key_flag sh_val_flag sh_elm_flag compatible_ranges;

const sh_key_flag = 1;
const sh_val_flag = 2;
const sh_elm_flag = 3;

compatible c1 c2 = if sh_is_set c1 then sh_is_set c2 else ~sh_is_set c2; 

/***  Constructors *********************************************************/

::emptystlhash = sh_make_empty 0;

::stlhash xs = hm when
  hm = ::emptystlhash;
  sh_insert_elms_xs hm xs;
end if listp xs || matrixp xs;

::stlhash hm::stlhash = sh_copy hm;

::emptystlhashset = sh_make_empty 1;

::stlhashset xs = ss when
  ss = ::emptystlhashset;
  sh_insert_elms_xs ss xs;
end if listp xs || matrixp xs;

::stlhashset hm::stlhash = sh_copy hm if sh_is_set hm;

hash_reserve hm::stlhash mlf::double size::int = sh_reserve hm mlf size;

/*** Info ***************************************************************/

(::#) hm::stlhash = sh_size hm;

empty hm::stlhash = sh_empty hm;

container_info hm::stlhash = sh_info hm;

bucket_size hm::stlhash i::int = sh_bucket_size hm i;

count hm::stlhash key = sh_count hm key;

::member hm::stlhash key = stl::sh_member hm key;

/*** Access *************************************************************/

(::!) hm::stlhash key = sh_find hm key;

::members hm::stlhash = sh_listmap 0 hm sh_elm_flag;

::keys hm::stlhash = sh_listmap 0 hm sh_key_flag;

::vals hm::stlhash = sh_listmap 0 hm sh_val_flag;

vector hm::stlhash = sh_make_vector hm;

/*** Modifiers *********************************************************/

::insert hm::stlhash xs::list = sh_insert_elms_xs hm xs;

::insert hm::stlhash xs::matrix = sh_insert_elms_xs hm xs;

::insert hm::stlhash val@(k=>v) = sh_insert_elm hm val;

::insert hm::stlhash elm = sh_insert_elm hm elm if sh_is_set hm; 

::update hm::stlhash key v = sh_update hm key v;

::update_elm hm::stlhash (k=>v) = sh_update hm k v;

::erase hm::stlhash = sh_clear hm;

::erase (hm::stlhash,key) = sh_erase hm key;

swap hm1::stlhash hm2::stlhash = sh_swap hm1 hm2 if compatible hm1 hm2;

/*** Equality **********************************************************/

(::==) c1::stlhash c2::stlhash = sh_equal c1 c2 if compatible c1 c2;

(::~=) c1::stlhash c2::stlhash = ~sh_equal c1 c2 if compatible c1 c2;

/*** Mapping ***********************************************************/

::map f hm::stlhash = sh_listmap f hm sh_elm_flag;

::listmap f hm::stlhash = sh_listmap f hm sh_elm_flag;

::catmap f hm::stlhash = sh_listcatmap f hm sh_elm_flag;

::rowmap f hm::stlhash = rowcat (sh_listmap f hm sh_elm_flag);

::rowcatmap f hm::stlhash = rowcat (sh_listmap f hm sh_elm_flag);

::colmap f hm::stlhash = colcat (sh_listmap f hm sh_elm_flag);

::colcatmap f hm::stlhash = colcat (sh_listmap f hm sh_elm_flag);

