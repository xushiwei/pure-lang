/* stlmmap.pure: Pure interface to C++ STL mulitmap
    
--- DRAFT - FOR DISCUSSON PURPOSES ONLY ---

Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stlmap, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stlmap distribution package for details.

*/

using stlbase;
using "lib:stlassoc";

namespace stl;

/*** C++ Support ************************************************************/

extern expr* smm_type_tags();
private extern expr* smm_make_empty(expr* kcmp, expr* vcmp, expr* veql,
                                    expr* default_val, int ko);
private extern void  smm_delete(void* smp);
private extern void  smm_iter_delete(void* smip);
private extern expr* smm_container_info(expr* rng);
private extern int   smm_size(expr* rng);
private extern int   smm_count(expr* pxsmmp, expr* key);
private extern bool  smm_empty(expr* rng);
private extern bool  smm_is_set(expr* rng);
private extern expr* smm_find(expr* pxsmp, expr* key, int what);
private extern expr* smm_copy_iter(expr* pxsmip);
private extern expr* smm_begin(expr* pxsmp);
private extern expr* smm_end(expr* pxsmp); 
private extern expr* smm_bounds(expr* pxsmp, expr* key, int what);
private extern expr* smm_range_info(expr* rng);
private extern expr* smm_move_iter(expr* pxsmp, int count);
private extern expr* smm_iter_is_at(expr* pxsmip, int where);
private extern expr* smm_iter_info(expr* pxsmip);
private extern expr* smm_equal_iter(expr* pxsmp, expr* pxsmp);
private extern expr* smm_get_at(expr* pxsmip, int what);
private extern expr* smm_get_elm_at_inc(expr* pxsmip);
private extern expr* smm_put_at(expr* pxsmip, expr* val);
private extern expr* smm_insert_hinted(expr*map, expr* iter, expr* kv);
private extern expr* smm_insert_elm(expr* map, expr* kv);
private extern int   smm_insert_elms_xs(expr* map, expr* src);
private extern int   smm_insert_elms_stlvec(expr* map, expr* svrng);
private extern int   smm_insert_elms_stlmmap(expr* map, expr* rng);
private extern void  smm_swap(expr* sac1, expr* sac2);
private extern int   smm_erase(expr* sac, expr* trg);
private extern int   smm_clear(expr* map);
private extern int   smm_equal(expr* rng1, expr* rng2);
private extern int   smm_less(expr* rng1, expr* rng2);
private extern bool  smm_includes(expr* rng1, expr* rng2);
private extern expr* smm_setop(int op, expr* rng1, expr* rng2);
private extern expr* smm_make_vector(expr* rng);
private extern void* smm_fill_stlvec(expr* rng, void* v);
private extern expr* smm_listmap(expr* fun, expr* rng, int what);
private extern expr* smm_listcatmap(expr* fun, expr* rng, int what);
private extern expr* smm_foldl(expr* fun, expr* val, expr* rng);
private extern expr* smm_foldl1(expr* fun, expr* rng);
private extern expr* smm_foldr(expr* fun, expr* val, expr* rng);
private extern expr* smm_foldr1(expr* fun, expr* rng);
private extern int   smm_member(expr* map, expr* key);
private extern expr* smm_bounding_keys(expr* rng);
private extern expr* smm_prev_key(expr* map, expr* key);
private extern expr* smm_next_key(expr* map, expr* key);
private extern expr* smm_update(expr* map, expr* key, expr* val);


/*** Global Definitions ************************************************/

namespace ;

public emptystlmmap mkstlmmap emptystlmset mkstlmset; 

let stlmmap_t, stlmmap_iter_t, stlmset_t, stlmset_iter_t = stl::smm_type_tags;

type stlmmap x = check_ptrtag stlmmap_t x;     //c++ multimap
type stlmset x = check_ptrtag stlmset_t x;     //c++ multiset
type stlmacon x::stlmmap | stlmacon x::stlmset;  //multi sorted assoc container

type stlmmap_iter x = check_ptrtag stlmmap_iter_t x;
type stlmset_iter x = check_ptrtag stlmset_iter_t x;
type stlmacon_iter x::stlmmap_iter | stlmacon_iter x::stlmset_iter;

type stlmacon_rng x::stlmacon | stlmacon_rng (x::stlmacon, _);
type stlmacon_rng (x::stlmmap_iter, y::stlmmap_iter);
type stlmacon_rng (x::stlmset_iter, y::stlmset_iter);

namespace stl;

/*** Helpers **************************************************************/

private 
  smm_lower_bound smm_update_with
  smm_iter smm_key smm_val smm_elm 
  smm_merge smm_union smm_difference smm_intersection smm_symmetric_difference 
  smm_less smm_equal compatible_ranges;

const smm_lower_bound = 1;
const smm_upper_bound = 2;
const smm_equal_range = 3;

const smm_key = 1;
const smm_val = 2;
const smm_elm = 3;
const smm_iter = 4;
const smm_iter_dflt = 5;

const smm_merge = 1;
const smm_union = 2;
const smm_difference = 3;
const smm_intersection = 4;
const smm_symmetric_difference = 5;

const smm_at_beginning = 1;
const smm_at_pastend = 2;

compatible_ranges rng1::stlmacon_rng rng2 = 
  if smm_is_set rng1 then smm_is_set rng2 else ~smm_is_set rng2;

/*** Iterators **********************************************************/

iterator pos::stlmacon_iter = smm_copy_iter pos;

begin smm::stlmacon = smm_begin smm;

pastend smm::stlmacon = smm_end smm;

find smm::stlmacon key = smm_find smm key smm_iter;

lower_bound smm::stlmacon key = smm_bounds smm key smm_lower_bound;

upper_bound smm::stlmacon key = smm_bounds smm key smm_upper_bound;

equal_range smm::stlmacon key = smm_bounds smm key smm_equal_range;

is_begin pos::stlmacon_iter = smm_iter_is_at pos smm_at_beginning;

is_pastend pos::stlmacon_iter = smm_iter_is_at pos smm_at_pastend;

get_info pos::stlmacon_iter = smm_iter_info pos;

get pos::stlmacon_iter = smm_get_at pos smm_elm;

get_key pos::stlmacon_iter = smm_get_at pos smm_key;

get_val pos::stlmacon_iter = smm_get_at pos smm_val;

put pos::stlmmap_iter val = smm_put_at pos val;

inc pos::stlmacon_iter = smm_move_iter pos 1;

dec pos::stlmacon_iter = smm_move_iter pos (-1);

move pos::stlmacon_iter n::int = smm_move_iter pos n;

/*** Iterator Operators ****************************************************/

(::==) pos1::stlmacon_iter pos2::stlmacon_iter = smm_equal_iter pos1 pos2;

(::^) smm::stlmmap key = smm_find smm key smm_iter_dflt;  // inserts default

/***  Constructors *********************************************************/

::emptystlmmap                    = smm_make_empty (<) (<) (==) [] 0;

::mkstlmmap (kcmp,dflt,vcmp,veql) = smm_make_empty kcmp vcmp veql dflt 0;
::mkstlmmap (kcmp,dflt,vcmp)      = smm_make_empty kcmp vcmp (==) dflt 0;
::mkstlmmap (kcmp,dflt)           = smm_make_empty kcmp (<) (==) dflt  0;
::mkstlmmap kcmp                  = smm_make_empty kcmp (<) (==) [] 0;

::stlmmap xs = smm when
  smm = ::emptystlmmap;
  smm_insert_elms_xs smm xs;
end if listp xs || matrixp xs;

::stlmmap rng::svrng = smm when
  smm = ::emptystlmmap;
  smm_insert_elms_stlvec smm rng;
end;

::stlmmap rng::stlmacon_rng = smm when
  _,params = smm_container_info rng;
  smm = mkstlmmap params;
  smm_insert_elms_stlmmap smm rng;
end if ~smm_is_set rng;

::emptystlmset = smm_make_empty (<) (<) (==) [] 1;

::mkstlmset kcmp = smm_make_empty kcmp (<) (==) [] 1;

::stlmset xs = ss when
  ss = ::emptystlmset;
  smm_insert_elms_xs ss xs;
end if listp xs || matrixp xs;

::stlmset rng::svrng = ss when
  ss = ::emptystlmset;
  smm_insert_elms_stlvec ss rng;
end;

::stlmset rng::stlmacon_rng = ss when
  _,kc,_ = smm_container_info rng;
  ss = mkstlmset kc;
  smm_insert_elms_stlmmap ss rng;
end if smm_is_set rng;

/*** Info ***************************************************************/

container_info rng::stlmacon_rng = smm_container_info rng;

(::#) smm::stlmacon = smm_size smm;

empty smm::stlmacon = smm_empty smm;

count smm::stlmacon key = smm_count smm key;

range_info rng::stlmacon_rng = smm_range_info rng;

distance rng::stlmacon_rng = smm_size rng;

/*** Range Access ******************************************************/

lazy_map f rng::stlmacon_rng = gen first with
  gen i = if smm_equal_iter i last then [] 
          else f (smm_get_elm_at_inc i) : (gen i &);  
end if valid when 
  valid,m,b,last = smm_range_info rng;
  first = smm_copy_iter b;
end;

stream rng::stlmacon_rng = gen first with 
  gen i = if smm_equal_iter i last then [] 
          else smm_get_elm_at_inc i : (gen i &);  
end if valid when 
  valid,m,b,last = smm_range_info rng;
  first = smm_copy_iter b;
end;

elms rng::stlmacon_rng = smm_listmap 0 rng smm_elm; 

members rng::stlmacon_rng = smm_listmap 0 rng smm_elm; 

keys rng::stlmacon_rng = smm_listmap 0 rng smm_key;// if ~smm_is_set rng;

vals rng::stlmacon_rng = smm_listmap 0 rng smm_val;// if ~smm_is_set rng;

vector rng::stlmacon_rng = smm_make_vector rng;

stlvec rng::stlmacon_rng = sv if ok when
  sv = emptystlvec;
  ok = case sv of  
    STLVEC v = smm_fill_stlvec rng v $$ 1;
    _ = 0;
  end;
end;

/*** Modifiers *********************************************************/

insert smm::stlmacon xs::list = smm_insert_elms_xs smm xs;

insert smm::stlmacon xs::matrix = smm_insert_elms_xs smm xs;

insert smm::stlmacon rng::stlmacon_rng = smm_insert_elms_stlmmap smm rng;

insert smm::stlmacon rng::svrng = smm_insert_elms_stlvec smm rng;

insert smm::stlmmap (elm@(k=>v), pos::stlmacon_iter) = 
  smm_insert_hinted smm pos elm;

insert smm::stlmmap elm@(k=>v) = smm_insert_elm smm elm;

insert_or_update smm::stlmmap elm@(k=>v) = smm_insert_elm smm elm $$ smm;

insert_or_update smm::stlmset k = smm_insert_elm smm k $$ smm;

//insert_or_update_with -- N/A

insert smm::stlmset (key, pos::stlmacon_iter) = smm_insert_hinted smm pos key;

insert smm::stlmset key = smm_insert_elm smm key;

insert_elm smm::stlmset key = smm_insert_elm smm key; // to get xs, etc into set

erase smm::stlmacon = smm_clear smm;

erase (smm::stlmacon,i::stlmacon_iter,j::stlmacon_iter) = smm_erase smm (i,j);

erase (smm::stlmacon,pos::stlmacon_iter) = smm_erase smm pos;

erase (smm::stlmacon,key1,key2) = smm_erase smm (smm,key1,key2);

erase (smm::stlmacon,key) = smm_erase smm (smm,key);

swap sm1::stlmmap sm2::stlmmap = smm_swap sm1 sm2;

swap ss1::stlmset ss2::stlmset = smm_swap ss1 ss2;

/*** Equality and Lexicographical Comparison ***************************/

equal rng1::stlmacon_rng rng2::stlmacon_rng = smm_equal rng1 rng2
  if compatible_ranges rng1 rng2;

(::==) sac1::stlmacon_rng sac2::stlmacon_rng = smm_equal sac1 sac2
  if compatible_ranges sac1 sac2;

(::~=) sac1::stlmacon_rng sac2::stlmacon_rng = ~smm_equal sac1 sac2
  if compatible_ranges sac1 sac2;

(::<) rng1::stlmacon_rng rng2::stlmacon_rng = smm_less rng1 rng2
  if compatible_ranges rng1 rng2;

(::<=) rng1::stlmacon_rng rng2::stlmacon_rng = ~smm_less rng2 rng1
  if compatible_ranges rng1 rng2;

(::>) rng1::stlmacon_rng rng2::stlmacon_rng = smm_less rng2 rng1
  if compatible_ranges rng1 rng2;

(::>=) rng1::stlmacon_rng rng2::stlmacon_rng = ~smm_less rng1 rng2
  if compatible_ranges rng1 rng2;

/** STL Set Algorithms ***************************************************/

merge rng1::stlmacon_rng rng2::stlmacon_rng = 
  smm_setop smm_merge rng1 rng2 if compatible_ranges rng1 rng2;

set_union rng1::stlmacon_rng rng2::stlmacon_rng = 
  smm_setop smm_union rng1 rng2 if compatible_ranges rng1 rng2;

set_difference rng1::stlmacon_rng rng2::stlmacon_rng = 
  smm_setop smm_difference rng1 rng2 if compatible_ranges rng1 rng2;

set_intersection rng1::stlmacon_rng rng2::stlmacon_rng = 
  smm_setop smm_intersection rng1 rng2 if compatible_ranges rng1 rng2;

set_symmetric_difference rng1::stlmacon_rng rng2::stlmacon_rng = 
  smm_setop smm_symmetric_difference rng1 rng2 if compatible_ranges rng1 rng2;

set_includes rng1::stlmacon_rng rng2::stlmacon_rng =
 smm_includes rng1 rng2 if compatible_ranges rng1 rng2;

// add find adj ?? some others ??05

/*** Key oriented interface functions *********************************/

/* The key oriented interface allows one to work with stlmmaps and stlmsets
   without using iterators. If (!key) is applied to a stlmmap it returns the
   (possibly empty) list of values for elements with the indicated key. If
   (!key) is applied to a stlmset it returns the elements that are equivalent
   to the key. Basically as if the container had unique keys were associated
   with list of vals as opposed to many keys each with a val.
*/

(::!) smm::stlmacon key = smm_listmap 0 (smm,key) smm_val;

get (smm::stlmacon,key) = throw out_of_bounds if empty smm;
get (smm::stlmacon,key) = k=>(smm_listmap 0 (smm,key) smm_val) when 
  k = if key === stlbeg then get_key (find smm stlbeg) else key;
end;

put (smm::stlmmap,key) vals = smm_update smm key vals;

has_key smm::stlmacon key = smm_member smm key;

bounding_keys rng::stlmacon_rng = smm_bounding_keys rng;

next_key smm::stlmacon key = smm_next_key smm key;

prev_key smm::stlmacon key = smm_prev_key smm key;

/*** Mapping and Folding ********************************************/

::map f rng::stlmacon_rng = smm_listmap f rng smm_elm; // => smm_key for sets

::foldl f x rng::stlmacon_rng = smm_foldl f x rng;

::foldl1 f rng::stlmacon_rng = smm_foldl1 f rng;

::foldr f x rng::stlmacon_rng = smm_foldr f x rng;

::foldr1 f rng::stlmacon_rng = smm_foldr1 f rng;

::do f rng::stlmacon_rng = smm_foldl (\_ x->f x) () rng $$ ();

::filter p rng::stlmacon_rng = smm_foldr f [] rng with
  f x xs = res when
    res = case p x of
      1 = x:xs;
      0 = xs;
      y = throw failed_cond;
    end;
  end;
end;

::listmap f rng::stlmacon_rng = smm_listmap f rng smm_elm;

::catmap f rng::stlmacon_rng = smm_listcatmap f rng smm_elm;

::rowmap f rng::stlmacon_rng = rowcat (smm_listmap f rng smm_elm);

::rowcatmap f rng::stlmacon_rng = rowcat (smm_listmap f rng smm_elm);

::colmap f rng::stlmacon_rng = colcat (smm_listmap f rng smm_elm);

::colcatmap f rng::stlmacon_rng = colcat (smm_listmap f rng smm_elm);

