/* stlmmap.pure: Pure interface to C++ STL multimap
    
--- DRAFT - FOR DISCUSSON PURPOSES ONLY ---

Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stlmap, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stlmap distribution package for details.

*/
 
using stlbase;
using "lib:stlmmap";

// stlmmap constuctors
nonfix STLMMAP;
STLMMAP = 'STLMMAP;

// stlmmap types
type stlmset (STLMMAP _);
type stlmmap (STLMMAP _);
type smmrng (STLMMAP _);
type smmrng (STLMMAP _, _);

namespace stl;

/*** C++ support *****************************************************/

private extern expr* smm_make_empty(expr* kc, expr* vcmp, expr* veql, int ko);
private extern void  smm_delete(void* mmap);
private extern bool  smm_is_set(expr* tpl);
private extern expr* smm_set_default(void* mmap, expr* val);
private extern expr* smm_get_default(void* mmap);
private extern expr* smm_get_elm(void* map, expr* key, int what);
private extern int   smm_equal(expr* tpl1, expr* tpl2);
private extern int   smm_less(expr* tpl1, expr* tpl2);
private extern bool  smm_includes(expr* rng1, expr* rng2);
private extern expr* smm_setop(int op, expr* rng1, expr* rng2);
private extern expr* smm_make_vector(expr* tpl);
private extern void* smm_make_stlvec(expr* tpl);
private extern int   smm_size(expr* tpl);
private extern expr* smm_bounds(expr* tpl);
private extern int   smm_member(void* mmap, expr* key);
private extern expr* smm_next_key(void* mmap, expr* key);
private extern expr* smm_prev_key(void* mmap, expr* key);
private extern expr* smm_update(void* mmap, expr* key, expr* val);
private extern expr* smm_update_vals_xs(void* mmap, expr* k, expr* src);
private extern int   smm_insert_elm(void* mmap, expr* kv);
private extern int   smm_insert_elms_xs(void* mmap, expr* src);
private extern int   smm_insert_elms_stlvec(void* mmap, expr* tpl);
private extern int   smm_insert_elms_stlmmap(void* mmap, expr* tpl);
private extern int   smm_clear(void* mmap);
private extern int   smm_erase(expr* rng);
private extern int   smm_erase_if(expr* pred, expr* rng);
private extern int   smm_erase_first(expr* rng);
private extern int   smm_erase_first_if(expr* pred, expr* rng);
private extern expr* smm_listmap(expr* fun, expr* rng, int what);
private extern expr* smm_listcatmap(expr* fun, expr* rng, int what);
private extern expr* smm_foldl(expr* fun, expr* val, expr* rng);
private extern expr* smm_foldl1(expr* fun, expr* rng);
private extern expr* smm_foldr(expr* fun, expr* val, expr* rng);
private extern expr* smm_foldr1(expr* fun, expr* rng);

extern void stl_set_smm_trace(bool enable) = set_smm_trace;
extern bool stl_smm_trace_enabled() = smm_trace_enabled;

/*** Helpers **************************************************************/

private smm_key smm_val smm_elm
  smm_union smm_difference smm_intersection smm_symmetric_difference 
  smm_wrap smm_wrap_sv smm_less smm_equal;

const smm_key = 1;
const smm_val = 2;
const smm_elm = 3;

const smm_merge = 1;
const smm_union = 2;
const smm_difference = 3;
const smm_intersection = 4;
const smm_symmetric_difference = 5;

smm_wrap mm = STLMMAP (sentry smm_delete mm);

smm_wrap_sv mm = STLVEC (sentry smm_delete mm);

both_msets rng1 rng2 = smm_is_set rng1 && smm_is_set rng2;

both_mmaps rng1 rng2 = ~smm_is_set rng1 && ~smm_is_set rng2;

/*** Accessors, modifiers and observers ********************************/

size rng::smmrng = smm_size rng;

set_default smm@(STLMMAP mm) val = smm_set_default mm val;

get_default smm@(STLMMAP mm) = smm_get_default mm;

empty rng::smmrng = smm_size rng == 0;

bounds (STLMMAP mm) = (STLMMAP mm), stlbeg, stlend;

bounds rng@(STLMMAP mm, _) = (STLMMAP mm), smm_bounds rng;

::next_key smm@(STLMMAP mm) key = smm_next_key mm key;

::prev_key smm@(STLMMAP mm) key = smm_prev_key mm key;

::member (STLMMAP mm) key = smm_member mm key;

::find_elm what (STLMMAP mm) key = smm_get_elm mm key what;

::stlvec rng::smmrng = smm_wrap_sv $ smm_make_stlvec rng;

::insert_elm smm@(STLMMAP mm) rk = smm_insert_elm mm rk $$ smm;

::insert_elms smm@(STLMMAP mm) xs::list = smm_insert_elms_xs mm xs $$ smm;

::insert_elms smm@(STLMMAP mm) xs::matrix = smm_insert_elms_xs mm xs $$ smm;

::insert_elms smm@(STLMMAP mm) rng::smmrng = smm_insert_elms_stlmmap mm rng $$ smm;

::insert_elms smm@(STLMMAP mm) rng::svrng = smm_insert_elms_stlvec mm rng $$ smm;

::erase smm@(STLMMAP mm) = smm_clear mm;

::erase rng::smmrng = smm_erase rng;

::erase_if pred rng::smmrng = smm_erase_if pred rng;

::update smm@(STLMMAP mm) key x = smm_update mm key x $$ smm if ~smm_is_set smm;

::update_vals (STLMMAP mm) k vals = smm_update_vals_xs mm k vals;

/*** Constructors **********************************************************/

::emptystlmmap = smm_wrap $ smm_make_empty (<) (<) (==) 0;

::emptystlmmap_with kcmp vcmp veq = smm_wrap $ smm_make_empty kcmp vcmp veq 0;

::stlmmap xs = smm when
  smm = ::emptystlmmap;
  insert_elms smm xs;
end if listp xs || matrixp xs;

::stlmmap rng::svrng = smm when
  smm = ::emptystlmmap;
  insert_elms smm rng;
end;

::stlmmap rng::smmrng = smm when
  smm = ::emptystlmmap;
  insert_elms smm rng;
end;

::mkstlmmap y ks::list = do add ks $$ smm with
  add k = ::update smm k y;
end when
  smm = emptystlmmap;
end;

::emptystlmset = smm_wrap $ smm_make_empty (<) (<) (==) 1;

::emptystlmset_with kcmp vcmp veq = smm_wrap $ smm_make_empty kcmp vcmp veq 1; 

::stlmset xs = smm when
  smm = ::emptystlmset;
  insert_elms smm xs;
end if listp xs || matrixp xs;

::stlmset rng::svrng = smm when
  smm = ::emptystlmset;
  insert_elms smm rng;
end;

::stlmset rng::smmrng = smm when
  smm = ::emptystlmset;
  insert_elms smm rng;
end;

/*** Operators *************************************************************/

(::!) (STLMMAP mm) key = smm_get_elm mm key smm_val;

(::#) smm::stlmmap = smm_size smm;

(::==) smm1::stlmmap smm2::stlmmap = smm_equal smm1 smm2;

(::~=) smm1::stlmmap smm2::stlmmap = ~smm_equal smm1 smm2;

(::<) rng1::smmrng rng2::smmrng = smm_less rng1 rng2;

(::<=) rng1::smmrng rng2::smmrng = ~smm_less rng2 rng1;

(::>) rng1::smmrng rng2::smmrng = smm_less rng2 rng1;

(::>=) rng1::smmrng rng2::smmrng = ~smm_less rng1 rng2;

smm_equal rng1::smmrng rng2::smmrng = smm_equal rng1 rng2 
  if both_mmaps rng1 rng2 || both_msets rng1 rng2;

smm_less rng1::smmrng rng2::smmrng = smm_less rng1 rng2 
  if both_mmaps rng1 rng2 || both_msets rng1 rng2;

/** STL algorithms **********************************************************/

merge rng1::smmrng rng2::smmrng = 
  smm_wrap $ smm_setop smm_merge rng1 rng2
  if both_msets rng1 rng2 || both_mmaps rng1 rng2;

set_union rng1::smmrng rng2::smmrng = 
  smm_wrap $ smm_setop smm_union rng1 rng2
  if both_msets rng1 rng2 || both_mmaps rng1 rng2;

set_difference rng1::smmrng rng2::smmrng = 
  smm_wrap $ smm_setop smm_difference rng1 rng2
  if both_msets rng1 rng2 || both_mmaps rng1 rng2;

set_intersection rng1::smmrng rng2::smmrng = 
  smm_wrap $ smm_setop smm_intersection rng1 rng2
  if both_msets rng1 rng2 || both_mmaps rng1 rng2;

set_symmetric_difference rng1::smmrng rng2::smmrng = 
  smm_wrap $ smm_setop smm_symmetric_difference rng1 rng2 
  if both_msets rng1 rng2 || both_mmaps rng1 rng2;

set_includes rng1::smmrng rng2::smmrng = smm_includes rng1 rng2 
  if both_msets rng1 rng2 || both_mmaps rng1 rng2;

// add find adj ?? some others ??

/*** List interface functions *********************************************/

::members rng::smmrng = smm_listmap 0 rng smm_elm;

::map f rng::smmrng = smm_listmap f rng smm_elm;

::listmap f rng::smmrng = smm_listmap f rng smm_elm;

::catmap f rng::smmrng = smm_listcatmap f rng smm_elm;

::foldl f x rng::smmrng = smm_foldl f x rng;

::foldl1 f rng::smmrng = smm_foldl1 f rng;

::foldr f x rng::smmrng = smm_foldr f x rng;

::foldr1 f rng::smmrng = smm_foldr1 f rng;

::do f rng::smmrng = smm_foldl (\_ x->f x) () rng $$ ();

::filter p rng::smmrng = smm_foldr f [] rng with
  f x xs = res when
    res = case p x of
      1 = x:xs;
      0 = xs;
      y = throw failed_cond;
    end;
  end;
end;

::keys rng::smmrng = smm_listmap 0 rng smm_key if ~smm_is_set rng;

::vals rng::smmrng = smm_listmap 0 rng smm_val if ~smm_is_set rng;

::map_keys f rng::smmrng = smm_listmap f rng smm_key if ~smm_is_set rng;

::map_vals f rng::smmrng = smm_listmap f rng smm_val if ~smm_is_set rng;

::catmap_keys f rng::smmrng = smm_listcatmap f rng smm_key if ~smm_is_set rng;;

::catmap_vals f rng::smmrng = smm_listcatmap f rng smm_val if ~smm_is_set rng;

/*** Vector interface functions ****************************************/

vector rng::smmrng = smm_make_vector rng;

::rowmap f rng::smmrng = rowcat (smm_listmap f rng smm_elm);

::rowcatmap f rng::smmrng = rowcat (smm_listmap f rng smm_elm);

::colmap f rng::smmrng = colcat (smm_listmap f rng smm_elm);

::colcatmap f rng::smmrng = colcat (smm_listmap f rng smm_elm);

/*** Pure dict and set emulation *****************************************/

null rng::smmrng = smm_size rng == 0;

::first rng::smmrng = smm_get_elm mm b smm_key 
when STLMMAP mm,b,e = bounds rng end if smm_is_set rng;

::first rng::smmrng = smm_get_elm mm b smm_elm 
when STLMMAP mm,b,e = bounds rng end;

::last rng::smmrng = smm_get_elm mm (smm_prev_key mm e) smm_key
when STLMMAP mm,b,e = bounds rng end  if smm_is_set rng;

::last rng::smmrng = smm_get_elm mm (smm_prev_key mm e) smm_elm 
when STLMMAP mm,b,e = bounds rng; end;

//::list smm::stlmmap = members smm;  // this is erroneous for smmrng

::insert smm@(STLMMAP mm) rng::smmrng = smm_insert_elms_stlmmap mm rng $$ smm;

::rmfirst rng::smmrng = smm_erase (smm,b) 
when smm,b,e = bounds rng end;

::rmlast rng::smmrng = smm_erase (smm, ::prev_key smm e) 
when smm,b,e = bounds rng end;

::delete smm::stlmmap k = smm_erase_first (smm,k);

::delete_all smm::stlmmap k = smm_erase (smm,k);

::delete_if pred smm::stlmmap k = smm_erase_first_if pred (smm,k);

::delete_val smm::stlmmap (k=>v) =
  smm_erase_first_if (\(_=>x)->x==v) (smm,k) if ~smm_is_set smm; 

(::+) rng1::smmrng rng2::smmrng = res when
  res = ::stlmmap rng1;
  ::insert_elms res rng2;
end if both_mmaps rng1 rng2;

(::+) rng1::smmrng rng2::smmrng = res when
  res = ::stlmset rng1;
  ::insert_elms res rng2;
end if both_msets rng1 rng2;

(::-) rng1::smmrng rng2::smmrng = res when
  res = stlmmap rng1;
  do (::delete_val res) rng2 
end if both_mmaps rng1 rng2;

(::-) rng1::smmrng rng2::smmrng = res when
  res = stlmset rng1;
  do (::delete res) rng2 
end if both_msets rng1 rng2;

(::*) rng1::smmrng rng2::smmrng = 
  if size rng1 < size rng2 then rng1 - (rng1 -rng2) else rng2 - (rng2 -rng1)
  if both_msets rng1 rng2 || both_mmaps rng1 rng2;

(::/) rng1::smmrng rng2::smmrng = (rng1 - rng2) +  (rng2 -rng1)
  if both_msets rng1 rng2 || both_mmaps rng1 rng2;


