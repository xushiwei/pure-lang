/* stlmmap.pure: Pure interface to C++ STL multimap
    
--- DRAFT - FOR DISCUSSON PURPOSES ONLY ---

Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stlmap, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stlmap distribution package for details.

*/
 
using stlbase;
using "lib:stlmmap";

// stlmmap constuctors
nonfix STLMMAP;
STLMMAP = 'STLMMAP;

// stlmmap types
type stlmset (STLMMAP _);
type stlmmap (STLMMAP _);
type smmit (STLMMAP _);
type smmit (STLMMAP _, _);

namespace stl;

/*** C++ support *****************************************************/

private extern void* smm_make_empty(expr* comp, int keys_only);
private extern void  smm_delete(void* mmap);
private extern bool  smm_is_set(expr* tpl);
private extern expr* smm_set_default(void* mmap, expr* val);
private extern expr* smm_get_default(void* mmap);
private extern bool  smm_includes(expr* it1, expr* it2);
private extern void* smm_setop(int op, expr* it1, expr* it2);
private extern expr* smm_make_vector(expr* tpl);
private extern void* smm_make_stlvec(expr* tpl);
private extern int   smm_size(expr* tpl);
private extern expr* smm_bounds(expr* tpl);
private extern int   smm_member(void* mmap, expr* key);
private extern expr* smm_next(void* mmap, expr* key);
private extern expr* smm_prev(void* mmap, expr* key);
private extern expr* smm_get(void* mmap, expr* key);
private extern expr* smm_first(expr* tpl);
private extern expr* smm_last(expr* tpl);
private extern expr* smm_update(void* mmap, expr* key, expr* val);
private extern expr* smm_update_with(void* mmap, expr* key, expr* unaryfun);
private extern void  smm_insert_elm(void* mmap, expr* kv);
private extern void  smm_insert_elms_xs(void* mmap, expr* src);
private extern void  smm_insert_elms_stlvec(void* mmap, expr* tpl);
private extern void  smm_insert_elms_stlmmap(void* mmap, expr* tpl);
private extern void  smm_rmfirst(expr* tpl);
private extern void  smm_rmlast(expr* tpl);
private extern void  smm_erase(expr* it);
private extern void  smm_clear(void* mmap);
private extern int   smm_remove(void* mmap, expr* k, int all);
private extern int   smm_remove_if(void* mmap, expr* k, expr* pred, int all);
private extern int   smm_allpairs(expr* fun, expr* it, expr* it);
private extern expr* smm_listmap(expr* fun, expr* it, int what);
private extern expr* smm_listcatmap(expr* fun, expr* it, int what);
private extern expr* smm_foldl(expr* fun, expr* val, expr* it);
private extern expr* smm_foldl1(expr* fun, expr* it);
private extern expr* smm_foldr(expr* fun, expr* val, expr* it);
private extern expr* smm_foldr1(expr* fun, expr* it);

extern void stl_set_smm_trace(bool enable) = set_smm_trace;
extern bool stl_smm_trace_enabled() = smm_trace_enabled;

/*** Helpers **************************************************************/

private smm_keys smm_vals smm_both smm_union smm_difference
  smm_intersection smm_symmetric_difference smm_wrap smm_wrap_sv;

const smm_keys = 1;
const smm_vals = 2;
const smm_both = 3;

const smm_union = 1;
const smm_difference = 2;
const smm_intersection = 3;
const smm_symmetric_difference = 4;

smm_wrap mm = STLMMAP (sentry smm_delete mm);
smm_wrap_sv mm = STLVEC (sentry smm_delete mm);

smm_kv_equal k1 v1 k2 v2 = k1 == k2 && v1 == v2;

both_msets it1 it2 = smm_is_set it1 && smm_is_set it2;

both_mmaps it1 it2 = ~smm_is_set it1 && ~smm_is_set it2;

/*** Public functions for stlmmap and stlmset *************************/

::stlvec it::smmit = smm_wrap_sv $ smm_make_stlvec it;

vector it::smmit = smm_make_vector it;

(::!) (STLMMAP mm) key = smm_get mm key;

(::#) smm::stlmmap = smm_size smm;

size it::smmit = smm_size it;

null it::smmit = smm_size it == 0;

empty it::smmit = smm_size it == 0;

bounds (STLMMAP mm) = (STLMMAP mm), stlbeg, stlend;

bounds it@(STLMMAP mm, _) = (STLMMAP mm), smm_bounds it;

::member (STLMMAP mm) key = smm_member mm key;

::members it::smmit = smm_listmap 0 it smm_both;

::next_key smm@(STLMMAP mm) key = smm_next mm key;

::prev_key smm@(STLMMAP mm) key = smm_prev mm key;

// ::list smm::stlmmap = members smm;  // use members

::first it::smmit = smm_first it;

::last it::smmit = smm_last it;

::rmfirst it::smmit = smm_rmfirst it;

::rmlast it::smmit = smm_rmlast it;

::insert smm@(STLMMAP mm) rk = smm_insert_elm mm rk $$ smm;

::insert_elms smm@(STLMMAP mm) xs::list = smm_insert_elms_xs mm xs $$ smm;

::insert_elms smm@(STLMMAP mm) xs::matrix = smm_insert_elms_xs mm xs $$ smm;

::insert_elms smm@(STLMMAP mm) it::smmit = smm_insert_elms_stlmmap mm it $$ smm;

::insert_elms smm@(STLMMAP mm) it::svit = smm_insert_elms_stlvec mm it $$ smm;

::erase it@(STLMMAP mm, f, e) = smm_erase it $$ STLMMAP mm;

::erase smm@(STLMMAP mm) = smm_clear mm $$ smm;

::delete (STLMMAP mm) k = smm_remove mm k 0;

::delete_all smm@(STLMMAP mm) k = smm_remove mm k 1;

allpairs fun it1::smmit it2::smmit = smm_allpairs fun it1 it2 
  if both_msets it1 it2 && functionp fun && nargs fun == 2 ;

allpairs fun it1::smmit it2::smmit = smm_allpairs fun it1 it2
  if ~smm_is_set it1 && ~smm_is_set it2 && functionp fun && nargs fun == 4;

(::==) smm1::stlmmap smm2::stlmmap = allpairs smm_kv_equal smm1 smm2
  if both_mmaps smm1 smm2;

(::~=) smm1::stlmmap smm2::stlmmap = ~allpairs smm_kv_equal smm1 smm2
  if both_mmaps smm1 smm2;

(::==) smm1::stlmmap smm2::stlmmap = allpairs (==) smm1 smm2 
  if both_msets smm1 smm2;

(::~=) smm1::stlmmap smm2::stlmmap = ~allpairs (==) smm1 smm2
  if both_msets smm1 smm2;

::map f it::smmit = smm_listmap f it smm_both; // => smm_key for sets

::listmap f it::smmit = smm_listmap f it smm_both;

::catmap f it::smmit = smm_listcatmap f it smm_both;

::foldl f x it::smmit = smm_foldl f x it;

::foldl1 f it::smmit = smm_foldl1 f it;

::foldr f x it::smmit = smm_foldr f x it;

::foldr1 f it::smmit = smm_foldr1 f it;

::do f it::smmit = smm_foldl (\_ x->f x) () it $$ ();

::filter p it::smmit = smm_foldr f [] it with
  f x xs = res when
    res = case p x of
      1 = x:xs;
      0 = xs;
      y = throw failed_cond;
    end;
  end;
end;

::rowmap f it::smmit = rowcat (smm_listmap f it smm_both);

::rowcatmap f it::smmit = rowcat (smm_listmap f it smm_both);

::colmap f it::smmit = colcat (smm_listmap f it smm_both);

::colcatmap f it::smmit = colcat (smm_listmap f it smm_both);

/*** Functions for stlmmap *******************************************/

::emptystlmmap = smm_wrap $ smm_make_empty (<) 0;

::emptystlmmap_with comp = smm_wrap $ smm_make_empty comp 0;

::stlmmap xs = smm when
  smm = ::emptystlmmap;
  insert_elms smm xs;
end if listp xs || matrixp xs;

::stlmmap it::svit = smm when
  smm = ::emptystlmmap;
  insert_elms smm it;
end;

::stlmmap it::smmit = smm when
  smm = ::emptystlmmap;
  insert_elms smm it;
end;

::mkstlmmap y ks::list = do add ks $$ smm with
  add k = ::update smm k y;
end when
  smm = emptystlmmap;  
end;

set_default smm@(STLMMAP mm) val = smm_set_default mm val if ~smm_is_set smm;

// bool, default
get_default smm@(STLMMAP mm) = smm_get_default mm if ~smm_is_set smm;

::update smm@(STLMMAP mm) key x = smm_update mm key x $$ smm if ~smm_is_set smm;

::update_with f smm@(STLMMAP mm) key x = 
  smm_update_with mm key (f x) $$ smm if ~smm_is_set smm;

::delete_if pred smm@(STLMMAP mm) k = 
  smm_remove_if mm k pred 0 if ~smm_is_set smm;

::delete_all_if pred smm@(STLMMAP mm) k = 
  smm_remove_if mm k pred 1 if ~smm_is_set smm;

::keys it::smmit = smm_listmap 0 it smm_keys if ~smm_is_set it;

::vals it::smmit = smm_listmap 0 it smm_vals if ~smm_is_set it;

::map_keys f it::smmit = smm_listmap f it smm_keys if ~smm_is_set it;

::map_vals f it::smmit = smm_listmap f it smm_vals if ~smm_is_set it;

::catmap_keys f it::smmit = smm_listcatmap f it smm_keys if ~smm_is_set it;;

::catmap_vals f it::smmit = smm_listcatmap f it smm_vals if ~smm_is_set it;

/*** Functions for stlmset ************************************************/

::emptystlmset = smm_wrap $ smm_make_empty (<) 1;

::emptystlmset_with comp = smm_wrap $ smm_make_empty comp 1;

::stlmset xs = smm when
  smm = ::emptystlmset;
  insert_elms smm xs;
end if listp xs || matrixp xs;

::stlmset it::svit = smm when
  smm = ::emptystlmset;
  insert_elms smm it;
end;

::stlmset it::smmit = smm when
  smm = ::emptystlmset;
  insert_elms smm it;
end;

(::+) it1::smmit it2::smmit = 
  smm_wrap $ smm_setop smm_union it1 it2 if both_msets it1 it2;

(::-) it1::smmit it2::smmit = 
  smm_wrap $ smm_setop smm_difference it1 it2 if both_msets it1 it2;

(::*) it1::smmit it2::smmit = 
  smm_wrap $ smm_setop smm_intersection it1 it2 if both_msets it1 it2;

(::/) it1::smmit it2::smmit = 
  smm_wrap $ smm_setop smm_symmetric_difference it1 it2 if both_msets it1 it2;

(::<=) it1::smmit it2::smmit = smm_includes it2 it1 if both_msets it1 it2;

(::<) it1::smmit it2::smmit = 
  size it1 < size it2 && smm_includes it2 it1 if both_msets it1 it2;

