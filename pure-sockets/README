
====================================
pure-sockets: Pure Sockets Interface
====================================

:Author: Albert Gr√§f <Dr.Graef@t-online.de>
:Date: |date|

.. |date| date::

This is an interface to the Berkeley socket functions. It provides most of the
core functionality, so you can create sockets for both stream and datagram
based protocols and use these to transmit messages. Unix-style file sockets
are also available if the host system supports them.

Installation
============

This package uses Pure's new bitcode loader to ease porting, so you'll need
Pure 0.45 or later and an LLVM-based C compiler installed. The Makefile is set
up for clang (http://clang.llvm.org/) by default, because it's easier to
install, but you can also use llvm-gcc if you set the CC make variable
accordingly.

For clang compilation, do the usual ``make && sudo make install`` and you
should be set. To use llvm-gcc, replace ``make`` with ``make CC=llvm-gcc``.
You can also set custom compilation options with the CFLAGS variable, e.g.:
``make CFLAGS=-O3``.

To uninstall the module, use ``sudo make uninstall``. There are a number of
other targets (mostly for maintainers), please see the Makefile for details.

Usage
=====

To use the operations of this module, put the following in your Pure script::

  using sockets;

NOTE: On some systems you may also have to pull in a special system library to
get the socket functions. E.g.::

  using "lib:wsock32", sockets;

With the ``sockets`` module loaded, all the standard socket functions are
available and work pretty much like in C. The only real difference is that,
for convenience, functions taking socket addresses as parameters
(``struct_sockaddr*`` pointers in Pure), are called without the ``addrlen``
parameter; the size of the socket address structure will be inferred
automatically and passed to the underlying C functions. Also, there are some
convenience functions which act as wrappers around ``getaddrinfo`` and
``getnameinfo`` to create socket addresses from symbolic information (hostname
or ip, port names or numbers) and return information about existing address
pointers, see `Creating and Inspecting Socket Addresses`_ below.

Below is a list of the provided functions. Please see the corresponding manual
pages for details, and check the Pure scripts in the examples subdirectory for
some examples.

Creating and Inspecting Socket Addresses
----------------------------------------

These functions are Pure-specific. The created socket addresses are
``malloc``'ed and free themselves automatically when garbage-collected.

``struct_sockaddr *sockaddr();``

    Create a pointer to an empty socket address suitable to hold the socket
    address result of routines like ``accept``, ``getsockname``, ``recvfrom``,
    etc. which return a socket address.

``struct_sockaddr *sockaddr([int family,] char *path);``

    Create a local (a.k.a. file) socket for the given pathname. The ``family``
    parameter, if specified, must be ``AF_UNIX`` here. Please note that
    ``AF_UNIX`` is not supported on all platforms. You can check for this by
    testing the ``HAVE_AF_UNIX`` constant, which is a truth value specifying
    whether ``AF_UNIX`` is available on your system.

``struct_sockaddr *sockaddr([int family,] char *host, char *port);``

``struct_sockaddr *sockaddr([int family,] char *host, int port);``

    This uses ``getaddrinfo`` to retrieve an ``AF_INET`` or ``AF_INET6``
    address for the given hostname (or numeric IP address in string form) and
    port (specified either as an int or a string). If ``family`` is omitted,
    it defaults to ``AF_UNSPEC`` which matches both ``AF_INET`` and
    ``AF_INET6`` addresses.

``struct_sockaddr *sockaddrs([int family,] char *host, char *port);``

``struct_sockaddr *sockaddrs([int family,] char *host, int port);``

    This works like ``sockaddr`` above, but returns a list with *all* matching
    addresses.

``int sockaddr_family(struct_sockaddr *addr);``

    Returns the address family of the given address.

``char *sockaddr_path(struct_sockaddr *addr);``

    Returns the pathname for ``AF_UNIX`` addresses.

``char *sockaddr_hostname(struct_sockaddr *addr);``

    Returns the hostname if available, the IP address otherwise.

``char *sockaddr_ip(struct_sockaddr *addr);``

    Returns the IP address.

``char *sockaddr_service(struct_sockaddr *addr);``

    Returns the service (a.k.a. port) name.

``int sockaddr_port(struct_sockaddr *addr);``

    Returns the port number.

``expr *sockaddr_info(struct_sockaddr *addr);``

    Returns a readable description of a socket address, as a
    ``(family,hostname,port)`` tuple. You should be able to pass this into
    ``sockaddr`` again to get the original address.

Creating and Closing Sockets
----------------------------

``int socket(int domain, int type, int protocol);``

    Creates a socket for the given protocol family (``AF_UNIX``, ``AF_INET``
    or ``AF_INET6``), socket type (``SOCK_STREAM``, ``SOCK_DGRAM``, etc.) and
    protocol. The protocol can be 0, denoting the default protocol, or any of
    the defined ``IPPROTO`` constants, try ``show -g IPPROTO_*`` for a list of
    those. Note that on Linux we also support the ``SOCK_NONBLOCK`` and
    ``SOCK_CLOEXEC`` flags which can be or'ed with the socket type to get
    sockets with the corresponding features.

``int socketpair(int domain, int type, int protocol, int *sv);``

    Create a pair of sockets. The descriptors are returned in the integer
    vector passed in the last argument.

``int shutdown(int fd, int how);``

  Perform shutdown on a socket. The second argument should be one of
  ``SHUT_RD``, ``SHUT_WR`` and ``SHUT_RDWR``.

``closesocket(int fd);``

  This is provided for Windows compatibility. On POSIX systems this is just
  ``close``.

Establishing Connections
------------------------

``int accept(int sockfd, struct_sockaddr *addr);``

``int bind(int sockfd, struct_sockaddr *addr);``

``int connect(int sockfd, struct_sockaddr *addr);``

``int listen(int sockfd, int backlog);``

Socket I/O
----------

``size_t recv(int fd, void *buf, size_t len, int flags);``

``size_t send(int fd, void *buf, size_t len, int flags);``

``size_t recvfrom(int fd, void *buf, size_t len, int flags, struct_sockaddr *addr);``

``size_t sendto(int fd, void *buf, size_t len, int flags, struct_sockaddr *addr);``

The usual ``send``/``recv`` flags specified by POSIX (``MSG_EOR``,
``MSG_OOB``, ``MSG_PEEK``, ``MSG_WAITALL``) are provided. On Linux we also
support ``MSG_DONTWAIT``. Note that on POSIX systems you can also just
``fdopen`` the socket descriptor and use the standard file I/O operations from
the ``system`` module instead.

Socket Information
------------------

``int getsockname(int fd, struct_sockaddr *addr);``

``int getpeername(int fd, struct_sockaddr *addr);``

``int getsockopt(int fd, int level, int name, void *val, int *len);``

``int setsockopt(int fd, int level, int name, void *val, int len);``

For ``getsockopt`` and ``setsockopt``, currently only the ``SOL_SOCKET`` level
is defined (``level`` argument) along with the available POSIX socket options
(``name`` argument). Try ``show -g SO_*`` to get a list of those. Also note
that for most socket level options the ``val`` argument is actually an
``int*``, so you can pass a Pure int vector (with ``len = SIZEOF_INT``) for
that parameter.
