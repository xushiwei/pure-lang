
/* gsl_randist.pure: GSL wrapper for the Pure programming language. */

/* Copyright (c) 2008 by Albert Graef <Dr.Graef@t-online.de>.
   Copyright (c) 2008 by Robert E. Rucker <erucker@bmc.edu>.

   This file is part of the Pure programming language and system.

   Pure is free software: you can redistribute it and/or modify it under the
   terms of the GNU General Public License as published by the Free Software
   Foundation, either version 3 of the License, or (at your option) any later
   version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
   details.

   You should have received a copy of the GNU General Public License along
   with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* ..
   
   Random Number Distributions
   ---------------------------
   
   This module is loaded via the command ``using gsl::randist`` and provides
   Pure wrappers for the GSL random distribution routines found in Chapter 
   19 of the GSL manual,
   
   http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html.
   
   There are two namespaces provided by randist.pure, ``gsl::ran`` for
   probability densitity functions and ``gsl::cdf`` for cumulative
   distribution functions. The two namespaces minimize typing of the
   prefixes ``gsl_ran_`` and ``gsl_cdf_`` respectively.
   
   Much of the documentation in this section is copied directly from the GSL
   Reference Manual.
   
   Routines
   ~~~~~~~~ */

using "lib:gsl";

namespace gsl;
namespace gsl::ran;

private extern double gsl_ran_gaussian_pdf(double, double);
private extern double gsl_ran_ugaussian_pdf(double);
private extern double gsl_ran_gaussian_tail_pdf(double, double, double);
private extern double gsl_ran_ugaussian_tail_pdf(double, double);
private extern double gsl_ran_bivariate_gaussian_pdf
  (double, double, double, double, double);
private extern double gsl_ran_exponential_pdf(double, double);
private extern double gsl_ran_laplace_pdf(double, double);
private extern double gsl_ran_exppow_pdf(double, double, double);
private extern double gsl_ran_cauchy_pdf(double, double);
private extern double gsl_ran_rayleigh_pdf(double, double);
private extern double gsl_ran_rayleigh_tail_pdf(double, double, double);
private extern double gsl_ran_landau_pdf(double);
private extern double gsl_ran_gamma_pdf(double, double, double);
private extern double gsl_ran_flat_pdf(double, double, double);
private extern double gsl_ran_lognormal_pdf(double, double, double);
private extern double gsl_ran_chisq_pdf(double, double);
private extern double gsl_ran_fdist_pdf(double, double, double);
private extern double gsl_ran_tdist_pdf(double, double);
private extern double gsl_ran_beta_pdf(double, double, double);
private extern double gsl_ran_logistic_pdf(double, double);
private extern double gsl_ran_pareto_pdf(double, double, double);
private extern double gsl_ran_weibull_pdf(double, double, double);
private extern double gsl_ran_gumbel1_pdf(double, double, double);
private extern double gsl_ran_gumbel2_pdf(double, double, double);
private extern double gsl_ran_dirichlet_pdf(size_t, double*, double*);
private extern double gsl_ran_dirichlet_lnpdf(size_t, double*, double*);
private extern gsl_ran_discrete_t *gsl_ran_discrete_preproc(size_t, double*);
private extern double gsl_ran_discrete_pdf(size_t, gsl_ran_discrete_t*);
private extern void gsl_ran_discrete_free(gsl_ran_discrete_t *);
private extern double gsl_ran_poisson_pdf(int, double);
private extern double gsl_ran_bernoulli_pdf(int, double);
private extern double gsl_ran_binomial_pdf(int, double, int);
private extern double gsl_ran_multinomial_pdf(size_t, double*, int*);
private extern double gsl_ran_multinomial_lnpdf(size_t, double*, int*);
private extern double gsl_ran_negative_binomial_pdf(int, double, double);
private extern double gsl_ran_pascal_pdf(int, double, int);
private extern double gsl_ran_geometric_pdf(int, double);
private extern double gsl_ran_hypergeometric_pdf(int, int, int, int);
private extern double gsl_ran_logarithmic_pdf(int, double);

/* P.d.f. macro. */

private
  apply2_ran;

def apply2_ran  f  m1  m2  =
  if rowvectorp m1 && rowvectorp m2 && #m1 == #m2 then
    (v
     when
       x1, x2 = dmatrix m1, dmatrix m2;
       v = f (#m1) (pointer x1) (pointer x2);
     end)
  else
    f m1 m2;

public
  ugaussian_pdf
  gaussian_pdf
  gaussian_tail_pdf
  ugaussian_tail_pdf
  bivariate_gaussian_pdf
  exponential_pdf
  laplace_pdf
  exppow_pdf
  cauchy_pdf
  rayleigh_pdf
  rayleigh_tail_pdf
  landau_pdf
  gamma_pdf
  flat_pdf
  lognormal_pdf
  chisq_pdf
  fdist_pdf
  tdist_pdf
  beta_pdf
  logistic_pdf
  pareto_pdf
  weibull_pdf
  gumbel1_pdf
  gumbel2_pdf
  dirichlet_pdf
  dirichlet_lnpdf
  discrete_preproc
  discrete_pdf
  discrete_free
  poisson_pdf
  bernoulli_pdf
  binomial_pdf
  multinomial_pdf
  multinomial_lnpdf
  negative_binomial_pdf
  pascal_pdf
  geometric_pdf
  hypergeometric_pdf
  logarithmic_pdf;

/* .. _ugaussian_pdf:
   
   ``ugaussian_pdf  x``
     
     computes the probability density at ``x`` for the Gaussian 
     distribution with a standard deviation of 1.
*/

ugaussian_pdf  x
  = gsl_ran_ugaussian_pdf (double x) if realp x;

/* .. _gaussian_pdf:
   
   ``gaussian_pdf  x  sigma``
     
     computes the probability density at ``x`` for the Gaussian
     distribution with standard deviation ``sigma``.
*/

gaussian_pdf  x  sigma
  = gsl_ran_gaussian_pdf (double x) (double sigma) if realp x && realp sigma;

/* .. _gaussian_tail_pdf:
   
   ``gaussian_tail_pdf  x  a  sigma``
     
     computes the probability density at ``x`` for the Gaussian tail
     distribution with standard deviation ``sigma`` and lower limit ``a``.
*/

gaussian_tail_pdf  x  a  sigma
  = gsl_ran_gaussian_tail_pdf (double x) (double a) (double sigma)
    if realp x && realp a && realp sigma;

/* .. _ugaussian_tail_pdf:
   
   ``ugaussian_tail_pdf  x  a``
     
     computes the probability density at ``x`` for the Gaussian tail
     distribution with standard deviation 1 and lower limit `a`.
*/

ugaussian_tail_pdf  x  a
  = gsl_ran_ugaussian_tail_pdf (double x) (double a) if realp x && realp a;

/* .. _bivariate_gaussian_pdf:
   
   ``bivariate_gaussian_tail_pdf  x  a``
     
     computes the probability density at ``(x, y)`` for a bivariate
     Gaussian distribution with standard deviations ``sigma_x``, 
     ``sigma_y`` and correlation coefficient ``rho``.
*/

bivariate_gaussian_pdf  x  y  sigma_x  sigma_y  rho
  = gsl_ran_bivariate_gaussian_pdf
      (double x) (double y) (double sigma_x) (double sigma_y) (double rho)
    if realp x && realp y && realp sigma_x && realp sigma_y && realp rho;

/* .. _expoential_pdf:
   
   ``exponential_pdf  x  mu``
     
     computes the probability density at ``x`` for an exponential 
     distribution with mean ``mu``.
*/

exponential_pdf  x  mu
  = gsl_ran_exponential_pdf (double x) (double mu) if realp x && realp mu;

/* .. _laplace_pdf:
   
   ``laplace_pdf  x  a``
     
     computes the probability density at ``x`` for a Laplace 
     distribution with width ``a``.
*/

laplace_pdf  x  a
  = gsl_ran_laplace_pdf (double x) (double a) if realp x && realp a;

/* .. _exppow_pdf:
   
   ``exppow_pdf  x  a  b``
     
     computes the probability density at ``x`` for an exponential power
     distribution with scale parameter ``a`` and exponent ``b``.
*/

exppow_pdf  x  a  b
  = gsl_ran_exppow_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

/* .. _cauchy_pdf:
   
   ``cauchy_pdf  x  a``
     
     computes the probability density at ``x`` for a Cauchy distribution 
     with scale parameter ``a``.
*/

cauchy_pdf  x  a
  = gsl_ran_cauchy_pdf (double x) (double a) if realp x && realp a;

/* .. _rayleigh_pdf:
   
   ``rayleigh_pdf  x  sigma``
     
     computes the probability density at `x` for a Rayleigh distribution with
     scale parameter ``sigma``.
*/

rayleigh_pdf  x  sigma
  = gsl_ran_rayleigh_pdf (double x) (double sigma) if realp x && realp sigma;

/* .. _rayleigh_tail_pdf:
   
   ``rayleigh_tail_pdf  x  a  sigma``
     
     computes the probability density at ``x`` for a Rayleigh tail
     distribution with scale parameter ``sigma`` and lower limit ``a``.
*/

rayleigh_tail_pdf  x  a  sigma
  = gsl_ran_rayleigh_tail_pdf (double x) (double a) (double sigma)
    if realp x && realp a && realp sigma;

/* .. _landau_pdf:
   
   ``landau_pdf  x``
     
     computes the probability density at ``x`` for the Landau distribution.
*/

landau_pdf  x
  = gsl_ran_landau_pdf x if realp x;

/* .. _gamma_pdf:
   
   ``gamma_pdf  x  a  b``
     
     computes the probability density at ``x`` for a gamma distribution with
     parameters ``a`` and ``b``.
*/

gamma_pdf  x  a  b
  = gsl_ran_gamma_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

/* .. _flat_pdf:
   
   ``flat_pdf  x  a  b``
     
     computes the probability density at ``x`` for a uniform distribution 
     from ``a`` to ``b``.
*/

flat_pdf  x  a  b
  = gsl_ran_flat_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

/* .. _lognormal_pdf:
   
   ``lognormal_pdf  x  zeta  sigma``
     
     computes the probability density at ``x`` for a lognormal distribution
     with parameters ``zeta`` and ``sigma``.
*/

lognormal_pdf  x  zeta  sigma
  = gsl_ran_lognormal_pdf (double x) (double zeta) (double sigma)
    if realp x && realp zeta && realp sigma;

/* .. _chisq_pdf:
   
   ``chisq_pdf  x  nu``
     
     computes the probability density at ``x`` for a chi-squared
     distribution with ``nu`` degrees of freedom.
*/

chisq_pdf  x  nu
  = gsl_ran_chisq_pdf (double x) (double nu) if realp x && realp nu;

/* .. _fdist_pdf:
   
   ``fdist_pdf  x  nu1  nu2``
     
     computes the probability density at ``x`` for an F-distribution with
     ``nu1`` and ``nu2`` degrees of freedom.
*/

fdist_pdf  x  nu1  nu2
  = gsl_ran_fdist_pdf (double x) (double nu1) (double nu2)
    if realp x && realp nu1 && realp nu2;

/* .. _tdist_pdf:
   
   ``tdist_pdf  x  nu``
     
     computes the probability density at ``x`` for a t-distribution with
     ``nu`` degrees of freedom.
*/

tdist_pdf  x  nu
  = gsl_ran_tdist_pdf (double x) (double nu) if realp x && realp nu;

/* .. _beta_pdf:
   
   ``beta_pdf  x  a  b``
     
     computes the probability density at ``x`` for a beta distribution with
     parameters ``a`` and ``b``.
*/

beta_pdf  x  a  b
  = gsl_ran_beta_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

/* .. _logistic_pdf:
   
   ``logistic_pdf  x  a``
     
     computes the probability density at ``x`` for a logistic distribution 
     with scale parameter ``a``.
*/

logistic_pdf  x  a
  = gsl_ran_logistic_pdf (double x) (double a) if realp x && realp a;

/* .. _pareto_pdf:
   
   ``pareto_pdf  x  a  b``
     
     computes the probability density at ``x`` for a Pareto distribution with
     exponent ``a`` and scale ``b``.
*/

pareto_pdf  x  a  b
  = gsl_ran_pareto_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

/* .. _weibull_pdf:
   
   ``weibull_pdf  x  a  b``
     computes the probability density `p(x)` at `x` for a Weibull distribution with 
     scale `a` and exponent `b`.
*/

weibull_pdf  x  a  b
  = gsl_ran_weibull_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

/* .. _gumbel1_pdf:
   
   ``gumbel1_pdf  x  a  b``
     
     computes the probability density at ``x`` for a Type-1 Gumbel
     distribution with parameters ``a`` and ``b``.
*/

gumbel1_pdf  x  a  b
  = gsl_ran_gumbel1_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

/* .. _gumbel2_pdf:
   
   ``gumbel2_pdf  x  a  b``
     
     computes the probability density at ``x`` for a Type-2 Gumbel 
     distribution with parameters ``a`` and ``b``.
*/

gumbel2_pdf  x  a  b
  = gsl_ran_gumbel2_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

/* .. _dirichlet_pdf:
   
   ``dirichlet_pdf  alpha::matrix  theta::matrix``
     
     computes the probability density at ``theta!K`` for a
     Dirichlet distribution with parameters ``alpha!K``.
*/

dirichlet_pdf  alpha::matrix  theta::matrix
  = apply2_ran gsl_ran_dirichlet_pdf alpha theta;

/* .. _dirichlet_lnpdf:
   
   ``dirichlet_lnpdf  alpha::matrix  theta::matrix``
     
     computes the logarithm of the probability density at ``theta!K`` for
     a Dirichlet distribution with parameters ``alpha!K``.
*/

dirichlet_lnpdf  alpha::matrix  theta::matrix
  = apply2_ran gsl_ran_dirichlet_lnpdf alpha theta;

/* .. _discrete_preproc:
   
   ``discrete_preproc  p::matrix``
     
     returns a pointer to a structure that contains the lookup table for the
     discrete random number generator. 
*/

discrete_preproc  p::matrix
  = v
    when
      x = dmatrix p;
      v = gsl_ran_discrete_preproc (#p) (pointer x);
    end
    if rowvectorp p;

/* .. _discrete_pdf:
   
   ``discrete_pdf  k::int  p::pointer``
     
     Returns the probability of observing the variable ``k`` where
     ``p`` points to the lookup table created by the ``discrete_preproc``
     function.
*/

discrete_pdf  k::int  p::pointer
  = gsl_ran_discrete_pdf k p if k >= 0;

/* .. _discrete_free:
   
   ``discrete_free  p::pointer``
     
     De-allocates the lookup table created by ``discrete_preproc`` and pointed 
     to by ``p``.
*/

discrete_free  p::pointer
  = gsl_ran_discrete_free p;

/* .. _poisson_pdf:
   
   ``poisson_pdf  k::int  mu``
     
     computes the probability of obtaining ``k`` from a Poisson distribution
     with mean ``mu``.
*/

poisson_pdf  k::int  mu
  = gsl_ran_poisson_pdf k (double mu) if realp mu && k >= 0;

/* .. _bernoulli_pdf:
   
   ``bernoulli_pdf  k::int  p``
     
     computes the probability of obtaining ``k`` from a Bernoulli distribution
     with probability parameter ``p``.
*/

bernoulli_pdf  k::int  p
  = gsl_ran_bernoulli_pdf k (double p) if realp p && k >= 0;

/* .. _binomial_pdf:
   
   ``binomial_pdf  k::int  p  n::int``
     
     computes the probability of obtaining ``k`` from a binomial distribution 
     with parameters ``p`` and ``n``.
*/

binomial_pdf  k::int  p  n::int
  = gsl_ran_binomial_pdf k (double p) n if realp p && k >= 0 && n > 0;

/* .. _multinomial_pdf:
   
   ``multinomial_pdf  p::matrix  n::matrix``
     
     computes the probability of sampling ``n!K`` from a 
     multinomial distribution with parameters ``p!K``.
*/

multinomial_pdf  p::matrix  n::matrix
  = apply2_ran gsl_ran_multinomial_pdf p n;

/* .. _multinomial_lnpdf:
   
   ``multinomial_lnpdf  p::matrix  n::matrix``
     
     returns the logarithm of the probability for the multinomial distribution 
     with parameters ``p!K``.
*/

multinomial_lnpdf  p::matrix  n::matrix
  = apply2_ran gsl_ran_multinomial_lnpdf p n;

/* .. _negative_binomial_pdf:
   
   ``negative_binomial_pdf  k::int  p  n``
     
     computes the probability of obtaining ``k`` from a negative binomial 
     distribution with parameters ``p`` and ``n``.
*/

negative_binomial_pdf  k::int  p  n
  = gsl_ran_negative_binomial_pdf k (double p) (double n)
    if realp p && realp n && k >= 0;

/* .. _pascal_pdf:
   
   ``pascal_pdf  k::int  p  n::int``
     
     computes the probability of obtaining ``k`` from a Pascal distribution 
     with parameters ``p`` and ``n``.
*/

pascal_pdf  k::int  p  n::int
  = gsl_ran_pascal_pdf k (double p) n if realp p && k >= 0;

/* .. _geometric_pdf:
   
   ``geometric_pdf  k::int  p``
     
     computes the probability of obtaining ``k`` from a geometric distribution
     with probability parameter ``p``.
*/

geometric_pdf  k::int  p
  = gsl_ran_geometric_pdf k (double p) if realp p && k >= 1;

/* .. _hypergeometric_pdf:
   
   ``hypergeometric_pdf  k::int  n1::int  n2::int  t::int``
     
     computes the probability of obtaining ``k`` from a hypergeometric 
     distribution with parameters ``n1``, ``n2``, ``t``.
*/

hypergeometric_pdf  k::int  n1::int  n2::int  t::int
  = gsl_ran_hypergeometric_pdf k n1 n2 t
    if k >= 0 && n1 >= 0 && n2 >= 0 && t >= 0;

/* .. _logarithmic_pdf:
   
   ``logarithmic_pdf  k::int  p``
     
     computes the probability of obtaining ``k`` from a logarithmic 
     distribution with probability parameter ``p``.
*/

logarithmic_pdf  k::int  p
  = gsl_ran_logarithmic_pdf k (double p) if k >= 1 && realp p;

namespace gsl::cdf;

private extern double gsl_cdf_ugaussian_P(double);
private extern double gsl_cdf_gaussian_P(double, double);
private extern double gsl_cdf_ugaussian_Q(double);
private extern double gsl_cdf_gaussian_Q(double, double);
private extern double gsl_cdf_ugaussian_Pinv(double);
private extern double gsl_cdf_gaussian_Pinv(double, double);
private extern double gsl_cdf_ugaussian_Qinv(double);
private extern double gsl_cdf_gaussian_Qinv(double, double);
private extern double gsl_cdf_exponential_P(double, double);
private extern double gsl_cdf_exponential_Q(double, double);
private extern double gsl_cdf_exponential_Pinv(double, double);
private extern double gsl_cdf_exponential_Qinv(double, double);
private extern double gsl_cdf_laplace_P(double, double);
private extern double gsl_cdf_laplace_Q(double, double);
private extern double gsl_cdf_laplace_Pinv(double, double);
private extern double gsl_cdf_laplace_Qinv(double, double);
private extern double gsl_cdf_exppow_P(double, double, double);
private extern double gsl_cdf_exppow_Q(double, double, double);
private extern double gsl_cdf_cauchy_P(double, double);
private extern double gsl_cdf_cauchy_Q(double, double);
private extern double gsl_cdf_cauchy_Pinv(double, double);
private extern double gsl_cdf_cauchy_Qinv(double, double);
private extern double gsl_cdf_rayleigh_P(double, double);
private extern double gsl_cdf_rayleigh_Q(double, double);
private extern double gsl_cdf_rayleigh_Pinv(double, double);
private extern double gsl_cdf_rayleigh_Qinv(double, double);
private extern double gsl_cdf_gamma_P(double, double, double);
private extern double gsl_cdf_gamma_Q(double, double, double);
private extern double gsl_cdf_gamma_Pinv(double, double, double);
private extern double gsl_cdf_gamma_Qinv(double, double, double);
private extern double gsl_cdf_flat_P(double, double, double);
private extern double gsl_cdf_flat_Q(double, double, double);
private extern double gsl_cdf_flat_Pinv(double, double, double);
private extern double gsl_cdf_flat_Qinv(double, double, double);
private extern double gsl_cdf_lognormal_P(double, double, double);
private extern double gsl_cdf_lognormal_Q(double, double, double);
private extern double gsl_cdf_lognormal_Pinv(double, double, double);
private extern double gsl_cdf_lognormal_Qinv(double, double, double);
private extern double gsl_cdf_chisq_P(double, double);
private extern double gsl_cdf_chisq_Q(double, double);
private extern double gsl_cdf_chisq_Pinv(double, double);
private extern double gsl_cdf_chisq_Qinv(double, double);
private extern double gsl_cdf_fdist_P(double, double, double);
private extern double gsl_cdf_fdist_Q(double, double, double);
private extern double gsl_cdf_fdist_Pinv(double, double, double);
private extern double gsl_cdf_fdist_Qinv(double, double, double);
private extern double gsl_cdf_tdist_P(double, double);
private extern double gsl_cdf_tdist_Q(double, double);
private extern double gsl_cdf_tdist_Pinv(double, double);
private extern double gsl_cdf_tdist_Qinv(double, double);
private extern double gsl_cdf_beta_P(double, double, double);
private extern double gsl_cdf_beta_Q(double, double, double);
private extern double gsl_cdf_beta_Pinv(double, double, double);
private extern double gsl_cdf_beta_Qinv(double, double, double);
private extern double gsl_cdf_logistic_P(double, double);
private extern double gsl_cdf_logistic_Q(double, double);
private extern double gsl_cdf_logistic_Pinv(double, double);
private extern double gsl_cdf_logistic_Qinv(double, double);
private extern double gsl_cdf_pareto_P(double, double, double);
private extern double gsl_cdf_pareto_Q(double, double, double);
private extern double gsl_cdf_pareto_Pinv(double, double, double);
private extern double gsl_cdf_pareto_Qinv(double, double, double);
private extern double gsl_cdf_weibull_P(double, double, double);
private extern double gsl_cdf_weibull_Q(double, double, double);
private extern double gsl_cdf_weibull_Pinv(double, double, double);
private extern double gsl_cdf_weibull_Qinv(double, double, double);
private extern double gsl_cdf_gumbel1_P(double, double, double);
private extern double gsl_cdf_gumbel1_Q(double, double, double);
private extern double gsl_cdf_gumbel1_Pinv(double, double, double);
private extern double gsl_cdf_gumbel1_Qinv(double, double, double);
private extern double gsl_cdf_gumbel2_P(double, double, double);
private extern double gsl_cdf_gumbel2_Q(double, double, double);
private extern double gsl_cdf_gumbel2_Pinv(double, double, double);
private extern double gsl_cdf_gumbel2_Qinv(double, double, double);
private extern double gsl_cdf_poisson_P(int, double);
private extern double gsl_cdf_poisson_Q(int, double);
private extern double gsl_cdf_binomial_P(int, double, int);
private extern double gsl_cdf_binomial_Q(int, double, int);
private extern double gsl_cdf_negative_binomial_P(int, double, double);
private extern double gsl_cdf_negative_binomial_Q(int, double, double);
private extern double gsl_cdf_pascal_P(int, double, int);
private extern double gsl_cdf_pascal_Q(int, double, int);
private extern double gsl_cdf_geometric_P(int, double);
private extern double gsl_cdf_geometric_Q(int, double);
private extern double gsl_cdf_hypergeometric_P(int, int, int, int);
private extern double gsl_cdf_hypergeometric_Q(int, int, int, int);

public
  ugaussian_P
  gaussian_P
  ugaussian_Q
  gaussian_Q
  ugaussian_Pinv
  gaussian_Pinv
  ugaussian_Qinv
  gaussian_Qinv
  exponential_P
  exponential_Q
  exponential_Pinv
  exponential_Qinv
  laplace_P
  laplace_Q
  laplace_Pinv
  laplace_Qinv
  exppow_P
  exppow_Q
  cauchy_P
  cauchy_Q
  cauchy_Pinv
  cauchy_Qinv
  rayleigh_P
  rayleigh_Q
  rayleigh_Pinv
  rayleigh_Qinv
  gamma_P
  gamma_Q
  gamma_Pinv
  gamma_Qinv
  flat_P
  flat_Q
  flat_Pinv
  flat_Qinv
  lognormal_P
  lognormal_Q
  lognormal_Pinv
  lognormal_Qinv
  chisq_P
  chisq_Q
  chisq_Pinv
  chisq_Qinv
  fdist_P
  fdist_Q
  fdist_Pinv
  fdist_Qinv
  tdist_P
  tdist_Q
  tdist_Pinv
  tdist_Qinv
  beta_P
  beta_Q
  beta_Pinv
  beta_Qinv
  logistic_P
  logistic_Q
  logistic_Pinv
  logistic_Qinv
  pareto_P
  pareto_Q
  pareto_Pinv
  pareto_Qinv
  weibull_P
  weibull_Q
  weibull_Pinv
  weibull_Qinv
  gumbel1_P
  gumbel1_Q
  gumbel1_Pinv
  gumbel1_Qinv
  gumbel2_P
  gumbel2_Q
  gumbel2_Pinv
  gumbel2_Qinv
  poisson_P
  poisson_Q
  binomial_P
  binomial_Q
  negative_binomial_P
  negative_binomial_Q
  pascal_P
  pascal_Q
  geometric_P
  geometric_Q
  hypergeometric_P
  hypergeometric_Q;

/* .. _ugaussian_P: _ugaussian_Q: _ugaussian_Pinv: _ugaussian_Qinv:
   
   ``ugaussian_P  x``
     
     computes the Guassian cumulative distribution function `P(x)` with
     standard deviation 1.
   
   ``ugaussian_Q  x``
     
     computes the Guassian cumulative distribution function `Q(x)` with
     standard deviation 1.
   
   ``ugaussian_Pinv p``
     
     computes the inverse of the Guassian cumulative distribution function
     of `P(x)` with standard deviation 1.
   
   ``ugaussian_Qinv q``
     
     computes the inverse of the Guassian cumulative distribution function
     of `Q(x)` with standard deviation 1.
*/

ugaussian_P  x
  = gsl_cdf_ugaussian_P (double x) if realp x;

ugaussian_Q  x
  = gsl_cdf_ugaussian_Q (double x) if realp x;

ugaussian_Pinv  p
  = gsl_cdf_ugaussian_Pinv (double p) if realp p;

ugaussian_Qinv  q
  = gsl_cdf_ugaussian_Qinv (double q) if realp q;

/* .. _gaussian_P: _gaussian_Q: _gaussian_Pinv: _gaussian_Qinv:
   
   ``gaussian_P  x  sigma``
     
     computes the cumulative Guassian distribution function `P(x)` with
     standard deviation ``sigma``.
     
   ``gaussian_Q  x  sigma``
     
     computes the cumulative Guassian distribution function `Q(x)` with
     standard deviation ``sigma``.
     
   ``gaussian_Pinv  p  sigma``
     
     computes the inverse of the cumulative Guassian distribution function
     of `P(x)` with standard deviation ``sigma``.
   
   ``guassian_Qinv  q  sigma``
     
     computes the inverse of the cumulative Guassian distribution function
     of `Q(x)` with standard deviation ``sigma``.
*/

gaussian_P  x  sigma
  = gsl_cdf_gaussian_P (double x) (double sigma) if realp x && realp sigma;

gaussian_Q  x  sigma
  = gsl_cdf_gaussian_Q (double x) (double sigma) if realp x && realp sigma;

gaussian_Pinv  p  sigma
  = gsl_cdf_gaussian_Pinv (double p) (double sigma) if realp p && realp sigma;

gaussian_Qinv  q  sigma
  = gsl_cdf_gaussian_Qinv (double q) (double sigma) if realp q && realp sigma;

/* .. _exponential_P: _exponential_Q: _exponential_Pinv: _exponential_Qinv:
   
   ``exponential_P  x  mu``
     
     computes the cumulative exponential distribution function `P(x)` with
     mean ``mu``.
       
   ``exponential_Q  x  mu``
     
     computes the cumulative exponential distribution function `Q(x)` with
     mean ``mu``.
     
   ``exponential_Pinv  p  mu``
     
     computes the inverse of the cumulative exponential distribution function
     of `P(x)` with mean ``mu``.
     
   ``exponential_Qinv  q  mu``
     
     computes the inverse of the cumulative exponential distribution function
     of `Q(x)` with mean ``mu``.
*/

exponential_P  x  mu
  = gsl_cdf_exponential_P (double x) (double mu) if realp x && realp mu;

exponential_Q  x  mu
  = gsl_cdf_exponential_Q (double x) (double mu) if realp x && realp mu;

exponential_Pinv  p  mu
  = gsl_cdf_exponential_Pinv (double p) (double mu) if realp p && realp mu;

exponential_Qinv  q  mu
  = gsl_cdf_exponential_Qinv (double q) (double mu) if realp q && realp mu;

/* .. _laplace_P: _laplace_Q: _laplace_Pinv: _laplace_Qinv:
   
   ``laplace_P  x  a``
     
     computes the cumulative Laplace distribution function `P(x)` with
     width ``a``.   
     
   ``laplace_Q  x  a``
     
     computes the cumulative Laplace distribution function `Q(x)` with
     width ``a``.
   
   ``laplace_Pinv  p  a``
     
     computes the inverse of the cumulative Laplace distribution function
     of `P(x)` with width ``a``.

   ``laplace_Qinv  q  a``
     
     computes the inverse of the cumulative Laplace distribution function
     of `Q(x)` with width ``a``.
*/

laplace_P  x  a
  = gsl_cdf_laplace_P (double x) (double a) if realp x && realp a;

laplace_Q  x  a
  = gsl_cdf_laplace_Q (double x) (double a) if realp x && realp a;

laplace_Pinv  p  a
  = gsl_cdf_laplace_Pinv (double p) (double a) if realp p && realp a;

laplace_Qinv  q  a
  = gsl_cdf_laplace_Qinv (double q) (double a)
    if realp q && realp a;

/* .. _exppow_P: _exppow_Q:
   
   ``exppow_P  x  a  b``
     
     computes the cumulative exponential power distribution function `P(x)`
     with parameters ``a`` and `b`.
     
   ``exppow_Q  x  a  b``
     
     computes the cumulative exponential power distribution function `Q(x)`
     with parameters ``a`` and `b`.
*/

exppow_P  x  a  b
  = gsl_cdf_exppow_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

exppow_Q  x  a  b
  = gsl_cdf_exppow_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

/* .. _cauchy_P: _cauchy_Q: _cauchy_Pinv: _cauchy_Qinv:
   
   ``cauchy_P  x  a``
     
     computes the cumulative Cauchy distribution function `P(x)` with
     scale parameter ``a``.
     
   ``cauchy_Q  x  a``
     
     computes the cumulative Cauchy distribution function `Q(x)` with
     scale parameter ``a``.
     
   ``cauchy_Pinv  p  a``
     
     computes the inverse of the cumulative Cauchy distribution function
     of `P(x)` with scale ``a``.
     
   ``cauchy_Qinv  q  a``
     
     computes the inverse of the cumulative Cauchy distribution function
     of `Q(x)` with scale ``a``.
*/

cauchy_P  x  a
  = gsl_cdf_cauchy_P (double x) (double a) if realp x && realp a;

cauchy_Q  x  a
  = gsl_cdf_cauchy_Q (double x) (double a) if realp x && realp a;

cauchy_Pinv  p  a
  = gsl_cdf_cauchy_Pinv (double p) (double a) if realp p && realp a;

cauchy_Qinv  q  a
  = gsl_cdf_cauchy_Qinv (double q) (double a) if realp q && realp a;

/* .. _rayleigh_P: _rayleigh_Q: _rayleigh_Pinv: _rayleigh_Qinv:
   
   ``rayleigh_P  x  sigma``
     
     computes the cumulative Rayleigh distribution function `P(x)` with
     scale parameter ``sigma``.
     
   ``rayleigh_Q  x  sigma``
     
     computes the cumulative Rayleigh distribution function `Q(x)` with
     scale parameter ``sigma``.

   ``rayleigh_Pinv  p  sigma``
     
     computes the inverse of the cumulative Rayleigh distribution function
     of `P(x)` with scale parameter ``sigma``.
     
   ``rayleigh_Qinv  q  sigma``
     
     computes the inverse of the cumulative Rayleigh distribution function
     of `Q(x)` with scale parameter ``sigma``.
*/

rayleigh_P  x  sigma
  = gsl_cdf_rayleigh_P (double x) (double sigma) if realp x && realp sigma;

rayleigh_Q  x  sigma
  = gsl_cdf_rayleigh_Q (double x) (double sigma) if realp x && realp sigma;

rayleigh_Pinv  p  sigma
  = gsl_cdf_rayleigh_Pinv (double p) (double sigma) if realp p && realp sigma;

rayleigh_Qinv  q  sigma
  = gsl_cdf_rayleigh_Qinv (double q) (double sigma) if realp q && realp sigma;

/* .. _gamma_P: _gamma_Q: _gamma_Pinv: _gamma_Qinv:
      
   ``gamma_P  x  a  b``
     
     computes the cumulative gamma distribution function `P(x)` with
     parameters ``a`` and ``b``.
     
   ``gamma_Q  x  a  b``
     
     computes the cumulative gamma distribution function `Q(x)` with
     parameters ``a`` and ``b``.
     
   ``gamma_Pinv  p  a  b``
     
     computes the inverse of the cumulative gamma distribution function
     of `P(x)` with parameters ``a`` and ``b``.
     
   ``gamma_Qinv  q  a  b``
     
     computes the inverse of the cumulative gamma distribution function
     of `Q(x)` with parameters ``a`` and ``b``.
*/

gamma_P  x  a  b
  = gsl_cdf_gamma_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

gamma_Q  x  a  b
  = gsl_cdf_gamma_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

gamma_Pinv  p  a  b
  = gsl_cdf_gamma_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

gamma_Qinv  q  a  b
  = gsl_cdf_gamma_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* .. _flat_P: _flat_Q: _flat_Pinv: _flat_Qinv:
   
   ``flat_P  x  a  b``
     
     computes the cumulative uniform distribution function `P(x)` from
     ``a`` to ``b``.
     
   ``flat_Q  x  a  b``
     
     computes the cumulative uniform distribution function `P(x)` from
     ``a`` to ``b``.
     
   ``flat_Pinv  p  a  b``
     
     computes the inverse of the cumulative uniform distribution function
     of `P(x)` from ``a`` to ``b``.
     
   ``flat_Qinv  q  a  b``
     
     computes the inverse of the cumulative uniform distribution function
     of `Q(x)` from ``a`` to ``b``.
*/

flat_P  x  a  b
  = gsl_cdf_flat_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

flat_Q  x  a  b
  = gsl_cdf_flat_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

flat_Pinv  p  a  b
  = gsl_cdf_flat_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

flat_Qinv  q  a  b
  = gsl_cdf_flat_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* .. _lognormal_P: _lognormal_Q: _lognormal_Pinv: _lognormal_Qinv:
   
   ``lognormal_P  x  zeta  sigma``
     
     computes the cumulative lognormal distribution function `P(x)` with
     parameters ``zeta`` and ``sigma``.
     
   ``lognormal_Q  x  zeta  sigma``
     
     computes the cumulative lognormal distribution function `Q(x)` with
     parameters ``zeta`` and ``sigma``.
     
   ``lognormal_Pinv  p  zeta  sigma``
     
     computes the inverse of the cumulative lognormal distribution function
     of `P(x)` with parameters ``zeta`` and ``sigma``.
     
   ``lognormal_Qinv  q  zeta  sigma``
     
     computes the inverse of the cumulative lognormal distribution function
     of `Q(x)` with parameters ``zeta`` and ``sigma``.
*/

lognormal_P  x  zeta  sigma
  = gsl_cdf_lognormal_P (double x) (double zeta) (double sigma)
    if realp x && realp zeta && realp sigma;

lognormal_Q  x  zeta  sigma
  = gsl_cdf_lognormal_Q (double x) (double zeta) (double sigma)
    if realp x && realp zeta && realp sigma;

lognormal_Pinv  p  zeta  sigma
  = gsl_cdf_lognormal_Pinv (double p) (double zeta) (double sigma)
    if realp p && realp zeta && realp sigma;

lognormal_Qinv  q  zeta  sigma
  = gsl_cdf_lognormal_Qinv (double q) (double zeta) (double sigma)
    if realp q && realp zeta && realp sigma;

/* .. _chisq_P: _chisq_Q: _chisq_Pinv: _chisq_Qinv:
   
   ``chisq_P  x  nu``
     
     computes the cumulative chisq distribution function `P(x)` with
     ``nu`` degrees of freedom.
     
   ``chisq_Q  x  nu``
     
     computes the cumulative chisq distribution function `Q(x)` with
     ``nu`` degrees of freedom.
     
   ``chisq_Pinv  p  nu``
     
     computes the inverse of the cumulative chisq distribution function
     of `P(x)` with ``nu`` degrees of freedom.
     
   ``chisq_Qinv  q  nu``
     
     computes the inverse of the cumulative chisq distribution function
     of `Q(x)` with ``nu`` degrees of freedom.
*/

chisq_P  x  nu
  = gsl_cdf_chisq_P (double x) (double nu) if realp x && realp nu;

chisq_Q  x  nu
  = gsl_cdf_chisq_Q (double x) (double nu) if realp x && realp nu;

chisq_Pinv  p  nu
  = gsl_cdf_chisq_P (double p) (double nu) if realp p && realp nu;

chisq_Qinv  q  nu
  = gsl_cdf_chisq_Qinv (double q) (double nu) if realp q && realp nu;

/* .. _fdist_P: _fdist_Q: _fdist_Pinv: _fdist_Qinv:
   
   ``fdist_P  x  nu1  nu2``
     
     computes the cumulative chisq distribution function `P(x)` with
     ``nu1`` and ``nu2`` degrees of freedom.
     
   ``fdist_Q  x  nu1  nu2``
     
     computes the cumulative chisq distribution function `Q(x)` with
     ``nu1`` and ``nu2``  degrees of freedom.
     
   ``fdist_Pinv  p  nu1  nu2``
     
     computes the inverse of the cumulative chisq distribution function
     of `P(x)` with ``nu1`` and ``nu2``  degrees of freedom.
     
   ``fdist_Qinv  q  nu1  nu2``
     
     computes the inverse of the cumulative chisq distribution function
     of `Q(x)` with ``nu1`` and ``nu2``  degrees of freedom.
*/

fdist_P  x  nu1  nu2
  = gsl_cdf_fdist_P (double x) (double nu1) (double nu2)
    if realp x && realp nu1 && realp nu2;

fdist_Q  x  nu1  nu2
  = gsl_cdf_fdist_Q (double x) (double nu1) (double nu2)
    if realp x && realp nu1 && realp nu2;

fdist_Pinv  p  nu1  nu2
  = gsl_cdf_fdist_Pinv (double p) (double nu1) (double nu2)
    if realp p && realp nu1 && realp nu2;

fdist_Qinv  q  nu1  nu2
  = gsl_cdf_fdist_Qinv (double q) (double nu1) (double nu2)
    if realp q && realp nu1 && realp nu2;

/* .. _tdist_P: _tdist_Q: _tdist_Pinv: _tdist_Qinv:
   
   ``tdist_P  x  nu``
     
     computes the cumulative student's t-distribution function `P(x)` with
     ``nu`` degrees of freedom.
     
   ``tdist_Q  x  nu``
     
     computes the cumulative student's t-distribution function `Q(x)` with
     ``nu`` degrees of freedom.
     
   ``tdist_Pinv  p  nu``
     
     computes the inverse of the cumulative student's t-distribution function
     of `P(x)` with ``nu`` degrees of freedom.
     
   ``tdist_Qinv  q  nu``
     
     computes the inverse of the cumulative student's t-distribution function
     of `Q(x)` with ``nu`` degrees of freedom.
*/

tdist_P  x  nu
  = gsl_cdf_tdist_P (double x) (double nu) if realp x && realp nu;

tdist_Q  x  nu
  = gsl_cdf_tdist_Q (double x) (double nu) if realp x && realp nu;

tdist_Pinv  p  nu
  = gsl_cdf_tdist_Pinv (double p) (double nu) if realp p && realp nu;

tdist_Qinv  q  nu
  = gsl_cdf_tdist_Qinv (double q) (double nu) if realp q && realp nu;

/* .. _beta_P: _beta_Q: _beta_Pinv: _beta_Qinv:
   
   ``beta_P  x  a  b``
     
     computes the cumulative beta distribution function `P(x)` with
     parameters ``a`` and ``b``.
 
   ``beta_Q  x  a  b``
     
     computes the cumulative beta distribution function `Q(x)` with
     parameters ``a`` and ``b``.
     
   ``beta_Pinv  p  a  b``
     
     computes the inverse of the cumulative beta distribution function
     of `P(x)` with parameters ``a`` and ``b``.

   ``beta_Qinv  q  a  b``
     
     computes the inverse of the cumulative beta distribution function
     of `Q(x)` with parameters ``a`` and ``b``.
*/

beta_P  x  a  b
  = gsl_cdf_beta_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

beta_Q  x  a  b
  = gsl_cdf_beta_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

beta_Pinv  p  a  b
  = gsl_cdf_beta_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

beta_Qinv  q  a  b
  = gsl_cdf_beta_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* .. _logistic_P: _logistic_Q: _logistic_Pinv: _logistic_Qinv:
   
   ``logistic_P  x  a``
     
     computes the cumulative logistic distribution function `P(x)` with
     scale parameter ``a``.
     
   ``logistic_Q  x  a``
     
     computes the cumulative logistic distribution function `Q(x)` with
     scale parameter ``a``.
     
   ``logistic_Pinv  p  a``
     
     computes the inverse of the cumulative logistic distribution function
     of `P(x)` with scale parameter ``a``.
     
   ``logistic_Qinv  q  a``
     
     computes the inverse of the cumulative logistic distribution function
     of `Q(x)` with scale parameter ``a``.  
*/

logistic_P  x  a
  = gsl_cdf_logistic_P (double x) (double a) if realp x && realp a;

logistic_Q  x  a
  = gsl_cdf_logistic_Q (double x) (double a) if realp x && realp a;

logistic_Pinv  p  a
  = gsl_cdf_logistic_Pinv (double p) (double a) if realp p && realp a;

logistic_Qinv  q  a
  = gsl_cdf_logistic_Qinv (double q) (double a) if realp q && realp a;

/* .. _pareto_P: _pareto_Q: _pareto_Pinv: _pareto_Qinv:
   
   ``pareto_P  x  a  b``
     
     computes the cumulative Pareto distribution function `P(x)` with
     exponent ``a`` and scale ``b``.
     
   ``pareto_Q  x  a  b``
     
     computes the cumulative Pareto distribution function `Q(x)` with
     exponent ``a`` and scale ``b``.
     
   ``pareto_Pinv  p  a  b``
     
     computes the inverse of the cumulative Pareto distribution function
     of `P(x)` with exponent ``a`` and scale ``b``.
     
   ``pareto_Qinv  q  a  b``
     
     computes the inverse of the cumulative Pareto distribution function
     of `Q(x)` with exponent ``a`` and scale ``b``.
*/

pareto_P  x  a  b
  = gsl_cdf_pareto_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

pareto_Q  x  a  b
  = gsl_cdf_pareto_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

pareto_Pinv  p  a  b
  = gsl_cdf_pareto_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

pareto_Qinv  q  a  b
  = gsl_cdf_pareto_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* .. _weibull_P: _weibull_Q: _weibull_Pinv: _weibull_Qinv:
   
   ``weibull_P  x  a  b``
     
     computes the cumulative Weibull distribution function `P(x)` with
     exponent ``a`` and scale ``b``.
     
   ``weibull_Q  x  a  b``
     
     computes the cumulative Weibull distribution function `Q(x)` with
     exponent ``a`` and scale ``b``.
     
   ``weibull_Pinv  p  a  b``
     
     computes the inverse of the cumulative Weibull distribution function
     of `P(x)` with exponent ``a`` and scale ``b``.
     
   ``weibull_Qinv  q  a  b``
     
     computes the inverse of the cumulative Weibull distribution function
     of `Q(x)` with exponent ``a`` and scale ``b``.
*/

weibull_P  x  a  b
  = gsl_cdf_weibull_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

weibull_Q  x  a  b
  = gsl_cdf_weibull_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

weibull_Pinv  p  a  b
  = gsl_cdf_weibull_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

weibull_Qinv  q  a  b
  = gsl_cdf_weibull_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* .. _gumbel1_P: _gumbel1_Q: _gumbel1_Pinv: _gumbel1_Qinv:
   
   ``gumbel1_P  x  a  b``
     
     computes the cumulative Type-1 Gumbel distribution function `P(x)` with
     parameters ``a`` and ``b``.
     
   ``gumbel1_Q  x  a  b``
     
     computes the cumulative Type-1 Gumbel distribution function `Q(x)` with
     parameters ``a`` and ``b``.
     
   ``gumbel1_Pinv  p  a  b``
     
     computes the inverse of the cumulative Type-1 Gumbel distribution function
     of `P(x)` with parameters ``a`` and ``b``.
     
   ``gumbel1_Qinv  q  a  b``
     
     computes the inverse of the cumulative Type-1 Gumbel distribution function
     of `Q(x)` with parameters ``a`` and ``b``.
*/

gumbel1_P  x  a  b
  = gsl_cdf_gumbel1_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

gumbel1_Q  x  a  b
  = gsl_cdf_gumbel1_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

gumbel1_Pinv  p  a  b
  = gsl_cdf_gumbel1_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

gumbel1_Qinv  q  a  b
  = gsl_cdf_gumbel1_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* .. _gumbel2_P: _gumbel2_Q: _gumbel2_Pinv: _gumbel2_Qinv:
   
   ``gumbel2_P  x  a  b``
     
     computes the cumulative Type-2 Gumbel distribution function `P(x)` with
     parameters ``a`` and ``b``.
     
   ``gumbel2_Q  x  a  b``
     
     computes the cumulative Type-2 Gumbel distribution function `Q(x)` with
     parameters ``a`` and ``b``.
 
   ``gumbel2_Pinv  p  a  b``
     
     computes the inverse of the cumulative Type-2 Gumbel distribution function
     of `P(x)` with parameters ``a`` and ``b``.

   ``gumbel2_Qinv  q  a  b``
     
     computes the inverse of the cumulative Type-2 Gumbel distribution function
     of `Q(x)` with parameters ``a`` and ``b``.
*/

gumbel2_P  x  a  b
  = gsl_cdf_gumbel2_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

gumbel2_Q  x  a  b
  = gsl_cdf_gumbel2_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

gumbel2_Pinv  p  a  b
  = gsl_cdf_gumbel2_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

gumbel2_Qinv  q  a  b
  = gsl_cdf_gumbel2_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* .. _poisson_P: _poisson_Q:
   
   ``poisson_P  k::int  mu``
     
     computes the cumulative Poisson distribution function `P(k)` with
     parameter ``mu``.
     
   ``poisson_Q  k::int  mu``
     
     computes the cumulative Poisson distribution function `Q(k)` with
     parameter ``mu``.
*/

poisson_P  k::int  mu
  = gsl_cdf_poisson_P k (double mu) if realp mu && k >= 0;

poisson_Q  k::int  mu
  = gsl_cdf_poisson_Q k (double mu) if realp mu && k >= 0;

/* .. _binomial_P: _binomial_Q:
   
   ``binomial_P  k::int  p  n::int``
     
     computes the cumulative binomial distribution function `P(k)` with
     parameters ``p`` and ``n``. 
     
   ``binomial_Q  k::int  q  n::int``
     
     computes the cumulative binomial distribution function `Q(k)` with
     parameters ``p`` and ``n``.
*/

binomial_P  k::int  p  n::int
  = gsl_cdf_binomial_P k (double p) n if realp p && k >= 0 && n > 0;

binomial_Q  k::int  q  n::int
  = gsl_cdf_binomial_Q k (double q) n if realp q && k >= 0 && n > 0;

/* .. _negative_binomial_P: _negative_binomial_Q:
   
   ``negative_binomial_P  k::int  p  n``
     
     computes the cumulative negative binomial distribution function `P(k)`
     with parameters ``p`` and ``n``. 
      
   ``negative_binomial_Q  k::int  p  n``
     
     computes the cumulative negative binomial distribution function `Q(k)`
     with parameters ``p`` and ``n``.
*/

negative_binomial_P  k::int  p  n
  = gsl_cdf_negative_binomial_P k (double p) (double n)
    if realp p && realp n && k >= 0;

negative_binomial_Q  k::int  p  n
  = gsl_cdf_negative_binomial_Q k (double p) (double n)
    if realp p && realp n && k >= 0;

/* .. _pascal_P:
      _pascal_Q:
   
   ``pascal_P  k::int  p  n::int``
     
     computes the cumulative Pascal distribution function `P(k)` with
     parameters ``p`` and ``n``.
 
   ``pascal_Q  k::int  p  n::int``
     
     computes the cumulative Pascal distribution function `Q(k)` with
     parameters ``p`` and ``n``.
*/

pascal_P  k::int  p  n::int
  = gsl_cdf_pascal_P k (double p) n if realp p && k >= 0;

pascal_Q  k::int  p  n::int
  = gsl_cdf_pascal_Q k (double p) n if realp p && k >= 0;

/* .. _geometric_P: _geometric_Q:
   
   ``geometric_P  k::int  p``
     
     computes the cumulative geometric distribution function `P(k)` with
     parameter ``p``.
     
   ``geometric_Q  k::int  p``
     
     computes the cumulative geometric distribution function `Q(k)` with
     parameter ``p``.
*/

geometric_P  k::int  p
  = gsl_cdf_geometric_P k (double p) if realp p && k >= 1;

geometric_Q  k::int  p
  = gsl_cdf_geometric_Q k (double p) if realp p && k >= 1;

/* .. _hypergeometric_P: _hypergeometric_Q:
   
   ``hypergeometric_P  k::int  n1::int  n2::int  t::int``
     
     computes the cumulative hypergeometric distribution function `P(k)` with
     parameters ``p``, ``n1``, ``n2``, and ``t``.
     
   ``hypergeometric_Q  k::int  n1::int  n2::int  t::int``
     
     computes the cumulative hypergeometric distribution function `Q(k)` with
     parameters ``p``, ``n1``, ``n2``, and ``t``.
*/

hypergeometric_P  k::int  n1::int  n2::int  t::int
  = gsl_cdf_hypergeometric_P k n1 n2 t
    if k >= 0 && n1 >= 0 && n2 >= 0 && t >= 0;

hypergeometric_Q  k::int  n1::int  n2::int  t::int
  = gsl_cdf_hypergeometric_Q k n1 n2 t
    if k >= 0 && n1 >= 0 && n2 >= 0 && t >= 0;

/*  ..
   
   Examples
   ~~~~~~~~
   
   The following illustrates the use of each function in the ``randist`` module.
   The pdf functions are illustrated first.
      
     ::
     
       > using gsl::stats;
       > using namespace gsl::ran;
       > ugaussian_pdf 1.2;
       0.194186054983213
       > gaussian_pdf (-1.3) 1.5;
       0.182690978264686
       > gaussian_tail_pdf 2.0 1.0 1.5;
       0.433042698395299
       > ugaussian_tail_pdf 2.0 1.0;
       0.34030367841782
       > bivariate_gaussian_pdf 1.2 0.9 1.0 1.0 0.95;
       0.184646843689817
       > exponential_pdf 1.0 0.5;
       0.270670566473225
       > laplace_pdf 1.5 2.0;
       0.118091638185254
       > exppow_pdf 0.0 1.0 1.5;
       0.553866083716236
       > cauchy_pdf (-1.0) 1.0;
       0.159154943091895
       > rayleigh_pdf 2.5 1.0;
       0.109842334058519
       > rayleigh_tail_pdf 1.5 1.0 1.0;
       0.802892142778485
       > landau_pdf 1.1;
       0.140968737919623
       > gamma_pdf 1.0 1.0 1.5;
       0.342278079355061
       > flat_pdf 1.0 0.5 2.5;
       0.5
       > lognormal_pdf 0.01 0.0 1.0;
       0.000990238664959182
       > chisq_pdf 1.0 2.0;
       0.303265329856317
       > fdist_pdf 0.5 3.0 2.0;
       0.480970043785452
       > tdist_pdf 0.1 10.0;
       0.386975225815181
       > beta_pdf 0.5 4.0 1.0;
       0.499999999999999
       > logistic_pdf (-1.0) 2.0;
       0.117501856100797
       > pareto_pdf 0.01 3.0 2.0;
       0.0
       > weibull_pdf  0.01 1.0 1.0;
       0.990049833749168
       > gumbel1_pdf 0.01 1.0 1.0;
       0.367861108816436
       > gumbel2_pdf 0.01 1.0 1.0;
       3.72007597602084e-40
       > dirichlet_pdf {0.1,0.2,0.8} {2.0,2.0,2.0};
       0.00501316294425874
       > dirichlet_lnpdf {0.1,0.2,0.8} {2.0,2.0,2.0};
       -5.29568823688856
       > poisson_pdf 4 0.4;
       0.000715008049104682
       > bernoulli_pdf 1 0.7;
       0.7
       > binomial_pdf 3 0.5 9;
       0.1640625
       > multinomial_pdf {0.1,0.2,0.7} {2,2,2};
       0.0
       > multinomial_lnpdf {0.1,0.2,0.7} {2,2,2};
       -1728120799.71174
       > negative_binomial_pdf 10 0.5 3.5;
       0.0122430486923836
       > pascal_pdf 10 0.5 3;
       0.00805664062499999
       > geometric_pdf 5 0.4;
       0.05184
       > hypergeometric_pdf 1 5 20 3;
       0.413043478260872
       > logarithmic_pdf 10 0.7; 
       0.00234619293712492
       > test_discrete
       >   = v
       >     when
       >       px = discrete_preproc {0.1,0.3,0.4};
       >       v = discrete_pdf 0 px +
       >           discrete_pdf 1 px +
       >           discrete_pdf 2 px;
       >       _ = discrete_free px
       >     end;
       > test_discrete;
       1.0
       
   Here the cdf functions are shown.
   
     ::

       > ugaussian_P  (-1.3);
       0.0968004845856103
       > ugaussian_Q  (-1.3);
       0.90319951541439
       > ugaussian_Pinv  0.84;
       0.994457883209753
       > ugaussian_Qinv  0.84;
       -0.994457883209753
       > gaussian_P  (1.3)  1.5;
       0.806937662858093
       > gaussian_Q  (1.3)  1.5;
       0.193062337141907
       > gaussian_Pinv  0.4  5.0;
       -1.266735515679
       > gaussian_Qinv  0.4 5.0;
       1.266735515679
       > exponential_P  1.0  0.5;
       0.864664716763387
       > exponential_Q  1.0  0.5;
       0.135335283236613
       > exponential_Pinv  0.6  0.5;
       0.458145365937077
       > exponential_Qinv  0.6  0.5;
       0.255412811882995
       > laplace_P  1.5  2.0;
       0.763816723629493
       > laplace_Q  1.5  2.0;
       0.236183276370507
       > laplace_Pinv  0.6  2.0;
       0.446287102628419
       > laplace_Qinv  0.4  2.0;
       0.446287102628419
       > exppow_P  0.0  1.0  2.5;
       0.5
       > exppow_Q  0.0  1.0  0.5;
       0.5
       > cauchy_P  (-1.0)  1.0;
       0.25
       > cauchy_Q  (-1.0)  1.0;
       0.75
       > cauchy_Pinv  0.75  1.0;
       1.0
       > cauchy_Qinv  0.25  1.0;
       1.0
       > rayleigh_P  1.5  2.0;
       0.245160398010993
       > rayleigh_Q  0.5  1.0;
       0.882496902584595
       > rayleigh_Pinv  0.5  1.0;
       1.17741002251547
       > rayleigh_Qinv  0.5  1.0;
       1.17741002251547
       > gamma_P  1.0  1.0  3.0;
       0.283468689426211
       > gamma_Q  1.0  1.0  3.0;
       0.716531310573789
       > gamma_Pinv  0.5  1.0  1.0;
       0.693147180559945
       > gamma_Qinv  0.5  1.0  1.0;
       0.693147180559945
       > flat_P  2.0  1.2  4.8;
       0.222222222222222
       > flat_Q  2.0  1.2  4.8;
       0.777777777777778
       > flat_Pinv  0.2  0.5  2.5;
       0.9
       > flat_Qinv  0.2  0.5  2.5;
       2.1
       > lognormal_P  0.01  0.0  1.0;
       2.06064339597172e-06
       > lognormal_Q  0.01  0.0  1.0;
       0.999997939356604
       > lognormal_Pinv  0.1  0.0  1.0;
       0.27760624185201
       > lognormal_Qinv  0.1  0.0  1.0;
       3.60222447927916
       > chisq_P  1.0  2.0;
       0.393469340287367
       > chisq_Q  1.0  2.0;
       0.606530659712633
       > chisq_Pinv  0.5  2.0;
       0.221199216928595
       > chisq_Qinv  0.5  2.0;
       1.38629436111989
       > fdist_P  1.0  3.0  2.0;
       0.46475800154489
       > fdist_Q  1.0  3.0  2.0;
       0.53524199845511
       > fdist_Pinv  0.5  3.0  2.0;
       1.13494292261288
       > fdist_Qinv  0.5  3.0  2.0;
       1.13494292261288
       > tdist_P  2.1  10.0;
       0.968961377898891
       > tdist_Q  (-2.1)  10.0;
       0.968961377898891
       > tdist_Pinv  0.68  10.0;
       0.482264205919689
       > tdist_Qinv  0.68  10.0;
       -0.482264205919689
       > beta_P  0.75  2.0  2.0;
       0.84375
       > beta_Q  0.75  2.0  2.0;
       0.15625
       > beta_Pinv  0.75  2.0  2.0;
       0.673648177666931
       > beta_Qinv  0.25  2.0  2.0;
       0.673648177666931
       > logistic_P  (-1.0)  2.0;
       1
       > logistic_Q  (-1.0)  2.0;
       0.622459331201855
       > logistic_Pinv  0.75  1.0;
       1.09861228866811
       > logistic_Qinv  0.25  1.0;
       1.09861228866811
       > pareto_P  2.01  3.0  2.0;
       0.0148512406901899
       > pareto_Q  2.01  3.0  2.0;
       0.98514875930981
       > pareto_Pinv  0.1  3.0  2.0;
       2.07148833730257
       > pareto_Qinv  0.1  3.0  2.0;
       4.30886938006377
       > weibull_P  1.01  1.0  2.0;
       0.639441117518024
       > weibull_Q  1.01  2.0  3.0;
       0.879160657465162
       > weibull_Pinv  0.1  1.0  2.0;
       0.324592845974501
       > weibull_Qinv  0.1  1.0  2.0;
       1.51742712938515
       > gumbel1_P  1.01  1.0  1.0;
       0.694739044426344
       > gumbel1_Q  1.01  1.0  1.0;
       0.305260955573656
       > gumbel1_Pinv  0.1  1.0  1.0;
       -0.834032445247956
       > gumbel1_Qinv  0.1  1.0  1.0;
       2.25036732731245
       > gumbel2_P  1.01  1.0  1.0;
       0.371539903071873
       > gumbel2_Q  1.01  1.0  1.0;
       0.628460096928127
       > gumbel2_Pinv  0.1  1.0  1.0;
       0.434294481903252
       > gumbel2_Qinv  0.1  1.0  1.0;
       9.4912215810299
       > poisson_P  4  0.4;
       0.999938756672898
       > poisson_Q  4  0.6;
       0.000394486018340255
       > binomial_P  3  0.5  10;
       0.171874999999999
       > binomial_Q  3  0.5  10;
       0.828125000000001
       > negative_binomial_P  10  0.5  3.0;
       0.98876953125
       > negative_binomial_Q  10  0.5  3.0;
       0.01123046875
       > pascal_P  10  0.5  3;
       0.98876953125
       > pascal_Q  10  0.5  3;
       0.01123046875
       > geometric_P  5  0.4;
       0.92224
       > geometric_Q  5  0.6;
       0.01024
       > hypergeometric_P  1  5  20  3;
       0.908695652173913
       > hypergeometric_Q  1  5  20  3;
       0.0913043478260873
*/
