
/* gsl/poly.pure: GSL wrapper for the Pure programming language. */

/* Copyright (c) 2008 by Albert Graef <Dr.Graef@t-online.de>.
   Copyright (c) 2008 by Robert E. Rucker <erucker@bmc.edu>.

   This file is part of the Pure programming language and system.

   Pure is free software: you can redistribute it and/or modify it under the
   terms of the GNU General Public License as published by the Free Software
   Foundation, either version 3 of the License, or (at your option) any later
   version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
   details.

   You should have received a copy of the GNU General Public License along
   with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* ..
   
   Polynomials
   -----------
   
   This module provides Pure wrappers for the GSL polynomial routines. For details, see
   Chapter 6 of the GSL manual,
   
   http://www.gnu.org/software/gsl/manual/html_node/Polynomials.html.
   
   Notes:

     1. Pure routines omit the C routines' array length parameters.
     2. A Polynomials is represented by a one row matrix.
       
   Routines
   ~~~~~~~~
*/

using "lib:gsl";

namespace gsl;
namespace gsl::poly;

private extern double gsl_poly_eval(double*, int, double);
private extern expr* wrap_gsl_poly_complex_eval(double*, int, double, double);
private extern expr* wrap_gsl_complex_poly_complex_eval
  (cmatrix*, int, double, double);

public eval;

/* .. _eval:

   ``eval  c::matrix  x``
     evaluates the polynomial
     
     ``(c!0)+(c!1)x+(c!2)x^2+...+(c!(#c-1))x^(#c-1)``.
     
     An extra Pure routine for evaluating polynomials with ``int`` and
     ``bigint`` coefficients is provided because GSL does not supply one.
     The integer routine implements the Chinese Remainder Theorem.
*/

eval  c::matrix  (a+:b)
  = wrap_gsl_poly_complex_eval (dmatrix c) (#c) (double a) (double b)
    if rowvectorp c && (dmatrixp c || imatrixp c);
  = wrap_gsl_complex_poly_complex_eval c (#c) (double a) (double b)
    if rowvectorp c && cmatrixp c;

eval c::matrix x
  = loop x (c!n) c (n-1)
    when
      n = #c-1;
    end
    with
      loop x s c i
        = loop x (x*s+(c!i)) c (i-1) if i >= 0;
        = s;
    end
    if rowvectorp c && imatrixp c && (intp x || bigintp x);
  = gsl_poly_eval (dmatrix c) (#c) (double x) 
    if rowvectorp c && (dmatrixp c || (imatrixp c && doublep x));

private extern int gsl_poly_dd_init(double*, double*, double*, size_t);
private extern double gsl_poly_dd_eval(double*, double*, size_t, double);
private extern int gsl_poly_dd_taylor
  (double*, double, double*, double*,size_t, double*);

public
  dd_init
  dd_eval
  dd_taylor;

/* .. _dd_init:

   ``dd_init x::matrix y::matrix``
     computes a divided-difference representation of the interpolating
     polynomial for the points
   
     ``(x!0, y!0), (x!1, y!1), ..., (x!(#x-1), y!(#x-1))``.
*/

dd_init  xa::matrix  ya::matrix
  = gsl_poly_dd_init (pointer m) (dmatrix xa) (dmatrix ya) (#xa) $$ m
    when
      m = dmatrix xa;
    end
    if rowvectorp xa && rowvectorp ya;

/* .. _dd_eval:

   ``dd_eval dd::matrix xa::matrix x::double``
     evaluates the polynomial stored in divided-difference form in matrices
     ``dd`` and ``xa`` at the point ``x``.
*/

dd_eval  dd::matrix  xa::matrix  x
  = gsl_poly_dd_eval (dmatrix dd) (dmatrix xa) (#dd) (double x)
    if rowvectorp dd && rowvectorp xa && realp x;

/* .. _dd_talyor:

   ``dd_taylor xp::double dd::matrix xa::matrix``
     converts the divided-difference representation of a polynomial to a
     Taylor expansion where the divided-difference representation is supplied
     by the matrices ``dd`` and ``xa`` expanded about the point ``xp``.
*/

dd_taylor  xp  dd::matrix  xa::matrix
  = gsl_poly_dd_taylor (pointer c) (double xp) (dmatrix dd) (dmatrix xa) (#xa) w
    $$ c
    when
      w = dmatrix xa;
      c = dmatrix xa;
    end
    if realp xp && rowvectorp dd && rowvectorp xa;

private extern expr* wrap_gsl_poly_solve_quadratic(double, double, double);
private extern expr* wrap_gsl_poly_complex_solve_quadratic
  (double, double, double);
private extern expr* wrap_gsl_poly_solve_cubic(double, double, double);
private extern expr* wrap_gsl_poly_complex_solve_cubic(double, double, double);

public
  solve_quadratic
  complex_solve_quadratic
  solve_cubic
  complex_solve_cubic;

/* .. _solve_quadratic:

   ``solve_quadratic a b c``
     computes the real roots of the quadratic equation

     ``a*x^2+b*x+c=0``.
     
     This function returns a list with no root if the determinate is 
     negative, one root if ``a == 0``, or two of roots otherwise.
*/

solve_quadratic  a  b  c
  = wrap_gsl_poly_solve_quadratic (double a) (double b) (double c)
    if realp a && realp b && realp c;

/* .. _complex_solve_quadratic:

   ``complex_solve_quadratic a b c``
     computes the complex roots of the quadratic equation
     
     ``a*x^2+b*x+c=0``.
          
     This function returns a list with one root if ``a == 0``, or a pair,
     sorted by real part and then img part, of roots otherwise.
*/     

complex_solve_quadratic  a  b  c
  = wrap_gsl_poly_complex_solve_quadratic (double a) (double b) (double c)
    if realp a && realp b && realp c;

/* .. _solve_cubic:

   ``solve_cubic a b c``
     computes the real roots of the cubic equation
     
     ``x^3+a*x^2+b*x+c=0``.
     
     This function returns a list with exactly one or exactly three roots.
*/

solve_cubic  a  b  c
  = wrap_gsl_poly_solve_cubic (double a) (double b) (double c)
    if realp a && realp b && realp c;

/* .. _complex_colve_cubic:

   ``complex_solve_cubic a b c``
     computes the complex roots of the cubic equation
    
     ``x^3+a*x^2+b*x+c=0``.
    
     This functions returns a list with three complex roots.
*/

complex_solve_cubic  a  b  c
  = wrap_gsl_poly_complex_solve_cubic (double a) (double b) (double c)
    if realp a && realp b && realp c;

private extern expr* wrap_gsl_poly_complex_solve(double*, size_t);

public complex_solve;

/* .. _complex_solve:

   ``complex_solve  c::matrix``
     returns a list of the roots of the general polynomial
   
     ``P(x)=(c!0)+(c!1)*x+(c!2)*x^2+(c!(#c-1))*x^(#c-1)``.
   
     If the roots cannot be found, an empty list, ``[]``, is returned. The
     user does not need to supply the GSL routines for creating and freeing a
     workspace as in the C programming language.
*/

complex_solve  c::matrix
  = wrap_gsl_poly_complex_solve c (#c);

/* ..
   
   Examples
   ~~~~~~~~
   
   Usage of each library routine is illustrated below.
   
   ::
   
     > using gsl::poly;
     > using namespace gsl::poly;
     > eval {1,2,3} 2;
     17
     > eval {1.0,2.0,3.0} (-2.0);
     9.0
     > eval {1, 2, 2} (1+:1);
     3.0+:6.0
     > eval {1+:2, 2+:3, 2+:3} (1+:1);
     -6.0+:11.0
     > let dd = dd_init {1,2,3} {2,4,6};
     > dd;
     {2.0,2.0,0.0}
     > dd_eval dd {1,2,3} 2;
     4.0
     > dd_taylor 0.0 dd {1,2,3};
     {0.0,2.0,0.0}
     > solve_quadratic 2 4 1;
     [-1.70710678118655,-0.292893218813452]
     > solve_quadratic 1 4 4;
     [-2.0,-2.0]
     > solve_quadratic 0 2 1;
     [-0.5]
     > solve_quadratic 1 2 8;
     []
     > complex_solve_quadratic 0 2 1;
     [-0.5+:0.0]
     > complex_solve_quadratic 2 2 3;
     [-0.5+:-1.11803398874989,-0.5+:1.11803398874989]   
     > solve_cubic 3 3 1;
     [-1.0,-1.0,-1.0]
     > solve_cubic 3 2 1;
     [-2.32471795724475]
     > complex_solve_cubic 2 2 1;
     [-1.0+:0.0,-0.5+:-0.866025403784439,-0.5+:0.866025403784439]
     > complex_solve {6,1,-7,-1,1};
     [1.0+:0.0,-1.0+:0.0,-2.0+:0.0,3.0+:0.0]
   
*/
