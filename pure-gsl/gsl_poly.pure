
/* gsl_poly.pure: GSL wrapper for the Pure programming language. */

/* Copyright (c) 2008 by Albert Graef <Dr.Graef@t-online.de>.
   Copyright (c) 2008 by Robert E. Rucker <erucker@bmc.edu>.

   This file is part of the Pure programming language and system.

   Pure is free software: you can redistribute it and/or modify it under the
   terms of the GNU General Public License as published by the Free Software
   Foundation, either version 3 of the License, or (at your option) any later
   version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
   details.

   You should have received a copy of the GNU General Public License along
   with this program.  If not, see <http://www.gnu.org/licenses/>. */

using "lib:gsl";

namespace gsl;

private extern double gsl_poly_eval(double*, int, double);
private extern expr* wrap_gsl_poly_complex_eval(double*, int, double, double);
private extern expr* wrap_gsl_complex_poly_complex_eval
  (cmatrix*, int, double, double);

public
  poly_eval;

/* ..
  ``poly_eval  c::matrix  x``
    evaluates the polynomial 
    ``(c!0)+(c!1)x+(c!2)x^2+...+(c!(#c-1))x^(#c-1)``.
*/

poly_eval c::matrix (a+:b)
  = wrap_gsl_poly_complex_eval (dmatrix c) (#c) (double a) (double b)
    if rowvectorp c && (dmatrixp c || imatrixp c);
  = wrap_gsl_complex_poly_complex_eval c (#c) (double a) (double b)
    if rowvectorp c && cmatrixp c;

// GSL doesn't support plain int coefficients
// This is just the Chinese Remainder Thoerem
poly_eval c::matrix x
  = loop x (c!n) c (n-1)
    when
      n = #c-1;
    end
    with
      loop x s c i = loop x (x*s+(c!i)) c (i-1) if i >= 0;
      loop x s c i = s;
    end
    if rowvectorp c && imatrixp c && (intp x || bigintp x);
  = gsl_poly_eval (dmatrix c) (#c) (double x) 
    if rowvectorp c && (dmatrixp c || (imatrixp c && doublep x));

private extern int gsl_poly_dd_init(double*, double*, double*, size_t);
private extern double gsl_poly_dd_eval(double*, double*, size_t, double);
private extern int gsl_poly_dd_taylor
  (double*, double, double*, double*, size_t, double*);

public
  poly_dd_init
  poly_dd_eval
  poly_dd_taylor;

/* ..
  ``poly_dd_init x::matrix y::matrix``
    computes a divided-difference representation of the interpolating
    polynomial for the points
   
    (x!0, y!0), (x!1, y!1), ..., (x!(#x-1), y!(#x-1)).
*/

poly_dd_init  xa::matrix  ya::matrix
  = gsl_poly_dd_init (pointer m) (dmatrix xa) (dmatrix ya) (#xa) $$ m
    when
      m = dmatrix xa;
    end
    if rowvectorp xa && rowvectorp ya;

/* ..
  ``poly_dd_eval dd:matrix xa::matrix x::double``
    evaluates the polynomial stored in divided-difference form in 
    dd and xa at the point x.
*/

poly_dd_eval  dd::matrix  xa::matrix  x::double
  = gsl_poly_dd_eval (dmatrix dd) (dmatrix xa) (#dd) x
    if rowvectorp dd && rowvectorp xa;

/* ..
  ``poly_dd_taylor xp::double dd::matrix xa::matrix``
    converts the divided-difference representation of a polynomial to a
    Taylor expansion where the divided-difference representation is supplied
    in the arrays dd and xa expanded about the point xp.
*/

poly_dd_taylor  xp  dd::matrix  xa::matrix
  = gsl_poly_dd_taylor (pointer c) (double xp) 
      (dmatrix dd) (dmatrix xa) (#xa) w $$ c
    when
      w = dmatrix xa;
      c = dmatrix xa;
    end
    if rowvectorp dd && rowvectorp xa;

private extern expr* wrap_gsl_poly_solve_quadratic
  (double, double, double);
private extern expr* wrap_gsl_poly_complex_solve_quadratic
  (double, double, double);

private extern expr* wrap_gsl_poly_solve_cubic
  (double, double, double);
private extern expr* wrap_gsl_poly_complex_solve_cubic
  (double, double, double);

public
  poly_solve_quadratic
  poly_complex_solve_quadratic
  poly_solve_cubic
  poly_complex_solve_cubic;

/* ..
   ``poly_solve_quadratic a b c``
     finds the real roots of the quadratic equation

     ``a*x^2+b*x+c=0``.
     
     This function returns ``{}`` if the determinate is negative, a 
     matrix with one root if ``a == 0``, or a matrix of two ordered 
     roots otherwise.
*/

poly_solve_quadratic  a  b  c
  = wrap_gsl_poly_solve_quadratic (double a) (double b) (double c)
    if realp a && realp b && realp c;

/* ..
   ``poly_complex_solve_quadratic``
     finds the complex roots of the quadratic equation
     
     ``a*x^2+b*x+c=0``.
          
     This function returns a matrix with one root if ``a == 0``, or a 
     matrix of two ordered (by real part then img part) roots otherwise.
*/     

poly_complex_solve_quadratic  a  b  c
  = wrap_gsl_poly_complex_solve_quadratic (double a) (double b) 
      (double c)
    if realp a && realp b && realp c;

/* ..
   ``poly_solve_cubic``
     finds the real roots of the cubic equation
        
     ``x^3+a*x^2+b*x+c=0``.
     
     This function returns a matrix with one or three double roots.
*/

poly_solve_cubic  a  b  c
  = wrap_gsl_poly_solve_cubic (double a) (double b) (double c)
    if realp a && realp b && realp c;

/* ..
   ``poly_complex_solve_cubic  a  b  c
    finds the complex roots of the cubic equation
    
    ``x^3+z*x^2+b*x+c=0``.
    
    This functions returns a matrix with three complex roots.
*/

poly_complex_solve_cubic  a  b  c
  = wrap_gsl_poly_complex_solve_cubic (double a) (double b) (double c)
    if realp a && realp b && realp c;

private extern expr* wrap_gsl_poly_complex_solve(double*, size_t);

public poly_complex_solve;

/* ..
   ``poly_complex_solve  m::matrix``
   returns a matrix of the roots of the general polynomial
   
   ``P(x)=(a!0)+(a!1)*x+(a!2)*x^2+(a!(n-1))*x^(n-1)``
   
   if they exist. Otherwise, an empty matrix ``{}`` is returned. Note 
   that GSL routines for creating and freeing a workspace are not 
   needed.
*/

poly_complex_solve  m::matrix
  = wrap_gsl_poly_complex_solve (pointer m) (#m);
