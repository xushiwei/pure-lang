
/* gsl.pure: GSL wrapper for the Pure programming language. */

/* Copyright (c) 2008 by Albert Graef <Dr.Graef@t-online.de>.
   Copyright (c) 2008 by Robert E. Rucker <erucker@bmc.edu>.

   This file is part of the Pure programming language and system.

   Pure is free software: you can redistribute it and/or modify it under the
   terms of the GNU General Public License as published by the Free Software
   Foundation, either version 3 of the License, or (at your option) any later
   version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
   details.

   You should have received a copy of the GNU General Public License along
   with this program.  If not, see <http://www.gnu.org/licenses/>. */

using "lib:gsl";

/* Additional matrix operators: element-wise multiplication, division,
   exponentiation, and left division. Note that left division is denoted '\\',
   since the backslash is already used for lambdas in Pure. */

infixl 7 .* ./ \\;
infixr 8 .^ ;

/* Additional number predicates. gsl_complexp checks if a Pure expression
   represents a valid GSL complex value (which is a Pure complex value whose
   real and imaginary components are either double or machine int values).
   gsl_scalarp checks for any kind of Pure number which passes muster as a
   scalar in GSL land (i.e., int, double, GSL complex value). */

extern bool gsl_complexp(expr*);
gsl_scalarp x = intp x || doublep x || gsl_complexp x;

/* Complex functions. */

extern expr* wrap_gsl_complex_sqrt(expr*) = gsl_complex_sqrt;

/* Utility matrices. zeros and ones create matrices with all elements zero or
   one, respectively, and eye creates identity matrices. These functions can
   be invoked either with a pair (n,m) denoting the desired number of rows or
   columns, or an integer n in which case a square nxn matrix is created. The
   result is always a double matrix. */

zeros (n::int,m::int)	= dmatrix (n,m);
zeros n::int		= zeros (n,n);

extern void gsl_matrix_set_all(dmatrix*, double);
ones (n::int,m::int)	= x when
			    x = dmatrix (n,m);
			    _ = gsl_matrix_set_all x 1.0;
			  end;
ones n::int		= ones (n,n);

extern void gsl_matrix_set_identity(dmatrix*);
eye (n::int,m::int)	= x when
			    x = dmatrix (n,m);
			    _ = gsl_matrix_set_identity x;
			  end;
eye n::int		= eye (n,n);

/* Complex and integer matrix variations of the above. */

czeros (n::int,m::int)	= cmatrix (n,m);
czeros n::int		= czeros (n,n);

extern void wrap_gsl_matrix_complex_set_all(cmatrix*, expr*)
 = gsl_matrix_complex_set_all;
cones (n::int,m::int)	= x when
			    x = cmatrix (n,m);
			    _ = gsl_matrix_complex_set_all x 1.0;
			  end;
cones n::int		= cones (n,n);

extern void gsl_matrix_complex_set_identity(cmatrix*);
ceye (n::int,m::int)	= x when
			    x = cmatrix (n,m);
			    _ = gsl_matrix_complex_set_identity x;
			  end;
ceye n::int		= ceye (n,n);

izeros (n::int,m::int)	= imatrix (n,m);
izeros n::int		= izeros (n,n);

extern void gsl_matrix_int_set_all(imatrix*, int);
iones (n::int,m::int)	= x when
			    x = imatrix (n,m);
			    _ = gsl_matrix_int_set_all x 1;
			  end;
iones n::int		= iones (n,n);

extern void gsl_matrix_int_set_identity(imatrix*);
ieye (n::int,m::int)	= x when
			    x = imatrix (n,m);
			    _ = gsl_matrix_int_set_identity x;
			  end;
ieye n::int		= ieye (n,n);

/* Matrix-scalar operations. */

extern int gsl_matrix_add_constant(dmatrix*, double);
extern int wrap_gsl_matrix_complex_add_constant(cmatrix*, expr*)
 = gsl_matrix_complex_add_constant;
extern int gsl_matrix_int_add_constant(imatrix*, double);

a + x::matrix		|
x::matrix + a		= if gsl_complexp a then
			    // complex matrix result
			    (x when x = pack (cmatrix x);
			       _ = gsl_matrix_complex_add_constant x a end)
			  else if imatrixp x && intp a then
			    // int matrix result
			    (x when x = pack x;
			       _ = gsl_matrix_int_add_constant x (double a)
			     end)
			  else
			    // other numeric matrices; ints get promoted to
			    // double here
			    (x when
			       x = pack (if imatrixp x then dmatrix x else x);
			       a = double a;
			       _ = case matrix_type x of
			             1 = gsl_matrix_add_constant x a;
			             2 = gsl_matrix_complex_add_constant x a;
			             3 = gsl_matrix_add_constant x a;
			           end
			     end)
			  if nmatrixp x && gsl_scalarp a;
// symbolic cases
a + x::matrix		= map (\x->a+x) x if ~matrixp a;
x::matrix + a		= map (\x->x+a) x if ~matrixp a;

a - x::matrix		= (-x)+a if nmatrixp x && gsl_scalarp a;
x::matrix - a		= x+(-a) if nmatrixp x && gsl_scalarp a;
a - x::matrix		= map (\x->a-x) x if ~matrixp a;
x::matrix - a		= map (\x->x-a) x if ~matrixp a;

extern int gsl_matrix_scale(dmatrix*, double);
extern int wrap_gsl_matrix_complex_scale(cmatrix*, expr*)
 = gsl_matrix_complex_scale;
extern int gsl_matrix_int_scale(imatrix*, double);

a * x::matrix		|
x::matrix * a		= if gsl_complexp a then
			    // complex matrix result
			    (x when x = pack (cmatrix x);
			       _ = gsl_matrix_complex_scale x a end)
			  else if imatrixp x && intp a then
			    // int matrix result
			    (x when x = pack x;
			       _ = gsl_matrix_int_scale x (double a) end)
			  else
			    // other numeric matrices; ints get promoted to
			    // double here
			    (x when
			       x = pack (if imatrixp x then dmatrix x else x);
			       a = double a;
			       _ = case matrix_type x of
			             1 = gsl_matrix_scale x a;
			             2 = gsl_matrix_complex_scale x a;
			             3 = gsl_matrix_scale x a;
			           end
			     end)
			  if nmatrixp x && gsl_scalarp a;
// symbolic cases
a * x::matrix		= map (\x->a*x) x if ~matrixp a;
x::matrix * a		= map (\x->x*a) x if ~matrixp a;

a / x::matrix		= a*ones(dim x)./x if nmatrixp x && gsl_scalarp a;
x::matrix / a		= x*(1/a) if nmatrixp x && gsl_scalarp a;
a / x::matrix		= map (\x->a/x) x if ~matrixp a;
x::matrix / a		= map (\x->x/a) x if ~matrixp a;

/* Some additional matrix-scalar operations which aren't in GSL, but are
   provided as matrix-matrix operations below. */

a ^ x::matrix		= (a*ones(dim x)).^x if nmatrixp x && gsl_scalarp a;
x::matrix ^ a		= x.^(a*ones(dim x)) if nmatrixp x && gsl_scalarp a;
a ^ x::matrix		= map (\x->a^x) x if ~matrixp a;
x::matrix ^ a		= map (\x->x^a) x if ~matrixp a;

/* Integer matrix-scalar operations. */

a div x::matrix		= (a*iones(dim x)) div x if imatrixp x && intp a;
x::matrix div a		= x div (a*iones(dim x)) if imatrixp x && intp a;
a div x::matrix		= map (\x->a div x) x if ~matrixp a;
x::matrix div a		= map (\x->x div a) x if ~matrixp a;

a mod x::matrix		= (a*iones(dim x)) mod x if imatrixp x && intp a;
x::matrix mod a		= x mod (a*iones(dim x)) if imatrixp x && intp a;
a mod x::matrix		= map (\x->a mod x) x if ~matrixp a;
x::matrix mod a		= map (\x->x mod a) x if ~matrixp a;

a << x::matrix		= (a*iones(dim x)) << x if imatrixp x && intp a;
x::matrix << a		= x << (a*iones(dim x)) if imatrixp x && intp a;
a << x::matrix		= map (\x->a << x) x if ~matrixp a;
x::matrix << a		= map (\x->x << a) x if ~matrixp a;

a >> x::matrix		= (a*iones(dim x)) >> x if imatrixp x && intp a;
x::matrix >> a		= x >> (a*iones(dim x)) if imatrixp x && intp a;
a >> x::matrix		= map (\x->a >> x) x if ~matrixp a;
x::matrix >> a		= map (\x->x >> a) x if ~matrixp a;

a and x::matrix		= (a*iones(dim x)) and x if imatrixp x && intp a;
x::matrix and a		= x and (a*iones(dim x)) if imatrixp x && intp a;
a and x::matrix		= map (\x->a and x) x if ~matrixp a;
x::matrix and a		= map (\x->x and a) x if ~matrixp a;

a or x::matrix		= (a*iones(dim x)) or x if imatrixp x && intp a;
x::matrix or a		= x or (a*iones(dim x)) if imatrixp x && intp a;
a or x::matrix		= map (\x->a or x) x if ~matrixp a;
x::matrix or a		= map (\x->x or a) x if ~matrixp a;

/* Matrix-matrix operations. */

extern int gsl_matrix_add(dmatrix*, dmatrix*);
extern int gsl_matrix_complex_add(cmatrix*, cmatrix*);
extern int gsl_matrix_int_add(imatrix*, imatrix*);

x::matrix + y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = case matrix_type x of
			      1 = gsl_matrix_add x y;
			      2 = gsl_matrix_complex_add x y;
			      3 = gsl_matrix_int_add x y;
			    end;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x + y if nmatrixp x && cmatrixp y;
			= x + cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x + y if imatrixp x && dmatrixp y;
			= x + dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix operations
			= zipwith (+) x y;

extern int gsl_matrix_sub(dmatrix*, dmatrix*);
extern int gsl_matrix_complex_sub(cmatrix*, cmatrix*);
extern int gsl_matrix_int_sub(imatrix*, imatrix*);

x::matrix - y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = case matrix_type x of
			      1 = gsl_matrix_sub x y;
			      2 = gsl_matrix_complex_sub x y;
			      3 = gsl_matrix_int_sub x y;
			    end;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x - y if nmatrixp x && cmatrixp y;
			= x - cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x - y if imatrixp x && dmatrixp y;
			= x - dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix operations
			= zipwith (-) x y;

extern int gsl_matrix_mul_elements(dmatrix*, dmatrix*);
extern int gsl_matrix_complex_mul_elements(cmatrix*, cmatrix*);
extern int gsl_matrix_int_mul_elements(imatrix*, imatrix*);

x::matrix .* y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = case matrix_type x of
			      1 = gsl_matrix_mul_elements x y;
			      2 = gsl_matrix_complex_mul_elements x y;
			      3 = gsl_matrix_int_mul_elements x y;
			    end;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x .* y if nmatrixp x && cmatrixp y;
			= x .* cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x .* y if imatrixp x && dmatrixp y;
			= x .* dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix operations
			= zipwith (*) x y;

extern int gsl_matrix_div_elements(dmatrix*, dmatrix*);
extern int gsl_matrix_complex_div_elements(cmatrix*, cmatrix*);

x::matrix ./ y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= dmatrix x ./ dmatrix y if imatrixp x && imatrixp y;
			= x when
			    x = pack x;
			    _ = case matrix_type x of
			      1 = gsl_matrix_div_elements x y;
			      2 = gsl_matrix_complex_div_elements x y;
			    end;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x ./ y if nmatrixp x && cmatrixp y;
			= x ./ cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x ./ y if imatrixp x && dmatrixp y;
			= x ./ dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix operations
			= zipwith (/) x y;

/* Element-wise exponentiation. This isn't in GSL so we provide it in
   gsl.c. */

extern int gsl_matrix_pow_elements(dmatrix*, dmatrix*);
extern int gsl_matrix_complex_pow_elements(cmatrix*, cmatrix*);

x::matrix .^ y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= dmatrix x .^ dmatrix y if imatrixp x && imatrixp y;
			= x when
			    x = pack x;
			    _ = case matrix_type x of
			      1 = gsl_matrix_pow_elements x y;
			      2 = gsl_matrix_complex_pow_elements x y;
			    end;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x .^ y if nmatrixp x && cmatrixp y;
			= x .^ cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x .^ y if imatrixp x && dmatrixp y;
			= x .^ dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix operations
			= zipwith (^) x y;

/* Element-wise operations on int matrices. These aren't in GSL so we provide
   them in gsl.c. */

extern int gsl_matrix_int_div(imatrix*, imatrix*);
extern int gsl_matrix_int_mod(imatrix*, imatrix*);
extern int gsl_matrix_int_shl(imatrix*, imatrix*);
extern int gsl_matrix_int_shr(imatrix*, imatrix*);
extern int gsl_matrix_int_or(imatrix*, imatrix*);
extern int gsl_matrix_int_and(imatrix*, imatrix*);
extern int gsl_matrix_int_not(imatrix*);

x::matrix div y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= if r==0 then x else 1 div 0 when
			    x = pack x;
			    r = gsl_matrix_int_div x y;
			  end if imatrixp x && imatrixp y;
			= zipwith (div) x y;

x::matrix mod y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= if r==0 then x else 1 mod 0 when
			    x = pack x;
			    r = gsl_matrix_int_mod x y;
			  end if imatrixp x && imatrixp y;
			= zipwith (mod) x y;

x::matrix << y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = gsl_matrix_int_shl x y;
			  end if imatrixp x && imatrixp y;
			= zipwith (<<) x y;

x::matrix >> y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = gsl_matrix_int_shr x y;
			  end if imatrixp x && imatrixp y;
			= zipwith (>>) x y;

x::matrix and y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = gsl_matrix_int_and x y;
			  end if imatrixp x && imatrixp y;
			= zipwith (and) x y;

x::matrix or y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = gsl_matrix_int_or x y;
			  end if imatrixp x && imatrixp y;
			= zipwith (or) x y;

not x::matrix		= x when
			    x = pack x;
			    _ = gsl_matrix_int_not x;
			  end if imatrixp x;
			= map (not) x;

/* Unary minus. */

-x::matrix		= (-1)*x if nmatrixp x;
			= map neg x;

/* Matrix multiplication is implemented via the BLAS interface (actually a
   thin wrapper around the BLAS routines, as we don't need all the arguments).
   BLAS doesn't support integer matrices, currently we emulate these by
   converting to double matrices and then back to integer. */

extern int gsl_matrix_multiply(dmatrix*, dmatrix*, dmatrix*);
extern int gsl_matrix_complex_multiply(cmatrix*, cmatrix*, cmatrix*);

x::matrix * y::matrix	= throw (bad_matrix_value y) if dim x!1~=dim y!0;
			= z when
			    mat = [dmatrix,cmatrix,dmatrix]!(matrix_type x-1);
			    z = mat (dim x!0,dim y!1);
			    _ = if null z then () else
			    (case matrix_type x of
			       1 = gsl_matrix_multiply x y z;
			       2 = gsl_matrix_complex_multiply x y z;
			       3 = gsl_matrix_multiply
			           (dmatrix x) (dmatrix y) z;
			     end);
			    z = if imatrixp x then imatrix z else z;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x * y if nmatrixp x && cmatrixp y;
			= x * cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x * y if imatrixp x && dmatrixp y;
			= x * dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix multiplication
			= redim (dim x!0,dim y!1)
			  {dot u v | u = rows x; v = cols y}
			  with dot x::matrix y::matrix =
			    foldl (+) 0 [x!i*y!i | i=0..#x-1];
			  end;

/* Powers of matrices. x must be a square matrix, k a nonnegative integer. */

pow x::matrix k::int	= throw (bad_matrix_value x) if dim x!0~=dim x!1;
			= case matrix_type x of
			    1 = eye (dim x!0);
			    2 = ceye (dim x!0);
			    _ = ieye (dim x!0);
			  end if k==0;
			= x if k==1;
			= if k mod 2 then y*y*x else y*y
			  when y = pow x (k>>1) end if k>1;
pow x::matrix k::bigint	= pow x (int k);

/* Singular value decompositions. For a given nxm matrix x, these yield a
   singular-value decomposition u,s,v of the matrix such that x==u*s*v', where
   u and v are orthogonal matrices of dimensions nxm and nxn, respectively,
   and s is a nxn diagonal matrix which has the singular values in its
   diagonal, in descending order. Note that GSL implements this only for
   double matrices right now. Also, GSL only handles the case of square or
   overdetermined systems, but we work around that in our wrapper functions by
   just adding a suitable number of zero rows in the underdetermined case.  */

/* This uses the Golub-Reinsch algorithm. */

extern int wrap_gsl_linalg_SV_decomp
(dmatrix* A, dmatrix* V, dmatrix* S, dmatrix* work) = gsl_linalg_SV_decomp;

svd x::matrix		= throw (bad_matrix_value x)
			    if cmatrixp x || smatrixp x;
			= u!!(0..n-1,0..m-1),s,v when
			    n,m = dim x;
			    u,s,v = svd {dmatrix x;dmatrix (m-n,m)};
			  end if dim x!0<dim x!1;
			= u,s,v when n,m = dim x;
			    u = pack (dmatrix x); v = dmatrix (m,m);
			    s = dmatrix (m,m); w = dmatrix m;
			    _ = gsl_linalg_SV_decomp u v s w;
			  end;

/* This uses the modified Golub-Reinsch algorithm, which is faster if n>>m but
   needs O(m^2) extra memory as internal workspace. */

extern int wrap_gsl_linalg_SV_decomp_mod
(dmatrix* A, dmatrix* X, dmatrix* V, dmatrix* S, dmatrix* work)
 = gsl_linalg_SV_decomp_mod;

svd_mod x::matrix	= throw (bad_matrix_value x)
			    if cmatrixp x || smatrixp x;
			= u!!(0..n-1,0..m-1),s,v when
			    n,m = dim x;
			    u,s,v = svd_mod {dmatrix x;dmatrix (m-n,m)};
			  end if dim x!0<dim x!1;
			= u,s,v when n,m = dim x;
			    u = pack (dmatrix x); v = dmatrix (m,m);
			    s = dmatrix (m,m); w = dmatrix m;
			    y = dmatrix (m,m);
			    _ = gsl_linalg_SV_decomp_mod u y v s w;
			  end;

/* This uses one-sided Jacobi orthogonalization which provides better relative
   accuracy but is slower. */

extern int wrap_gsl_linalg_SV_decomp_jacobi
(dmatrix* A, dmatrix* V, dmatrix* S) = gsl_linalg_SV_decomp_jacobi;

svd_jacobi x::matrix	= throw (bad_matrix_value x)
			    if cmatrixp x || smatrixp x;
			= u!!(0..n-1,0..m-1),s,v when
			    n,m = dim x;
			    u,s,v = svd_jacobi {dmatrix x;dmatrix (m-n,m)};
			  end if dim x!0<dim x!1;
			= u,s,v when n,m = dim x;
			    u = pack (dmatrix x); v = dmatrix (m,m);
			    s = dmatrix (m,m);
			    _ = gsl_linalg_SV_decomp_jacobi u v s;
			  end;

/* Solve the system Ax=b, using the SVD of A. Our wrapper svd_solve takes the
   result (u,s,v) of a svd call, and a column vector b of the appropriate
   dimension. The result is another column vector solving the system (possibly
   in the least-squares sense). */

extern int wrap_gsl_linalg_SV_solve
(dmatrix* U, dmatrix* V, dmatrix* S, dmatrix* b, dmatrix* x)
 = gsl_linalg_SV_solve;

svd_solve (u::matrix,s::matrix,v::matrix) b::matrix
			= throw (bad_matrix_value u)
			    if ~dmatrixp u;
			= throw (bad_matrix_value s)
			    if ~dmatrixp s ||
			      dim s!0 ~= dim u!1 || dim s!1 ~= dim u!1;
			= throw (bad_matrix_value v)
			    if ~dmatrixp v ||
			      dim v!0 ~= dim u!1 || dim v!1 ~= dim u!1;
			= throw (bad_matrix_value b)
			    if cmatrixp b || smatrixp b ||
			      ~colvectorp b || dim b!0 ~= dim u!0;
			= x when x = dmatrix (dim u!1,1);
			    _ = gsl_linalg_SV_solve u v s b x;
			  end if dmatrixp b;
			= svd_solve (u,s,v) (dmatrix b) if imatrixp b;

/* Pseudo inverse of a matrix. */

pinv x::matrix		= v*s*u' when
			    u,s,v = svd x;
			    s = map (\x->if x==0 then x else 1/x) (diag s);
			    s = diagmat s;
			  end if nmatrixp x;

/* Right and left matrix division. */

x::matrix / y::matrix	= x*pinv y if nmatrixp x && nmatrixp y;
x::matrix \\ y::matrix	= pinv x*y if nmatrixp x && nmatrixp y;


/* gsl C random distribution functions */
namespace C;

extern double gsl_ran_gaussian_pdf(double x, double sigma);
extern double gsl_ran_ugaussian_pdf(double x);
extern double gsl_cdf_ugaussian_P(double x);
extern double gsl_cdf_gaussian_P(double x, double sigma);
extern double gsl_cdf_ugaussian_Q(double x);
extern double gsl_cdf_gaussian_Q(double x, double sigma);
extern double gsl_cdf_ugaussian_Pinv(double p);
extern double gsl_cdf_gaussian_Pinv(double p, double sigma);
extern double gsl_cdf_ugaussian_Qinv(double q);
extern double gsl_cdf_gaussian_Qinv(double q, double sigma);
extern double gsl_ran_gaussian_tail_pdf(double x, double a, double sigma);
extern double gsl_ran_ugaussian_tail_pdf(double x, double a);
extern double gsl_ran_bivariate_gaussian_pdf
  (double x, double y, double sigma_x, double sigma_y, double rho);
extern double gsl_ran_exponential_pdf(double x, double mu);
extern double gsl_cdf_exponential_P(double x, double mu);
extern double gsl_cdf_exponential_Q(double x, double mu);
extern double gsl_cdf_exponential_Pinv(double p, double mu);
extern double gsl_cdf_exponential_Qinv(double q, double mu);
extern double gsl_ran_laplace_pdf(double x, double a);
extern double gsl_cdf_laplace_P(double x, double a);
extern double gsl_cdf_laplace_Q(double x, double a);
extern double gsl_cdf_laplace_Pinv(double p, double a);
extern double gsl_cdf_laplace_Qinv(double q, double a);
extern double gsl_ran_exppow_pdf(double x, double a, double b);
extern double gsl_cdf_exppow_P(double x, double a, double b);
extern double gsl_cdf_exppow_Q(double x, double a, double b);
extern double gsl_ran_cauchy_pdf(double x, double a);
extern double gsl_cdf_cauchy_P(double x, double a);
extern double gsl_cdf_cauchy_Q(double x, double a);
extern double gsl_cdf_cauchy_Pinv(double p, double a);
extern double gsl_cdf_cauchy_Qinv(double q, double a);
extern double gsl_ran_rayleigh_pdf(double x, double sigma);
extern double gsl_cdf_rayleigh_P(double x, double sigma);
extern double gsl_cdf_rayleigh_Q(double x, double sigma);
extern double gsl_cdf_rayleigh_Pinv(double p, double sigma);
extern double gsl_cdf_rayleigh_Qinv(double q, double sigma);
extern double gsl_ran_rayleigh_tail_pdf(double x, double a, double sigma);
extern double gsl_ran_landau_pdf(double x);
extern double gsl_ran_gamma_pdf(double x, double a, double b);
extern double gsl_cdf_gamma_P(double x, double a, double b);
extern double gsl_cdf_gamma_Q(double x, double a, double b);
extern double gsl_cdf_gamma_Pinv(double p, double a, double b);
extern double gsl_cdf_gamma_Qinv(double q, double a, double b);
extern double gsl_ran_flat_pdf(double x, double a, double b);
extern double gsl_cdf_flat_P(double x, double a, double b);
extern double gsl_cdf_flat_Q(double x, double a, double b);
extern double gsl_cdf_flat_Pinv(double p, double a, double b);
extern double gsl_cdf_flat_Qinv(double q, double a, double b);
extern double gsl_ran_lognormal_pdf(double x, double zeta, double sigma);
extern double gsl_cdf_lognormal_P(double x, double zeta, double sigma);
extern double gsl_cdf_lognormal_Q(double x, double zeta, double sigma);
extern double gsl_cdf_lognormal_Pinv(double p, double zeta, double sigma);
extern double gsl_cdf_lognormal_Qinv(double q, double zeta, double sigma);
extern double gsl_ran_chisq_pdf(double x, double nu);
extern double gsl_cdf_chisq_P(double x, double nu);
extern double gsl_cdf_chisq_Q(double x, double nu);
extern double gsl_cdf_chisq_Pinv(double p, double nu);
extern double gsl_cdf_chisq_Qinv(double q, double nu);
extern double gsl_ran_fdist_pdf(double x, double nu1, double nu2);
extern double gsl_cdf_fdist_P(double x, double nu1, double nu2);
extern double gsl_cdf_fdist_Q(double x, double nu1, double nu2);
extern double gsl_cdf_fdist_Pinv(double p, double nu1, double nu2);
extern double gsl_cdf_fdist_Qinv(double q, double nu1, double nu2);
extern double gsl_ran_tdist_pdf(double x, double nu);
extern double gsl_cdf_tdist_P(double x, double nu);
extern double gsl_cdf_tdist_Q(double x, double nu);
extern double gsl_cdf_tdist_Pinv(double p, double nu);
extern double gsl_cdf_tdist_Qinv(double q, double nu);
extern double gsl_ran_beta_pdf(double x, double a, double b);
extern double gsl_cdf_beta_P(double x, double a, double b);
extern double gsl_cdf_beta_Q(double x, double a, double b);
extern double gsl_cdf_beta_Pinv(double p, double a, double b);
extern double gsl_cdf_beta_Qinv(double q, double a, double b);
extern double gsl_ran_logistic_pdf(double x, double a);
extern double gsl_cdf_logistic_P(double x, double a);
extern double gsl_cdf_logistic_Q(double x, double a);
extern double gsl_cdf_logistic_Pinv(double p, double a);
extern double gsl_cdf_logistic_Qinv(double q, double a);
extern double gsl_ran_pareto_pdf(double x, double a, double b);
extern double gsl_cdf_pareto_P(double x, double a, double b);
extern double gsl_cdf_pareto_Q(double x, double a, double b);
extern double gsl_cdf_pareto_Pinv(double p, double a, double b);
extern double gsl_cdf_pareto_Qinv(double q, double a, double b);
extern double gsl_ran_weibull_pdf(double x, double a, double b);
extern double gsl_cdf_weibull_P(double x, double a, double b);
extern double gsl_cdf_weibull_Q(double x, double a, double b);
extern double gsl_cdf_weibull_Pinv(double p, double a, double b);
extern double gsl_cdf_weibull_Qinv(double q, double a, double b);
extern double gsl_ran_gumbel1_pdf(double x, double a, double b);
extern double gsl_cdf_gumbel1_P(double x, double a, double b);
extern double gsl_cdf_gumbel1_Q(double x, double a, double b);
extern double gsl_cdf_gumbel1_Pinv(double p, double a, double b);
extern double gsl_cdf_gumbel1_Qinv(double q, double a, double b);
extern double gsl_ran_gumbel2_pdf(double x, double a, double b);
extern double gsl_cdf_gumbel2_P(double x, double a, double b);
extern double gsl_cdf_gumbel2_Q(double x, double a, double b);
extern double gsl_cdf_gumbel2_Pinv(double p, double a, double b);
extern double gsl_cdf_gumbel2_Qinv(double q, double a, double b);
extern double gsl_ran_dirichlet_pdf(size_t k, double* alpha, double *theta);
extern double gsl_ran_dirichlet_lnpdf(size_t k, double* alpha, double *theta);
extern gsl_ran_discrete_t *gsl_ran_discrete_preproc(size_t k, double *p);
extern double gsl_ran_discrete_pdf(size_t k, gsl_ran_discrete_t *g);
extern void gsl_ran_discrete_free(gsl_ran_discrete_t *g);
extern double gsl_ran_poisson_pdf(int k, double mu);
extern double gsl_cdf_poisson_P(int k, double mu);
extern double gsl_cdf_poisson_Q(int k, double mu);
extern double gsl_ran_bernoulli_pdf(int k, double p);
extern double gsl_ran_binomial_pdf(int k, double p, int n);
extern double gsl_cdf_binomial_P(int k, double p, int n);
extern double gsl_cdf_binomial_Q(int k, double p, int n);
extern double gsl_ran_multinomial_pdf(size_t k, double* p, int* n);
extern double gsl_ran_multinomial_lnpdf(size_t k, double* p, int* n);
extern double gsl_ran_negative_binomial_pdf(int k, double p, double n);
extern double gsl_cdf_negative_binomial_P(int k, double p, double n);
extern double gsl_cdf_negative_binomial_Q(int k, double p, double n);
extern double gsl_ran_pascal_pdf(int k, double p, int n);
extern double gsl_cdf_pascal_P(int k, double p, int n);
extern double gsl_cdf_pascal_Q(int k, double p, int n);
extern double gsl_ran_geometric_pdf(int k, double p);
extern double gsl_cdf_geometric_P(int k, double p);
extern double gsl_cdf_geometric_Q(int k, double p);
extern double gsl_ran_hypergeometric_pdf(int k, int n1, int n2, int t);
extern double gsl_cdf_hypergeometric_P(int k, int n1, int n2, int t);
extern double gsl_cdf_hypergeometric_Q(int k, int n1, int n2, int t);
extern double gsl_ran_logarithmic_pdf(int k, double p);
extern double gsl_stats_mean(double *data, size_t stride, size_t n);
extern double gsl_stats_variance(double *data, size_t stride, size_t n);
extern double gsl_stats_variance_m
  (double *data, size_t stride, size_t n, double mean);
extern double gsl_stats_sd(double *data, size_t stride, size_t n);
extern double gsl_stats_sd_m
  (double *data, size_t stride, size_t n, double mean);
extern double gsl_stats_tss(double *data, size_t stride, size_t n);
extern double gsl_stats_tss_m
  (double *data, size_t stride, size_t n, double mean);
extern double gsl_stats_variance_with_fixed_mean
  (double *data, size_t stride, size_t n, double mean);
extern double gsl_stats_sd_with_fixed_mean
  (double *data, size_t stride, size_t n, double mean);
extern double gsl_stats_absdev(double *data, size_t stride, size_t n);
extern double gsl_stats_absdev_m
  (double *data, size_t stride, size_t n, double mean);
extern double gsl_stats_skew(double *data, size_t stride, size_t n);
extern double gsl_stats_skew_m_sd
  (double *data, size_t stride, size_t n, double mean, double sd);
extern double gsl_stats_kurtosis
  (double *data, size_t stride, size_t n);
extern double gsl_stats_kurtosis_m_sd
  (double *data, size_t stride, size_t n, double mean, double sd);
extern double gsl_stats_lag1_autocorrelation
  (double *data, size_t stride, size_t n);
extern double gsl_stats_lag1_autocorrelation_m
  (double *data, size_t stride, size_t n, double mean);
extern double gsl_stats_covariance
  (double *data1, size_t stride1, double *data2, size_t stride2, size_t n);
extern double gsl_stats_covariance_m
  (double *data1, size_t stride1, double *data2, size_t stride2, size_t n,
   double mean1, double mean2);
extern double gsl_stats_correlation
  (double *data1, size_t stride1, double *data2, size_t stride2, size_t n);
extern void gsl_sort(double *data, size_t stride, size_t n);
extern double gsl_stats_median_from_sorted_data
  (double *sorted_data, size_t stride, size_t n);
extern double gsl_stats_quantile_from_sorted_data
  (double *sorted_data, size_t stride, size_t n, double f);

namespace gsl;

public
  ran_ugaussian_pdf
  ran_gaussian_pdf
  cdf_ugaussian_P
  cdf_gaussian_P
  cdf_ugaussian_Q
  cdf_gaussian_Q
  cdf_ugaussian_Pinv
  cdf_gaussian_Pinv
  cdf_ugaussian_Qinv
  cdf_gaussian_Qinv
  ran_gaussian_tail_pdf
  ran_ugaussian_tail_pdf
  ran_bivariate_gaussian_pdf
  ran_exponential_pdf
  cdf_exponential_P
  cdf_exponential_Q
  cdf_exponential_Pinv
  cdf_exponential_Qinv
  ran_laplace_pdf
  cdf_laplace_P
  cdf_laplace_Q
  cdf_laplace_Pinv
  cdf_laplace_Qinv
  ran_exppow_pdf
  cdf_exppow_P
  cdf_exppow_Q
  ran_cauchy_pdf
  cdf_cauchy_P
  cdf_cauchy_Q
  cdf_cauchy_Pinv
  cdf_cauchy_Qinv
  ran_rayleigh_pdf
  cdf_rayleigh_P
  cdf_rayleigh_Q
  cdf_rayleigh_Pinv
  cdf_rayleigh_Qinv
  ran_rayleigh_tail_pdf
  ran_landau_pdf
  ran_gamma_pdf
  cdf_gamma_P
  cdf_gamma_Q
  cdf_gamma_Pinv
  cdf_gamma_Qinv
  ran_flat_pdf
  cdf_flat_P
  cdf_flat_Q
  cdf_flat_Pinv
  cdf_flat_Qinv
  ran_lognormal_pdf
  cdf_lognormal_P
  cdf_lognormal_Q
  cdf_lognormal_Pinv
  cdf_lognormal_Qinv
  ran_chisq_pdf
  cdf_chisq_P
  cdf_chisq_Q
  cdf_chisq_Pinv
  cdf_chisq_Qinv
  ran_fdist_pdf
  cdf_fdist_P
  cdf_fdist_Q
  cdf_fdist_Pinv
  cdf_fdist_Qinv
  ran_tdist_pdf
  cdf_tdist_P
  cdf_tdist_Q
  cdf_tdist_Pinv
  cdf_tdist_Qinv
  ran_beta_pdf
  cdf_beta_P
  cdf_beta_Q
  cdf_beta_Pinv
  cdf_beta_Qinv
  ran_logistic_pdf
  cdf_logistic_P
  cdf_logistic_Q
  cdf_logistic_Pinv
  cdf_logistic_Qinv
  ran_pareto_pdf
  cdf_pareto_P
  cdf_pareto_Q
  cdf_pareto_Pinv
  cdf_pareto_Qinv
  ran_weibull_pdf
  cdf_weibull_P
  cdf_weibull_Q
  cdf_weibull_Pinv
  cdf_weibull_Qinv
  ran_gumbel1_pdf
  cdf_gumbel1_P
  cdf_gumbel1_Q
  cdf_gumbel1_Pinv
  cdf_gumbel1_Qinv
  ran_gumbel2_pdf
  cdf_gumbel2_P
  cdf_gumbel2_Q
  cdf_gumbel2_Pinv
  cdf_gumbel2_Qinv
  ran_dirichlet_pdf
  ran_dirichlet_lnpdf
  ran_discrete_preproc
  ran_discrete_pdf
  ran_discrete_free
  ran_poisson_pdf
  cdf_poisson_P
  cdf_poisson_Q
  ran_bernoulli_pdf
  ran_binomial_pdf
  cdf_binomial_P
  cdf_binomial_Q
  ran_multinomial_pdf
  ran_multinomial_lnpdf
  ran_negative_binomial_pdf
  cdf_negative_binomial_P
  cdf_negative_binomial_Q
  ran_pascal_pdf
  cdf_pascal_P
  cdf_pascal_Q
  ran_geometric_pdf
  cdf_geometric_P
  cdf_geometric_Q
  ran_hypergeometric_pdf
  cdf_hypergeometric_P
  cdf_hypergeometric_Q
  ran_logarithmic_pdf
  stats_mean
  stats_variance
  stats_variance_m
  stats_sd
  stats_sd_m
  stats_tss
  stats_tss_m
  stats_variance_with_fixed_mean
  stats_sd_with_fixed_mean
  stats_absdev
  stats_absdev_m
  stats_skew
  stats_skew_m_sd
  stats_kurtosis
  stats_kurtosis_m_sd
  stats_lag1_autocorrelation
  stats_lag1_autocorrelation_m
  stats_covariance
  stats_covariance_m
  stats_correlation
  sort
  stats_median_from_sorted_data
  stats_quantile_from_sorted_data;

using namespace C;
/* Gaussian (Normal) Distribution */

ran_ugaussian_pdf x
  = gsl_ran_ugaussian_pdf (double x)
    if realp x;
ran_gaussian_pdf x sigma
  = gsl_ran_gaussian_pdf (double x) (double sigma)
    if realp x && realp sigma;
cdf_ugaussian_P x
  = gsl_cdf_ugaussian_P (double x) if realp x;
cdf_gaussian_P x sigma
  = gsl_cdf_gaussian_P (double x) (double sigma)
    if realp x && realp sigma;
cdf_ugaussian_Q x
  = gsl_cdf_ugaussian_Q (double x) if realp x;
cdf_gaussian_Q x sigma
  = gsl_cdf_gaussian_Q (double x) (double sigma)
    if realp x && realp sigma;
cdf_ugaussian_Pinv p
  = gsl_cdf_ugaussian_Pinv (double p) if realp p;
cdf_gaussian_Pinv p sigma
  = gsl_cdf_gaussian_Pinv (double p) (double sigma)
    if realp p && realp sigma;
cdf_ugaussian_Qinv q
  = gsl_cdf_ugaussian_Qinv (double q) if realp q;
cdf_gaussian_Qinv q sigma
  = gsl_cdf_gaussian_Qinv (double q) (double sigma)
    if realp q && realp sigma;

/* Gaussian Tail Distribution */

ran_gaussian_tail_pdf x a sigma
  = gsl_ran_gaussian_tail_pdf (double x) (double a) (double sigma)
    if realp x && realp a && realp sigma;
ran_ugaussian_tail_pdf x a
  = gsl_ran_ugaussian_tail_pdf (double x) (double a)
    if realp x && realp a;

/* Bivariate Gaussian Distribution */

ran_bivariate_gaussian_pdf x y sigma_x sigma_y rho
  = gsl_ran_bivariate_gaussian_pdf (double x) (double y)
      (double sigma_x) (double sigma_y) (double rho)
    if realp x && realp y && realp sigma_x && realp sigma_y && realp rho;

/* Exponential Distribution */

ran_exponential_pdf x mu
  = gsl_ran_exponential_pdf (double x) (double mu)
    if realp x && realp mu;
cdf_exponential_P x mu
  = gsl_cdf_exponential_P (double x) (double mu)
    if realp x && realp mu;
cdf_exponential_Q x mu
  = gsl_cdf_exponential_Q (double x) (double mu)
    if realp x && realp mu;
cdf_exponential_Pinv p mu
  = gsl_cdf_exponential_Pinv (double p) (double mu)
    if realp p && realp mu;
cdf_exponential_Qinv q mu
  = gsl_cdf_exponential_Qinv (double q) (double mu)
    if realp q && realp mu;

/* The Laplace Distribution */

ran_laplace_pdf x a
  = gsl_ran_laplace_pdf (double x) (double a)
    if realp x && realp a;
cdf_laplace_P x a
  = gsl_cdf_laplace_P (double x) (double a)
    if realp x && realp a;
cdf_laplace_Q x a
  = gsl_cdf_laplace_Q (double x) (double a)
    if realp x && realp a;
cdf_laplace_Pinv p a
  = gsl_cdf_laplace_Pinv (double p) (double a)
    if realp p && realp a;
cdf_laplace_Qinv q a
  = gsl_cdf_laplace_Qinv (double q) (double a)
    if realp q && realp a;

/* Exponential Power Distribution */

ran_exppow_pdf x a b
  = gsl_ran_exppow_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_exppow_P x a b
  = gsl_cdf_exppow_P (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_exppow_Q x a b
  = gsl_cdf_exppow_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

/* Cauchy Distribution */

ran_cauchy_pdf x a
  = gsl_ran_cauchy_pdf (double x) (double a)
    if realp x && realp a;
cdf_cauchy_P x a
  = gsl_cdf_cauchy_P (double x) (double a)
    if realp x && realp a;
cdf_cauchy_Q x a
  = gsl_cdf_cauchy_Q (double x) (double a)
    if realp x && realp a;
cdf_cauchy_Pinv p a
  = gsl_cdf_cauchy_Pinv (double p) (double a)
    if realp p && realp a;
cdf_cauchy_Qinv q a
  = gsl_cdf_cauchy_Qinv (double q) (double a)
    if realp q && realp a;

/* Rayleigh Distribution */

ran_rayleigh_pdf x sigma
  = gsl_ran_rayleigh_pdf (double x) (double sigma)
    if realp x && realp sigma;
cdf_rayleigh_P x sigma
  = gsl_cdf_rayleigh_P  (double x) (double sigma)
    if realp x && realp sigma;
cdf_rayleigh_Q x sigma
  = gsl_cdf_rayleigh_Q  (double x) (double sigma)
    if realp x && realp sigma;
cdf_rayleigh_Pinv p sigma
  = gsl_cdf_rayleigh_Pinv  (double p) (double sigma)
    if realp p && realp sigma;
cdf_rayleigh_Qinv q sigma
  = gsl_cdf_rayleigh_Qinv  (double q) (double sigma)
    if realp q && realp sigma;

/* Rayleigh Tail Distribution */

ran_rayleigh_tail_pdf x a sigma
  = gsl_ran_rayleigh_tail_pdf (double x) (double a) (double sigma)
    if realp x && realp a && realp sigma;

/* Landau Distribution */
ran_landau_pdf x
  = gsl_ran_landau_pdf x
    if realp x;

/* Gamma Distribution */

ran_gamma_pdf x a b
  = gsl_ran_gamma_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_gamma_P x a b
  = gsl_cdf_gamma_P (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_gamma_Q x a b
  = gsl_cdf_gamma_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_gamma_Pinv p a b
  = gsl_cdf_gamma_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;
cdf_gamma_Qinv q a b
  = gsl_cdf_gamma_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* Flat (Uniform) Distribution */

ran_flat_pdf x a b
  = gsl_ran_flat_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_flat_P x a b
  = gsl_cdf_flat_P (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_flat_Q x a b
  = gsl_cdf_flat_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_flat_Pinv p a b
  = gsl_cdf_flat_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;
cdf_flat_Qinv q a b
  = gsl_cdf_flat_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* Lognormal Distribution */

ran_lognormal_pdf x zeta sigma
  = gsl_ran_lognormal_pdf (double x) (double zeta) (double sigma)
    if realp x && realp zeta && realp sigma;
cdf_lognormal_P x zeta sigma
  = gsl_cdf_lognormal_P (double x) (double zeta) (double sigma)
    if realp x && realp zeta && realp sigma;
cdf_lognormal_Q x zeta sigma
  = gsl_cdf_lognormal_Q (double x) (double zeta) (double sigma)
    if realp x && realp zeta && realp sigma;
cdf_lognormal_Pinv p zeta sigma
  = gsl_cdf_lognormal_Pinv (double p) (double zeta) (double sigma)
    if realp p && realp zeta && realp sigma;
cdf_lognormal_Qinv q zeta sigma
  = gsl_cdf_lognormal_Qinv (double q) (double zeta) (double sigma)
    if realp q && realp zeta && realp sigma;

/* Chi-squared Distribution */

ran_chisq_pdf x nu
  = gsl_ran_chisq_pdf (double x) (double nu)
    if realp x && realp nu;
cdf_chisq_P x nu
  = gsl_cdf_chisq_P (double x) (double nu)
    if realp x && realp nu;
cdf_chisq_Q x nu
  = gsl_cdf_chisq_Q (double x) (double nu)
    if realp x && realp nu;
cdf_chisq_Pinv p nu
  = gsl_cdf_chisq_P (double p) (double nu)
    if realp p && realp nu;
cdf_chisq_Qinv q nu
  = gsl_cdf_chisq_Qinv (double q) (double nu)
    if realp q && realp nu;

/* F-distribution */

ran_fdist_pdf x nu1 nu2
  = gsl_ran_fdist_pdf (double x) (double nu1) (double nu2)
    if realp x && realp nu1 && realp nu2;
cdf_fdist_P x nu1 nu2
  = gsl_cdf_fdist_P (double x) (double nu1) (double nu2)
    if realp x && realp nu1 && realp nu2;
cdf_fdist_Q x nu1 nu2
  = gsl_cdf_fdist_Q (double x) (double nu1) (double nu2)
    if realp x && realp nu1 && realp nu2;
cdf_fdist_Pinv p nu1 nu2
  = gsl_cdf_fdist_Pinv (double p) (double nu1) (double nu2)
	  if realp p && realp nu1 && realp nu2;
cdf_fdist_Qinv q nu1 nu2
  = gsl_cdf_fdist_Qinv (double q) (double nu1) (double nu2)
	  if realp q && realp nu1 && realp nu2;

/* Student t-distribution */

ran_tdist_pdf x nu
  = gsl_ran_tdist_pdf (double x) (double nu)
    if realp x && realp nu;
cdf_tdist_P x nu
  = gsl_cdf_tdist_P (double x) (double nu)
    if realp x && realp nu;
cdf_tdist_Q x nu
  = gsl_cdf_tdist_Q (double x) (double nu)
    if realp x && realp nu;
cdf_tdist_Pinv p nu
  = gsl_cdf_tdist_Pinv (double p) (double nu)
    if realp p && realp nu;
cdf_tdist_Qinv q nu
  = gsl_cdf_tdist_Qinv (double q) (double nu)
    if realp q && realp nu;

/* Beta Distribution */

ran_beta_pdf x a b
  = gsl_ran_beta_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_beta_P x a b
  = gsl_cdf_beta_P (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_beta_Q x a b
  = gsl_cdf_beta_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_beta_Pinv p a b
  = gsl_cdf_beta_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;
cdf_beta_Qinv q a b
  = gsl_cdf_beta_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* Logistic Distribution */

ran_logistic_pdf x a
  = gsl_ran_logistic_pdf (double x) (double a)
    if realp x && realp a;
cdf_logistic_P x a
  = gsl_cdf_logistic_P (double x) (double a)
    if realp x && realp a;
cdf_logistic_Q x a
  = gsl_cdf_logistic_Q (double x) (double a)
    if realp x && realp a;
cdf_logistic_Pinv p a
  = gsl_cdf_logistic_Pinv (double p) (double a)
    if realp p && realp a;
cdf_logistic_Qinv q a
  = gsl_cdf_logistic_Qinv (double q) (double a)
    if realp q && realp a;

/* Pareto Distribution */

ran_pareto_pdf x a b
  = gsl_ran_pareto_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_pareto_P x a b
  = gsl_cdf_pareto_P (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_pareto_Q x a b
  = gsl_cdf_pareto_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_pareto_Pinv p a b
  = gsl_cdf_pareto_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;
cdf_pareto_Qinv q a b
  = gsl_cdf_pareto_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* Weibull Distribution */

ran_weibull_pdf x a b
  = gsl_ran_weibull_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_weibull_P x a b
  = gsl_cdf_weibull_P (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_weibull_Q x a b
  = gsl_cdf_weibull_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_weibull_Pinv p a b
  = gsl_cdf_weibull_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;
cdf_weibull_Qinv q a b
  = gsl_cdf_weibull_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* Type-1 Gumbel Distribution */

ran_gumbel1_pdf x a b
  = gsl_ran_gumbel1_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_gumbel1_P x a b
  = gsl_cdf_gumbel1_P (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_gumbel1_Q x a b
  = gsl_cdf_gumbel1_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_gumbel1_Pinv p a b
  = gsl_cdf_gumbel1_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;
cdf_gumbel1_Qinv q a b
  = gsl_cdf_gumbel1_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* Type-2 Gumbel Distribution */

ran_gumbel2_pdf x a b
  = gsl_ran_gumbel2_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_gumbel2_P x a b
  = gsl_cdf_gumbel2_P (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_gumbel2_Q x a b
  = gsl_cdf_gumbel2_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;
cdf_gumbel2_Pinv p a b
  = gsl_cdf_gumbel2_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;
cdf_gumbel2_Qinv q a b
  = gsl_cdf_gumbel2_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* Dirichlet Distribution
   Notice the 'k' parameter is not used in the Pure wrapper. */

ran_dirichlet_pdf alpha theta
  = x
    when
      x = gsl_ran_dirichlet_pdf (#alpha) (pointer alpha) (pointer theta)
    end
    if #alpha == #theta && dmatrixp alpha && dmatrixp theta;
ran_dirichlet_lnpdf alpha theta
  = x
    when
      x = gsl_ran_dirichlet_lnpdf (#alpha) (pointer alpha) (pointer theta)
    end
    if #alpha == #theta && dmatrixp alpha && dmatrixp theta;

/* General Discrete Distributions */

ran_discrete_preproc p
  = x
    when
      x = gsl_ran_discrete_preproc (#p) (pointer p);
    end
    if dmatrixp p;

ran_discrete_pdf k::int p::pointer
  = gsl_ran_discrete_pdf k p if k >= 0;

ran_discrete_free p::pointer
  = gsl_ran_discrete_free p;

/* Poisson Distribution */

ran_poisson_pdf k::int mu
  = gsl_ran_poisson_pdf k (double mu)
    if realp mu && k >= 0;
cdf_poisson_P k::int mu
  = gsl_cdf_poisson_P k (double mu)
    if realp mu && k >= 0;
cdf_poisson_Q k::int mu
  = gsl_cdf_poisson_Q k (double mu)
    if realp mu && k >= 0;

/* Bernoulli Distribution */

ran_bernoulli_pdf k::int p
  = gsl_ran_bernoulli_pdf k (double p)
    if realp p && k >= 0;

/* Binomial Distribution */

ran_binomial_pdf k::int p n::int
  = gsl_ran_binomial_pdf k (double p) n
    if realp p && k >= 0 && n > 0;
cdf_binomial_P k::int p n::int
  = gsl_cdf_binomial_P k (double p) n
    if realp p && k >= 0 && n > 0;
cdf_binomial_Q k::int q n::int
  = gsl_cdf_binomial_Q k (double q) n
    if realp q && k >= 0 && n > 0;

/* Multinomial Distribution
   Notice the 'k' parameter is not used in the Pure wrapper. */

ran_multinomial_pdf p n
  = x
    when
      x = gsl_ran_multinomial_pdf (#n) (pointer p) (pointer n)
    end
    if #p == #n && dmatrixp p && imatrixp n;

ran_multinomial_lnpdf p n
  = x
    when
      x = gsl_ran_multinomial_lnpdf (#n) (pointer p) (pointer n)
    end
    if #p == #n && dmatrixp p && imatrixp n;

/* Negative Binomial Distribution */

ran_negative_binomial_pdf k::int p n
  = gsl_ran_negative_binomial_pdf k (double p) (double n)
    if realp p && realp n && k >= 0;
cdf_negative_binomial_P k::int p n
  = gsl_cdf_negative_binomial_P k (double p) (double n)
    if realp p && realp n && k >= 0;
cdf_negative_binomial_Q k::int p n
  = gsl_cdf_negative_binomial_Q k::int (double p) (double n)
    if realp p && realp n && k >= 0;

/* Pascal Distribution */

ran_pascal_pdf k::int p n::int
  = gsl_ran_pascal_pdf k (double p) n
    if realp p && k >= 0;
cdf_pascal_P k::int p n::int
  = gsl_cdf_pascal_P k (double p) n
    if realp p && k >= 0;
cdf_pascal_Q k::int p n::int
  = gsl_cdf_pascal_Q k (double p) n
    if realp p && k >= 0;

/* Geometric Distribution */

ran_geometric_pdf k::int p
  = gsl_ran_geometric_pdf k (double p)
    if realp p && k >= 1;
cdf_geometric_P k::int p
  = gsl_cdf_geometric_P k (double p)
    if realp p && k >= 1;
cdf_geometric_Q k::int p
  = gsl_cdf_geometric_Q k (double p)
    if realp p && k >= 1;

/* Hypergeometric Distribution */

ran_hypergeometric_pdf k::int n1::int n2::int t::int
  = gsl_ran_hypergeometric_pdf k n1 n2 t
    if k >= 0 && n1 >= 0 && n2 >= 0 && t >= 0;
cdf_hypergeometric_P k::int n1::int n2::int t::int
  = gsl_cdf_hypergeometric_P k n1 n2 t
    if k >= 0 && n1 >= 0 && n2 >= 0 && t >= 0;
cdf_hypergeometric_Q k::int n1::int n2::int t::int
  = gsl_cdf_hypergeometric_Q k n1 n2 t
    if k >= 0 && n1 >= 0 && n2 >= 0 && t >= 0;

/* Logarithmic Distribution */

ran_logarithmic_pdf k::int p
  = gsl_ran_logarithmic_pdf k (double p)
    if k >= 1 && realp p;

/* Mean, Standard Deviation, and Variance */

stats_mean m::matrix
  = v
    when
      mm = dmatrix m;
      v = gsl_stats_mean (pointer mm) 1 (#m);
    end
    if rowvectorp m;

stats_variance m::matrix
  = v
    when
      mm = dmatrix m;
      v = gsl_stats_variance (pointer mm) 1 (#m);
    end
    if rowvectorp m;

stats_variance_m m::matrix mean
  = v
    when
      mm = dmatrix m;
      v = gsl_stats_variance_m (pointer mm) 1 (#m) (double mean);
    end
    if rowvectorp m;

stats_sd m::matrix
  = v
    when
      mm = dmatrix m;
      v = gsl_stats_sd (pointer mm) 1 (#m);
    end
    if rowvectorp m;

stats_sd_m m::matrix mean
  = v
    when
      mm = dmatrix m;
      v = gsl_stats_sd_m (pointer mm) 1 (#m) (double mean);
    end
    if rowvectorp m;

stats_tss m::matrix
  = v
  when
    mm = dmatrix m;
    v = gsl_stats_tss (pointer mm) 1 (#m);
  end
  if rowvectorp m;

stats_tss_m m::matrix mean
  = v
    when
      mm = dmatrix m;
      v = gsl_stats_tss_m (pointer mm) 1 (#m) (double mean);
    end
    if rowvectorp m;

stats_variance_with_fixed_mean m::matrix mean
  = v
    when
      mm = dmatrix m;
      v = gsl_stats_variance_with_fixed_mean (pointer mm) 1 (#m) (double mean);
    end
    if rowvectorp m;

stats_sd_with_fixed_mean m::matrix mean
  = v
    when
      mm = dmatrix m;
      v = gsl_stats_sd_with_fixed_mean (pointer mm) 1 (#m) (double mean);
    end
    if rowvectorp m;

/* Absolute deviation */

stats_absdev m::matrix
  = v
    when
      mm = dmatrix m;
      v = gsl_stats_absdev (pointer mm) 1 (#m);
    end
    if rowvectorp m;

stats_absdev_m m::matrix mean
  = v
    when
      mm = dmatrix m;
      v = gsl_stats_absdev_m (pointer mm) 1 (#m) (double mean);
    end
    if rowvectorp m;

/* Higher moments (skewness and kurtosis) */

stats_skew m::matrix
  = v
    when
      mm = dmatrix m;
      v = gsl_stats_skew (pointer mm) 1 (#m);
    end
    if rowvectorp m;

stats_skew_m_sd m::matrix mean sd
  = v
    when
      mm = dmatrix m;
      v = gsl_stats_skew_m_sd (pointer mm) 1 (#m) (double mean) (double sd);
    end
    if rowvectorp m && sd >= 0.0;

stats_kurtosis m::matrix
  = v
    when
      mm = dmatrix m;
      v = gsl_stats_kurtosis (pointer mm) 1 (#m);
    end
    if rowvectorp m;

stats_kurtosis_m_sd m::matrix mean sd
  = v
    when
      mm = dmatrix m;
      v = gsl_stats_kurtosis_m_sd (pointer mm) 1 (#m) (double mean) (double sd);
    end
    if rowvectorp m && sd >= 0.0;
 
/* Autocorrelation */

stats_lag1_autocorrelation m::matrix
  = v
    when
      mm = dmatrix m;
      v = gsl_stats_lag1_autocorrelation (pointer mm) 1 (#m);
    end
    if rowvectorp m;

stats_lag1_autocorrelation_m m::matrix mean
  = v
    when
      mm = dmatrix m;
      v = gsl_stats_lag1_autocorrelation_m (pointer mm) 1 (#m) (double mean);
    end
    if rowvectorp m;

/* Covariance */

stats_covariance m1::matrix m2::matrix
  = v
    when
      mm1 = dmatrix m1;
      mm2 = dmatrix m2;
      v = gsl_stats_covariance (pointer mm1) 1 (pointer mm2) 1 (#m1);
    end
    if rowvectorp m1 && rowvectorp m2;

stats_covariance_m m1::matrix m2::matrix mean1 mean2
  = v
    when
      mm1 = dmatrix m1;
      mm2 = dmatrix m2;
      v = gsl_stats_covariance_m 
        (pointer mm1) 1 (pointer mm2) 1 (#m1) (double mean1) (double mean2);
    end
    if rowvectorp m1 && rowvectorp m2;

/* Correlation */

stats_correlation m1::matrix m2::matrix
  = v
    when
      mm1 = dmatrix m1;
      mm2 = dmatrix m2;
      v = gsl_stats_correlation (pointer mm1) 1 (pointer mm2) 1 (#m1);
    end
    if rowvectorp m1 && rowvectorp m2;

/* Sort for median and quatile functions
   The manual recomends using a better stable sort. */

sort m::matrix
  = mm
    when
      mm = dmatrix m;
      gsl_sort (pointer mm) 1 (#m);
    end
    if rowvectorp m;

/* Median and Percentiles */

stats_median_from_sorted_data m::matrix
  = v
    when
      mm = dmatrix m;
      v = gsl_stats_median_from_sorted_data (pointer mm) 1 (#m);
    end
    if rowvectorp m;

stats_quantile_from_sorted_data m::matrix f::double
  = v
    when
      mm = dmatrix m;
      v = gsl_stats_quantile_from_sorted_data (pointer mm) 1 (#m) f;
    end
    if rowvectorp m && f >= 0.0 && f <= 1.0;
