
/* gsl.pure: GSL wrapper for the Pure programming language. */

/* Copyright (c) 2008 by Albert Graef <Dr.Graef@t-online.de>.
   Copyright (c) 2008 by Robert E. Rucker <erucker@bmc.edu>.

   This file is part of the Pure programming language and system.

   Pure is free software: you can redistribute it and/or modify it under the
   terms of the GNU General Public License as published by the Free Software
   Foundation, either version 3 of the License, or (at your option) any later
   version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
   details.

   You should have received a copy of the GNU General Public License along
   with this program.  If not, see <http://www.gnu.org/licenses/>. */

using "lib:gsl";

/* Additional matrix operators: element-wise multiplication, division,
   exponentiation, and left division. Note that left division is denoted '\\',
   since the backslash is already used for lambdas in Pure. */

infixl 7 .* ./ \\;
infixr 8 .^ ;

/* Additional number predicates. gsl_complexp checks if a Pure expression
   represents a valid GSL complex value (which is a Pure complex value whose
   real and imaginary components are either double or machine int values).
   gsl_scalarp checks for any kind of Pure number which passes muster as a
   scalar in GSL land (i.e., int, double, GSL complex value). */

extern bool gsl_complexp(expr*);
gsl_scalarp x = intp x || doublep x || gsl_complexp x;

/* Complex functions. */

extern expr* wrap_gsl_complex_sqrt(expr*) = gsl_complex_sqrt;

/* Utility matrices. zeros and ones create matrices with all elements zero or
   one, respectively, and eye creates identity matrices. These functions can
   be invoked either with a pair (n,m) denoting the desired number of rows or
   columns, or an integer n in which case a square nxn matrix is created. The
   result is always a double matrix. */

zeros (n::int,m::int)	= dmatrix (n,m);
zeros n::int		= zeros (n,n);

extern void gsl_matrix_set_all(dmatrix*, double);
ones (n::int,m::int)	= x when
			    x = dmatrix (n,m);
			    _ = gsl_matrix_set_all x 1.0;
			  end;
ones n::int		= ones (n,n);

extern void gsl_matrix_set_identity(dmatrix*);
eye (n::int,m::int)	= x when
			    x = dmatrix (n,m);
			    _ = gsl_matrix_set_identity x;
			  end;
eye n::int		= eye (n,n);

/* Complex and integer matrix variations of the above. */

czeros (n::int,m::int)	= cmatrix (n,m);
czeros n::int		= czeros (n,n);

extern void wrap_gsl_matrix_complex_set_all(cmatrix*, expr*)
 = gsl_matrix_complex_set_all;
cones (n::int,m::int)	= x when
			    x = cmatrix (n,m);
			    _ = gsl_matrix_complex_set_all x 1.0;
			  end;
cones n::int		= cones (n,n);

extern void gsl_matrix_complex_set_identity(cmatrix*);
ceye (n::int,m::int)	= x when
			    x = cmatrix (n,m);
			    _ = gsl_matrix_complex_set_identity x;
			  end;
ceye n::int		= ceye (n,n);

izeros (n::int,m::int)	= imatrix (n,m);
izeros n::int		= izeros (n,n);

extern void gsl_matrix_int_set_all(imatrix*, int);
iones (n::int,m::int)	= x when
			    x = imatrix (n,m);
			    _ = gsl_matrix_int_set_all x 1;
			  end;
iones n::int		= iones (n,n);

extern void gsl_matrix_int_set_identity(imatrix*);
ieye (n::int,m::int)	= x when
			    x = imatrix (n,m);
			    _ = gsl_matrix_int_set_identity x;
			  end;
ieye n::int		= ieye (n,n);

/* Matrix-scalar operations. */

extern int gsl_matrix_add_constant(dmatrix*, double);
extern int wrap_gsl_matrix_complex_add_constant(cmatrix*, expr*)
 = gsl_matrix_complex_add_constant;
extern int gsl_matrix_int_add_constant(imatrix*, double);

a + x::matrix		|
x::matrix + a		= if gsl_complexp a then
			    // complex matrix result
			    (x when x = pack (cmatrix x);
			       _ = gsl_matrix_complex_add_constant x a end)
			  else if imatrixp x && intp a then
			    // int matrix result
			    (x when x = pack x;
			       _ = gsl_matrix_int_add_constant x (double a)
			     end)
			  else
			    // other numeric matrices; ints get promoted to
			    // double here
			    (x when
			       x = pack (if imatrixp x then dmatrix x else x);
			       a = double a;
			       _ = case matrix_type x of
			             1 = gsl_matrix_add_constant x a;
			             2 = gsl_matrix_complex_add_constant x a;
			             3 = gsl_matrix_add_constant x a;
			           end
			     end)
			  if nmatrixp x && gsl_scalarp a;
// symbolic cases
a + x::matrix		= map (\x->a+x) x if ~matrixp a;
x::matrix + a		= map (\x->x+a) x if ~matrixp a;

a - x::matrix		= (-x)+a if nmatrixp x && gsl_scalarp a;
x::matrix - a		= x+(-a) if nmatrixp x && gsl_scalarp a;
a - x::matrix		= map (\x->a-x) x if ~matrixp a;
x::matrix - a		= map (\x->x-a) x if ~matrixp a;

extern int gsl_matrix_scale(dmatrix*, double);
extern int wrap_gsl_matrix_complex_scale(cmatrix*, expr*)
 = gsl_matrix_complex_scale;
extern int gsl_matrix_int_scale(imatrix*, double);

a * x::matrix		|
x::matrix * a		= if gsl_complexp a then
			    // complex matrix result
			    (x when x = pack (cmatrix x);
			       _ = gsl_matrix_complex_scale x a end)
			  else if imatrixp x && intp a then
			    // int matrix result
			    (x when x = pack x;
			       _ = gsl_matrix_int_scale x (double a) end)
			  else
			    // other numeric matrices; ints get promoted to
			    // double here
			    (x when
			       x = pack (if imatrixp x then dmatrix x else x);
			       a = double a;
			       _ = case matrix_type x of
			             1 = gsl_matrix_scale x a;
			             2 = gsl_matrix_complex_scale x a;
			             3 = gsl_matrix_scale x a;
			           end
			     end)
			  if nmatrixp x && gsl_scalarp a;
// symbolic cases
a * x::matrix		= map (\x->a*x) x if ~matrixp a;
x::matrix * a		= map (\x->x*a) x if ~matrixp a;

a / x::matrix		= a*ones(dim x)./x if nmatrixp x && gsl_scalarp a;
x::matrix / a		= x*(1/a) if nmatrixp x && gsl_scalarp a;
a / x::matrix		= map (\x->a/x) x if ~matrixp a;
x::matrix / a		= map (\x->x/a) x if ~matrixp a;

/* Some additional matrix-scalar operations which aren't in GSL, but are
   provided as matrix-matrix operations below. */

a ^ x::matrix		= (a*ones(dim x)).^x if nmatrixp x && gsl_scalarp a;
x::matrix ^ a		= x.^(a*ones(dim x)) if nmatrixp x && gsl_scalarp a;
a ^ x::matrix		= map (\x->a^x) x if ~matrixp a;
x::matrix ^ a		= map (\x->x^a) x if ~matrixp a;

/* Integer matrix-scalar operations. */

a div x::matrix		= (a*iones(dim x)) div x if imatrixp x && intp a;
x::matrix div a		= x div (a*iones(dim x)) if imatrixp x && intp a;
a div x::matrix		= map (\x->a div x) x if ~matrixp a;
x::matrix div a		= map (\x->x div a) x if ~matrixp a;

a mod x::matrix		= (a*iones(dim x)) mod x if imatrixp x && intp a;
x::matrix mod a		= x mod (a*iones(dim x)) if imatrixp x && intp a;
a mod x::matrix		= map (\x->a mod x) x if ~matrixp a;
x::matrix mod a		= map (\x->x mod a) x if ~matrixp a;

a << x::matrix		= (a*iones(dim x)) << x if imatrixp x && intp a;
x::matrix << a		= x << (a*iones(dim x)) if imatrixp x && intp a;
a << x::matrix		= map (\x->a << x) x if ~matrixp a;
x::matrix << a		= map (\x->x << a) x if ~matrixp a;

a >> x::matrix		= (a*iones(dim x)) >> x if imatrixp x && intp a;
x::matrix >> a		= x >> (a*iones(dim x)) if imatrixp x && intp a;
a >> x::matrix		= map (\x->a >> x) x if ~matrixp a;
x::matrix >> a		= map (\x->x >> a) x if ~matrixp a;

a and x::matrix		= (a*iones(dim x)) and x if imatrixp x && intp a;
x::matrix and a		= x and (a*iones(dim x)) if imatrixp x && intp a;
a and x::matrix		= map (\x->a and x) x if ~matrixp a;
x::matrix and a		= map (\x->x and a) x if ~matrixp a;

a or x::matrix		= (a*iones(dim x)) or x if imatrixp x && intp a;
x::matrix or a		= x or (a*iones(dim x)) if imatrixp x && intp a;
a or x::matrix		= map (\x->a or x) x if ~matrixp a;
x::matrix or a		= map (\x->x or a) x if ~matrixp a;

/* Matrix-matrix operations. */

extern int gsl_matrix_add(dmatrix*, dmatrix*);
extern int gsl_matrix_complex_add(cmatrix*, cmatrix*);
extern int gsl_matrix_int_add(imatrix*, imatrix*);

x::matrix + y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = case matrix_type x of
			      1 = gsl_matrix_add x y;
			      2 = gsl_matrix_complex_add x y;
			      3 = gsl_matrix_int_add x y;
			    end;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x + y if nmatrixp x && cmatrixp y;
			= x + cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x + y if imatrixp x && dmatrixp y;
			= x + dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix operations
			= zipwith (+) x y;

extern int gsl_matrix_sub(dmatrix*, dmatrix*);
extern int gsl_matrix_complex_sub(cmatrix*, cmatrix*);
extern int gsl_matrix_int_sub(imatrix*, imatrix*);

x::matrix - y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = case matrix_type x of
			      1 = gsl_matrix_sub x y;
			      2 = gsl_matrix_complex_sub x y;
			      3 = gsl_matrix_int_sub x y;
			    end;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x - y if nmatrixp x && cmatrixp y;
			= x - cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x - y if imatrixp x && dmatrixp y;
			= x - dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix operations
			= zipwith (-) x y;

extern int gsl_matrix_mul_elements(dmatrix*, dmatrix*);
extern int gsl_matrix_complex_mul_elements(cmatrix*, cmatrix*);
extern int gsl_matrix_int_mul_elements(imatrix*, imatrix*);

x::matrix .* y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = case matrix_type x of
			      1 = gsl_matrix_mul_elements x y;
			      2 = gsl_matrix_complex_mul_elements x y;
			      3 = gsl_matrix_int_mul_elements x y;
			    end;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x .* y if nmatrixp x && cmatrixp y;
			= x .* cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x .* y if imatrixp x && dmatrixp y;
			= x .* dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix operations
			= zipwith (*) x y;

extern int gsl_matrix_div_elements(dmatrix*, dmatrix*);
extern int gsl_matrix_complex_div_elements(cmatrix*, cmatrix*);

x::matrix ./ y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= dmatrix x ./ dmatrix y if imatrixp x && imatrixp y;
			= x when
			    x = pack x;
			    _ = case matrix_type x of
			      1 = gsl_matrix_div_elements x y;
			      2 = gsl_matrix_complex_div_elements x y;
			    end;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x ./ y if nmatrixp x && cmatrixp y;
			= x ./ cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x ./ y if imatrixp x && dmatrixp y;
			= x ./ dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix operations
			= zipwith (/) x y;

/* Element-wise exponentiation. This isn't in GSL so we provide it in
   gsl.c. */

extern int gsl_matrix_pow_elements(dmatrix*, dmatrix*);
extern int gsl_matrix_complex_pow_elements(cmatrix*, cmatrix*);

x::matrix .^ y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= dmatrix x .^ dmatrix y if imatrixp x && imatrixp y;
			= x when
			    x = pack x;
			    _ = case matrix_type x of
			      1 = gsl_matrix_pow_elements x y;
			      2 = gsl_matrix_complex_pow_elements x y;
			    end;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x .^ y if nmatrixp x && cmatrixp y;
			= x .^ cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x .^ y if imatrixp x && dmatrixp y;
			= x .^ dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix operations
			= zipwith (^) x y;

/* Element-wise operations on int matrices. These aren't in GSL so we provide
   them in gsl.c. */

extern int gsl_matrix_int_div(imatrix*, imatrix*);
extern int gsl_matrix_int_mod(imatrix*, imatrix*);
extern int gsl_matrix_int_shl(imatrix*, imatrix*);
extern int gsl_matrix_int_shr(imatrix*, imatrix*);
extern int gsl_matrix_int_or(imatrix*, imatrix*);
extern int gsl_matrix_int_and(imatrix*, imatrix*);
extern int gsl_matrix_int_not(imatrix*);

x::matrix div y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= if r==0 then x else 1 div 0 when
			    x = pack x;
			    r = gsl_matrix_int_div x y;
			  end if imatrixp x && imatrixp y;
			= zipwith (div) x y;

x::matrix mod y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= if r==0 then x else 1 mod 0 when
			    x = pack x;
			    r = gsl_matrix_int_mod x y;
			  end if imatrixp x && imatrixp y;
			= zipwith (mod) x y;

x::matrix << y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = gsl_matrix_int_shl x y;
			  end if imatrixp x && imatrixp y;
			= zipwith (<<) x y;

x::matrix >> y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = gsl_matrix_int_shr x y;
			  end if imatrixp x && imatrixp y;
			= zipwith (>>) x y;

x::matrix and y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = gsl_matrix_int_and x y;
			  end if imatrixp x && imatrixp y;
			= zipwith (and) x y;

x::matrix or y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = gsl_matrix_int_or x y;
			  end if imatrixp x && imatrixp y;
			= zipwith (or) x y;

not x::matrix		= x when
			    x = pack x;
			    _ = gsl_matrix_int_not x;
			  end if imatrixp x;
			= map (not) x;

/* Unary minus. */

-x::matrix		= (-1)*x if nmatrixp x;
			= map neg x;

/* Matrix multiplication is implemented via the BLAS interface (actually a
   thin wrapper around the BLAS routines, as we don't need all the arguments).
   BLAS doesn't support integer matrices, currently we emulate these by
   converting to double matrices and then back to integer. */

extern int gsl_matrix_multiply(dmatrix*, dmatrix*, dmatrix*);
extern int gsl_matrix_complex_multiply(cmatrix*, cmatrix*, cmatrix*);

x::matrix * y::matrix	= throw (bad_matrix_value y) if dim x!1~=dim y!0;
			= z when
			    mat = [dmatrix,cmatrix,dmatrix]!(matrix_type x-1);
			    z = mat (dim x!0,dim y!1);
			    _ = if null z then () else
			    (case matrix_type x of
			       1 = gsl_matrix_multiply x y z;
			       2 = gsl_matrix_complex_multiply x y z;
			       3 = gsl_matrix_multiply
			           (dmatrix x) (dmatrix y) z;
			     end);
			    z = if imatrixp x then imatrix z else z;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x * y if nmatrixp x && cmatrixp y;
			= x * cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x * y if imatrixp x && dmatrixp y;
			= x * dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix multiplication
			= redim (dim x!0,dim y!1)
			  {dot u v | u = rows x; v = cols y}
			  with dot x::matrix y::matrix =
			    foldl (+) 0 [x!i*y!i | i=0..#x-1];
			  end;

/* Powers of matrices. x must be a square matrix, k a nonnegative integer. */

pow x::matrix k::int	= throw (bad_matrix_value x) if dim x!0~=dim x!1;
			= case matrix_type x of
			    1 = eye (dim x!0);
			    2 = ceye (dim x!0);
			    _ = ieye (dim x!0);
			  end if k==0;
			= x if k==1;
			= if k mod 2 then y*y*x else y*y
			  when y = pow x (k>>1) end if k>1;
pow x::matrix k::bigint	= pow x (int k);

/* Singular value decompositions. For a given nxm matrix x, these yield a
   singular-value decomposition u,s,v of the matrix such that x==u*s*v', where
   u and v are orthogonal matrices of dimensions nxm and nxn, respectively,
   and s is a nxn diagonal matrix which has the singular values in its
   diagonal, in descending order. Note that GSL implements this only for
   double matrices right now. Also, GSL only handles the case of square or
   overdetermined systems, but we work around that in our wrapper functions by
   just adding a suitable number of zero rows in the underdetermined case.  */

/* This uses the Golub-Reinsch algorithm. */

extern int wrap_gsl_linalg_SV_decomp
(dmatrix* A, dmatrix* V, dmatrix* S, dmatrix* work) = gsl_linalg_SV_decomp;

svd x::matrix		= throw (bad_matrix_value x)
			    if cmatrixp x || smatrixp x;
			= u!!(0..n-1,0..m-1),s,v when
			    n,m = dim x;
			    u,s,v = svd {dmatrix x;dmatrix (m-n,m)};
			  end if dim x!0<dim x!1;
			= u,s,v when n,m = dim x;
			    u = pack (dmatrix x); v = dmatrix (m,m);
			    s = dmatrix (m,m); w = dmatrix m;
			    _ = gsl_linalg_SV_decomp u v s w;
			  end;

/* This uses the modified Golub-Reinsch algorithm, which is faster if n>>m but
   needs O(m^2) extra memory as internal workspace. */

extern int wrap_gsl_linalg_SV_decomp_mod
(dmatrix* A, dmatrix* X, dmatrix* V, dmatrix* S, dmatrix* work)
 = gsl_linalg_SV_decomp_mod;

svd_mod x::matrix	= throw (bad_matrix_value x)
			    if cmatrixp x || smatrixp x;
			= u!!(0..n-1,0..m-1),s,v when
			    n,m = dim x;
			    u,s,v = svd_mod {dmatrix x;dmatrix (m-n,m)};
			  end if dim x!0<dim x!1;
			= u,s,v when n,m = dim x;
			    u = pack (dmatrix x); v = dmatrix (m,m);
			    s = dmatrix (m,m); w = dmatrix m;
			    y = dmatrix (m,m);
			    _ = gsl_linalg_SV_decomp_mod u y v s w;
			  end;

/* This uses one-sided Jacobi orthogonalization which provides better relative
   accuracy but is slower. */

extern int wrap_gsl_linalg_SV_decomp_jacobi
(dmatrix* A, dmatrix* V, dmatrix* S) = gsl_linalg_SV_decomp_jacobi;

svd_jacobi x::matrix	= throw (bad_matrix_value x)
			    if cmatrixp x || smatrixp x;
			= u!!(0..n-1,0..m-1),s,v when
			    n,m = dim x;
			    u,s,v = svd_jacobi {dmatrix x;dmatrix (m-n,m)};
			  end if dim x!0<dim x!1;
			= u,s,v when n,m = dim x;
			    u = pack (dmatrix x); v = dmatrix (m,m);
			    s = dmatrix (m,m);
			    _ = gsl_linalg_SV_decomp_jacobi u v s;
			  end;

/* Solve the system Ax=b, using the SVD of A. Our wrapper svd_solve takes the
   result (u,s,v) of a svd call, and a column vector b of the appropriate
   dimension. The result is another column vector solving the system (possibly
   in the least-squares sense). */

extern int wrap_gsl_linalg_SV_solve
(dmatrix* U, dmatrix* V, dmatrix* S, dmatrix* b, dmatrix* x)
 = gsl_linalg_SV_solve;

svd_solve (u::matrix,s::matrix,v::matrix) b::matrix
			= throw (bad_matrix_value u)
			    if ~dmatrixp u;
			= throw (bad_matrix_value s)
			    if ~dmatrixp s ||
			      dim s!0 ~= dim u!1 || dim s!1 ~= dim u!1;
			= throw (bad_matrix_value v)
			    if ~dmatrixp v ||
			      dim v!0 ~= dim u!1 || dim v!1 ~= dim u!1;
			= throw (bad_matrix_value b)
			    if cmatrixp b || smatrixp b ||
			      ~colvectorp b || dim b!0 ~= dim u!0;
			= x when x = dmatrix (dim u!1,1);
			    _ = gsl_linalg_SV_solve u v s b x;
			  end if dmatrixp b;
			= svd_solve (u,s,v) (dmatrix b) if imatrixp b;

/* Pseudo inverse of a matrix. */

pinv x::matrix		= v*s*u' when
			    u,s,v = svd x;
			    s = map (\x->if x==0 then x else 1/x) (diag s);
			    s = diagmat s;
			  end if nmatrixp x;

/* Right and left matrix division. */

x::matrix / y::matrix	= x*pinv y if nmatrixp x && nmatrixp y;
x::matrix \\ y::matrix	= pinv x*y if nmatrixp x && nmatrixp y;

/* General and elementary functions */

namespace C;
extern void gsl_sort(double*, size_t, size_t);
extern void gsl_sort_int(int*, size_t, size_t);
namespace;

using namespace C;
namespace gsl;

public
  sort;

/* Sort for median and quatile functions
   The manual recomends using a better stable sort. */


sort  m::matrix
  = case matrix_type m of
      1 = gsl_sort (pointer mm) 1 (#mm)  $$  mm  when mm = dmatrix m; end;
      3 = gsl_sort_int (pointer mm) 1 (#mm)  $$  mm  when mm = imatrix m; end;
      _ = quote (gsl::sort m);
    end
    if rowvectorp m;

/* gsl C random distribution functions */
namespace C;

extern double gsl_ran_gaussian_pdf(double, double);
extern double gsl_ran_ugaussian_pdf(double);
extern double gsl_cdf_ugaussian_P(double);
extern double gsl_cdf_gaussian_P(double, double);
extern double gsl_cdf_ugaussian_Q(double);
extern double gsl_cdf_gaussian_Q(double, double);
extern double gsl_cdf_ugaussian_Pinv(double);
extern double gsl_cdf_gaussian_Pinv(double, double);
extern double gsl_cdf_ugaussian_Qinv(double);
extern double gsl_cdf_gaussian_Qinv(double, double);

extern double gsl_ran_gaussian_tail_pdf(double, double, double);
extern double gsl_ran_ugaussian_tail_pdf(double, double);

extern double gsl_ran_bivariate_gaussian_pdf
  (double, double, double, double, double);

extern double gsl_ran_exponential_pdf(double, double);
extern double gsl_cdf_exponential_P(double, double);
extern double gsl_cdf_exponential_Q(double, double);
extern double gsl_cdf_exponential_Pinv(double, double);
extern double gsl_cdf_exponential_Qinv(double, double);

extern double gsl_ran_laplace_pdf(double, double);
extern double gsl_cdf_laplace_P(double, double);
extern double gsl_cdf_laplace_Q(double, double);
extern double gsl_cdf_laplace_Pinv(double, double);
extern double gsl_cdf_laplace_Qinv(double, double);

extern double gsl_ran_exppow_pdf(double, double, double);
extern double gsl_cdf_exppow_P(double, double, double);
extern double gsl_cdf_exppow_Q(double, double, double);

extern double gsl_ran_cauchy_pdf(double, double);
extern double gsl_cdf_cauchy_P(double, double);
extern double gsl_cdf_cauchy_Q(double, double);
extern double gsl_cdf_cauchy_Pinv(double, double);
extern double gsl_cdf_cauchy_Qinv(double, double);

extern double gsl_ran_rayleigh_pdf(double, double);
extern double gsl_cdf_rayleigh_P(double, double);
extern double gsl_cdf_rayleigh_Q(double, double);
extern double gsl_cdf_rayleigh_Pinv(double, double);
extern double gsl_cdf_rayleigh_Qinv(double, double);

extern double gsl_ran_rayleigh_tail_pdf(double, double, double);

extern double gsl_ran_landau_pdf(double);

extern double gsl_ran_gamma_pdf(double, double, double);
extern double gsl_cdf_gamma_P(double, double, double);
extern double gsl_cdf_gamma_Q(double, double, double);
extern double gsl_cdf_gamma_Pinv(double, double, double);
extern double gsl_cdf_gamma_Qinv(double, double, double);

extern double gsl_ran_flat_pdf(double, double, double);
extern double gsl_cdf_flat_P(double, double, double);
extern double gsl_cdf_flat_Q(double, double, double);
extern double gsl_cdf_flat_Pinv(double, double, double);
extern double gsl_cdf_flat_Qinv(double, double, double);

extern double gsl_ran_lognormal_pdf(double, double, double);
extern double gsl_cdf_lognormal_P(double, double, double);
extern double gsl_cdf_lognormal_Q(double, double, double);
extern double gsl_cdf_lognormal_Pinv(double, double, double);
extern double gsl_cdf_lognormal_Qinv(double, double, double);

extern double gsl_ran_chisq_pdf(double, double);
extern double gsl_cdf_chisq_P(double, double);
extern double gsl_cdf_chisq_Q(double, double);
extern double gsl_cdf_chisq_Pinv(double, double);
extern double gsl_cdf_chisq_Qinv(double, double);

extern double gsl_ran_fdist_pdf(double, double, double);
extern double gsl_cdf_fdist_P(double, double, double);
extern double gsl_cdf_fdist_Q(double, double, double);
extern double gsl_cdf_fdist_Pinv(double, double, double);
extern double gsl_cdf_fdist_Qinv(double, double, double);

extern double gsl_ran_tdist_pdf(double, double);
extern double gsl_cdf_tdist_P(double, double);
extern double gsl_cdf_tdist_Q(double, double);
extern double gsl_cdf_tdist_Pinv(double, double);
extern double gsl_cdf_tdist_Qinv(double, double);

extern double gsl_ran_beta_pdf(double, double, double);
extern double gsl_cdf_beta_P(double, double, double);
extern double gsl_cdf_beta_Q(double, double, double);
extern double gsl_cdf_beta_Pinv(double, double, double);
extern double gsl_cdf_beta_Qinv(double, double, double);

extern double gsl_ran_logistic_pdf(double, double);
extern double gsl_cdf_logistic_P(double, double);
extern double gsl_cdf_logistic_Q(double, double);
extern double gsl_cdf_logistic_Pinv(double, double);
extern double gsl_cdf_logistic_Qinv(double, double);

extern double gsl_ran_pareto_pdf(double, double, double);
extern double gsl_cdf_pareto_P(double, double, double);
extern double gsl_cdf_pareto_Q(double, double, double);
extern double gsl_cdf_pareto_Pinv(double, double, double);
extern double gsl_cdf_pareto_Qinv(double, double, double);

extern double gsl_ran_weibull_pdf(double, double, double);
extern double gsl_cdf_weibull_P(double, double, double);
extern double gsl_cdf_weibull_Q(double, double, double);
extern double gsl_cdf_weibull_Pinv(double, double, double);
extern double gsl_cdf_weibull_Qinv(double, double, double);

extern double gsl_ran_gumbel1_pdf(double, double, double);
extern double gsl_cdf_gumbel1_P(double, double, double);
extern double gsl_cdf_gumbel1_Q(double, double, double);
extern double gsl_cdf_gumbel1_Pinv(double, double, double);
extern double gsl_cdf_gumbel1_Qinv(double, double, double);

extern double gsl_ran_gumbel2_pdf(double, double, double);
extern double gsl_cdf_gumbel2_P(double, double, double);
extern double gsl_cdf_gumbel2_Q(double, double, double);
extern double gsl_cdf_gumbel2_Pinv(double, double, double);
extern double gsl_cdf_gumbel2_Qinv(double, double, double);

extern double gsl_ran_dirichlet_pdf(size_t, double*, double*);
extern double gsl_ran_dirichlet_lnpdf(size_t, double*, double*);

extern gsl_ran_discrete_t *gsl_ran_discrete_preproc(size_t, double*);
extern double gsl_ran_discrete_pdf(size_t, gsl_ran_discrete_t*);
extern void gsl_ran_discrete_free(gsl_ran_discrete_t *);

extern double gsl_ran_poisson_pdf(int, double);
extern double gsl_cdf_poisson_P(int, double);
extern double gsl_cdf_poisson_Q(int, double);

extern double gsl_ran_bernoulli_pdf(int, double);

extern double gsl_ran_binomial_pdf(int, double, int);
extern double gsl_cdf_binomial_P(int, double, int);
extern double gsl_cdf_binomial_Q(int, double, int);

extern double gsl_ran_multinomial_pdf(size_t, double*, int*);
extern double gsl_ran_multinomial_lnpdf(size_t, double*, int*);

extern double gsl_ran_negative_binomial_pdf(int, double, double);
extern double gsl_cdf_negative_binomial_P(int, double, double);
extern double gsl_cdf_negative_binomial_Q(int, double, double);

extern double gsl_ran_pascal_pdf(int, double, int);
extern double gsl_cdf_pascal_P(int, double, int);
extern double gsl_cdf_pascal_Q(int, double, int);

extern double gsl_ran_geometric_pdf(int, double);
extern double gsl_cdf_geometric_P(int, double);
extern double gsl_cdf_geometric_Q(int, double);

extern double gsl_ran_hypergeometric_pdf(int, int, int, int);
extern double gsl_cdf_hypergeometric_P(int, int, int, int);
extern double gsl_cdf_hypergeometric_Q(int, int, int, int);

extern double gsl_ran_logarithmic_pdf(int, double);
namespace;

/* Convenience macro for use with probability density functions */

private
  apply2_ran;

def apply2_ran  f  m1  m2  =
  if rowvectorp m1 && rowvectorp m2 && #m1 == #m2 then
    v
  else
    f m1 m2
  when
    x1, x2 = dmatrix m1, dmatrix m2;
    v = f (#m1) (pointer x1) (pointer x2);
  end;

namespace gsl_pdf;

public
  ugaussian
  gaussian
  gaussian_tail
  ugaussian_tail
  bivariate_gaussian
  exponential
  laplace
  exppow
  cauchy
  rayleigh
  rayleigh_tail
  landau
  gamma
  flat
  lognormal
  chisq
  fdist
  tdist
  beta
  logistic
  pareto
  weibull
  gumbel1
  gumbel2
  dirichlet
  dirichlet_ln
  discrete_preproc
  discrete
  discrete_free
  poisson
  bernoulli
  binomial
  multinomial
  multinomial_ln
  negative_binomial
  pascal
  geometric
  hypergeometric
  logarithmic;

ugaussian  x
  = gsl_ran_ugaussian_pdf (double x) if realp x;

gaussian  x  sigma
  = gsl_ran_gaussian_pdf (double x) (double sigma) if realp x && realp sigma;

gaussian_tail  x  a  sigma
  = gsl_ran_gaussian_tail_pdf (double x) (double a) (double sigma)
    if realp x && realp a && realp sigma;

ugaussian_tail  x  a
  = gsl_ran_ugaussian_tail_pdf (double x) (double a) if realp x && realp a;

bivariate_gaussian  x  y  sigma_x  sigma_y  rho
  = gsl_ran_bivariate_gaussian_pdf
      (double x) (double y) (double sigma_x) (double sigma_y) (double rho)
    if realp x && realp y && realp sigma_x && realp sigma_y && realp rho;

exponential  x  mu
  = gsl_ran_exponential_pdf (double x) (double mu) if realp x && realp mu;

laplace  x  a
  = gsl_ran_laplace_pdf (double x) (double a) if realp x && realp a;

exppow  x  a  b
  = gsl_ran_exppow_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

cauchy  x  a
  = gsl_ran_cauchy_pdf (double x) (double a) if realp x && realp a;

rayleigh  x  sigma
  = gsl_ran_rayleigh_pdf (double x) (double sigma) if realp x && realp sigma;

rayleigh_tail  x  a  sigma
  = gsl_ran_rayleigh_tail_pdf (double x) (double a) (double sigma)
    if realp x && realp a && realp sigma;

landau  x
  = gsl_ran_landau_pdf x if realp x;

gamma  x  a  b
  = gsl_ran_gamma_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

flat  x  a  b
  = gsl_ran_flat_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

lognormal  x  zeta  sigma
  = gsl_ran_lognormal_pdf (double x) (double zeta) (double sigma)
    if realp x && realp zeta && realp sigma;

chisq  x  nu
  = gsl_ran_chisq_pdf (double x) (double nu) if realp x && realp nu;

fdist  x  nu1  nu2
  = gsl_ran_fdist_pdf (double x) (double nu1) (double nu2)
    if realp x && realp nu1 && realp nu2;

tdist  x  nu
  = gsl_ran_tdist_pdf (double x) (double nu) if realp x && realp nu;

beta  x  a  b
  = gsl_ran_beta_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

logistic  x  a
  = gsl_ran_logistic_pdf (double x) (double a) if realp x && realp a;

pareto  x  a  b
  = gsl_ran_pareto_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

weibull  x  a  b
  = gsl_ran_weibull_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

gumbel1  x  a  b
  = gsl_ran_gumbel1_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

gumbel2  x  a  b
  = gsl_ran_gumbel2_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

dirichlet  alpha::matrix  theta::matrix
  = apply2_ran  gsl_ran_dirichlet_pdf  alpha  theta;

dirichlet_ln  alpha::matrix  theta::matrix
  = apply2_ran  gsl_ran_dirichlet_lnpdf  alpha  theta;

discrete_preproc  p::matrix
  = v
    when
      x = dmatrix p;
      v = gsl_ran_discrete_preproc (#p) (pointer x);
    end
    if rowvectorp p;

discrete  k::int  p::pointer
  = gsl_ran_discrete_pdf  k  p if k >= 0;

discrete_free  p::pointer
  = gsl_ran_discrete_free  p;

poisson  k::int  mu
  = gsl_ran_poisson_pdf  k (double mu) if realp mu && k >= 0;

bernoulli  k::int  p
  = gsl_ran_bernoulli_pdf  k (double p) if realp p && k >= 0;

binomial  k::int  p  n::int
  = gsl_ran_binomial_pdf  k (double p) n if realp p && k >= 0 && n > 0;

negative_binomial  k::int  p  n
  = gsl_ran_negative_binomial_pdf  k  (double p) (double n)
    if realp p && realp n && k >= 0;

multinomial  p::matrix  n::matrix
  = apply2_ran  gsl_ran_multinomial_pdf  p  n;

multinomial_ln  p::matrix  n::matrix
  = apply2_ran  gsl_ran_multinomial_lnpdf  p  n;

pascal  k::int  p  n::int
  = gsl_ran_pascal_pdf k (double p) n if realp p && k >= 0;

geometric  k::int  p
  = gsl_ran_geometric_pdf k (double p) if realp p && k >= 1;

hypergeometric  k::int  n1::int  n2::int  t::int
  = gsl_ran_hypergeometric_pdf k n1 n2 t
    if k >= 0 && n1 >= 0 && n2 >= 0 && t >= 0;

logarithmic  k::int  p
  = gsl_ran_logarithmic_pdf k (double p) if k >= 1 && realp p;

/* Continuous distribution functions */

namespace gsl_cdf;

public
  ugaussian_P
  gaussian_P
  ugaussian_Q
  gaussian_Q
  ugaussian_Pinv
  gaussian_Pinv
  ugaussian_Qinv
  gaussian_Qinv
  exponential_P
  exponential_Q
  exponential_Pinv
  exponential_Qinv
  laplace_P
  laplace_Q
  laplace_Pinv
  laplace_Qinv
  exppow_P
  exppow_Q
  cauchy_P
  cauchy_Q
  cauchy_Pinv
  cauchy_Qinv
  rayleigh_P
  rayleigh_Q
  rayleigh_Pinv
  rayleigh_Qinv
  gamma_P
  gamma_Q
  gamma_Pinv
  gamma_Qinv
  flat_P
  flat_Q
  flat_Pinv
  flat_Qinv
  lognormal_P
  lognormal_Q
  lognormal_Pinv
  lognormal_Qinv
  chisq_P
  chisq_Q
  chisq_Pinv
  chisq_Qinv
  fdist_P
  fdist_Q
  fdist_Pinv
  fdist_Qinv
  tdist_P
  tdist_Q
  tdist_Pinv
  tdist_Qinv
  beta_P
  beta_Q
  beta_Pinv
  beta_Qinv
  logistic_P
  logistic_Q
  logistic_Pinv
  logistic_Qinv
  pareto_P
  pareto_Q
  pareto_Pinv
  pareto_Qinv
  weibull_P
  weibull_Q
  weibull_Pinv
  weibull_Qinv
  gumbel1_P
  gumbel1_Q
  gumbel1_Pinv
  gumbel1_Qinv
  gumbel2_P
  gumbel2_Q
  gumbel2_Pinv
  gumbel2_Qinv
  poisson_P
  poisson_Q
  binomial_P
  binomial_Q
  negative_binomial_P
  negative_binomial_Q
  pascal_P
  pascal_Q
  geometric_P
  geometric_Q
  hypergeometric_P
  hypergeometric_Q;

ugaussian_P  x
  = gsl_cdf_ugaussian_P (double x) if realp x;

gaussian_P  x  sigma
  = gsl_cdf_gaussian_P (double x) (double sigma) if realp x && realp sigma;

ugaussian_Q  x
  = gsl_cdf_ugaussian_Q (double x) if realp x;

gaussian_Q  x  sigma
  = gsl_cdf_gaussian_Q (double x) (double sigma) if realp x && realp sigma;

ugaussian_Pinv  p
  = gsl_cdf_ugaussian_Pinv (double p) if realp p;

gaussian_Pinv  p  sigma
  = gsl_cdf_gaussian_Pinv (double p) (double sigma) if realp p && realp sigma;

ugaussian_Qinv  q
  = gsl_cdf_ugaussian_Qinv (double q) if realp q;

gaussian_Qinv  q  sigma
  = gsl_cdf_gaussian_Qinv (double q) (double sigma) if realp q && realp sigma;

exponential_P  x  mu
  = gsl_cdf_exponential_P (double x) (double mu) if realp x && realp mu;

exponential_Q  x  mu
  = gsl_cdf_exponential_Q (double x) (double mu) if realp x && realp mu;

exponential_Pinv  p  mu
  = gsl_cdf_exponential_Pinv (double p) (double mu) if realp p && realp mu;

exponential_Qinv  q  mu
  = gsl_cdf_exponential_Qinv (double q) (double mu) if realp q && realp mu;

laplace_P  x  a
  = gsl_cdf_laplace_P (double x) (double a) if realp x && realp a;

laplace_Q  x  a
  = gsl_cdf_laplace_Q (double x) (double a) if realp x && realp a;

laplace_Pinv  p  a
  = gsl_cdf_laplace_Pinv (double p) (double a) if realp p && realp a;

laplace_Qinv  q  a
  = gsl_cdf_laplace_Qinv (double q) (double a)
    if realp q && realp a;

exppow_P  x  a  b
  = gsl_cdf_exppow_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

exppow_Q  x  a  b
  = gsl_cdf_exppow_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

cauchy_P  x  a
  = gsl_cdf_cauchy_P (double x) (double a) if realp x && realp a;

cauchy_Q  x  a
  = gsl_cdf_cauchy_Q (double x) (double a) if realp x && realp a;

cauchy_Pinv  p  a
  = gsl_cdf_cauchy_Pinv (double p) (double a) if realp p && realp a;

cauchy_Qinv  q  a
  = gsl_cdf_cauchy_Qinv (double q) (double a) if realp q && realp a;

rayleigh_P  x  sigma
  = gsl_cdf_rayleigh_P (double x) (double sigma) if realp x && realp sigma;

rayleigh_Q  x  sigma
  = gsl_cdf_rayleigh_Q (double x) (double sigma) if realp x && realp sigma;

rayleigh_Pinv  p  sigma
  = gsl_cdf_rayleigh_Pinv (double p) (double sigma) if realp p && realp sigma;

rayleigh_Qinv  q  sigma
  = gsl_cdf_rayleigh_Qinv  (double q) (double sigma) if realp q && realp sigma;

gamma_P  x  a  b
  = gsl_cdf_gamma_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

gamma_Q  x  a  b
  = gsl_cdf_gamma_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

gamma_Pinv  p  a  b
  = gsl_cdf_gamma_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

gamma_Qinv  q  a  b
  = gsl_cdf_gamma_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

flat_P  x  a  b
  = gsl_cdf_flat_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

flat_Q  x  a  b
  = gsl_cdf_flat_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

flat_Pinv  p  a  b
  = gsl_cdf_flat_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

flat_Qinv  q  a  b
  = gsl_cdf_flat_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

lognormal_P  x  zeta  sigma
  = gsl_cdf_lognormal_P (double x) (double zeta) (double sigma)
    if realp x && realp zeta && realp sigma;

lognormal_Q  x  zeta  sigma
  = gsl_cdf_lognormal_Q (double x) (double zeta) (double sigma)
    if realp x && realp zeta && realp sigma;

lognormal_Pinv  p  zeta  sigma
  = gsl_cdf_lognormal_Pinv (double p) (double zeta) (double sigma)
    if realp p && realp zeta && realp sigma;

lognormal_Qinv  q  zeta  sigma
  = gsl_cdf_lognormal_Qinv (double q) (double zeta) (double sigma)
    if realp q && realp zeta && realp sigma;

chisq_P  x  nu
  = gsl_cdf_chisq_P (double x) (double nu) if realp x && realp nu;

chisq_Q  x  nu
  = gsl_cdf_chisq_Q (double x) (double nu) if realp x && realp nu;

chisq_Pinv  p  nu
  = gsl_cdf_chisq_P (double p) (double nu) if realp p && realp nu;

chisq_Qinv  q  nu
  = gsl_cdf_chisq_Qinv (double q) (double nu) if realp q && realp nu;

fdist_P  x  nu1  nu2
  = gsl_cdf_fdist_P (double x) (double nu1) (double nu2)
    if realp x && realp nu1 && realp nu2;

fdist_Q  x  nu1  nu2
  = gsl_cdf_fdist_Q (double x) (double nu1) (double nu2)
    if realp x && realp nu1 && realp nu2;

fdist_Pinv  p  nu1  nu2
  = gsl_cdf_fdist_Pinv (double p) (double nu1) (double nu2)
	  if realp p && realp nu1 && realp nu2;

fdist_Qinv  q  nu1  nu2
  = gsl_cdf_fdist_Qinv (double q) (double nu1) (double nu2)
	  if realp q && realp nu1 && realp nu2;

tdist_P  x  nu
  = gsl_cdf_tdist_P (double x) (double nu) if realp x && realp nu;

tdist_Q  x  nu
  = gsl_cdf_tdist_Q (double x) (double nu) if realp x && realp nu;

tdist_Pinv  p  nu
  = gsl_cdf_tdist_Pinv (double p) (double nu) if realp p && realp nu;

tdist_Qinv  q  nu
  = gsl_cdf_tdist_Qinv (double q) (double nu) if realp q && realp nu;

beta_P  x  a  b
  = gsl_cdf_beta_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

beta_Q  x  a  b
  = gsl_cdf_beta_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

beta_Pinv  p  a  b
  = gsl_cdf_beta_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

beta_Qinv  q  a  b
  = gsl_cdf_beta_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

logistic_P  x  a
  = gsl_cdf_logistic_P (double x) (double a) if realp x && realp a;

logistic_Q  x  a
  = gsl_cdf_logistic_Q (double x) (double a) if realp x && realp a;

logistic_Pinv  p  a
  = gsl_cdf_logistic_Pinv (double p) (double a) if realp p && realp a;

logistic_Qinv  q  a
  = gsl_cdf_logistic_Qinv (double q) (double a) if realp q && realp a;

pareto_P  x  a  b
  = gsl_cdf_pareto_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

pareto_Q  x  a  b
  = gsl_cdf_pareto_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

pareto_Pinv  p  a  b
  = gsl_cdf_pareto_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

pareto_Qinv  q  a  b
  = gsl_cdf_pareto_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

weibull_P  x  a  b
  = gsl_cdf_weibull_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

weibull_Q  x  a  b
  = gsl_cdf_weibull_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

weibull_Pinv  p  a  b
  = gsl_cdf_weibull_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

weibull_Qinv  q  a  b
  = gsl_cdf_weibull_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

gumbel1_P  x  a  b
  = gsl_cdf_gumbel1_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

gumbel1_Q  x  a  b
  = gsl_cdf_gumbel1_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

gumbel1_Pinv  p  a  b
  = gsl_cdf_gumbel1_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

gumbel1_Qinv  q  a  b
  = gsl_cdf_gumbel1_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

gumbel2_P  x  a  b
  = gsl_cdf_gumbel2_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

gumbel2_Q  x  a  b
  = gsl_cdf_gumbel2_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

gumbel2_Pinv  p  a  b
  = gsl_cdf_gumbel2_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

gumbel2_Qinv  q  a  b
  = gsl_cdf_gumbel2_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

poisson_P  k::int  mu
  = gsl_cdf_poisson_P  k (double mu) if realp mu && k >= 0;

poisson_Q  k::int  mu
  = gsl_cdf_poisson_Q  k (double mu) if realp mu && k >= 0;

binomial_P  k::int  p  n::int
  = gsl_cdf_binomial_P  k (double p) n if realp p && k >= 0 && n > 0;

binomial_Q  k::int  q  n::int
  = gsl_cdf_binomial_Q  k (double q) n if realp q && k >= 0 && n > 0;

negative_binomial_P  k::int  p  n
  = gsl_cdf_negative_binomial_P  k  (double p) (double n)
    if realp p && realp n && k >= 0;

negative_binomial_Q  k::int  p  n
  = gsl_cdf_negative_binomial_Q  k  (double p) (double n)
    if realp p && realp n && k >= 0;

pascal_P  k::int  p  n::int
  = gsl_cdf_pascal_P k (double p) n if realp p && k >= 0;

pascal_Q  k::int  p  n::int
  = gsl_cdf_pascal_Q k (double p) n if realp p && k >= 0;

geometric_P  k::int  p
  = gsl_cdf_geometric_P k (double p) if realp p && k >= 1;

geometric_Q  k::int  p
  = gsl_cdf_geometric_Q k (double p) if realp p && k >= 1;

hypergeometric_P  k::int  n1::int  n2::int  t::int
  = gsl_cdf_hypergeometric_P k n1 n2 t
    if k >= 0 && n1 >= 0 && n2 >= 0 && t >= 0;

hypergeometric_Q  k::int  n1::int  n2::int  t::int
  = gsl_cdf_hypergeometric_Q k n1 n2 t
    if k >= 0 && n1 >= 0 && n2 >= 0 && t >= 0;

namespace C;

extern double gsl_stats_mean(double*, size_t, size_t);

extern double gsl_stats_variance(double*, size_t, size_t);
extern double gsl_stats_variance_m(double*, size_t, size_t, double);

extern double gsl_stats_sd(double*, size_t, size_t);
extern double gsl_stats_sd_m(double*, size_t, size_t, double);

extern double gsl_stats_tss(double*, size_t, size_t);
extern double gsl_stats_tss_m(double*, size_t, size_t, double);

extern double gsl_stats_variance_with_fixed_mean
  (double*, size_t, size_t, double);
extern double gsl_stats_sd_with_fixed_mean(double*, size_t, size_t, double);

extern double gsl_stats_absdev(double*, size_t, size_t);
extern double gsl_stats_absdev_m(double*, size_t, size_t, double);

extern double gsl_stats_skew(double*, size_t, size_t);
extern double gsl_stats_skew_m_sd(double*, size_t, size_t, double, double);

extern double gsl_stats_kurtosis(double*, size_t, size_t);
extern double gsl_stats_kurtosis_m_sd(double*, size_t, size_t, double, double);

extern double gsl_stats_lag1_autocorrelation(double*, size_t, size_t);
extern double gsl_stats_lag1_autocorrelation_m(double*, size_t, size_t, double);

extern double gsl_stats_covariance(double*, size_t, double*, size_t, size_t);
extern double gsl_stats_covariance_m
  (double*, size_t, double*, size_t, size_t, double, double);

extern double gsl_stats_wmean(double*, size_t, double*, size_t, size_t);
extern double gsl_stats_wvariance(double*, size_t, double*, size_t, size_t);
extern double gsl_stats_wvariance_m
  (double*, size_t, double*, size_t, size_t, double);
extern double gsl_stats_wsd(double*, size_t, double*, size_t, size_t);
extern double gsl_stats_wsd_m(double*, size_t, double*, size_t, size_t, double);
extern double gsl_stats_wvariance_with_fixed_mean
  (double*, size_t, double*, size_t, size_t, double);
extern double gsl_stats_wsd_with_fixed_mean
  (double*, size_t, double*, size_t, size_t, double);
extern double gsl_stats_wabsdev(double*, size_t, double*, size_t, size_t);
extern double gsl_stats_wabsdev_m
  (double*, size_t, double*, size_t, size_t, double);
extern double gsl_stats_wskew(double*, size_t, double*, size_t, size_t);
extern double gsl_stats_wskew_m_sd
  (double*, size_t, double*, size_t, size_t, double, double);
extern double gsl_stats_wkurtosis(double*, size_t, double*, size_t, size_t);
extern double gsl_stats_wkurtosis_m_sd
  (double*, size_t, double*, size_t, size_t, double, double);

extern double gsl_stats_correlation(double*, size_t, double*, size_t, size_t);

extern double gsl_stats_median_from_sorted_data(double*, size_t, size_t);
extern double gsl_stats_quantile_from_sorted_data
  (double*, size_t, size_t, double);

extern double gsl_stats_max(double*, size_t, size_t);
extern double gsl_stats_min(double*, size_t, size_t);

extern int gsl_stats_int_max(int*, size_t, size_t);
extern int gsl_stats_int_min(int*, size_t, size_t);
extern void gsl_stats_int_minmax(int*, int*, int*, size_t, size_t);
extern void gsl_stats_minmax(double*, double*, double*, size_t, size_t);
extern int gsl_stats_int_max_index(int*, size_t, size_t);
extern int gsl_stats_max_index(double*, size_t, size_t);
extern int gsl_stats_int_min_index(int*, size_t, size_t);
extern int gsl_stats_min_index(double*, size_t, size_t);
extern void gsl_stats_int_minmax_index
  (size_t*, size_t*, int*, size_t, size_t);
extern void gsl_stats_minmax_index(size_t*, size_t*, double*, size_t, size_t);

namespace;

/* Convenience macros for stats functions */

private
  apply1
  apply1_d
  apply1_dd
  apply2
  apply2_d
  apply2_dd;

def apply1  f  m  mtype  =
  if rowvectorp m then
    v
  else
    f m
  when 
    x = mtype m;
    v = f (pointer x) 1 (#m);
  end;
  
def apply1_d  f  m  d  =
  if rowvectorp m then
    v
  else
    f m d
  when
    x = dmatrix m;
    v = f (pointer x) 1 (#m) (double d);
  end;

def apply1_dd  f  m  d1  d2  =
  if rowvectorp m then
    v
  else
    f m d1 d2
  when
    x = dmatrix m;
    v = f (pointer x) 1 (#m) (double d1) (double d2);
  end;

def apply2  f  m1  m2  =
  if rowvectorp m1 && rowvectorp m2 && #m1 == #m2 then
    v
  else
    f m1 m2
  when
    x1, x2 = dmatrix m1, dmatrix m2;
    v = f (pointer x1) 1 (pointer x2) 1 (#m1);
  end;

def apply2_d  f  m1  m2  d  =
  if rowvectorp m1 && rowvectorp m2 && #m1 == #m2 then
    v
  else
    f m1 m2 d
  when
    x1, x2 = dmatrix m1, dmatrix m2;
    v = f (pointer x1) 1 (pointer x2) 1 (#m1) (double d);
  end;

def apply2_dd  f  m1  m2  d1  d2  =
  if rowvectorp m1 && rowvectorp m2 && #m1 == #m2 then
    v
  else
    f m1 m2 d1 d2
  when
    x1, x2 = dmatrix m1, dmatrix m2;
    v = f (pointer x1) 1 (pointer x2) 1 (#m1) (double d1) (double d2);
  end;

namespace gsl_stats;

public
  mean
  variance
  variance_m
  sd
  sd_m
  tss
  tss_m
  variance_with_fixed_mean
  sd_with_fixed_mean
  absdev
  absdev_m
  skew
  skew_m_sd
  kurtosis
  kurtosis_m_sd
  lag1_autocorrelation
  lag1_autocorrelation_m
  covariance
  covariance_m
  wmean
  wvariance
  wvariance_m
  wsd
  wsd_m
  wvariance_with_fixed_mean
  wsd_with_fixed_mean
  wabsdev
  wabsdev_m
  wskew
  wskew_m_sd
  wkurtosis
  wkurtosis_m_sd
  max
  min
  minmax
  max_index
  min_index
  minmax_index
  median_from_sorted_data
  quantile_from_sorted_data
  correlation;

mean  m::matrix
  = apply1  gsl_stats_mean  m  dmatrix;

variance  m::matrix
  = apply1  gsl_stats_variance  m  dmatrix;

variance_m  m::matrix  mean
  = apply1_d  gsl_stats_variance_m  m  mean;

sd  m::matrix
  = apply1  gsl_stats_sd  m  dmatrix;

sd_m m::matrix mean
  = apply1_d  gsl_stats_sd_m  m  mean;

tss  m::matrix
  = apply1  gsl_stats_tss  m  dmatrix;

tss_m  m::matrix  mean
  = apply1_d  gsl_stats_tss_m  m  mean;

variance_with_fixed_mean  m::matrix  mean
  = apply1_d  gsl_stats_variance_with_fixed_mean  m  mean;

sd_with_fixed_mean  m::matrix  mean
  = apply1_d  gsl_stats_sd_with_fixed_mean  m  mean;

absdev  m::matrix
  = apply1  gsl_stats_absdev  m  dmatrix;

absdev_m  m::matrix  mean
  = apply1_d  gsl_stats_absdev_m  m  mean;

skew  m::matrix
  = apply1  gsl_stats_skew  m  dmatrix;

skew_m_sd  m::matrix  mean  sd
  = apply1_dd  gsl_stats_skew_m_sd  m  mean  sd  if sd >= 0.0;

kurtosis  m::matrix
  = apply1  gsl_stats_kurtosis  m  dmatrix;

kurtosis_m_sd  m::matrix  mean  sd
  = apply1_dd  gsl_stats_kurtosis_m_sd  m  mean  sd  if sd >= 0.0;

lag1_autocorrelation  m::matrix
  = apply1  gsl_stats_lag1_autocorrelation  m  dmatrix;

lag1_autocorrelation_m  m::matrix  mean
  = apply1_d  gsl_stats_lag1_autocorrelation_m  m  mean;

covariance  m1::matrix  m2::matrix
  = apply2  gsl_stats_covariance  m1  m2;

covariance_m  m1::matrix  m2::matrix  mean1  mean2
  = apply2_dd  gsl_stats_covariance_m  m1  m2  mean1  mean2;

wmean  w::matrix  m::matrix
  = apply2  gsl_stats_wmean  w  m;

wvariance  w::matrix  m::matrix
  = apply2  gsl_stats_wvariance  w  m;

wvariance_m  w::matrix  m::matrix  mean
  = apply2_d  gsl_stats_wvariance_m  w  m  mean;

wsd  weights::matrix  m::matrix
  = apply2  gsl_stats_wsd  weights  m;

wsd_m  weights::matrix  m::matrix  weighted_mean
  = apply2_d  gsl_stats_wsd_m weights  m  weighted_mean;

wvariance_with_fixed_mean  weights::matrix  m::matrix  mean
  = apply2_d  gsl_stats_wvariance_with_fixed_mean  weights  m  mean;

wsd_with_fixed_mean  weights::matrix  m::matrix  mean
  = apply2_d  gsl_stats_wsd_with_fixed_mean  weights  m  mean;

wabsdev  weights::matrix  m::matrix
  = apply2  gsl_stats_wabsdev  weights  m;

wskew  weights::matrix  m::matrix
  = apply2  gsl_stats_wskew  weights  m;

wskew_m_sd  weights::matrix  m::matrix  mean  sd
  = apply2_dd  gsl_stats_wskew_m_sd  weights  m  mean  sd if sd >= 0.0;

wkurtosis  weights::matrix  m::matrix
  = apply2  gsl_stats_wkurtosis  weights  m;

wkurtosis_m_sd  weights::matrix  m::matrix mean sd
  = apply2_dd  gsl_stats_wkurtosis_m_sd  weights  m  mean  sd  if sd >= 0.0;

max  m::matrix
  = apply1  gsl_stats_int_max  m  imatrix  if imatrixp m;
  = apply1  gsl_stats_max  m  dmatrix  if dmatrixp m;

min  m::matrix
  = apply1  gsl_stats_int_min  m  imatrix  if imatrixp m;
  = apply1  gsl_stats_min  m  dmatrix  if dmatrixp m;

minmax  m::matrix
  = case matrix_type m of
      1 = gsl_stats_minmax (pointer x) (pointer y) (pointer m)  1  (#m)
          $$ (x!0, y!0)
          when
            x, y = {0.0}, {0.0};
          end;
      3 = gsl_stats_int_minmax (pointer x) (pointer y)  pointer m)  1  (#m)
          $$ (x!0, y!0)
          when
            x, y = {0}, {0};
          end;
      _ = quote (gsl_stats::minmax  m);
    end;

min_index  m::matrix
  = apply1  gsl_stats_int_min_index  m  imatrix  if imatrixp m;
  = apply1  gsl_stats_min_index  m  dmatrix  if dmatrixp m;
  
max_index  m::matrix
  = apply1  gsl_stats_int_max_index  m  imatrix  if imatrixp m;
  = apply1  gsl_stats_max_index  m  dmatrix  if dmatrixp m;

minmax_index  m::matrix
  = case matrix_type m of
      1 = gsl_stats_minmax_index (pointer x) (pointer y) (pointer m)  1  (#m)
          $$ (x!0, y!0);
      3 = gsl_stats_int_minmax_index (pointer x) (pointer y) (pointer m)  1 (#m)
          $$ (x!0, y!0);
      _ = quote (gsl_stats::minmax_index  m);
    end
    when
      x, y = {0}, {0};
    end;

correlation  m1::matrix  m2::matrix
  = apply2  gsl_stats_correlation  m1  m2;

median_from_sorted_data  m::matrix
  = apply1  gsl_stats_median_from_sorted_data  m  dmatrix;

quantile_from_sorted_data  m::matrix  f::double
  = apply1_d  gsl_stats_quantile_from_sorted_data  m  f
    if f >= 0.0 && f <= 1.0;
