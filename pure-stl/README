/* README - readme file for pure-stlvec.pure and related modules

   Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>

   DRAFT FOR DISCUSSION PURPOSES ONLY.


*/


===========
Pure-Stlvec
===========

.. default-domain:: pure
.. module:: stlvec

Version @version@, |today|

| Peter Summerland <p.summerland@gmail.com>
| Albert Graef <Dr.Graef@t-online.de>

This document describes **Stlvec**, an interface to The C++ Standard Template
Library's vector for the Pure_ programming language.

.. _Pure: http://pure-lang.googlecode.com

.. contents::
.. sectnum::

Introduction
============

The C++ Standard Template Library ("STL") is a library of generic containers
(data structures designed for storing other objects) and generic algorithms
that operate on the them. (http://www.cplusplus.com/reference/stl/)

One of the most useful of the containers is STL vector, which holds a
sequence of objects that can be accessed in constant time according to their
position in the sequence.

Pure-Stlvec is a collection of modules that provide an interface to STL
vectors (specialized to hold Pure expressions) and most of the STL algorithms
that apply to them. On the Pure side, the STL vectors are referred to as
"stlvecs".  The stlvec module provides basic functions, such as those that
create stlvecs and access their members. The other modules, sv_modifying,
sv_nonmodifying, sv_sort, sv_merge, sv_heap, sv_minmax and sv_numeric provide
access to the STL algorithms. This grouping of the STL algorithms follows that
found at http://www.cplusplus.com/reference/algorithm/. This web page contains
a table that summarizes of all of the algorithms in one place.

For the sake of brevity and understandability, the descriptions provided here
are simplified and incomplete. users are encouraged to refer to the STL
documentation for their STL implemenation. A good book on STL is STL Tutorial
and Reference Guide, Second Edition, by David R. Musser, Gillmer J. Derge and
Atul Saini. That said, it must be noted that the Pure-Stlvec functions are not
guaranteed to have the same behavior as the corresponding functions in the
STL. In particular, the Pure-Stlvec versions sometimes check for indexing
errors and range_overflow errors where their STL counterparts might not.

Access to Members and Ranges
============================

In the Pure-Stlvec documentation, the member of a stlvec that is at the nth
position in the sequence of expressions stored in the stlvec is referred to as
its nth member. The nth member of a stlvec, sv, is sometimes denoted by sv!n.
The sequence of members of sv starting at position i up to but not including j
is denoted by sv[i,j). There is a "past-the-end" symbol, svend, that denotes
the position after that occupied by the last member contained by a stlvec.

For example, if sv contains the sequence "a", "b", "c" "d" and "e", sv!0 is
"a", sv[1,3) is the sequence consisting of "b" followed by "c" and v[3,svend)
denotes the sequence consisting of "d" followed by "e".

Iterators and Ranges
--------------------

It is helpful to have a basic understandering of how the STL accesses members
and "ranges" of members of a STL container. Generally this is accomplished
using "iterators", which may be thought of as pointers to slots maintained by
STL containers for holding their members. Iterator's can be used to traverse a
containers objects. Each type of container has its own custom iterators.

A pair of iterators pointing into a single container can be used to specify a
"range" of the container's members. By convention, the range includes the
members in slots pointed to by the first iterator and all succeeding slots up
to but not including the slot pointed to by the second iterator. If iter1 and
iter2 are such a pair, the corresponding range is ofter referred to as [iter1,
iter2). Each container has a past-the-end iterator that can be used to
specifiy ranges that include the its last member.

Througout Pure-Stlvec, iterators are designated on the Pure side of the
interface to the STL by "iterator tuples". These are tuples consist of the
name of a stlvec followed by one of more ints (including the predifined ints
stl::svbeg, stl::svend, stl::svback).

It illustrate how iterator tuples are used, assume that msv is a mutable
stlvec with an underlying STL vector, v. The STL stable_sort function, sorts
objects in the range [first, last) in the order imposed by comp:

  void stable_sort ( RandomAccessIterator first, RandomAccessIterator last,
                     Compare comp )

The corresponding Pure function, from the sv_sort module, looks like this:

   stable_sort (msv, first, last) comp

where msv is a mutable stlvec, and first and last are integers. The first
thing stable_sort does is create a pair of iterators that point to the first
and last positions in msv's underlying STL vector, v. Next it wraps the Pure
comp function in a C++ function object that, along with the two iterators can
be passed to t he C++ stable_sort function.

For convenience, (sv,stl::svbeg, stl::svend) can be written simply as
sv. Thus, if first were stl::svbeg (or 0), and last were stl::svend (or #msv,
the number of elements in msv), the last Pure call could be written:

   stable_sort msv comp

It should be noted that often the STL library provides a default version of
functions, which like stable_sort, use a comparator or other function provided
by the caller. For stable_sort the default version assumes that the "<"
operator can be used on the elements held by the container in question:

   void stable_sort ( RandomAccessIterator first, RandomAccessIterator last)

The Pure-Stlvec functions rarely, if ever, supply a default version. A typical
call to stable_sort would, therefore look like this:

  stable_sort msv (<);

but never like this:

  stable_sort msv;
 

Back Inserter Iterators
-----------------------

Many of the STL algorithms insert members into a target range desinated
by an iterator that points to the first member of the target range. E.g.,:: 

   > using sv_modifying;

   > let v1 = stlvec (0..2);

   > let v2 = stlvec ("a".."g");

   > stl::copy v1 (v3,2) $$ members v3;
   ["a","b",0,1,2,"f","g"]

Sometimes it is preferable to append the new items to the end of the target
container, rather than overwriting all or part or part of it. This can be
accomplished using a back inserter interator (stl::svback for
stlvecs). E.g.,::

   > let v3 = stlvec ("a".."g");

   > stl::copy v1 (v3,stl::svback) $$ members v3;
   ["a","b","c","d","e","f","g",0,1,2]

Parameter Naming Conventions
============================

In the descriptions of functions that follow, parameters names used in
function descriptions represent specific types of Pure objects:

sv         - stlvec (mutable or immutable)
imsv       - immutable stlvec
msv        - mutable stlvec
x          - an arbitrary Pure expression
xs         - a list of arbitrary Pure expression
i,j        - whole numbers used to designate indexes into a stlvec
f,m,l      - whole numbers (or other interator constant such as stl::svend) 
             designating the "first", "middle" or "last" iterators in a 
             stlvec iterator tuple
p          - a whole number (or other interator constant such as
             stl::svend or stl::svback) used in a two element
             iterator tuple (e.g., (sv,p))
(sv,p)     - an iterator tuple that will be mapped to an iterator that points
             to the pth position of sv's underlying STL vector, v, (or to a 
             back iterator on v if p is stl::svback
(sv,f,l)   - an iterator tuple that will be mapped to the pair of iterators
             that are designated by (sv,f) and (sv,l)
(sv,f,m,l) - an iterator tuple that will be mapped to the iterators that
             are designated by (sv,f), (sv,m) and (sv,l)
sv[f,l)    - the range of members beginning with that at (sv,f)  up 
             to but inot including that at (con,l)
comp       - a function that accepts two objects and returns true if the
             first argument is less than the second (in the strict
             weak ordering defined by comp), and false otherwise
unary_pred - a function that accepts one object and returns true or false
bin_pred   - a function that accepts two objects and returns true or false
unary_fun  - a function that accepts one objects ane returns another
bin_fun    - a function that accepts two objects ane returns another
gen_fun -    a function of one parameter that produces a sequence of objects,
             one for each call (gen_fun 0). E.g., see test_generate in
             ut_sv_modifying.pure.

For readability, and to correspondence with the STL documentation, the words
"first", "middle", and "last", or varients such as "first1" are often used
instead of f,m,l.

STL Vector as Container
=======================

STL Vectors can be used a simple containers with elements indexed by integers
without resorting to all of the fancy STL algorithms that apply to them.
Support for STL Vectors as containers is provided by the stlvec module. The
functions provided by this module have names that are similar to those of the
corresponding functions that operate on Pure arrays. I.e., Pure naming
conventions are followed rather than STL naming conventions. As is the case
for the Pure Library containers, these functions are in the global
namespace. (In contrast, functions provided by the modules that access the STL
algorithms are in the stl namespace, and have the same names as their
corresponding function in the STL.)

Imports
-------

To use the operations of this module, add the following import declaration
to your program::

  using stlvec;

Constructors and Types
----------------------

Currently, access to the STL vector is accomplished through a constructor
of the form (STLVEC x) or (CONST_STLVEC x), where x is a pointer to
the underlying STL vector. E.g.,::

   > let v1 = stlvec (0..3); v1;
   STLVEC #<pointer 0x915c8e0>

   > members v1;
   [0,1,2,3]

   > let v2 = stlconst $ stlvec (0..3); v2;
   CONST_STLVEC #<pointer 0x8c1dbf0>

This representation may change in the future, and must not be relied upon
by client modules. In particular, one must never attempt to use the
embedded pointer directly.

Three type tags are provided:

.. type:: mutable_stlvec /type

   The type for a mutable stlvec. The stlvec must be contructed with
   STLVEC.

.. type:: const_stlvec /type

   The type for an immutable stlvec. The stlvec must be contructed with
   CONST_STLVEC.

.. type:: stlvec /type

   The type for a stlvec, mutable or immutable. The stvec can be constructed
   with STLVEC or CONST_STLVEC.

Support for Immutable Stlvecs
-----------------------------

Functions in the Pure STL module that modify a stlvec passed as input will
simply fail unless the stlvec is mutable::

   > update v2 0 100;
   update (CONST_STLVEC #<pointer 0x9f07690>) 0 100

Functions that modify a stlvec passed as input should use the
mutable_stlvec type tag. e.g::

   > put0 v::mutable_stlvec x = update v 0 x; 

   > put0 v1 42 $$ v1!0;
   42

   > put0 v2 42;
   put0 (CONST_STLVEC #<pointer 0x8c1dbf0>) 42

Operations
----------

When reading the function descriptions that follow, please bear in mind
that whenever a function is passed an iterator tuple of the from (sv,first,
last), first and last can be dropped, leaving (sv), or simply sv. The
function will treat the "unary" iterator tuple (sv) as (sv, stl::svbeg,
stl::svend).

.. function:: emptystlvec

   return an empty stlvec

.. function:: stlvec (sv,first,last) 

   create a new stlvec whose members include sv's members from first up
   to but not including last. If first and last are omitted, default values
   of 0 and #sv (number of members contained by sv) are assumed.

.. function:: stlvec xs

   create a new stlvec from a list of values.

.. function:: mkstlvec x n::int

.. function:: stlconst sv

   create an immutable stlvec that shares the same underlying STL vector
   with sv. Typically, a new locally scoped mutable stlvec is created and
   modified inside a client function which then uses stlconst to produce an
   immutable version of the stlvec which it returns to its caller. Assuming
   the local the mutable version is not returned, it will be to be garbage
   collected. This process is fast because it does not involve any copying
   of the underlying STL vector.

 .. function:: prefix #  sv

    return the size of ``sv``

 .. function:: reserve msv i::int

   reserve slots in the underlying STL vector in preparation for the
   addition of new members. This is not required before adding new
   members.

.. function:: capacity sv

   return the total amount of slots held by the underlying STL vector 

.. function:: null sv

   test whether ``sv`` is empty

.. function infix ! sv i

   return the ``i``\th member of ``sv``.

.. function:: first sv
   		 last sv

   first and last member of ``sv``

.. function::members (sv, first, last)

   return a list of values stored in ``sv``[first,last)

.. function:: update msv i x

   replace the ``i``\ th member of ``msv`` by ``x``

.. function:: append sv x

   append ``x`` to the end of ``sv``

.. function:: insert (msv,p) xs
              insert (msv,p) (sv,first,last)

   insert members of the list ``xs`` or the range ``sv``[``first``,
   ``last``) into ``msv``, all preceeding the pth member of msv. Members
   are shifted to make room for the inserted members.

.. function:: rmfirst msv
              rmlast msv

   remove first and last member from ``msv``

.. function:: erase (msv,first,last)
              erase (msv,p)
              erase msv

   remove msv[first,last), msv[p,p+1) or all of msv fromm msv. 

.. function:: clear msv i

   remove all of ``msv's`` members     

.. function:: all_equal comp (sv1, first1, last1) (sv2, first2, last2) 

   returns true if comp x y == true for all corresponding members of
   sv1[first1, last1) and sv1[first1, last1).

.. function:: infix == sv1 sv2
              infix ~= sv1 sv2 

   (x ``==`` y) is the same as equal (==) x y. (x ``~=`` y is simply ~(equal
   (==) x y). Note that this is not defined for iterator tuples. (The rule
   would never be executed because == is defined on tuples in the Prelude).

Convenience Functions
---------------------

The stlvec module provides convenience functions that apply map, catmap,
foldl, etc, to directly access Pure expressions stored in a stlvec.

.. function::listmap unary_fun (sv, first, last)

   one pass equivalent of map unary_fun $ members (sv, first, last)

.. function::listcatmap unary_fun (sv, first, last)

   one pass equivalent of catmap unary_fun $ members (sv, first, last)

.. function::do unary_fun (sv, first, last)

   one pass equivalent of do unary_fun $ members (sv, first, last)

.. function::foldl bin_fun x (sv, first, last)

   one pass equivalent of foldx bin_fun x $ members (sv, first, last)

.. function::foldl1 bin_fun (sv, first, last)

   one pass equivalent of foldx bin_fun $ members (sv, first, last)

.. function::listfilter unary_pred (sv, first, last)

   one pass equivalent of filter unary_pred $ members (sv, first, last)

Please note that "stlvec to stlvec" functions are provided by the Pure STL
algorithm modules. Thus, for example, the stlvec module does not provide a
function that maps one stlvec onto a new stlvec. That functionality, and
more, is provided by stl::transform, which can be found in the sv_modifying
module.

Examples
--------

   > using stlvec;

   > let v1 = mkstlvec "x" 10; members v1;
   STLVEC #<pointer 0xa17af00>
   ["x","x","x","x","x","x","x","x","x","x"]

   > update v1 1 1; members v1;
   STLVEC #<pointer 0xa17af00>
   ["x",1,"x","x","x","x","x","x","x","x"]

   > append v1 10; members v1;
   STLVEC #<pointer 0xa17af00>
   ["x",1,"x","x","x","x","x","x","x","x",10]

   > v1!10;
   10

   > rmfirst v1 $$ members v1;
   [1,"x","x","x","x","x","x","x","x",10]

   > erase (v1,9) $$ members v1;
   [1,"x","x","x","x","x","x","x","x"]

   > erase (v1,1,5) $$ members v1;
   [1,"x","x","x","x"]

   > insert (v1,2) (2..4) $$ members v1;
   [1,"x",2,3,4,"x","x","x"]

   > let v2 = stlvec (0..10);  members v2;
   [0,1,2,3,4,5,6,7,8,9,10]

   > listmap (+10) v2;
   [10,11,12,13,14,15,16,17,18,19,20]

   > listcatmap (\x->if x mod 2 then [x] else []) v2;
   [1,3,5,7,9]

   > foldl (+) 0 v2;
   55

STL Nonmodifying Algorithms
===========================

The sv_nonmodifying.pure module provides an interface to the STL's
non-modifying sequence operations.

Imports
-------

To use the operations of this module, add the following import declaration
to your program::

  using sv_nonmodifying;

All of the functions are in the stl namespace. 

Operations
----------

See parameter naming conventions at ..

.. function:: for_each (sv, first, last) unary_fun

   Applies unary_fun to each of the elements in sv[first,last).

.. function:: find (sv, first, last) x

   Returns the position of the first element in sv[first,last) for which
   (==x) is true (or svend if not found).

.. function:: find_if (sv, first, last) unary_pred

   Returns the position of the first element in sv[first,last) for which
   unary_pred is true (or svend if not found).

.. function:: find_first_of (sv1, first1, last1) (sv2, first2, last2) bin_pred 

   Returns the position of the first element, x, in sv1[first1,last1) for
   which there exists y in sv2[first2,last2) and (bin_pred x y) is true (or
   svend if no such x exist).

.. function:: adjacent_find (sv, first, last) bin_pred

   Search sv[first,last) for the first occurrence of two consecutive elements
   (x,y) for which (bin_pred x y) is true. Returns the position of x, if
   found, or svend if not found).

.. function:: count (sv, first, last) x

   Returns the number of elements in the range sv[first,last) for which (x==)
   is true.

.. function:: count_if (sv, first, last) unary_pred

   Returns the number of elements in the range sv[first,last) for which
   unary_pred is true.

.. function:: mismatch (sv1, first1, last1) (sv2, first2) bin_pred 

   Applies (bin_pred x y) sequentially, where x is from sv1[first1,last1) and
   y is from the range beginning at first2 until it finds the first pair x1,
   y1 such that (bin_pred x_i y_j) is false or reaches the end of the
   sequences (if any). If it finds a mismatch, it returns (i,j) where i and j
   are the positions of x_i and y_i. Otherwise, the function returns a (svend,
   first2 + last1 -first1) or (svend, svend).

.. function:: equal (sv1, first1, last1) (sv2, first2) bin_pred 

   Uses bin_pred to compare the elements in the sv[first1,last1) with those in
   the range beginning at (sv2,first2), and returns true if the elements in
   both ranges are considered equal.

.. function:: search (sv1, first1, last1) (sv2, first2) bin_pred 

   Using bin_pred to determine equality of the elements, searches
   sv1[first1,last1) for the first occurrence of the sequence defined by
   sv2[first2,last2), and returns the position in sv1 of its first element (or
   svend if not found).

.. function:: search_n (sv, first, last) count x bin_pred 

   Using bin_pred to determine equality of the elements, searches
   sv[first,last) for a succession of count elements equal x. If the
   succession of count elements is found, returns the position of the first
   of its elements. Otherwise, returns svend.

.. function:: find_end (sv1, first1, last1) (sv2, first2, last2) bin_pred

   Searches sv1[first1,last1) for the last occurrence of sv2[first2,last2),
   using bin_pred to determine equality of elements. Returns the position of
   first element in sv1 of the occurrence (or svend if not found).

Examples
--------

See ut_sv_nonmodifying.pure


STL Modifying Algorithms
========================

The sv_modifying.pure module provides an interface to the STL's modifying
sequence operations.

Imports
-------

To use the operations of this module, add the following import declaration
to your program::

  using sv_modifying;

All of the functions are in the stl namespace. 

Operations
----------

See parameter naming conventions at ..

.. function::copy (sv, first, last) (msv, p)

   Copies the elements in sv[first,last) into a range whose first element is
   (mvs,p). Note that p can be svback. An overflow exception is thrown if the
   target range cannot accomodate the copy.

.. function::copy_backward (sv,first,last) (msv,p)

   Copies the elements in sv[first,last), moving backward from (last-1), into
   a mvs[first2,p) where n is the number of elements in sv[first,last) and
   first2 = p - n.  Note that p cannot be svback. An overflow exception is
   thrown if the target range cannot accomodate the copy.

.. function:: swap_ranges (sv,first,last) (msv, p)

   Exchanges the elements in sv[first, last) with those at mvs[p, p+n)
   where n is last - first.

.. function transform (sv,first,last) (msv, p) unary_fun

   Applies unary_fun to the elements of sv[first,last) and places the
   resulting sequence in mvs[p, p+n) where n is last - first.  If sv is
   mutable, msv can be the same as sv. Returns (mvs,p+n);

.. function transform_2 (sv1,first1,last1) (sv2,first2) (msv, p) bin_fun

   Applies bin_fun to the elements of sv1[first1,last1) sv2[first2,n) and and
   places the resulting sequence in mvs[p, p+n) where n is last1 -
   first1. Returns (mvs,p+n).

.. function replace (msv,first,last) x y

   Same as replace_if (msv,first,last) (x==) y; 

.. function:: replace_if (msv,first,last) unary_pred x

   Replace all elements of msv[first,last) that satistfy unary_pred with x.   

.. function:: replace_copy (sv,first,last) (msv,p) x y 

   Same as replace (msv,first,last) x y except that the modified sequence is
   placed in msv[p,p+last-first). Note that p can be svback.

.. function:: replace_copy_if (sv,first,last) (msv,p) unary_pred x

   Same as replace_if except that the modified sequence is placed in
   msv[p,p+last-first). Note that p can be svback.

.. function fill (msv,first,last) x
   
   Replace all elements in msv[first,last) with x.

.. function:: fill_n (msv,first) n x

   Replace all elements in msv[first,first+n) with x.

.. function generate (msv,first,last) gen_fun

   Replace all elements in msv[first,last) with the sequence generated
   by successive calls to gen_fun.

.. function:: generate_n (msv,first) n gen_fun

   Replace all elements in msv[first,first+n) with the sequence generated by
   successive calls to gen_fen

.. function remove (msv,first,last) x

   Same as remove_if (msv,first,last) (==x).

.. function:: remove_if (msv,first,last) unary_pred

   Remove elements in msv[first,last) that do not satisfy unary_pred. If n
   elements satisfy unary_pred, they are moved to msv[first,first+n),
   preserving their relative order. The content of msv[first+n,svend) is
   undefined. Returns first+n. (If first+n is past the end, svend is
   subsituted for firs+n).

.. function:: remove_copy (sv,first,last) (msv,first) x

   Same as remove except that the purged sequence is copied to (msv,first) and
   sv[first,last) is not changed.

.. function:: remove_copy_if (sv,first,last) (msv,first) unary_pred

    Same as remove_if except that the purged sequence is copied to (msv,first)
    and sv[first,last) is not changed.

.. function unique (msv,first,last) bin_pred

   Eliminates consecutive duplicates from sv[first,last), using bin_pred to
   test for equality. The purged sequence is moved to sv[first,first+n)
   preserving their relative order where n is the size of the purged
   sequence. Returns first+n. (If first+n is past the end, svend is
   subsituted for firs+n).
   
.. function:: unique_copy (sv,first,last) (msv,first) bin_pred

   Same as unique except that the purged sequence is copied to (msv,first) and
   sv[first,last) is not changed.
   
.. function reverse (msv,first,last)

   Reverses the order of the elements in sv[first,last).

.. function:: reverse_copy (sv,first,last) (msv,first)

   Same as reverse except that the reversed sequence is copied to (msv,first)
   and sv[first,last) is not changed.

.. function rotate (msv,first,middle,last)

   Rotates the elemenst of msv[first,middle,last] so that middle becomes
   the first element of msv[first,last].

.. function:: rotate_copy (msv,first,middle,last) (msv,first)

   Same as reverse except that the rotated sequence is copied to (msv,first)
   and sv[first,last) is not changed.

.. function:: random_shuffle (msv,first,last)

   Randomly reorders the elements in msv[first,last).

.. function partition (msv,first,last) unary_pred

   Places all of the elements in msv[first,last) that satisfy unary_pred
   before those that don't. Returns middle, where msv [first,middle) contains
   all of the elements that satisfy unary_pre, and msv [middle, last).

.. function:: stable_partition (msv,first,last) unary_pred

   Same as partition except that the relative positions of the elements in
   each group are preserved.

Examples
--------

See ut_sv_modifying.pure


STL Sort Algorithms
===================

The sv_sort.pure module provides an interface to the STL's sorting and binary
search algorithms.

Imports
-------

To use the operations of this module, add the following import declaration
to your program::

  using sv_sort;

All of the functions are in the stl namespace. 

Operations
----------

See parameter naming conventions at ..

All of the functions in this module require the caller to supply an ordering
functions, comp (as for the Pure library sort function). The functions (<) and
(>) are commonly passed as comp.

.. function:: sort (msv, first, last) comp

   Sorts msv[first, last).

.. function:: stable_sort (msv, first, last) comp

   Sorts msv[first, last), preservint the relative order of equal members.

.. function:: partial_sort (msv, first, middle, last) comp

   Fills msv[first, middle) with the elements that would appear there if
   msv[first,last) were sorted. 

.. function:: partial_sort_copy (sv, first1, last1) (msv, first2, last2) comp

   Let n be the number of elements in sv[first1, last1) and r be the number of
   elements in msv[first2, last2). If r < n, partial_sort_copy fills
   msv[first2, last2) with the first r elements of what sv[first1, last1)
   would be if it had been sorted. If r >= n, it fills msv[first2, first2+n)
   with the elements of sv[first1, last1) in sorted order. The first stlvec,
   sv, is not modified. An overflow exception is thrown if the target range
   cannot accomodate the sorted elements.

.. function:: nth_element (msv, first, middle, last) comp

   Rearranges the elements of msv[first, last) as follows. Let n be middle -
   first, an x nth smallest element of msv[first, last). Sfter the function is
   called, sv!middle will be x. All of the elements of msv[first, middle) will
   be less than x and all of the elements of msv[middle+1, last) will be
   greater than x.

The next four functions assume that sv[first, last) is ordered by comp.

.. function:: lower_bound (sv, first, last) x comp

   Returns an integer p that such that (sv,p) is the first position into
   which x can be inserted into sv[first, last) while maintaining the sorted
   ordering.

.. function:: upper_bound (sv, first, last) x comp

   Returns an integer p that such that (sv,p) is the last position into
   which x can be inserted into sv[first, last) while maintaining the sorted
   ordering.

.. function:: equal_range (sv, first, last) x comp

   Returns a tuple, (lower, upper) where lower and upperf would have
   been returned by separate calls to lower_bound and upper_bound.

.. function:: binary_search (sv, first, last) x comp

   Returns true if x is an element of sv[first, last).

Examples
--------

See ut_sv_sort.pure


STL Merge Algorithms
====================

The sv_merge.pure module provides an interface to the STL's merge
algorithms. These algorithms operate on sorted ranges.

Imports
-------

To use the operations of this module, add the following import declaration
to your program::

  using sv_merge;

All of the functions are in the stl namespace. 

Operations
----------

All of the functions in this module require the caller to supply an ordering
functions, comp (as for the Pure library sort function). They only work
properly on input ranges that have been previously sorted using comp.

See parameter naming conventions at ..

.. function merge (sv1,first1,last1) (sv2,first2,last2) (msv,p) comp

   Merges the two sorted ranges into the range msv[p,p+n) where n is
   the total length of the merged sequence.

.. function::inplace_merge (msv,first, middle, last) comp

   Merges msv[first,middle) and msv[middle,last) into msv[first,last).

.. function::includes (sv1,first1,last1) (sv2,first2,last2) comp

   Returns true if every element of sv2[first2,last2) is an element
   of sv1[first1,last1).

.. function::set_union (sv1,first1,last1) (sv2,first2,last2) (msv,p) comp

   Places the sorted union of sv1[first1,last1) and sv2[first2,last2) into
   msv[p,p+n) where n is the number of elements in the sorted union. Returns
   the past-the-end position of the sorted union.

.. function::set_intersection (sv1,first1,last1) (sv2,first2,last2)
    (msv,p) comp

   Places the sorted intersection of sv1[first1,last1) and sv2[first2,last2)
   into msv[p,p+n) where n is the number of elements in the sorted
   intersection.  Returns the past-the-end position of the sorted
   intersection.

.. function::set_difference (sv1,first1,last1) (sv2,first2,last2)
    (msv,p) comp

   Places the sorted difference of sv1[first1,last1) and sv2[first2,last2)
   into msv[p,p+n) where n is the number of elements in the sorted difference.
   Returns the past-the-end position of the sorted difference.

.. function::set_symmetric_difference (sv1,first1,last1) 
   (sv2,first2,last2) (msv,p) comp

   Places the sorted symmetric_difference of sv1[first1,last1) and
   sv2[first2,last2) into msv[p,p+n) where n is the number of elements in the
   sorted symmetric_difference.  Returns the past-the-end position of the
   sorted symmetric_difference.

Examples
--------

See ut_sv_merge.pure

STL Heap Algorithms
===================

The sv_heap.pure module provides an interface to the STL's heap
operations.

Imports
-------

To use the operations of this module, add the following import declaration
to your program::

  using sv_heap;

All of the functions are in the stl namespace. 

Operations
----------

See parameter naming conventions at ..

All of the functions in this module require the caller to supply an ordering
functions, comp (as for the Pure library sort function). The functions (<) and
(>) are commonly passed as comp.

.. function:: make_heap (msv,first,last) comp
   
   Move elements of msv[first,last) so that they are a heap. After this
   msv!first will be the largest element in msv[first,last), and push_heap
   and pop_heap will work properly.

.. function:: push_heap (msv,first,last) comp

   Assumes msv[first,last-1) is a heap. Permutes elements in msv[first,last)
   so it will be a heap.

.. function:: pop_heap (msv,first,last) comp

   Assumes msv[first,last) is a heap. Swaps msv!first with msv!(last-1).
   Permutes elements in msv[first,last-1) so it will be a heap.

.. function:: sort_heap (msv,first,last) comp

   Assumes that msv[first,last) is a heap. Sorts the elements in
   msv[first,last).

Examples
--------

See ut_sv_heap.pure

Min/Max STL Algorithms
======================

The sv_minmax.pure module provides an interface to a few addional STL
algorithms.

Imports
-------

To use the operations of this module, add the following import declaration
to your program::

  using sv_minmax;

All of the functions are in the stl namespace. 

Operations
----------

See parameter naming conventions at ..

All of the functions in this module require the caller to supply an ordering
functions, comp (as for the Pure library sort function). The functions (<) and
(>) are commonly passed as comp.

.. function:: min_element

.. function:: max_element

.. function:: lexicographical_compare

.. function:: next_permutation

.. function:: prev_permutation

Examples
--------

See ut_sv_heap.pure


STL Numeric Algorithms
======================

The sv_numeric.pure module provides an interface to the STL's numeric
algorithms.

Imports
-------

To use the operations of this module, add the following import declaration
to your program::

  using sv_numeric;

All of the functions are in the stl namespace. 

Operations
----------

See parameter naming conventions at ..

.. function:: accumulate

.. function:: inner_product

.. function:: partial_sum

.. function:: adjacent_difference

Examples
--------

See ut_sv_numeric.pure

