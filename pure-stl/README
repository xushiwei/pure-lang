.. README - readme file for pure-stlvec

   Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>

   DRAFT FOR DISCUSSION PURPOSES ONLY.

===========
pure-stlvec
===========

.. default-domain:: pure
.. module:: stlvec

Version @version@, |today|

| Peter Summerland <p.summerland@gmail.com>
| Albert Graef <Dr.Graef@t-online.de>

Pure's interface to The C++ Standard Template Library's vector<expr*>

.. _Pure: http://pure-lang.googlecode.com

.. contents::
.. sectnum::

Introduction
============

The C++ Standard Template Library ("STL_") is a library of generic containers
(data structures designed for storing other objects) and a rich set of generic
algorithms that operate on them.

.. _STL http://www.cplusplus.com/reference/stl/

One of the most useful of the containers is STL's vector, a mutable container
that holds a sequence of objects that can be accessed in constant time
according to their position in the sequence. The stlvec module provides a Pure
container, "stlvec", that is essentially a pointer to a STL vector that has
been specialized to hold "smart pointers" to arbitrary Pure expressions. A set
of basic operations is provided for creating, accessing and modifying
stlvecs. These operations are similar in name and function to those provided
by the Pure Library for its containers. As is the case for their Pure Library
counterparts, these operations are in the global namespace.

The modules sv_modifying, sv_nonmodifying, sv_sort, sv_merge, sv_heap,
sv_minmax and sv_numeric provide functions that wrap the STL algorthms
(specialized to work on STL vectors of Pure expressions). This grouping of the
STL algorithms follows that found at
http://www.cplusplus.com/reference/algorithm/. This web page contains a table
that summarizes of all of the algorithms in one place. An "umbrella" module,
stlvec_algorithms, pulls in all of the STL algorithm interface modules in one
go. The algorithm wrapper functions reside in the stl namespace and have the
same names as their counterparts in the STL.

Copying
=======

| Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.
| Copyright (c) 2011 by Albert Graef <Dr.Graef@t-online.de>.

All rights reserved. pure-stlvec is distributed under a BSD-style license, see
the COPYING file for details.

Installation
============

Get the latest source from
http://pure-lang.googlecode.com/files/pure-stlvec-@version@.tar.gz.
 
To install Stlvec, extract the source, cd to the pure-stlvec directory, run
``make``, and then run ``sudo make install`` (on Linux). After that, you can
run ``make test`` to see if the installation worked. ``make`` tries to guess
your Pure installation directory and platform-specific setup. If it gets this
wrong, you can set some variables manually. In particular, ``make install
prefix=/usr`` sets the installation prefix. Please see the Makefile for
details.

Simple Examples
===============

Here are some examples that use the basic operations provided by the
stlvec module.

   > using stlvec;

   > let v1 = mkstlvec "x" 10 $$ members v1;
   ["x","x","x","x","x","x","x","x","x","x"]

   > update v1 1 1 $$ members v1;
   ["x",1,"x","x","x","x","x","x","x","x"]

   > append v1 10 $$ members v1;
   ["x",1,"x","x","x","x","x","x","x","x",10]

   > v1!10;
   10

   > rmfirst v1 $$ members v1;
   [1,"x","x","x","x","x","x","x","x",10]

   > erase (v1,9) $$ members v1;
   [1,"x","x","x","x","x","x","x","x"]

   > erase (v1,1,5) $$ members v1;
   [1,"x","x","x","x"]

   > insert (v1,2) (2..4) $$ members v1;
   [1,"x",2,3,4,"x","x","x"]

   > let v2 = stlvec (0..10) $$  members v2;
   [0,1,2,3,4,5,6,7,8,9,10]

   > listmap (+10) v2;
   [10,11,12,13,14,15,16,17,18,19,20]

   > listcatmap (\x->if x mod 2 then [x] else []) v2;
   [1,3,5,7,9]

   > foldl (+) 0 v2;
   55

Here are some examples using functions in the sv_sort module.

  [stable_sort, and one failed cond where sort would fail due to mixed elements]


Interface Conventions
=====================

Members and Sequences of Members
--------------------------------

Throughout the documentation for pure-stlvec, the member of a stlvec that is
at the nth position in the sequence of expressions stored in the stlvec is
referred to as its nth member. The nth member of a stlvec, sv, is sometimes
denoted by sv!n.  The sequence of members of sv starting at position i up to
but not including j is denoted by sv[i,j). There is a "past-the-end" symbol,
svend, that denotes the position after that occupied by the last member
contained by a stlvec.

For example, if sv contains the sequence "a", "b", "c" "d" and "e", sv!0 is
"a", sv[1,3) is the sequence consisting of "b" followed by "c" and v[3,svend)
denotes the sequence consisting of "d" followed by "e".

STL Iterators and Value Semantics
---------------------------------

The STL advocates a style of programming that is fundamentally different than
that offered by functional programming languages. 

In C++ STL user essentially accesses container elements by their physical
addresses by means of "iterators", which can be thought of as pointers to the
elements. Iterators are used to access specific elements and pairs of
interators are used to access "ranges" of elements. 

In the case of vectors there is an obvious correspondence between an iterator
that points to an element and the element's position (starting at zero) in the
vector.  pure-stlvec uses this correspondence to designate a stlvec's members
in a way that makes it relatively easy to see how pure-stlvec's functions are
acting on the stlvec's underlying STL vector by referencing the STL's
documentation. Thus, if sv is a stlvec, and j is an int, "update sv j x" uses
the STL to replace the element pointed to by the iterator for position j of
sv's underlying STL vector by a smart pointer to x. If, in addition, k is an
int, stl::sort (sv,j,k) (<) uses the STL to sort the elements in the range
designated by the "jth" and "kth" iterators for sv's underlying STL vector.

Another cornerstone of the STL has "value semantics", i.e., all of the STL
containers are mutable and if a container is copied, all of its elements are
copied. pure-stlvec deals with the STL's value semantics by introducing
mutable and nonmutable stlvecs, and by storing smart pointers to objects (with
cheap copies) rather than the actual objects.

Iterator Tuples
---------------

In C++, a pair of STL iterators pointing into a STL vector can be used to
specify a "range" of the STL vector's members. By convention, the range
includes the members in the slots pointed to by the first iterator and all
succeeding slots up to but not including the slot pointed to by the second
iterator. As mentioned, in the pure-stlvec documentation this sequence is
designated by [iter1, iter2). Each container has a past-the-end iterator that
can be used to specifiy ranges that include the its last member.

Functions provided by pure-stlvec that act on stlvecs are passed ints and
"iterator tuples" that can be translated to STL iterators rather than, say,
pointers to STL iterators. Iterator tuples consist of the name of a stlvec
followed by one of more ints (including the predifined ints stl::svbeg,
stl::svend, stl::svback).

It illustrate how iterator tuples are used, assume that msv is a mutable
stlvec with an underlying STL vector, v. The STL stable_sort function, sorts
objects in the range [first, last) in the order imposed by comp:

  void stable_sort ( RandomAccessIterator first, RandomAccessIterator last,
                     Compare comp )

The corresponding Pure function, from the sv_sort module, looks like this:

   stable_sort (msv, first, last) comp

where msv is a mutable stlvec, and first and last are integers. The first
thing the pure-stlvec stable_sort wrapper does is create a pair of iterators
that point to the first and last positions in msv's underlying STL vector,
v. Next it wraps the Pure comp function in a C++ function object that, along
with the two iterators can be passed to t he C++ stable_sort function.

For convenience, (sv,stl::svbeg, stl::svend) can be written simply as
sv. Thus, if first were stl::svbeg (or 0), and last were stl::svend (or #msv,
the number of elements in msv), the last Pure call could be written:

   stable_sort msv comp

It should be noted that often the STL library provides a default version of
functions, which like stable_sort, use a comparator or other callback function
provided by the caller. For stable_sort the default version assumes that the
"<" operator can be used on the elements held by the container in question:

   void stable_sort ( RandomAccessIterator first, RandomAccessIterator last)

The pure-stlvec modules rarely, if ever, supply a default version. A typical
example is pure-stlvec's stable_sort which must be called with a comparator
callback function:

  stable_sort msv (<);

Note also that the comparator (e.g., (<)), or other function being passed to a
pure-stlvec algorithm function is almost always the last parameter. This
is the opposite of what is required for similar Pure functions, but is
consistent with the STL calling conventions.

Back Inserter Iterators
-----------------------

Many of the STL algorithms insert members into a target range designated by an
iterator that points to the first member of the target range. Consistent with
raw C usage, it is ok to copy over existing elements the target
stlvec. E.g.,::

   > using sv_modifying;

   > let v1 = stlvec (0..2);

   > let v2 = stlvec ("a".."g");

   > stl::copy v1 (v3,2) $$ members v3;
   ["a","b",0,1,2,"f","g"]

This is great for C++ programmers (really), but for Pure programmers it is
almost always preferable to append the copied items to the end of the target
stlvec, rather than overwriting all or part or part of it. This can be
accomplished using the past-end-symbol, stl::svback. E.g.,::

   > let v3 = stlvec ("a".."g");

   > stl::copy v1 (v3,stl::svback) $$ members v3;
   ["a","b","c","d","e","f","g",0,1,2]

In short, when a pure-stlvec function detects the past-end-symbol in a target
iterator tuple, it constructs a STL "back inserter iterator" and passes it on
to the STL function.

Documentation Detail
--------------------

The documentation of the functions provided by the stlvec module are
reasonably complete.  In contrast, the descriptions of functions provided in
the STL algorithm modules are purposely simplified (and may not, therefore, be
technically accurate). This reflects that fact that the functions provided by
Stlvec have an obvious correspondence to the functions provided by the STL,
and the STL is extremely well documented. Furthermore, using the Pure
interpreter, it is very easy to simply play around with with any of the Stlvec
functions if there are doubts, especially with respect to "corner cases."
Often this leads to a deeper understanding compared to reading a precise
technical description.

A good book on STL is STL Tutorial and Reference Guide, Second Edition, by
David R. Musser, Gillmer J. Derge and Atul Saini. The web pages cited above
also provide excellent documentation.

Parameter Names
---------------

In the descriptions of functions that follow, parameters names used in
function descriptions represent specific types of Pure objects:

sv
  stlvec (mutable or immutable)

imsv
  immutable stlvec

msv
  mutable stlvec

x
  an arbitrary Pure expression

xs
  a list of arbitrary Pure expressions

i,j
  whole numbers used to designate indexes into a stlvec

f,m,l
  whole numbers (or other interator constant such as stl::svend)
  designating the "first", "middle" or "last" iterators in a
  stlvec iterator tuple

p
  a whole number (or other interator constant such as
  stl::svend or stl::svback) used in a two element
  iterator tuple (e.g., (sv,p))

(sv,p)
  an iterator tuple that will be mapped to an iterator that points
  to the pth position of sv's underlying STL vector, v, (or to a
  back iterator on v if p is stl::svback

(sv,f,l)
  an iterator tuple that will be mapped to the pair of iterators
  that are designated by (sv,f) and (sv,l)

(sv,f,m,l)
  an iterator tuple that will be mapped to the iterators that
  are designated by (sv,f), (sv,m) and (sv,l)

sv[f,l)
  the range of members beginning with that at (sv,f)  up
  to but inot including that at (con,l)

comp
  a function that accepts two objects and returns true if the
  first argument is less than the second (in the strict
  weak ordering defined by comp), and false otherwise

unary_pred
  a function that accepts one object and returns true or false

bin_pred
  a function that accepts two objects and returns true or false

unary_fun
  a function that accepts one objects ane returns another

bin_fun
  a function that accepts two objects ane returns another

gen_fun
  a function of one parameter that produces a sequence of objects,
  one for each call (gen_fun 0). E.g., see test_generate in
  ut_sv_modifying.pure.

For readability, and to correspond with the STL documentation, the words
"first", "middle", and "last", or varients such as "first1" are often used
instead of f,m,l.

Error Handling
==============

The functions provided this module handle errors by throwing exceptions.

Exception Symbols
-----------------

    .. constructor:: bad_argument

    This exception is thrown when a function is passed an unexpected value. A
    subtle error to watch for is a malformed iterator tuple (e.g., one with
    the wrong number of elements).

    .. constructor:: bad_function

    This exception is thrown when a purported Pure call-back function is not
    even callable.

    .. constructor:: failed_cond

    This exception is thrown when a Pure call-back predicate returns a value
    other than and int.

    .. constructor:: out_of_bounds

    This exception is thrown if the specified index is out of bounds.

    .. constructor:: range_overflow                 
 
    This exception is thrown by algorithm functions that write over part of a
    target stlvec (e.g., copy) when the target range too small to accomdate
    the result.

   .. constructor:: range_overlap 

    This exception is thrown by algorithm functions that write over part of a
    target stlvec when the target and source ranges overlap in a way that is
    not allowed.

In addition, any exception thrown by a Pure callback function, say cbf, will
be caught and be rethrown by the function that called with cbf as a parameter.

Examples
--------

    > using stlvec, sv_modifying;
    > let sv1 = stlvec (0..4); members sv1;
    [0,1,2,3,4]

    > let sv2 = stlvec ("a".."e"); members sv2;
    ["a","b","c","d","e"]

    > sv1!10;
    <stdin>, line 25: unhandled exception 'out_of_bounds' ...

    > stl::copy sv1 (sv2,10);
    <stdin>, line 26: unhandled exception 'out_of_bounds' ...

    > stl::copy sv1 (sv2,2,3); // sb (sv2,pos)
    <stdin>, line 22: unhandled exception 'bad_argument' 

    > stl::copy sv1 (sv2,2);
    <stdin>, line 23: unhandled exception 'range_overflow' ...

    > stl::copy sv2 (sv2,2);
    <stdin>, line 24: unhandled exception 'range_overlap'

    > stl::copy (sv1,1,3) (sv2,0); members sv2; // ok
    2
    [1,2,"c","d","e"]

    > stl::sort sv2 (>); // apples and oranges 
    <stdin>, line 31: unhandled exception 'failed_cond'

    > listmap (\x->throw doa) sv1; // callback function throws exception
    <stdin>, line 34: unhandled exception 'doa' ,,,

Circular References
-------------------

Warn re circular refs. They are not detected. Can be a problem with mutable
structures. Should never be a problem if plain old immutable Pure objects are
inserted in a stlvec.

The stlvec Module
=================

The stlvec module provides basic functions for accessing and modifying
stlvecs. They are all in the global namespace.

Imports
-------

To use the operations of this module, add the following import declaration
to your program::

  using stlvec;

Constructors and Types
----------------------

Currently, access to the STL vector is accomplished through a constructor
of the form (STLVEC x) or (CONST_STLVEC x), where x is a pointer to
the underlying STL vector. E.g.,::

   > let v1 = stlvec (0..3); v1;
   STLVEC #<pointer 0x915c8e0>

   > members v1;
   [0,1,2,3]

   > let v2 = stlconst $ stlvec (0..3); v2;
   CONST_STLVEC #<pointer 0x8c1dbf0>

This representation may change in the future, and must not be relied upon
by client modules. In particular, one must never attempt to use the
embedded pointer directly.

Functions in the Pure STL module that modify a stlvec passed as input will
simply fail unless the stlvec is mutable::

   > update v2 0 100;
   update (CONST_STLVEC #<pointer 0x9f07690>) 0 100

Three type tags are provided:

.. type:: mutable_stlvec /type

   The type for a mutable stlvec. The stlvec must be contructed with
   STLVEC.

.. type:: const_stlvec /type

   The type for an immutable stlvec. The stlvec must be contructed with
   CONST_STLVEC.

.. type:: stlvec /type

   The type for a stlvec, mutable or immutable. The stvec can be constructed
   with STLVEC or CONST_STLVEC.

Support for Copy-On-Write Semmantics
------------------------------------

Using a copy-on-write strategy it is possible to use stlvec's in a
manner that is consistent with a functional programming style.

The functions that create new stlvecs (emptystlvec, stlvec, and mkstlvec)
return a mutable stlvec. The key to the copy-on-write strategy is the stlconst
function which converts a mutable stlvec can be converted to an immutable
stlvec, without changing the underlying STL vector.

Typically, a pure function that modifies stlvec as an argument will copy the
input stlvec to a new locally scoped mutable stlvec, modify the new stovec and
use stlconst to make the new stlvec immutable which is then returned. It
should be noted that many of the STL algorithms take an input STL vector and
produce a sequence elements that is placed in a separate STL vector, which can
eliminate the need to copy the input stlvec.

Operations
----------

When reading the function descriptions that follow, please bear in mind
that whenever a function is passed an iterator tuple of the from (sv,first,
last), first and last can be dropped, leaving (sv), or simply sv. The
function will treat the "unary" iterator tuple (sv) as (sv, stl::svbeg,
stl::svend).

.. function:: emptystlvec

   return an empty stlvec

.. function:: stlvec (sv,first,last)

   create a new stlvec whose members include sv's members from first up
   to but not including last. If first and last are omitted, default values
   of 0 and #sv (number of members contained by sv) are assumed.

.. function:: stlvec xs

   create a new stlvec from a list of values.

.. function:: mkstlvec x n::int

.. function:: stlconst sv

   create an immutable stlvec that shares the same underlying STL vector
   with sv.

 .. function:: prefix #  sv

    return the size of ``sv``

 .. function:: reserve msv i::int

   reserve slots in the underlying STL vector in preparation for the
   addition of new members. This is not required before adding new
   members.

.. function:: capacity sv

   return the total amount of slots held by the underlying STL vector

.. function:: null sv

   test whether ``sv`` is empty

.. function infix ! sv i

   return the ``i``\th member of ``sv``.

.. function:: first sv
              last sv

   first and last member of ``sv``

.. function::members (sv, first, last)

   return a list of values stored in ``sv``[first,last)

.. function:: update msv i x

   replace the ``i``\ th member of ``msv`` by ``x``

.. function:: append sv x

   append ``x`` to the end of ``sv``

.. function:: insert (msv,p) xs
              insert (msv,p) (sv,first,last)

   insert members of the list ``xs`` or the range ``sv``[``first``,
   ``last``) into ``msv``, all preceeding the pth member of msv. Members
   are shifted to make room for the inserted members.

.. function:: rmfirst msv
              rmlast msv

   remove first and last member from ``msv``

.. function:: erase (msv,first,last)
              erase (msv,p)
              erase msv

   remove msv[first,last), msv[p,p+1) or all of msv fromm msv.

.. function:: clear msv i

   remove all of ``msv's`` members

.. function:: all_equal comp (sv1, first1, last1) (sv2, first2, last2)

   returns true if comp x y == true for all corresponding members of
   sv1[first1, last1) and sv1[first1, last1).

.. function:: infix == sv1 sv2
              infix ~= sv1 sv2

   (x ``==`` y) is the same as equal (==) x y. (x ``~=`` y is simply ~(equal
   (==) x y). Note that this is not defined for iterator tuples. (The rule
   would never be executed because == is defined on tuples in the Prelude).

Convenience Functions
---------------------

The stlvec module provides convenience functions that apply map, catmap,
foldl, etc, to directly access Pure expressions stored in a stlvec.

.. function::listmap unary_fun (sv, first, last)

   one pass equivalent of map unary_fun $ members (sv, first, last)

.. function::listcatmap unary_fun (sv, first, last)

   one pass equivalent of catmap unary_fun $ members (sv, first, last)

.. function::do unary_fun (sv, first, last)

   one pass equivalent of do unary_fun $ members (sv, first, last)

.. function::foldl bin_fun x (sv, first, last)

   one pass equivalent of foldx bin_fun x $ members (sv, first, last)

.. function::foldl1 bin_fun (sv, first, last)

   one pass equivalent of foldx bin_fun $ members (sv, first, last)

.. function::listfilter unary_pred (sv, first, last)

   one pass equivalent of filter unary_pred $ members (sv, first, last)

Please note that "stlvec to stlvec" functions are provided by the Pure STL
algorithm modules. Thus, for example, the stlvec module does not provide a
function that maps one stlvec onto a new stlvec. That functionality, and
more, is provided by stl::transform, which can be found in the sv_modifying
module.

Examples
--------

See ut_stvec in the ut subfolder.

The sv_nonmodifying Module
==========================

The sv_nonmodifying.pure module provides an interface to the STL's
non-modifying sequence operations.

Imports
-------

To use the operations of this module, add the following import declaration
to your program::

  using sv_nonmodifying;

All of the functions are in the stl namespace.

Operations
----------

.. function:: for_each (sv, first, last) unary_fun

   Applies unary_fun to each of the elements in sv[first,last).

.. function:: find (sv, first, last) x

   Returns the position of the first element in sv[first,last) for which
   (==x) is true (or svend if not found).

.. function:: find_if (sv, first, last) unary_pred

   Returns the position of the first element in sv[first,last) for which
   unary_pred is true (or svend if not found).

.. function:: find_first_of (sv1, first1, last1) (sv2, first2, last2) bin_pred

   Returns the position of the first element, x, in sv1[first1,last1) for
   which there exists y in sv2[first2,last2) and (bin_pred x y) is true (or
   svend if no such x exist).

.. function:: adjacent_find (sv, first, last) bin_pred

   Search sv[first,last) for the first occurrence of two consecutive elements
   (x,y) for which (bin_pred x y) is true. Returns the position of x, if
   found, or svend if not found).

.. function:: count (sv, first, last) x

   Returns the number of elements in the range sv[first,last) for which (x==)
   is true.

.. function:: count_if (sv, first, last) unary_pred

   Returns the number of elements in the range sv[first,last) for which
   unary_pred is true.

.. function:: mismatch (sv1, first1, last1) (sv2, first2) bin_pred

   Applies (bin_pred x y) sequentially, where x is from sv1[first1,last1) and
   y is from the range beginning at first2 until it finds the first pair x1,
   y1 such that (bin_pred x_i y_j) is false or reaches the end of the
   sequences (if any). If it finds a mismatch, it returns (i,j) where i and j
   are the positions of x_i and y_i. Otherwise, the function returns a (svend,
   first2 + last1 -first1) or (svend, svend).

.. function:: equal (sv1, first1, last1) (sv2, first2) bin_pred

   Uses bin_pred to compare the elements in the sv[first1,last1) with those in
   the range beginning at (sv2,first2), and returns true if the elements in
   both ranges are considered equal.

.. function:: search (sv1, first1, last1) (sv2, first2) bin_pred

   Using bin_pred to determine equality of the elements, searches
   sv1[first1,last1) for the first occurrence of the sequence defined by
   sv2[first2,last2), and returns the position in sv1 of its first element (or
   svend if not found).

.. function:: search_n (sv, first, last) count x bin_pred

   Using bin_pred to determine equality of the elements, searches
   sv[first,last) for a succession of count elements equal x. If the
   succession of count elements is found, returns the position of the first
   of its elements. Otherwise, returns svend.

.. function:: find_end (sv1, first1, last1) (sv2, first2, last2) bin_pred

   Searches sv1[first1,last1) for the last occurrence of sv2[first2,last2),
   using bin_pred to determine equality of elements. Returns the position of
   first element in sv1 of the occurrence (or svend if not found).

Examples
--------

See ut_sv_nonmodifying.pure


STL Modifying Algorithms
========================

The sv_modifying.pure module provides an interface to the STL's modifying
sequence operations.

Imports
-------

To use the operations of this module, add the following import declaration
to your program::

  using sv_modifying;

All of the functions are in the stl namespace.

Operations
----------

.. function::copy (sv, first, last) (msv, p)

   Copies the elements in sv[first,last) into a range whose first element is
   (mvs,p). Note that p can be svback. An overflow exception is thrown if the
   target range cannot accomodate the copy.

.. function::copy_backward (sv,first,last) (msv,p)

   Copies the elements in sv[first,last), moving backward from (last-1), into
   a mvs[first2,p) where n is the number of elements in sv[first,last) and
   first2 = p - n.  Note that p cannot be svback. An overflow exception is
   thrown if the target range cannot accomodate the copy.

.. function:: swap_ranges (sv,first,last) (msv, p)

   Exchanges the elements in sv[first, last) with those at mvs[p, p+n)
   where n is last - first.

.. function transform (sv,first,last) (msv, p) unary_fun

   Applies unary_fun to the elements of sv[first,last) and places the
   resulting sequence in mvs[p, p+n) where n is last - first.  If sv is
   mutable, msv can be the same as sv. Returns (mvs,p+n);

.. function transform_2 (sv1,first1,last1) (sv2,first2) (msv, p) bin_fun

   Applies bin_fun to the elements of sv1[first1,last1) sv2[first2,n) and and
   places the resulting sequence in mvs[p, p+n) where n is last1 -
   first1. Returns (mvs,p+n).

.. function replace (msv,first,last) x y

   Same as replace_if (msv,first,last) (x==) y;

.. function:: replace_if (msv,first,last) unary_pred x

   Replace all elements of msv[first,last) that satistfy unary_pred with x.

.. function:: replace_copy (sv,first,last) (msv,p) x y

   Same as replace (msv,first,last) x y except that the modified sequence is
   placed in msv[p,p+last-first). Note that p can be svback.

.. function:: replace_copy_if (sv,first,last) (msv,p) unary_pred x

   Same as replace_if except that the modified sequence is placed in
   msv[p,p+last-first). Note that p can be svback.

.. function fill (msv,first,last) x

   Replace all elements in msv[first,last) with x.

.. function:: fill_n (msv,first) n x

   Replace all elements in msv[first,first+n) with x.

.. function generate (msv,first,last) gen_fun

   Replace all elements in msv[first,last) with the sequence generated
   by successive calls to gen_fun.

.. function:: generate_n (msv,first) n gen_fun

   Replace all elements in msv[first,first+n) with the sequence generated by
   successive calls to gen_fen

.. function remove (msv,first,last) x

   Same as remove_if (msv,first,last) (==x).

.. function:: remove_if (msv,first,last) unary_pred

   Remove elements in msv[first,last) that do not satisfy unary_pred. If n
   elements satisfy unary_pred, they are moved to msv[first,first+n),
   preserving their relative order. The content of msv[first+n,svend) is
   undefined. Returns first+n. (If first+n is past the end, svend is
   subsituted for firs+n).

.. function:: remove_copy (sv,first,last) (msv,first) x

   Same as remove except that the purged sequence is copied to (msv,first) and
   sv[first,last) is not changed.

.. function:: remove_copy_if (sv,first,last) (msv,first) unary_pred

    Same as remove_if except that the purged sequence is copied to (msv,first)
    and sv[first,last) is not changed.

.. function unique (msv,first,last) bin_pred

   Eliminates consecutive duplicates from sv[first,last), using bin_pred to
   test for equality. The purged sequence is moved to sv[first,first+n)
   preserving their relative order where n is the size of the purged
   sequence. Returns first+n. (If first+n is past the end, svend is
   subsituted for firs+n).

.. function:: unique_copy (sv,first,last) (msv,first) bin_pred

   Same as unique except that the purged sequence is copied to (msv,first) and
   sv[first,last) is not changed.

.. function reverse (msv,first,last)

   Reverses the order of the elements in sv[first,last).

.. function:: reverse_copy (sv,first,last) (msv,first)

   Same as reverse except that the reversed sequence is copied to (msv,first)
   and sv[first,last) is not changed.

.. function rotate (msv,first,middle,last)

   Rotates the elements of msv[first,middle,last] so that middle becomes
   the first element of msv[first,last].

.. function:: rotate_copy (msv,first,middle,last) (msv,first)

   Same as reverse except that the rotated sequence is copied to (msv,first)
   and sv[first,last) is not changed.

.. function:: random_shuffle (msv,first,last)

   Randomly reorders the elements in msv[first,last).

.. function partition (msv,first,last) unary_pred

   Places all of the elements in msv[first,last) that satisfy unary_pred
   before those that don't. Returns middle, where msv [first,middle) contains
   all of the elements that satisfy unary_pre, and msv [middle, last).

.. function:: stable_partition (msv,first,last) unary_pred

   Same as partition except that the relative positions of the elements in
   each group are preserved.

Examples
--------

See ut_sv_modifying.pure


STL Sort Algorithms
===================

The sv_sort.pure module provides an interface to the STL's sorting and binary
search algorithms.

Imports
-------

To use the operations of this module, add the following import declaration
to your program::

  using sv_sort;

All of the functions are in the stl namespace.

Operations
----------

All of the functions in this module require the caller to supply an ordering
functions, comp (as for the Pure library sort function). The functions (<) and
(>) are commonly passed as comp.

.. function:: sort (msv, first, last) comp

   Sorts msv[first, last).

.. function:: stable_sort (msv, first, last) comp

   Sorts msv[first, last), preservint the relative order of equal members.

.. function:: partial_sort (msv, first, middle, last) comp

   Fills msv[first, middle) with the elements that would appear there if
   msv[first,last) were sorted.

.. function:: partial_sort_copy (sv, first1, last1) (msv, first2, last2) comp

   Let n be the number of elements in sv[first1, last1) and r be the number of
   elements in msv[first2, last2). If r < n, partial_sort_copy fills
   msv[first2, last2) with the first r elements of what sv[first1, last1)
   would be if it had been sorted. If r >= n, it fills msv[first2, first2+n)
   with the elements of sv[first1, last1) in sorted order. The first stlvec,
   sv, is not modified. An overflow exception is thrown if the target range
   cannot accomodate the sorted elements.

.. function:: nth_element (msv, first, middle, last) comp

   Rearranges the elements of msv[first, last) as follows. Let n be middle -
   first, an x nth smallest element of msv[first, last). Sfter the function is
   called, sv!middle will be x. All of the elements of msv[first, middle) will
   be less than x and all of the elements of msv[middle+1, last) will be
   greater than x.

The next four functions assume that sv[first, last) is ordered by comp.

.. function:: lower_bound (sv, first, last) x comp

   Returns an integer p that such that (sv,p) is the first position into
   which x can be inserted into sv[first, last) while maintaining the sorted
   ordering.

.. function:: upper_bound (sv, first, last) x comp

   Returns an integer p that such that (sv,p) is the last position into
   which x can be inserted into sv[first, last) while maintaining the sorted
   ordering.

.. function:: equal_range (sv, first, last) x comp

   Returns a tuple, (lower, upper) where lower and upperf would have
   been returned by separate calls to lower_bound and upper_bound.

.. function:: binary_search (sv, first, last) x comp

   Returns true if x is an element of sv[first, last).

Examples
--------

See ut_sv_sort.pure


STL Merge Algorithms
====================

The sv_merge.pure module provides an interface to the STL's merge
algorithms. These algorithms operate on sorted ranges.

Imports
-------

To use the operations of this module, add the following import declaration
to your program::

  using sv_merge;

All of the functions are in the stl namespace.

Operations
----------

All of the functions in this module require the caller to supply an ordering
functions, comp (as for the Pure library sort function). They only work
properly on input ranges that have been previously sorted using comp.

See parameter naming conventions at ..

.. function merge (sv1,first1,last1) (sv2,first2,last2) (msv,p) comp

   Merges the two sorted ranges into the range msv[p,p+n) where n is
   the total length of the merged sequence.

.. function::inplace_merge (msv,first, middle, last) comp

   Merges msv[first,middle) and msv[middle,last) into msv[first,last).

.. function::includes (sv1,first1,last1) (sv2,first2,last2) comp

   Returns true if every element of sv2[first2,last2) is an element
   of sv1[first1,last1).

.. function::set_union (sv1,first1,last1) (sv2,first2,last2) (msv,p) comp

   Places the sorted union of sv1[first1,last1) and sv2[first2,last2) into
   msv[p,p+n) where n is the number of elements in the sorted union. Returns
   the past-the-end position of the sorted union.

.. function::set_intersection (sv1,first1,last1) (sv2,first2,last2)
    (msv,p) comp

   Places the sorted intersection of sv1[first1,last1) and sv2[first2,last2)
   into msv[p,p+n) where n is the number of elements in the sorted
   intersection.  Returns the past-the-end position of the sorted
   intersection.

.. function::set_difference (sv1,first1,last1) (sv2,first2,last2)
    (msv,p) comp

   Places the sorted difference of sv1[first1,last1) and sv2[first2,last2)
   into msv[p,p+n) where n is the number of elements in the sorted difference.
   Returns the past-the-end position of the sorted difference.

.. function::set_symmetric_difference (sv1,first1,last1)
   (sv2,first2,last2) (msv,p) comp

   Places the sorted symmetric_difference of sv1[first1,last1) and
   sv2[first2,last2) into msv[p,p+n) where n is the number of elements in the
   sorted symmetric_difference.  Returns the past-the-end position of the
   sorted symmetric_difference.

Examples
--------

See ut_sv_merge.pure

STL Heap Algorithms
===================

The sv_heap.pure module provides an interface to the STL's heap
operations.

Imports
-------

To use the operations of this module, add the following import declaration
to your program::

  using sv_heap;

All of the functions are in the stl namespace.

Operations
----------

All of the functions in this module require the caller to supply an ordering
functions, comp (as for the Pure library sort function). The functions (<) and
(>) are commonly passed as comp.

.. function:: make_heap (msv,first,last) comp

   Move elements of msv[first,last) so that they are a heap. After this
   msv!first will be the largest element in msv[first,last), and push_heap
   and pop_heap will work properly.

.. function:: push_heap (msv,first,last) comp

   Assumes msv[first,last-1) is a heap. Permutes elements in msv[first,last)
   so it will be a heap.

.. function:: pop_heap (msv,first,last) comp

   Assumes msv[first,last) is a heap. Swaps msv!first with msv!(last-1).
   Permutes elements in msv[first,last-1) so it will be a heap.

.. function:: sort_heap (msv,first,last) comp

   Assumes that msv[first,last) is a heap. Sorts the elements in
   msv[first,last).

Examples
--------

See ut_sv_heap.pure

Min/Max STL Algorithms
======================

The sv_minmax.pure module provides an interface to a few addional STL
algorithms.

Imports
-------

To use the operations of this module, add the following import declaration
to your program::

  using sv_minmax;

All of the functions are in the stl namespace.

Operations
----------

All of the functions in this module require the caller to supply an ordering
functions, comp (as for the Pure library sort function). The functions (<) and
(>) are commonly passed as comp.

.. function:: min_element (sv,first,last) comp

   Returns the position of the minimal element of sv[first,last) under the
   ordering defined by comp.

.. function:: max_element (sv,first,last) comp

   Returns the position of the maximal element of sv[first,last) under the
   ordering defined by comp.

.. function:: lexicographical_compare (sv1,first1,last1) (sv2,first2,last2) comp

   Compare sv1[first1,last1) and sv2[first2,last2) element by element according
   to the ordering defined by comp. Return true if the first sequence is less
   than the second.

.. function:: next_permutation (msv,first,last) comp

   Rearranges msv[first,last) to produce the next permutation, in the ordering
   imposed by comp. The first permutation has the elements of msv[first,last)
   in ascending order and the last has the elements in descending order. If
   msv[first,last) is not the last permutation, change msv[first,last) to the
   next permutation and return true. Otherwise, change it to the first
   permutation and return true.

.. function:: prev_permutation (msv,first,last) comp

   This is nex_permutation in reverse.

Examples
--------

See ut_sv_minmax.pure


STL Numeric Algorithms
======================

The sv_numeric.pure module provides an interface to the STL's numeric
algorithms.

Imports
-------

To use the operations of this module, add the following import declaration
to your program::

  using sv_numeric;

All of the functions are in the stl namespace.

Operations
----------

.. function:: accumulate (sv,first,last) x bin_fun

   This is the STL's answer to foldl. 

.. function:: inner_product (sv1,first1,last1) (sv2,first2,last2) x bin_fun1 bin_fun2

   Initialize ret with x. Traverse pairs of elements of sv1[first1,last1) and
   sv2[first2,last2), denoted by (e1, e2), replacing ret with "bin_fun1 ret
   (bin_fun2 e1 e2)". The number pairs traversed is equal to the size of
   sv1[first1,last1).  

.. function:: partial_sum (sv,first,last) (msv, p) bin_fun

   Accumulate bin_fun f over the elements of sv1[first1,last1), as with
   foldl1, and replace the elements msv[p,p+N), where N is last - first, with
   the intermediate results. If p is stl::svback, then insert the intermediate
   results at the end of msv. Returns q where M is q - N and msv[M,q) is the
   intermediate sequence.

.. function:: adjacent_difference (sv,first,last) (msv, p) bin_fun

   Produces a sequence of new elements by applying bin_fun to adjacent
   elements of sv[first,last). Places the new elements in mvs[p,p+N), where N
   is last - first, with the intermediate results. If p is stl::svback, then
   insert the new results at the end of msv. Returns q where M is q - N and
   msv[M,q) is the new sequence.

Examples
--------

See ut_sv_numeric.pure in the ut subfolder.

Trace Mode
==========

If the pure-stl dlls are built using 'make debug' (as opposed to 'make' or
'make dlls'), the pure-stl tracing functions will be enabled. These functions
can be used to trace the creation and deletion of stlvecs as well as the
changes in ref counts that occur as Pure objects are moved and copied. In
addition to being useful for maintaining the pure-stl modules, these functions
can be used to observe STL C++ copy semantics.

.. function:: set_sv_trace on_off::int

   Enables or disables tracing the creation and deletion of stlvecs.

.. function:: sv_trace_enabled

   Returns 1 if stlvec tracing is enabled, else 0;

.. function:: set_px_trace on_off::int

   Enables or disables tracing the 'copying' of Pure expressions.

.. function:: px_trace_enabled

   Returns 1 if Pure expression tracing is enabled, else 0;




