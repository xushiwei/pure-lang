
/* ffi.pure: A libffi interface. */

using "lib:ffi";

/* This API enables you to call C functions from Pure and vice versa. It goes
   beyond Pure's built-in C interface in that it also handles C structs and
   makes Pure functions callable from C. Moreover, depending on the libffi
   implementation, it may also be possible to create wrappers for other call
   interfaces. TODO: Struct support needs to be implemented. */

/* Define the ABIs and the type numbers known to this libffi implementation.
   The constant FFI_DEFAULT_ABI is always defined and should be appropriate
   for most purposes. The type numbers FFI_TYPE_VOID etc. are useful with the
   type_info function, see below. Use 'show -g FFI_*' to get a full list of
   these constants. */

namespace C;
extern void ffi_defs(); ffi_defs;
namespace;

/* Atomic types. Note that the string_t type is a special variant of pointer_t
   which triggers automatic marshalling from/to Pure string values, including
   automatic conversions to/from the system encoding. This should be used only
   for const char* values which are not to be modified by the caller. Also be
   careful when using string_t as a return value in a C callback (fclos),
   because the returned string will be malloc'd and leak memory unless the
   caller is prepared to free it. */

extern ffi_type *ffi_type_void_ptr() = void_t;
extern ffi_type *ffi_type_uint8_ptr() = uint8_t;
extern ffi_type *ffi_type_sint8_ptr() = sint8_t;
extern ffi_type *ffi_type_uint16_ptr() = uint16_t;
extern ffi_type *ffi_type_sint16_ptr() = sint16_t;
extern ffi_type *ffi_type_uint32_ptr() = uint32_t;
extern ffi_type *ffi_type_sint32_ptr() = sint32_t;
extern ffi_type *ffi_type_uint64_ptr() = uint64_t;
extern ffi_type *ffi_type_sint64_ptr() = sint64_t;
extern ffi_type *ffi_type_float_ptr() = float_t;
extern ffi_type *ffi_type_double_ptr() = double_t;
extern ffi_type *ffi_type_pointer_ptr() = pointer_t;
extern ffi_type *ffi_type_uchar_ptr() = uchar_t;
extern ffi_type *ffi_type_schar_ptr() = schar_t;
extern ffi_type *ffi_type_ushort_ptr() = ushort_t;
extern ffi_type *ffi_type_sshort_ptr() = sshort_t;
extern ffi_type *ffi_type_uint_ptr() = uint_t;
extern ffi_type *ffi_type_sint_ptr() = sint_t;
extern ffi_type *ffi_type_ulong_ptr() = ulong_t;
extern ffi_type *ffi_type_slong_ptr() = slong_t;
extern ffi_type *ffi_type_string_ptr() = string_t;

/* Internal operations. */

namespace C;
extern ffi_cif *ffi_new_cif(int abi, ffi_type *rtype, ffi_type **atypes);
extern void ffi_free_cif(ffi_cif *cif);
extern expr *ffi_c_call(ffi_cif *cif, void *fn, expr *x);
extern ffi_closure *ffi_new_closure(ffi_cif *cif, expr *fn);
extern void ffi_free_closure(ffi_closure *clos, void *code);
extern void *ffi_closure_addr(ffi_closure *clos);
extern void *ffi_typevect(expr *types);
extern ffi_type *ffi_new_struct_t(ffi_type **elements);
extern void ffi_free_struct_t(ffi_type *type);
extern void *ffi_new_struct(ffi_type *type, expr *data);
extern void ffi_free_struct(ffi_type *type, void *data);
namespace;

using namespace C;

/* Interface functions. These take the desired ABI (FFI_DEFAULT_ABI etc.),
   return type (void_t etc.) and tuple of argument types as arguments. Note
   that arguments are always passed in uncurried form, as a Pure tuple. */

/* Create a Pure wrapper for a foreign function. */

fcall name::string abi::int rtype::pointer atypes = ffi_c_call cif fn
if ~null cif && pointerp fn
when
  cif = sentry ffi_free_cif $ ffi_new_cif abi rtype (ffi_typevect atypes);
  fn  = addr name;
end;

/* Create a foreign wrapper for a Pure function. */

fclos fn abi::int rtype::pointer atypes = ptr if ~null ptr
when
  cif  = ffi_new_cif abi rtype (ffi_typevect atypes);
  clos = ffi_new_closure cif fn;
  ptr  = sentry (ffi_free_closure clos) $ ffi_closure_addr clos;
end;

/* Create a struct type. */

struct_t elements = sentry ffi_free_struct_t type if ~null type
when type = ffi_new_struct_t (ffi_typevect elements) end;

/* Retrieve information about a type. This returns a tuple
   (size,align,type,...) with information about the size, alignment and type
   number. In the case of struct types (type == FFI_TYPE_STRUCT), the
   remaining elements are the descriptors of the element types. */

extern expr *ffi_type_info(ffi_type *type) = type_info;

/* Create a C struct from a tuple of its members, suitable to be passed as a
   value parameter in fcall and fclos. The result is a "cooked" pointer which
   is freed automatically when garbage-collected, so you must not free it
   manually. */

struct type::pointer data = sentry (ffi_free_struct type) p if ~null p
when p = ffi_new_struct type data end;

/* Get the member data and pointers of a struct. The result is a tuple with
   the data elements or the (raw) pointers to the data, respectively. The
   latter can be used to access and change the fields of the struct using the
   appropriate pointer operations in the prelude. */

extern expr *ffi_struct_data(ffi_type *type, void *data) = struct_data;
extern expr *ffi_struct_pointers(ffi_type *type, void *data) = struct_pointers;
